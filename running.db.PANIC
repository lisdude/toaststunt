** LambdaMOO Database, Format Version 17 **
6
2
71
36
38
96
98
0 values pending finalization
0 clocks
1 queued tasks
0 5 1648540800 1417686021
0
-111
1
79
1
79
1
79 -7 -8 2 -9 2 79 -10 1
No
More
Parse
Infos
schedule_measurement_task
schedule_measurement_task
26 variables
NUM
0
0
OBJ
0
1
STR
0
2
LIST
0
4
ERR
0
3
player
1
2
this
1
79
caller
1
79
verb
2
schedule_measurement_task
args
4
0
argstr
2

dobj
1
-1
dobjstr
2

prepstr
2

iobj
1
-1
iobjstr
2

INT
0
0
FLOAT
0
9
MAP
0
10
ANON
0
12
WAIF
0
13
BOOL
0
14
true
14
1
false
14
0
day
0
86400
hour_of_day_GMT
0
8
this:schedule_measurement_task();
this.measurement_task_running = task_id();
this:measurement_task(this.task_time_limit);
this.measurement_task_running = 0;
.
0 suspended tasks
0 interrupted tasks
1 active connections with listeners
2 0
128
#0
The System Object
24
2
1
-1
0
0
4
0
1
1
4
0
26
do_login_command
2
173
-1
server_started
2
173
-1
core_object_info core_objects
2
173
-1
init_for_core
2
173
-1
user_created user_connected
2
173
-1
user_disconnected user_client_disconnected
2
173
-1
bf_chparent chparent
2
173
-1
bf_add_verb add_verb
2
173
-1
bf_add_property add_property
2
173
-1
bf_recycle recycle
2
173
-1
user_reconnected
2
173
-1
bf_set_verb_info set_verb_info
2
173
-1
bf_match match
2
173
-1
bf_rmatch rmatch
2
173
-1
checkpoint_finished
2
173
-1
do_out_of_band_command doobc
2
173
-1
handle_uncaught_error
2
173
-1
checkpoint_started
2
173
-1
bf_force_input
2
173
-1
moveto
2
173
-1
bf_set_property_info set_property_info
2
173
-1
include_for_core
2
173
-1
handle_task_timeout
2
173
-1
bf_read
2
173
-1
sin
2
173
-1
s ies es
2
173
-1
110
builder
login
last_huh
guest_log
biglist
big_mail_recipient
limbo
registration_db
new_player_log
wiz_utils
site_db
math_utils
set_utils
new_prog_log
guest
spell
seq_utils
quota_log
you
hacker
generic_db
no_one
player_db
player_class
gender_utils
trig_utils
time_utils
mail_recipient
mail_agent
mail_editor
note_editor
verb_editor
generic_editor
match_utils
object_utils
lock_utils
letter
list_utils
command_utils
player
wiz
prog
code_utils
help
nothing
failed_match
ambiguous_match
perm_utils
building_utils
string_utils
news
note
container
thing
exit
room
player_start
root_class
recycler
generic_options
maxint
minint
error
newt_log
toad_log
site_log
housekeeper
network
generic_biglist_home
feature
local
generic_utils
quota_utils
paranoid_db
sysobj
byte_quota_utils
object_quota_utils
feature_warehouse
password_verifier
frand_class
mail_recipient_class
stage_talk
pasting_feature
matrix_utils
convert_utils
gendered_object
list_editor
http
ansi_pc
ansi_utils
mcp
waif
anon
server
help_db
generic_help
options
server_options
shapes
proto
str_proto
map_proto
list_proto
int_proto
obj_proto
frobs
edit_utils
edit_state
menu_utils
edit_session
114
1
4
2
5
1
10
2
1
1
11
2
1
1
12
2
1
1
13
2
5
1
14
2
5
1
15
2
5
1
16
2
5
1
17
2
5
1
24
2
5
1
25
2
5
1
26
2
5
1
27
2
5
1
29
2
5
1
31
2
1
1
32
2
5
1
33
2
5
1
34
2
5
1
35
36
1
1
36
2
5
1
37
2
5
1
38
2
1
1
39
2
1
1
40
2
5
1
41
2
1
1
26
2
5
1
43
2
5
1
45
2
5
1
46
2
5
1
47
2
5
1
48
2
5
1
49
2
5
1
50
2
5
1
51
2
5
1
52
2
5
1
53
2
5
1
54
2
5
1
55
2
5
1
56
2
5
1
6
2
5
1
57
2
5
1
58
2
5
1
59
2
5
1
60
2
5
1
-1
2
5
1
-3
2
5
1
-2
2
5
1
42
2
5
1
21
2
5
1
20
2
5
1
61
2
5
1
9
2
5
1
8
2
5
1
5
2
5
1
7
2
5
1
3
2
5
1
62
2
5
1
1
2
5
1
63
2
5
1
68
2
5
0
9223372036854775807
2
5
0
-9223372036854775807
2
5
1
69
2
5
1
70
2
5
1
70
2
5
1
70
2
5
1
71
2
5
1
72
2
5
1
73
2
1
1
74
2
5
1
-1
2
5
1
78
2
5
1
79
2
5
1
80
2
1
1
0
2
1
1
79
2
5
1
81
2
5
1
83
2
1
1
87
2
1
1
88
2
5
1
40
2
5
1
89
2
5
1
90
2
5
1
91
36
1
1
93
2
5
1
94
2
1
1
95
2
5
1
97
2
5
1
100
2
1
1
99
2
1
1
110
2
5
1
118
2
5
1
122
2
5
10
4
2
core_history
4
1
4
3
2
a 2018 LambdaCore
2
2.6.0
0
1576791887
2
last_restart_time
0
1648488120
2
name
2
LambdaMOO-ToastStunt
2
shutdown_time
0
0
2
5
10
11
2
ansi
1
101
2
builder
1
84
2
builtin_function
1
28
2
core
1
19
2
editor
1
44
2
frand
1
92
2
mail
1
85
2
prog
1
22
2
toaststunt
1
86
2
verb
1
18
2
wiz
1
23
2
5
1
30
2
5
10
6
2
ansi
1
102
2
build
1
77
2
display
1
67
2
edit
1
66
2
mail
1
65
2
prog
1
76
2
5
1
82
2
5
1
75
2
5
1
120
2
5
1
119
2
5
1
117
2
5
1
115
2
5
1
114
2
5
1
111
2
5
4
0
2
5
1
124
2
1
1
125
2
1
1
126
2
1
1
127
2
5
5
2
4
4
1
2
The System Object
2
5
2
The known universe.
2
5
4
2
0
37739
0
1648488120
36
1
#1
Root Class
152
2
1
-1
0
0
4
0
1
-1
4
27
1
3
1
0
1
5
1
7
1
46
1
45
1
94
1
37
1
15
1
73
1
18
1
12
1
11
1
10
1
68
1
69
1
72
1
78
1
80
1
82
1
30
1
103
1
107
1
109
1
110
1
118
1
32
37
initialize
2
173
-1
recycle
2
173
-1
set_name
2
173
-1
title
2
173
-1
titlec
2
173
-1
set_aliases
2
173
-1
match
2
173
-1
match_object
2
173
-1
set_description
2
173
-1
description
2
173
-1
look_self
2
173
-1
notify
2
173
-1
tell
2
173
-1
tell_lines
2
173
-1
accept
2
173
-1
moveto
2
173
-1
eject eject_nice eject_basic
2
173
-1
is_unlocked_for
2
173
-1
huh
2
173
-1
set_message
2
173
-1
do_examine
2
173
-1
examine_key
2
173
-1
examine_names
2
173
-1
examine_desc
2
173
-1
examine_contents
2
173
-1
examine_verbs
2
173
-1
get_message
2
173
-1
room_announce*_all_but
2
173
-1
init_for_core
2
173
-1
contents
36
173
-1
examine_verb_ok
2
173
-1
is_listening
2
173
-1
hidden_verbs
2
173
-1
examine_owner
2
173
-1
announce*_all_but
2
173
-1
tell_lines_suspended
2
173
-1
acceptable
2
173
-1
4
key
aliases
description
object_size
4
0
0
2
4
4
0
2
5
2

2
5
4
2
0
32226
0
1648488120
36
1
#2
Wizard
7
2
1
62
10
2
2
source
1
49
2
time
0
1641148599
4
0
1
57
4
0
2
@mcp
2
25
-1
@mcps
2
9
-1
0
104
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
4
5
2
5
5
36
1
5
36
1
5
36
1
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
2
5
5
2
5
5
2
5
5
36
1
5
2
5
5
2
4
5
2
5
5
2
1
5
2
5
5
2
5
5
2
5
5
2
5
4
2
0
0
0
0
2
4
5
2
4
5
98
1
5
98
1
5
98
1
5
36
1
4
2
0
0
2
?
2
0
5
2
0
5
2
1
5
2
5
5
2
5
5
36
1
5
36
1
5
36
0
5
36
1
4
48
1
0
1
1
1
2
1
3
1
4
1
5
1
6
1
7
1
8
1
9
1
10
1
11
1
12
1
15
1
17
1
20
1
21
1
24
1
29
1
34
1
40
1
42
1
52
1
53
1
54
1
56
1
57
1
58
1
70
1
72
1
75
1
78
1
82
1
87
1
94
1
97
1
111
1
114
1
115
1
117
1
118
1
119
1
120
1
122
1
124
1
125
1
126
1
127
2
1
5
36
1
1
2
2
4
4
1
2
localhost
2
0
2
localhost
2
0
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
0
1648488139
2
1
0
100
36
0
5
2
5
0
0
2
0
5
2
5
5
2
5
5
2
5
0
1648488139
2
1
4
4
0
50000
0
1127540
0
1648488120
0
1000
36
0
5
2
0
5
2
0
12
128
2
1
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
4
4
1
2
Wizard
2
1
5
2
5
4
2
0
6236
0
1648488120
36
1
#3
generic room
152
2
1
-1
0
0
4
0
1
1
4
2
1
50
1
62
47
confunc
2
173
-1
disfunc
2
173
-1
say
2
85
-2
emote
2
93
-2
announce
2
173
-1
match_exit
2
173
-1
add_exit
2
173
-1
tell_contents
2
173
-1
@exits
2
13
-1
look_self
2
173
-1
acceptable
2
173
-1
add_entrance
2
173
-1
bless_for_entry
2
173
-1
@entrances
2
9
-1
go
2
93
-2
l*ook
2
93
-2
announce_all
2
173
-1
announce_all_but
2
173
-1
enterfunc
2
173
-1
exitfunc
2
173
-1
remove_exit
2
173
-1
remove_entrance
2
173
-1
@add-exit
2
25
-1
@add-entrance
2
25
-1
recycle
2
173
-1
e east w west s south n north ne northeast nw northwest se southeast sw southwest u up d down
2
13
-1
@eject @eject! @eject!!
2
25
-1
ejection_msg oejection_msg victim_ejection_msg
36
173
-1
accept_for_abode
2
173
-1
@resident*s
2
25
-1
match
2
173
-1
@remove-exit
2
25
-1
@remove-entrance
2
25
-1
moveto
2
173
-1
who_location_msg
2
173
-1
exits entrances
2
173
-1
obvious_exits obvious_entrances
2
173
-1
here_huh
2
173
-1
room_announce*_all_but
2
173
-1
examine_commands_ok
2
173
-1
examine_key
2
173
-1
examine_contents
2
173
-1
free_entry
36
173
-1
init_for_core
2
173
-1
dark
2
173
-1
announce_lines_x
2
173
-1
basic_accept_for_abode
2
173
-1
13
who_location_msg
free_home
victim_ejection_msg
ejection_msg
oejection_msg
residents
free_entry
entrances
blessed_object
blessed_task
exits
dark
ctype
17
2
%T
2
5
0
0
2
5
2
You have been expelled from %i by %n.
2
5
2
You expel %d from %i.
2
5
2
%N unceremoniously %{!expels} %d from %i.
2
5
4
0
2
5
0
1
2
5
4
0
2
4
1
-1
2
5
0
0
2
5
4
0
2
4
0
0
2
5
0
3
2
5
5
2
4
4
1
2
generic room
2
5
5
2
5
4
2
0
43072
0
1648488120
36
1
#4
generic builder
144
2
1
-1
0
0
4
0
1
88
4
2
1
58
1
96
32
@quota
2
25
-1
@create
2
89
-2
@recycle
2
25
-1
@recreate
2
89
13
@dig
2
89
-2
@audit
2
89
-2
@count
2
25
-1
@countDB
2
25
-1
@sort-owned*-objects
2
25
-1
@add-owned
2
25
-1
@verify-owned
2
9
-1
@unlock
2
25
-1
@lock
2
89
0
@newmess*age
2
89
-2
@unmess*age
2
89
-2
_messagify
2
173
-1
@kids
2
29
-1
@contents
2
25
-1
@par*ents
2
25
-1
@location*s
2
25
-1
classes_2
2
173
-1
_create
2
173
-1
_recycle
2
173
-1
@chparent
2
89
1
@check-chp*arent
2
89
1
@set*prop
2
89
1
build_option
2
173
-1
set_build_option
2
173
-1
@build-o*ptions @buildo*ptions @builder-o*ptions @buildero*ptions
2
89
-2
@meas*ure
36
89
-2
init_for_core
2
173
-1
@listedit @pedit
36
25
-1
1
build_options
91
4
0
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
2
5
5
2
5
5
2
5
5
36
1
5
2
5
5
2
4
5
2
5
5
2
1
5
2
5
4
0
2
5
5
2
5
5
2
5
5
2
4
5
2
4
5
98
1
5
98
1
5
98
1
4
2
1
90
1
89
36
1
5
2
0
5
2
0
5
2
1
1
84
2
5
5
2
5
5
36
1
5
36
1
5
36
0
5
36
1
5
2
1
5
36
1
5
2
4
5
2
0
5
2
0
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
1
0
0
36
0
1
62
2
5
5
2
0
5
2
5
5
2
5
5
2
5
5
2
1
5
36
0
5
2
0
5
2
0
5
2
1
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
4
4
1
2
generic builder
2
1
2
You see a player who should type '@describe me as ...'.
2
5
4
2
0
48748
0
1648488120
36
1
#5
generic thing
152
2
1
-1
0
0
4
0
1
1
4
6
1
8
1
9
1
63
1
74
1
87
1
97
6
g*et t*ake
2
45
-1
d*rop th*row
2
45
-1
moveto
2
173
-1
take_failed_msg take_succeeded_msg otake_failed_msg otake_succeeded_msg drop_failed_msg drop_succeeded_msg odrop_failed_msg odrop_succeeded_msg
2
173
-1
gi*ve ha*nd
2
109
1
examine_key
2
173
-1
8
drop_failed_msg
drop_succeeded_msg
odrop_failed_msg
odrop_succeeded_msg
otake_succeeded_msg
otake_failed_msg
take_succeeded_msg
take_failed_msg
12
2
You can't seem to drop %t here.
2
5
2
You drop %t.
2
5
2
tries to drop %t but fails!
2
5
2
drops %t.
2
5
2
picks up %t.
2
5
2

2
5
2
You take %t.
2
5
2
You can't pick that up.
2
5
5
2
4
4
1
2
generic thing
2
5
5
2
5
4
2
0
7011
0
1648488120
36
1
#6
generic player
152
2
1
-1
0
0
4
0
1
94
4
1
1
100
100
init_for_core
2
173
-1
confunc
2
173
-1
disfunc
2
173
-1
initialize
2
173
-1
acceptable
2
173
-1
my_huh
2
173
-1
last_huh
2
173
-1
my_match_object
2
173
-1
tell_contents
2
173
-1
titlec
2
173
-1
notify
2
173
-1
notify_lines
2
173
-1
linesplit
2
173
-1
linelen
36
173
-1
@more
2
25
-1
@wrap
36
9
-2
@linelen*gth
36
25
-1
@pagelen*gth
2
25
-1
tell
2
173
-1
gag_p
2
173
-1
set_gaglist
2
173
-1
@gag*!
2
89
-2
@listgag @gaglist @gagged
2
29
-1
@ungag
2
29
-1
whodunnit
2
173
-1
@ch*eck-full
2
89
-2
@paranoid
2
89
-2
@sw*eep
2
9
-1
wh*isper
2
157
1
page
2
93
-2
receive_page
2
173
-1
page_origin_msg page_echo_msg page_absent_msg
36
173
-1
i inv*entory
2
9
-1
look_self
2
173
-1
home
2
9
-1
@sethome
2
9
-1
g*et take
2
45
-1
@move @teleport
2
93
1
@eject @eject! @eject!!
2
89
5
where*is @where*is
2
93
-2
@who
2
93
-2
@wizards
2
29
-1
?* help info*rmation @help
2
93
-2
display_option
2
173
-1
edit_option
2
173
-1
set_mail_option set_edit_option set_display_option
2
173
-1
@mailo*ptions @mail-o*ptions @edito*ptions @edit-o*ptions @displayo*ptions @display-o*ptions @generalo*ptions @general-o*ptions
2
89
-2
set_name
2
173
-1
set_aliases
2
173
-1
@rename*#
2
89
1
@addalias*# @add-alias*#
2
89
1
@rmalias*# @rm-alias*#
2
89
5
@desc*ribe
2
89
13
@mess*ages
2
25
-1
@notedit
96
25
-1
@last-c*onnection
2
29
-1
set_brief
2
173
-1
@mode
2
89
-2
exam*ine @exam*ine
2
25
-1
add_feature
36
173
-1
remove_feature
36
173
-1
@add-feature @addfeature
2
25
-1
@remove-feature @rmfeature
2
25
-1
@features
2
93
11
@features
2
25
-1
@memory
36
9
-1
@version
36
9
-1
@uptime
36
9
-1
@quit
2
9
-1
examine_commands_ok
2
173
-1
is_listening
2
173
-1
moveto
2
173
-1
announce*_all_but
2
173
-1
linewrap
36
173
-1
@set-note-string @set-note-text
2
25
-1
ownership_quota
2
173
-1
tell_lines
2
173
-1
@lastlog
2
29
-1
set_linelength
2
173
-1
set_pagelength
2
173
-1
set_home
2
173
-1
@registerme
2
89
-2
ctime
2
173
-1
@age
36
25
-1
news
2
29
-1
@edit
36
89
-2
erase_paranoid_data
2
173
-1
@move-new
2
89
-2
notify_lines_suspended
2
173
-1
_chparent
2
173
-1
@users
36
13
-1
@password
2
89
-2
recycle
2
173
-1
gc_gaglist
2
173
-1
email_address
2
173
-1
set_email_address
2
173
-1
reconfunc
2
173
-1
@owner
36
29
-1
@inline-o*ptions @editor-o*ptions
2
89
-2
@gender
2
25
-1
35
features
previous_connection
email_address
last_disconnect_time
help
more_msg
linetask
linesleft
linebuffer
pagelen
owned_objects
linelen
current_folder
all_connect_places
last_connect_place
dict
brief
page_absent_msg
page_origin_msg
page_echo_msg
edit_options
last_connect_time
ownership_quota
home
password
gaglist
paranoid
display_options
first_connect_time
size_quota
last_password_time
last_connect_attempt
out_of_band_session
reading_input
inline_editor_options
51
4
0
36
1
0
0
2
0
2

2
0
0
0
2
1
0
0
2
5
2
*** More ***  %n lines left.  Do @more [rest|flush] for more.
2
5
4
2
0
0
0
0
36
1
0
0
36
1
4
0
36
0
0
0
36
1
4
0
2
1
0
-79
36
1
0
1
2
4
4
0
2
0
2
?
2
0
4
0
2
5
0
0
2
5
2
%N is not currently logged in.
2
5
2
You sense that %n is looking for you in %l.
2
5
2
Your message has been sent.
2
5
4
0
2
5
0
0
2
1
0
0
36
0
1
62
2
5
2
impossible password to type
2
0
4
0
2
5
0
0
2
5
4
0
2
5
0
2147483647
2
1
4
0
36
0
0
0
2
0
0
0
2
0
1
-1
2
1
0
0
2
0
10
0
2
0
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
4
4
1
2
generic player
2
1
2
You see a player who should type '@describe me as ...'.
2
5
4
2
0
132036
0
1648488120
36
1
#7
generic exit
152
2
1
-1
0
0
4
0
1
1
4
0
11
invoke
2
173
-1
move
2
173
-1
recycle
2
173
-1
leave_msg oleave_msg arrive_msg oarrive_msg nogo_msg onogo_msg
2
173
-1
set_name
2
173
-1
set_aliases
2
173
-1
announce_all_but
2
173
-1
defaulting_oleave_msg
2
173
-1
moveto
2
173
-1
examine_key
2
173
-1
announce_msg
2
173
-1
9
obvious
source
dest
nogo_msg
onogo_msg
arrive_msg
oarrive_msg
oleave_msg
leave_msg
13
0
1
2
5
1
-1
2
5
1
-1
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
5
2
4
4
1
2
generic exit
2
5
5
2
5
4
2
0
10849
0
1648488120
36
1
#8
generic container
152
2
1
-1
0
0
4
0
1
5
4
1
1
83
15
p*ut in*sert d*rop
2
157
3
re*move ta*ke g*et
2
157
5
look_self
2
173
-1
acceptable
2
173
-1
open
2
45
-1
@lock_for_open @lock-for-open
2
105
0
is_openable_by
2
173
-1
close
2
45
-1
@unlock_for_open @unlock-for-open
2
41
-1
tell_contents
2
173
-1
set_opened
2
173
-1
@opacity
2
105
12
set_opaque
2
173
-1
oclose_msg close_msg oopen_msg open_msg oput_fail_msg put_fail_msg oremove_fail_msg oremove_msg remove_fail_msg remove_msg oput_msg put_msg oopen_fail_msg open_fail_msg empty_msg
36
173
-1
dark
2
173
-1
19
oclose_msg
close_msg
oopen_msg
open_msg
oput_fail_msg
put_fail_msg
opaque
dark
oremove_fail_msg
oremove_msg
remove_fail_msg
remove_msg
oput_msg
put_msg
oopen_fail_msg
open_fail_msg
empty_msg
opened
open_key
31
2
closes %d.
2
5
2
You close %d.
2
5
2
opens %d.
2
5
2
You open %d.
2
5
2

2
5
2
You can't put %d in that.
2
5
0
1
2
1
0
1
2
1
2

2
5
2
removes %d from %i.
2
5
2
You can't remove that.
2
5
2
You remove %d from %i.
2
5
2
puts %d in %i.
2
5
2
You put %d in %i.
2
5
2

2
5
2
You can't open that.
2
5
2
It is empty.
2
5
0
0
2
1
0
0
2
4
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
4
4
1
2
generic container
2
5
5
2
5
4
2
0
14463
0
1648488120
36
1
#9
generic note
152
2
1
-1
0
0
4
0
1
5
4
1
1
54
11
r*ead
2
45
-1
er*ase
2
45
-1
wr*ite
2
157
4
del*ete rem*ove
2
153
5
encrypt
2
105
0
decrypt
2
41
-1
text
2
173
-1
is_readable_by
2
173
-1
set_text
2
173
-1
is_writable_by
2
173
-1
mailme @mailme
2
41
-1
3
writers
encryption_key
text
15
4
0
2
5
0
0
2
4
4
0
2
4
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
4
4
1
2
generic note
2
5
2
There appears to be some writing on the note ...
2
5
4
2
0
9723
0
1648488120
36
1
#10
Login Commands
16
2
1
-1
0
0
4
0
1
1
4
0
48
?
2
93
-1
wel*come @wel*come
2
93
-1
w*ho @w*ho
2
93
-1
co*nnect @co*nnect
2
93
-1
cr*eate @cr*eate
2
93
-1
q*uit @q*uit
2
93
-1
up*time @up*time
2
93
-1
v*ersion @v*ersion
2
93
-1
parse_command
2
173
-1
check_for_shutdown
2
173
-1
check_player_db
2
173
-1
_match_player
2
173
-1
notify
2
173
-1
tell
36
173
-1
player_creation_enabled
2
173
-1
newt_registration_string registration_string
2
173
-1
init_for_core
2
173
-1
special_action
2
164
-1
blacklisted graylisted redlisted spooflisted
2
173
-1
blacklist_add*_temp graylist_add*_temp redlist_add*_temp spooflist_add*_temp
2
173
-1
blacklist_remove*_temp graylist_remove*_temp redlist_remove*_temp spooflist_remove*_temp
2
173
-1
listname
2
173
-1
who(vanilla)
2
173
-1
record_connection
2
173
-1
sample_lag
2
173
-1
is_lagging
2
173
-1
max_connections
2
173
-1
request_character
2
173
-1
req*uest @req*uest
2
93
-1
h*elp @h*elp
2
93
-1
maybe_print_lag
2
173
-1
current_lag
2
173
-1
maybe_limit_commands
2
173
-1
server_started
2
173
-1
uptime_since
2
173
-1
count_bg_players
2
173
-1
blacklisted_temp graylisted_temp redlisted_temp spooflisted_temp
2
173
-1
templist_expired
2
173
-1
temp_newt_registration_string
2
173
-1
add_interception
36
173
-1
delete_interception
36
173
-1
interception
36
173
-1
intercepted_password
2
173
-1
do_out_of_band_command doobc
36
173
-1
check_for_checkpoint
2
173
-1
encrypt_password
2
173
-1
connection_name_lookup
2
173
-1
delete_name_lookup
2
173
-1
40
welcome_message
newt_registration_string
registration_string
registration_address
create_enabled
bogus_command
blank_command
graylist
blacklist
redlist
who_masks_wizards
max_player_name
spooflist
ignored
max_connections
connection_limit_msg
lag_samples
request_enabled
help_message
last_lag_sample
lag_sample_interval
lag_cutoff
lag_exemptions
newted
current_numcommands
max_numcommands
temporary_newts
downtimes
print_lag
current_lag
temporary_blacklist
temporary_redlist
temporary_spooflist
temporary_graylist
intercepted_players
intercepted_actions
checkpoint_in_progress
no_connect_message
argon2
name_lookup_players
44
4
5
2
Welcome to the ToastCore database.
2

2
Type 'connect wizard' to log in.
2

2
You will probably want to change this text and the output of the `help' command, which are stored in $login.welcome_message and $login.help_message, respectively.
2
5
2
Your character is temporarily hosed.
2
5
2
Character creation is disabled.
2
5
2

2
5
0
0
2
5
2
?
2
1
2
welcome
2
1
4
2
4
0
4
0
2
0
4
2
4
0
4
0
2
0
4
2
4
0
4
0
2
0
0
0
2
0
0
40
2
5
4
2
4
0
4
0
2
0
4
0
2
5
0
99999
36
5
2
*** The MOO is too busy! The current lag is %l; there are %n connected.  WAIT FIVE MINUTES BEFORE TRYING AGAIN.
36
1
4
5
0
0
0
0
0
0
0
0
0
0
2
5
0
0
2
5
4
1
2
Sorry, but there's no help here yet.  Type `?' for a list of commands.
2
5
0
0
2
5
0
15
2
5
0
5
2
5
4
0
2
5
4
0
2
0
10
1
1
-2
0
2
2
5
0
20
2
5
4
0
2
4
4
1
4
2
0
1648488120
0
0
2
5
0
0
2
5
0
0
2
1
4
2
4
0
4
0
2
0
4
2
4
0
4
0
2
0
4
2
4
0
4
0
2
0
4
2
4
0
4
0
2
0
4
0
36
0
4
0
36
0
0
0
2
5
0
0
2
5
10
3
2
iterations
0
3
2
memory
0
4096
2
threads
0
1
2
5
4
0
2
5
5
2
4
4
1
2
Login Commands
2
5
2
This provides everything needed by #0:do_login_command.  See `help $login' on $core_help for details.
2
5
4
2
0
59701
0
1648488120
36
1
#11
Player Last_huh Verbs
16
2
1
-1
0
0
4
0
1
1
4
0
4
@*
2
173
-1
give hand
2
173
-1
get take
2
173
-1
drop throw
2
173
-1
0
4
5
2
4
4
1
2
Player Last_huh Verbs
2
5
2
A repository of last-resort player verbs to be called by $player:last_huh
2
5
4
2
0
6454
0
1648488120
36
1
#12
Guest Log
0
2
1
-1
0
0
4
0
1
1
4
0
4
enter
2
173
-1
last
2
173
-1
init_for_core
2
173
-1
find
2
173
-1
2
connections
max_entries
6
4
0
2
0
0
511
2
0
5
2
4
4
1
2
Guest Log
2
5
5
2
5
4
2
0
5510
0
1648488120
36
1
#13
Generic BigList Utilities
16
36
1
-1
0
0
4
0
1
78
4
0
26
length
36
173
-1
find_nth
36
173
-1
find_ord
36
173
-1
set_nth
36
173
-1
kill
36
173
-1
insert_after insert_before
36
173
-1
extract_range
36
173
-1
delete_range
36
173
-1
keep_range
36
173
-1
insert_last
36
173
-1
start
36
173
-1
next
36
173
-1
_find_nth
36
173
-1
_find_ord
36
173
-1
_set_nth
36
173
-1
_skill
36
173
-1
_extract
36
173
-1
_merge
36
173
-1
_smerge
36
173
-1
_split
36
173
-1
_rmerge
36
173
-1
_scrunch
36
173
-1
_listfind_nth
36
173
-1
_insertfirst
36
173
-1
debug
36
173
-1
_call
2
173
-1
2
about
maxfanout
7
4
15
2
Implementation notes
2
--------------------
2
Each biglist is actually a tree (a kind of B-tree, actually).
2
The routines above pass around handles of the form
2

2
    {root_node, size, leftmost_ord}
2

2
where root_node is the (string) name of a property that holds the root of the tree, size is the number of leaves in the tree, and leftmost_ord is the :_ord value of the leftmost element of the list (i.e., the leftmost leaf).
2
Each node property has a value of the form 
2

2
    {height,list of subtrees}.
2

2
where the each of the subtrees is itself a 3-element list as above unless
2
the height is 0, in which case the subtrees are actually biglist elements of the arbitrary form determined by the home object.
2
At every level, each node except the rightmost has between this.maxfanout/2 and this.maxfanout subtrees; the rightmost is allowed to have as few as 1 subtree.
36
5
0
7
36
5
4
73
2
Generic BigList Utilities
2
----------------------------
2
This is a package for maintaining huge persistent (sorted) lists in a format that is less likely to spam the server (which runs into a certain amount of trouble dealing with long ordinary lists --- btw we use `biglist' to refer to the huge data structure we're about to describe and `list' to refer to ordinary MOO lists {...}).  The biglist in question lives on a particular object, to which we will refer in the discussion below as the `home' object, and its various elements appear as leaves of a tree whose nodes are kept in properties of the home object.  It should be noted that the home object does not need to be (and in fact should *not* be) a descendant of this one; this object merely provides utilities for manipulating the properties on the home object that are used in a particular biglist manipulation.  
2

2
All of the utilities below refer to `caller' to locate the home object.  Thus verbs to manipulate a given biglist must be located on or inherited by its home object itself.  The home object needs to define the following verbs
2

2
  :_make(@args)     => new property on home object with value args
2
  :_kill(prop)      delete a given property that was created by :_make
2
  :_get(prop)       => home.prop
2
  :_put(prop,@args) set home.prop = args
2
  :_ord(element)    given something that is of the form of a biglist element
2
                    return the corresponding ordinal (for sorting purposes).
2
                    If you never intend to use :find_ord, then this can be a 
2
                    routine that always returns 0 or some other random value.
2

2
See #5546 (Generic Biglist Resident) or $big_mail_recipient
2
for examples.
2

2
Those of the following routines that take a biglist argument are expecting
2
either {} (empty biglist) or some biglist returned by one of the other routines
2

2
  :length(biglist)          => length(biglist) (i.e., number of elements)
2
  :find_nth(biglist,n)      => biglist[n]
2
  :find_ord(biglist,k,comp) => n where n is
2
     the largest such that home:(comp)(k,home:_ord(biglist[n])) is false, or
2
     the smallest such that home:(comp)(k,home:_ord(biglist[n+1])) is true.
2
     Always returns a value between 0 and length(biglist) inclusive.
2
     This assumes biglist to be sorted in order of increasing :_ord values 
2
     with respect to home:(comp)().
2
     Standard situation is :_ord returns a number and comp is a < verb.
2

2
  :start(biglist,s,e)  => {biglist[s..?],@handle} or {}
2
  :next(@handle)       => {biglist[?+1..??],@newhandle} or {}
2
     These two are used for iterating over a range of elements of a biglist
2
     The canonical incantation for doing
2
        for elt in (biglist[first..last])
2
          ...
2
        endfor
2
     is
2
        handle = :start(biglist,first,last);
2
        while(handle)
2
          for elt in (handle[1])
2
            ...
2
          endfor
2
          handle = :next(@listdelete(handle,1));
2
        endwhile
2

2
The following all destructively modify their biglist argument(s) L (and M).
2

2
  :set_nth(L,n,value)  =>  L[n] = value
2
     replaces the indicated element
2

2
  :insert_before(L,M,n) => {@L[1..n-1],@M,@L[n..length(L)]}
2
  :insert_after (L,M,n) => {@L[1..n],  @M,@L[n+1..length(L)]}
2
     takes two distinct biglists, inserts one into the other at the given point
2
     returns the resulting consolidated biglist
2

2
  :extract_range(L,m,n) => {{@L[1..m-1],@L[n+1..]}, L[m..n]} 
2
     breaks the given biglist into two distinct biglists.
2

2
  :delete_range(L,m,n[,leafkiller]) => {@L[1..m-1],@L[n+1..]}
2
  :keep_range  (L,m,n[,leafkiller]) => L[m..n]
2
     like extract_range only we destroy what we don't want.
2

2
  :insertlast(L,value)  => {@L,value}
2
     inserts a new element at the end of biglist.  
2
     If find_ord is to continue to work properly, it is assumed that the 
2
     home:_ord(elt) is greater (comp-wise) than all of the :_ord values
2
     of elements currently in the biglist.
2

2
  :kill(L[,leafkiller]) 
2
     destroys all nodes used by biglist.  
2
     Calls home:leafkiller on each element.
36
5
5
36
4
4
2
2
ghblu
2
biglist_utils
36
1
4
1
2
This is the Generic BigList Utilities utility package.  See `help $biglist' for more details.
36
5
4
2
0
30986
0
1641541193
36
1
#14
Generic Large-Capacity Mail Recipient
144
36
1
-1
0
0
4
0
1
45
4
1
1
17
44
_genprop
36
173
-1
_make
2
173
-1
_kill
2
173
-1
_get
36
173
-1
_put
36
173
-1
_ord
36
173
-1
_makemsg
36
173
-1
_killmsg
36
173
-1
_message_num
36
173
-1
_message_date
36
173
-1
_message_hdr
36
173
-1
_message_text
36
173
-1
_lt_msgnum
36
173
-1
_lt_msgdate
36
173
-1
receive_batch
36
173
-1
receive_message
36
173
-1
messages_in_seq
36
173
-1
display_seq_headers
36
173
-1
display_seq_full
36
173
-1
list_rmm
36
173
-1
undo_rmm
36
173
-1
expunge_rmm
36
173
-1
rm_message_seq
36
173
-1
renumber
36
173
-1
length_all_msgs
36
173
-1
length_num_le
36
173
-1
length_date_le
36
173
-1
exists_num_eq
36
173
-1
new_message_num
36
173
-1
from_msg_seq
36
173
-1
%from_msg_seq
36
173
-1
to_msg_seq
36
173
-1
%to_msg_seq
36
173
-1
subject_msg_seq
36
173
-1
body_msg_seq
36
173
-1
date_sort
36
173
-1
_fix_last_msg_date
36
173
-1
__fix
36
173
-1
init_for_core
2
173
-1
length_date_gt
36
173
-1
_repair
2
165
-1
repair
2
41
-1
restore_from
2
173
-1
set_message_body_by_index
36
173
-1
4
summary_uses_body
_mgr
mowner
_genprop
26
0
0
36
5
1
13
36
5
1
36
36
1
2

36
1
5
36
5
0
0
36
1
4
0
36
0
5
36
5
5
36
5
5
36
5
5
36
5
4
0
36
1
5
36
1
5
36
1
5
36
1
4
0
36
0
5
36
5
5
36
5
5
36
1
5
36
0
5
36
0
5
36
0
5
36
4
4
1
2
Generic Large-Capacity Mail Recipient
36
1
4
41
2
Generic Large Capacity Mail Recipient
2
-------------------------------------
2
Since any modifications to large lists entail copying the entire list over, operations on ordinary mail recipients having large numbers of messages, that actually change the content of .messages will take inordinately long.  Thus we have this version which makes use of the $biglist package, scattering the messages onto numerous properties so that write operations involving only a few messages will not require recopying of the entire list.
2

2
In nearly all respects it behaves as the ordinary Mail Recipient, except that it is faster for certain kinds of operations.
2

2
Certain unimplemented verbs, like :date_sort(), and :messages() currently return E_VERBNF.
2

2
To convert an existing $mail_recipient-child (call it #MR) into a $big_mail_recipient-child the basic procedure is
2

2
    ;;something.foo= #MR:messages();
2
    @rmm 1-$ from #MR
2
    @unrmm expunge
2
    @chparent #MR to $big_mail_recipient
2
    ;#MR:receive_batch(@something.foo);
2

2
Reconstructing Damaged Big Mail Recipients
2
------------------------------------------
2
On rare occasions, the tree structure created by $biglist can be corrupted (this can happen on lists sufficiently large that a list-modification operation (e.g., @rmm, @renumber) runs out of ticks/seconds).  In the vast majority of such cases, your messages are all still there; it's simply that the tree we use for finding/searching them is messed up.
2

2
To recover messages from a damaged big mail recipient (#DBMR)
2
 --- read to the end before you start typing any commands ---
2

2
create a fresh $big_mail_recipient (#NEWBMR) and then do the following:
2

2
   ;#NEWBMR:restore_from(#DBMR)
2

2
When this finishes, #NEWBMR will contain all of the mail messages we were able to find.  (note that this will include messages that you had deleted from #DBMR but not expunged).  #NEWMBR should thenceforth be useable in place of #DBMR, however if #DBMR contains custom verbs and non-clear properties, these will also need to be copied over.
2

2
Alternatively, one may do
2

2
   @copyobject #DBMR to #TEMPBMR
2
   ;#DBMR:restore_from(#TEMPBMR)
2

2
to rebuild #DBMR in place.  This, however, will take about twice as long.
2

2
oooooooooooooooooooooooooooooooo
2
WARNING!!! WARNING!!! WARNING!!!
2
oooooooooooooooooooooooooooooooo
2

2
Calling #OBJ:restore_from(...) COMPLETELY AND IRREVOCABLY REMOVES ALL MESSAGES from the object that it is run on (#OBJ); you MUST be sure to EITHER have made a copy of #OBJ OR be doing the restore to a DIFFERENT object.
36
5
4
2
0
53798
0
1641541193
36
1
#15
Limbo
16
2
1
-1
0
0
4
1
1
98
1
1
4
0
5
acceptable
2
173
-1
confunc
2
173
-1
who_location_msg
36
173
-1
moveto
36
173
-1
eject
2
173
-1
0
4
5
2
4
4
1
2
The Body Bag
2
5
5
2
5
4
2
0
3784
0
1648488120
36
1
#16
Registration Database
0
36
1
-1
0
0
4
0
1
37
4
0
10
find* _only* _every*
36
173
-1
add
36
173
-1
init_for_core
36
173
-1
suspicious_address
2
173
-1
suspicious_userid
2
173
-1
describe_registration
2
173
-1
prune
2
173
-1
report_prune_progress
2
173
-1
prune_reset
2
173
-1
search
2
109
11
7
registrar
prune_progress
prune_stop
total_pruned_people
total_pruned_characters
prune_task
alphabet
14
1
2
36
5
2
aaa
36
5
2
zzz
36
5
0
0
36
5
0
0
36
5
0
0
36
5
2
abcdefghijklmnopqrstuvwxy0123456789_.@+z
36
5
2

36
5
5
36
1
4
4
2

2

4
0
4
0
36
0
0
0
36
4
4
1
2
Registration Database
36
5
5
36
5
4
2
0
13392
0
1641541193
36
1
#17
Player-Creation-Log
0
2
1
46
0
0
4
0
1
14
4
0
5
display_seq_headers
2
173
-1
msg_summary_line
2
173
-1
init_for_core
2
173
-1
is_usable_by
2
173
-1
expire_old_messages
2
13
-1
2
 a
 b
28
4
1
2
none
36
0
4
2
0
0
4
1
4
6
2
 a
0
1
0
1541028130
2
Wizard (#2)
2
*Player-Creation-Log (#17)
2
Anti-Wizard (#98)
36
0
0
1
2
5
1
13
2
5
1
36
36
1
2
b
36
1
4
0
2
5
0
0
36
1
4
1
4
2
0
0
4
3
2
 b
0
1
4
2
0
1
0
1541028130
36
0
4
1
1
17
2
5
2
%n (%#) can't send to moderated list %t (%[#t]) directly.
2
5
4
0
2
5
4
0
2
5
4
1
1
2
36
1
4
0
36
1
0
2592000
36
1
0
1541028130
36
1
4
0
36
0
5
2
5
5
2
5
4
0
36
1
5
36
0
5
36
0
5
36
0
0
0
2
4
4
2
2
Player-Creation-Log
2
PCL
36
1
2
Log of player creations.
2
5
4
2
0
5701
0
1648488120
36
1
#18
Verb Help DB
16
36
1
-1
0
0
4
0
1
1
4
0
3
find_topics
36
173
-1
get_topic
2
173
-1
dump_topic
2
173
-1
1
help_msg
5
4
23
2
This is not a help database in the same way that children of $generic_help are. This object does the work when someone calls help in this way:
2

2
    help <object>:<verb>
2

2
It parses out the object and verb reference, pulls out the comments at the beginning of the verb, and returns them to the help system for nice display.
2

2
    :find_topics(string)
2
       tries to pull out an object:verb reference from string
2
       returns {string} if successful
2
       returns {} if not
2

2
    :get_topic(string)
2
       tries to pull out an object:verb reference from string (returns 0 if
2
          it fails to do so)
2
       tries to match the object
2
       checks the object to see if the verb exists
2
       pulls out the initial comments from the verb if they exist
2
       returns a meaningful list of strings to be displayed to the player
2

2
    :dump_topic(string)
2
       does the same as :get_topic above, but returns the verb documentation
2
          in dump form.
2
----
36
5
5
36
4
4
2
2
verbhelp
2
vh
36
5
2
A `help database' that knows about all of the documented verbs.
36
5
4
2
0
5412
0
1641541193
36
1
#19
Core Utility Help
16
36
1
-1
0
0
4
0
1
30
4
0
3
find_topics
36
173
-1
get_topic
36
173
-1
dump_topic
2
173
-1
43
$login
$container
$mail_agent
MR-subscribing
MR-naming
MR-access
$mail_recipient
receiving-mail
mail-format
mail-resolve
sending-mail
mail-system
$player_db
core-index
object-matching
$no_one
$exit
$room
$help
$generic_db
$generic_editor
$generic_help
$generic_options
MR-sequences
MR-reading
MR-writing
MR-searching
$housekeeper
$recycler
$error
$biglist
$guest_log
mail-resolution
$news
matching
MR-expiration
mail-expiration
$big_mail_recipient
init_for_core
include_for_core
proxy_for_core
$core_objects
make-core-database
49
4
81
2
$login
2
------
2
This object manages command parsing for unconnected players and governs the initiation of an actual connection.  There are verbs pertaining to registration, controlling player creation, and doing site-locks (see `help blacklist' on $wiz_help).
2

2
COMMANDS FOR UNCONNECTED PLAYERS
2

2
Recall that for each line that an unconnected player types, the server parses that line into words (the same way normal commands are parsed into a list of words that is then assigned to `args') and then #0:do_login_command is called.
2

2
  :parse_command (@args) => {verb, @args}
2
    given the sequence of arguments that were fed to #0:do_login_command
2
    this returns the name of a verb on $login to be called together with a 
2
    list of arguments to be passed to it.
2

2
By default this just returns args iff args[1] names an actual verb on $login that is +x and has args {"any","none","any"}.  Otherwise, it returns one of
2

2
  .blank_command   -- verb to call if command line is empty
2
  .bogus_command   -- verb to call if command line otherwise unintelligible
2

2
In both cases :parse_command returns a verbname followed by the entire args list passed to it (including the would-be verb at the beginning if any).
2

2
Currently the following verbs are available to non-connected players
2

2
  h*elp @h*elp       -- print .welcome_message
2
  ?                  -- print a short list of available commands
2
  w*ho @w*ho         -- print a list of logged in players (excluding wizards)
2
  co*nnect @co*nnect -- connect to an existing player
2
  cr*eate @cr*eate   -- create a new player
2
  up*time @up*time   -- tell how long the server has been running
2
  version @version   -- tell which version of the server is running
2
  q*uit @q*uit       -- logoff
2

2
Adding a new command is fairly straightforward; just create a verb on $login, making sure a previous verb doesn't already match the name you want to give it.  Then give it args of "any" "none "any" and make sure it is +x.  Such a verb should begin with `if (caller != #0) return E_PERM; ...' so as to prevent anyone other from a not-logged-in player from making use of it.
2

2
CUSTOMIZATIONS
2

2
  .welcome_message 
2
    -- the message for "help" to print.
2
  .create_enabled 
2
    == 0 => @create prints .registration_string if one tries to use it
2
    == 1 => anyone from a non-blacklisted site (see `help blacklist')
2
            may use @create to make a new player
2

2
  .registration_address
2
    -- an email address for character creation requests
2
  .registration_string  
2
    -- string to print to players to give them information about how to get 
2
       a character created for them, .registration_address is substituted 
2
       for %e, % for %%
2
  .newt_registration_string
2
    -- string to print to @newted players (see `help @newt').
2
       same substitutions as for .registration_string.
2

2
  .max_connections
2
    -- integer representing the maximum connected players permitted on this moo.
2
  .connection_limit_msg
2
    -- string printed out when this is reached.
2
  .lag_exemptions
2
    -- list of non-wizard players who may login anyway.
2

2
  .argon2
2
    -- parameters for hashing passwords. See HELP ARGON2 for information on the
2
       options available. 
2

2
Other verbs
2
   :registration_string()      => .registration_string with substitutions
2
   :newt_registration_string() => .newt_registration_string with substitutions
2
   :player_creation_enabled(connection) 
2
       decides whether someone on connection should be allowed to create 
2
       a player.  If you decide this shouldn't depend strictly on the blacklist
2
       and on the value of .create_enabled, here's where the extra code can go.
2
   :check_for_shutdown()
2
       prints a warning message to append to the login banner in the event 
2
       that the server will be going down soon.
2
   :check_player_db()
2
       prints a warning message to append to the login banner in the event 
2
       that $player_db is being reloaded to warn players that their character
2
       names might not be recognized.
2

2
SITE LOCKS
2
see `help blacklist'
2

36
5
4
29
2
The Generic Container (for programmers)
2

2
In addition to the command verbs described under `help containers'
2
and the _msg properties described in `help container-messages',
2
the following verbs and properties are available for use within programs
2

2
.opened == TRUE iff the container is open
2
.dark   == TRUE iff the contents of the container may be seen
2
.opaque -- describes the correlation between .open and .dark
2
   == 0  container is always !dark
2
   == 1  container is dark iff it is closed
2
   == 2  container is always dark              
2

2
:set_opaque(newvalue)   
2
  changes the .opaque value for the container
2
  => newvalue or E_PERM or E_INVARG
2

2
:set_opened(newvalue)   
2
  opens/closes the container (updates .open and .dark) according to newvalue
2
  => newvalue or E_PERM
2

2
:is_openable_by(player) 
2
 what the :open command uses to test whether the player should be able to open
2
 the container.  By default this refers to .open_key  (set by
2
 @(un)lock_for_open), but the object owner is free to customize this.
2

2
N.B.:  There is no way to directly set .dark; .dark can be changed only by 
2
changing one of .opaque or .opened.  Use :set_opaque(0) and :set_opaque(2)
2
to have .dark change independently of the value of .opened.
36
5
4
68
2
$mail_agent
2

2
This object contains a two distinct sets of routines:
2

2
  1.  utilities for performing basic mailsystem functions, e.g.,
2
      matching on recipient names, resolving mail forwarding, 
2
      formatting messages, sending messages
2

2
Recipient Matching
2

2
match           - match on a $mail_recipient
2
match_recipient - match on either a $mail_recipient or a player
2
match_failed    - print angry messages to the user for $failed/ambiguous_match
2

2
look_self  - provides a list of available $mail_recipients
2
check_names
2
touch
2
accept
2

2
Message Format
2

2
make_message        - produces a message in the canonical transmission format
2
name                - single recipient     => string for address field
2
name_list           - list of recipients   => string for address field
2
parse_address_field - address field string => object list
2

2
Sending Messages
2

2
send_message  - advertised message sending routine.
2
raw_send      - raw message sending routine 
2
                (only called by $mail_editor:send and this:send_message)
2
resolve_addr  - converts a given list recipients into a list of actual 
2
                recipients and objects to be notified.
2
sends_to      - Does X forward (transitively) to Y
2

2
Mail Options
2

2
option         
2
option_verbose
2

2
  2.  canonical versions of mail_recipient verbs
2

2
Ideally, the verbs to perform operations on a given mail recipient would be located on the recipient itself, except for the fact that these verbs also need to be located on players, which for various reasons, shouldn't be children of $mail_recipient.  Multiple inheritance would solve our problems, but we don't have it yet.  Ergo, both $mail_recipient and $player refer to the following verbs here:
2

2
display_seq_full     print entire text of messages  (@read)
2
display_seq_headers  print headers of messages      (@mail)
2
rm_message_seq       remove messages                (@rmm)
2
undo_rmm             undo last rm_message_seq       (@unrmm)
2
expunge_rmm          flush removed messages         (@unrmm expunge)
2
list_rmm             list removed messages          (@unrmm list)
2
renumber             renumber messages              (@renumber)
2
msg_summary_line     msg header => display_seq_headers/list_rmm summary line
2

2
parse_message_seq    command line msg sequence spec => message sequence
2
new_message_num      => message number of next new message
2
length_all_msgs      => number of messages (total)
2
length_num_le        => number of messages numbered <= some number
2
length_date_le       => number of messages dated <= some date
2
exists_num_eq        => true iff there exists a messsage with the given number
2
from_msg_seq         => message sequence of msgs from given sender(s)
2
to_msg_seq           => message sequence of msgs to given recipient(s)
2
subject_msg_seq      => message sequence of msgs with subjects containing text
2
body_msg_seq         => message sequence of msgs with bodies containing text
2
messages_in_seq      => list of {message number, message} pairs
2

2
messages             == :messages_in_seq(1,:length_all_msgs()+1)   (obsolete)
2

2
The $mail_agent versions of these verbs are set_task_perms(caller_perms()) and perform their operations on caller, which in turn is assumed to have done any necessary security checks.
36
5
4
38
2
Subscribing to Mail Recipients
2
------------------------------
2
There are two notions of being "subscribed" to a mailing list/recipient.
2

2
(1) Hard subscribed == being on the recipient's .mail_forward list so that mail sent to this list is forwarded to one's own .messages as well (see `help mail-forwarding').
2

2
(2) Soft subscribed == keeping track of a current message for this recipient and (optionally) being on the recipient's .mail_notify list.
2

2

2
Each player has a .current_message property that contains, for each recipient the player cares to keep track of, a current message number and a last read date.
2

2
player:current_message(rcpt)                 (somewhat obsolete)
2
 => player's current message number for rcpt 
2

2
player:get_current_message(rcpt) 
2
 => player's {current message number for rcpt, last-read-date for rcpt}
2

2
player:make_current_message(rcpt)
2
 => adds a current_message entry for rcpt  (NOOP if rcpt == player)
2

2
player:set_current_message(rcpt,n|E_NONE,[,date])
2
 => sets player's current message number for rcpt to n iff n!=E_NONE
2
    updates the last-read-date for rcpt to date iff date > last-read-date
2

2
player:kill_current_message(rcpt)
2
 => removes current-message info for rcpt  (NOOP if rcpt == player)
2

2

2
On $mail_recipient, .mail_forward and .mail_notify are -c so one needs to use the following verbs to actually modify them.
2

2
    :add_forward(@new_recipients)
2
    :delete_forward(@recpients)
2
    :add_notify(@new_notifiees)
2
    :delete_notify(@notifiees)
2

2
A recipient's owner is, of course, allowed to make arbitrary changes to .mail_forward and .mail_notify.  However, the default versions of these verbs also allow any player to add him/herself to a recipient's .mail_forward or .mail_notify if the recipient is readable (see `help MR-access') by him/her.
2

2
Likewise any player may use the :delete* verbs to delete him/herself from any .mail_forward/.mail_notify list, regardless of his actual access to the list.
36
5
4
15
2
One may always refer to a list by its object number.  In order to refer to it by name, it must be contained in $mail_agent, which holds all mailing lists, i.e., those that you want others to be able to refer to by name.
2

2
The .aliases field holds the names by which one may refer to the list, but only those names not containing spaces actually count for anything.  As with certain other types of objects (e.g., players), set_aliases() needs to be called in order to change the .aliases field.
2

2
$mail_agent:match(name) 
2
    is the canonical way to obtain the objectid of a mailing list 
2
    given the name ("*" is assumed; an initial "*" will be dropped).
2

2
$mail_agent:match_recipient(name) 
2
    is the canonical way to obtain the objectid of a list or player
2
    matching the given name.  An initial "*" indicates that this is 
2
    supposed to be a list.
2

2
$mail_agent:match_failed(objid,name) 
2
    is the mail_recipient counterpart to $command_utils:object_match_failed
36
5
4
32
2
Controlling Access to Mail Recipients
2
-------------------------------------
2
:is_writable_by(one) - one may alter/add/remove saved messages
2
:is_readable_by(one) - one may read messages.
2
:is_usable_by(one)   - one may send to this list
2

2
By default, these verbs refer to the following properties:
2

2
writers   - list of players other from the owner who can do anything
2
readers   - if == 1, indicates a public mailing list.
2
            list of additional readers (by default anyone who receives mail 
2
            sent to the list can read the saved messages).
2
moderated - if false, indicates a normal mail recipient everyone can send to.
2
            otherwise this should be a list of approved senders.
2

2
Terminology:
2
  A mailing list is "public" if everyone can read it.
2
  A mailing list is "moderated" if not everyone can send to it.
2

2
Note that while being able to write to a recipient implies being able to read from it or send to it, neither of read-ability or send-ability implies the other.
2

2
It is highly recommended that if you are creating custom mail recipients with variable reader/sender lists, i.e., you find you need to write your own :is_readable/usable/writabe_by verbs, you are best off if such verbs are of the form
2

2
  return pass(@args) || << your_test(args[1]) >>
2

2
and have .writers == .readers == {} and .moderated == 1.  This will ensure
2
 (1) wizards having write access
2
     --- necessary in order for :receive_message to work
2
 (2) writers being able to read and send (the converse being a ludicrous 
2
     situation), 
2
 (3) persons on the mail_forward list of someone with reader access will also
2
     have read access (convenient).
36
5
4
20
2
Generic Mail Recipient
2
----------------------
2
A "mail recipient" is, by definition, an object that can be sent mail.
2
Mail recipients must either be players or descendants of $mail_recipient.
2

2
One source of confusion is that the terms "mail recipient", "mail folder", "mailing list", and "mail collection" really all refer to the same kind of object.  It so happens that $mail_recipient serve several distinct functions and we tend to use whatever term happens to best match the application under discussion, e.g., it's a "mailing list" if we're playing with its .mail_forward property but it's also a "mail folder" if we're examining the messages that have been saved in it.
2

2
Note that, by default, a freshly created recipient is accessibly only by you.  If you wish to make a publically accessible recipient, set .readers=1.  Furthermore, if you want to allow a message on your recipient to be removed by its sender without your intervention, set .rmm_own_msgs=1.  Finally, in order for other players to be able to refer to your recipient by name, the object must reside in $mail_agent.  $mail_agent will not accept the object unless it has an actual description and a name distinct from all other mail recipient names/aliases.
2

2
Topics:
2

2
  MR-access       -- controlling read, write and send access to a recipient
2
  MR-naming       -- naming conventions and how to match on recipient names
2
  MR-sequences    -- message sequence arguments to $mail_recipient verbs
2
  MR-reading      -- reading messages/headers on recipients
2
  MR-searching    -- searching message lists for patterns in certain fields
2
  MR-writing      -- removing and renumbering messages
2
  MR-subscribing  -- updating .mail_forward, .mail_notify 
2
                       and the story of .current_message
2
  MR-expiration   -- expiring and netmailing messages from recipients
36
5
4
24
2
Receiving Mail
2
--------------
2
By definition a recipient "receives" a mail message when its :receive_message verb is called with that message as an argument.
2

2
:new_message_num()
2
=> number that will be assigned to the next incoming message.
2
By default this returns the maximum of the message numbers appearing in 
2
messages or .messages_going, incremented by 1.  If the recipient is a player
2
then the value returned will be 1 higher if it conflicts with the player's 
2
current message number for him/herself.
2

2
:receive_message(msg,sender)
2
By default this first calls this:new_message_num to obtain a message number to assign to the incoming message and then appends {num,msg} to this.messages.  
2
`sender', the original sender, is supplied in case one wants different 
2
action depending on who is sending the message (e.g., mail-gagging).
2
The return value should be an error or string if :receive_message is considered to have failed in some way.  Otherwise, a number should be returned --- this number is given to any :notify_mail routines that are called and is expected to either be 0 or the number assigned to the incoming message.
2

2
Note that :receive_message can do arbitrary things, including resending the same message to a new destination.  Hacking :receive_message to resend messages is different from using .mail_forward in the following respects
2
  (1) the resent message is considered to be a distinct message having this 
2
      object as its "author" --- i.e., the From: line will necessarily be 
2
      different.
2
  (2) since this "forwarding" is invisible to the mailsystem, 
2
      there is no protection against loops and multiple copies.
2

36
5
4
34
2
Mail Transmission Format
2
------------------------
2
There is a standard message format used for transmitting messages.  This is the format that $mail_editor:make_message produces, and that :receive_message verbs on players and $mail_recipients expect to see.  The (currently experimental) @refile and @copym commands also use this format to transfer messages.
2

2
This *transmission* format is distinct from the *storage* format, though, for convenience this same format is often used as well for storing messages in player collections and ordinary $mail_recipient children though, in general, there is no requirement that this be the case.
2

2
A transmitted message is a list in the following form
2

2
   date (number),
2
     the time() value at the time the message was sent.
2
   from (string),
2
     the sending object (address list form)
2
     if this is not a player, an additional header will indicate the 
2
     current ownership of the object.
2
   to  (string),
2
     recipients (address list form) which can either be players 
2
     or $mail_recipient descendents.
2
   subject (string),
2
     subject of the message, or " " if there is no subject,
2
  @additional optional headers (list of strings),
2
     each header has the form "<header-name>: text" where <header-name>: 
2
     is padded out to a width of 10 columns for the convenience of 
2
     :display_message.  Currently "Reply-to: <address list>" is the only 
2
     additional header in use,
2
   "",
2
  @body of message (list of strings)
2

2
Note that the from, to and subject lines do *not* include a header name like "From:", "To:", or "Subject:".  The @'s indicate that the lists in question get spliced in (as usual), thus the entire message is a list whose first element is a number and the rest are strings.
2

2
The address lists that appear in the from and to lines is a string in the form a sequence of object ids, each enclosed in parentheses and preceded by optional text, e.g.,
2

2
  "*Core-DB-Issues (#8175), Rog (#4292), and Haakon (#2)"
2

2
The text is intended to give the current name of each object for the benefit of human readers, but is actually ignored by all header parsing routines.  The convention is that the text is either a player name or a * followed by a mailing list name.
36
5
4
52
2
Resolving Mail Forwarding & Notification
2
----------------------------------------
2
For each recipient of a given mail message, the following two verbs are called to determine where the message should actually go and who should be notified about it:
2

2
:mail_forward([from])
2
    should return either
2
     . a list of objects (either players or $mail_recipients)
2
         to which mail for this recipient will be redirected.
2
     . a string error message to be printed to the player sending the message.
2
         If this recipient is one of the original destinations (i.e., not the
2
         result of a previous forwarding), no mail is actually sent.
2

2
    If :mail_forward returns a nonempty list, the recipient itself will *not*
2
    actually receive the mail message unless it is included in the list.
2
    #-1 is allowed to be on the list; it is ignored but does make the list 
2
    nonempty.  Thus, having :mail_forward() return {#-1} is the canonical way
2
    to have arriving mail disappear without being kept or forwarded.
2

2
:mail_notify([from]) 
2
    should return a list of objects that are to be told about any mail sent 
2
    to this recipient (whether or not the recipient actually receives it).
2
    Said objects must have a :notify_mail verb, but other from that, there 
2
    is no restriction on what these can be.
2

2
    object:notify_mail is called with the arguments 
2
    (sender,recipients,msgnumbers) where 
2
      recipients  == list of recipients including object in .mail_notify
2
      msgsnumbers == corresponding list of :receive_message return values
2
                 (or 0 if :receive_message is not actually called, which
2
                  will be the case if the recipient forwards without keeping)
2

2
When called as part of a mail send, the `from' argument is the immediate predecessor on the forwarding chain.  The default versions of these verbs return the values of .mail_forward and .mail_notify respectively (pronoun_subbing if the value is a string), unless this is a moderated mailing list and `from' is an unapproved sender (see `help MR-access') in which case the following verbs are called instead:
2

2
:moderator_forward(from) 
2
    what :mail_forward should return for mail coming from unapproved senders
2
    This returns .moderator_forward (pronoun_subbed if a string) by default.
2

2
:moderator_notify(from)
2
    what :mail_notify should return for mail coming from unapproved senders
2
    This returns .moderator_notify (pronoun_subbed if a string) by default.
2

2
Since the :mail_forward verbs only see the previous sender in the forwarding chain, if, e.g, B is moderated but A can send to B (i.e., B:mail_forward(A) returns an actual list), then any mail sent to A goes to B even if the original sender isn't normally allowed to send to B directly.
2

2
These verbs should all allow `from' to be omitted in which case they should return as if `from' were a generic approved sender (e.g., wizard).
2

2
It should rarely be necessary to actually modify any of :*_forward/*_notify verbs, since one has a fair amount of control over their behavior via the following properties
2

2
  .mail_forward
2
  .mail_notify
2
  .moderated          (see `help MR-access')
2
  .moderator_forward
2
  .moderator_notify
36
5
4
24
2
Sending Mail
2
------------
2
$mail_agent:send_message(from,recipients,headers,body)
2
  from:        sender of the message 
2
               (this must be you or something you own; otherwise => E_PERM)
2
  recipients:  object or list of objects (must all be players or 
2
               $mail_recipient descendants)
2
  headers:     either a string (contents of the Subject: line) 
2
               or a list {subject,replytos} replytos is a list 
2
               of objects designated to receive replies.
2
               Use {"",replytos} to have a Reply-to: without a Subject:
2

2
This is the canonical way to send a mail message from a program.
2
This calls $mail_agent:make_message to format the arguments into an actual message (see `help mail-format') and then $mail_agent:raw_send to do the actual sending which goes as follows:
2

2
  (1) Call :mail_forward on all recipients add any new recipients thus obtained to final recipient list, keep calling mail:forward on the new recipients until we obtain no additional recipients.  If one of the initial recipients is invalid, is not a player or $mail_recipient, or has its mail_forward return a string error, then we print the error message and abort at this point with no mail being sent.  If one of the later recipients bombs similarly, error messages are printed, but in this case mail still goes out to the other recipients.
2

2
  (2) Call :mail_notify on all recipients encountered in stage (1) to get a list of objects to notify.
2

2
  (3) All final recipients receive the message (see `help receive-mail')
2
  (4) All notifications are delivered (using :notify_mail())
2

2
We return {0, @failed_recipients} if we bombed out at step 1.
2
Otherwise return {1, @actual_rcpts} indicating what mail was sent.
36
5
4
13
2
Mail System
2
-----------
2
The following topics describe the guts of the LambdaCore mail system
2

2
sending-mail     -- how to send mail from a program; what happens.
2
mail-forwarding  -- how to do mail forwarding/notification (the simple version)
2
mail-resolve     -- how mail forwarding/notification works, in gory detail
2
receiving-mail   -- what :receive_message should do
2
mail-format      -- format of transmitted messages
2
mail-command-parsing   (TODO) -- routines for parsing mail commands
2

2
$mail_recipient  -- generic non-player mail recipient
2
$mail_agent      -- mail utility object
36
5
4
34
2

2
Database of Players
2
-------------------
2
This is an instance of the Generic Database ($generic_db) that
2
holds the {name/alias,#objectid} pairs for every 
2
name and alias of every player in the MOO.
2

2
Verbs supplied include
2

2
  :find(string)        => player or $ambiguous_match or $failed_match
2
  :find_exact(string)  => player or $failed_match (does not do partial matches)
2
  :find_all(string)    => list of all matching players
2

2
  :insert(string,player) 
2
       records that string is now a name or alias of player
2
  :delete(string) 
2
       removes string from the db
2
  :available(string)
2
       returns 1 if string is available as a player name or alias,
2
       an object if string is in use, or 0 if string is otherwise unavailable.
2
  :load()
2
       resets the db, inserting all current player names and aliases.
2

2
The internal representation and all of the above verbs (except :load() and
2
:available()) are as described for $generic_db.
2

2
It should be noted that for any application that involves resolving a player name from a command line, you should be using $string_utils:match_player() rather than $player_db:find(), since the former will deal correctly with other ways of referring to players apart from their names and aliases (e.g., literal object numbers, "me", "$no_one"...).
2

2
:load() needs to be done periodically as it is possible for the player db 
2
to get out of synch with reality.  In particular, there is currently no way
2
to block someone writing his own player :recycle() verb that neglects to 
2
remove his names from the player db.
2

2
While a :load() is in progress the .frozen property is set to 1 to indicate that any results of :find*() are not to be trusted.
36
5
4
2
2
*index*
2
Core Utility Help Topics
36
5
4
64
2

2
Which :match...() Verb Do I Call?
2
---------------------------------
2
There are many situations where one wishes to obtain an object from a room or a player's .contents whose name/aliases matches a particular string.  There are four main verbs available for this and it is important to understand the distinctions between them and how they are supposed to be used.
2

2
(*)  LOC:match("X")
2
     -- what you get looking for something that is inside LOC and named "X".
2
        By default, this looks through LOC.contents to find a unique object 
2
        having a name or alias that has "X" as a prefix.
2

2
Essentially, you can think of :match as a contents-matching verb, though, e.g., for rooms you also get matches on exits as well.
2

2
(*)  LOC:match_object("X", YOU)           [YOU defaults to player]
2
(*)  YOU:my_match_object("X", LOC)        [LOC defaults to player.location]
2
     -- what YOU get being located at LOC and looking for something named "X".
2
        By default these both return $string_utils:match_object("X",LOC,YOU)
2

2
(*)  $string_utils:match_object("X", LOC, YOU) 
2
   -- what you *would* get *if* YOU were a typical player, YOU were inside LOC,
2
      YOU were looking for something named "X", *and* LOC were a typical place.
2

2
In other words, $string_utils:match_object describes the :match_object() algorithm for "typical places" and the :my_match_object for "typical players":
2

2
    (1)  check for "X" being one of "", "me", "here", "$something", or "#n"
2
    (2)  try YOU:match("X") i.e., something in your inventory (maybe)
2
    (3)  try LOC:match("X") i.e., some object in the room (maybe)
2

2
The distinction between these location:match_object and player:my_match_object has to do with whether the player or the location should determine what the matching algorithm is.  Which one you should use depends on the command that you are writing.  If you are writing a command with a virtual-reality flavor, then you should be respecting the room owner's idea of which objects you can "see" and thus the command should be calling the location's :match_object verb.  If you are writing a building/programming command where it is appropriate for the player to determine the matching algorithm  --- whether because the current location is irrelevant, not to be trusted, or both --- then the player's :my_match_object verb should be called.
2

2
Examples:
2

2
  `look diamond in box'
2
      calls box:match("diamond").  This is a match on the contents of box.
2

2
  `take ball', 
2
      calls player.location:match_object("ball")
2
      to determine which "ball" to take.  Note that if the room is dark, 
2
      we might not be able to find any "ball".
2

2
  `@program widget:foo', 
2
      calls player:my_match_object("widget") to get the player's own idea
2
      of what "widget" should be.  Note that if I were carrying something 
2
      named "widget" and expecting to be programming a :foo() verb on it,
2
      it would be potentially disastrous should the room where I am decide
2
      for me to be programming something else (not even necessarily 
2
      called "widget").
2

2
Object Matching Failures
2
------------------------
2
As with other matching routines, one gets back 
2

2
  $failed_match in the case of no matching object
2
  $ambiguous_match in the case of more than one matching object
2
  $nothing in the case of a blank string argument
2

2
or an object-id.  In these first 3 cases, one usually wants to translate these nonresults to the player; this is what $command_utils:object_match_failed.  The standard idiom to mimic what the builtin parser does, say, with the direct object is
2

2
  dobj = foo:match_???(dobjstr);
2
  if($command_utils:object_match_failed(dobj, dobjstr))
2
    "...give up.  nothing to do.   error message has already printed...";
2
  else
2
    "...dobj is something useful.  Continue...";
2
    ...
2
  endif
36
5
4
25
2
$no_one
2
-------
2
... is a powerless player.  He owns no objects, not even himself; nor does he own any verbs.  He is, however, a programmer and thus may use eval().  In fact his sole purpose is to evaluate questionable code.  `questionable' could be in either or both of the following senses 
2

2
(1) Its origin is sufficiently uncertain so that there is no obvious way of deciding whose permissions it should run under.
2
(2) The code itself is potentially malicious, i.e., to the extent that one does not want to be evaluating it using one's own permissions.
2

2
set_task_perms($no_one);  is thus the canonical idiom in wizard code for rendering anything that follows mostly harmless.  For use by ordinary programmers, we have:
2

2
    $no_one:eval(string)
2

2
which attempts to evaluate an arbitrary string using $no_one's permissions.
2
string is either an expression or ";" followed by one or more statements, of which the final semicolon may be omitted.  return values are what eval() would return (either {1,value} or {0,@error_messages}).
2

2
Similarly, we have
2

2
    $no_one:eval_d(string)
2

2
which attempts to evaluate the specified string, but does it without the debug flag turned on (so that, for example, you'll get an error as opposed to terminating by traceback).
2

2
And, as a helpful utility for calling verbs whose behavior may be unpredictable, there is
2

2
    $no_one:call_verb(object, verb name, args)
2

2
which calls the specified verb with $no_one's permissions.
36
5
4
19
2
Exits
2
-----
2
An exit can be renamed by either the owner of the exit or the owner of its source.
2

2
The standard verbs that are called in exit movement are:
2

2
:move(object)  - moves the object via this exit
2
:invoke()      - equivalent to :move(player)
2

2
When an exit is invoked on a particular object (via exit:move(object)), the following occurs.
2

2
(1) The exit may be locked against the object, in which case we print the 
2
   nogo messages and quit.
2

2
(2) (room=exit.dest):bless_for_entry(object) is called.  Assuming that exit is recognized by room as being a legitimate entrance (i.e., is in room.entrances), this will enable room:accept(object) to return true.
2

2
(3) object:moveto(room) is called and the various messages (see `help exit-messages') are :announced/:told.  Note that this, in accordance with the way the builtin move() (and hence the default :moveto()) works, we get a call to room:accept(object) which checks for the room itself being locked against the object, and otherwise returns true if the blessing in the previous step worked.  The move is performed, here:exitfunc(object) and room:enterfunc(object) are called.  In particular, room:enterfunc clears the blessing bestowed in (2) now that it is no longer needed.
2

2
In general, the move may fail, in which case we :announce the (o)nogo_msgs.
36
5
4
81
2
The Generic Room ($room)
2
----------------
2

2
(1)  Announcements
2

2
:announce         (@text)         => broadcasts to all except player
2
:announce_all     (@text)         => broadcasts to all
2
:announce_all_but (objects,@text) => broadcasts to all except those in objects
2

2
say, emote
2

2

2
(2)  Command recovery
2

2
:huh            (verb,args) - server hook: last chance to make sense of verb
2
:here_huh       (verb,args) - room's last attempt to parse something
2
:here_explain_syntax (this,verb,args) - attempts to explain usage of verb
2

2

2
(3)  Residency
2

2
free_home  - true => @sethome allows anyone to set his .home to be here
2
residents  - objects on this list may teleport in and/or set their homes here.
2

2
:accept_for_abode(player) 
2
            => true iff player should be allowed to set .home to this room.
2

2
@resident*s
2

2

2
(4)  Looking
2

2
dark  - true => contents are not visible
2
ctype - 0..3 for four different styles of .contents lists
2

2
:match         (string)        => exit or object in room's .contents
2
:tell_contents (objects,ctype) - format objects according to ctype, tell player
2

2
l*ook
2

2

2
(5)  Entrance and exit.
2

2
:accept (object) - Called by move() and :moveto() before an object enters a room, if false is returned, movement is prevented.  Protocol permits this verb to make noise (though this is discouraged) as this is the only place the room will learn the object's original location.
2

2
:acceptable (object) - Called by verbs which wish to check whether movement will be possible.  Protocol prohibits this verb from making noise and requires it to return the same value as :accept would for the same arguments.
2

2
:is_unlocked_for (object) - interface with the @lock protocol.  Returns true or false depending on the state of locks for the object with the room.  Other things may prevent entrance even if this returns true.  Protocol prohibits this verb from making noise. 
2

2
:enterfunc (object) - called after entrance has succeeded.  Noise is fine.
2

2
:exitfunc (object) - called after an object has successfully left.  Noisemaking is fine.
2

2
(6)  Topology and Movement via Exits
2

2
See `help $exit' for an explanation of how the generic $exit works.
2

2
free_entry     - true  => `teleporting' in is allowed
2
                  false => only residents may teleport in
2
exits          - list of invokable exits leading from this room
2
entrances      - list of recognized exits leading to this room
2
blessed_object - object currently entering via an exit
2
blessed_task   - task_id for entering object
2

2
:match_exit      (string) => exit whose name matches string
2
:bless_for_entry (object) - set up room to accept object arriving from entrance
2
:add_exit        (exit)
2
:add_entrance    (exit)
2
:remove_exit     (exit)
2
:remove_entrance (exit)
2

2
e/east/w/west/s/south/n/north/ne/northeast/nw/northwest/se/southeast/sw/southwest/u/up/d/down, go, @add-exit, @add-entrance, @remove-exit, @remove-entrance, @exits, @entrances 
2

2

2
(7)  Ejection
2

2
victim_ejection_msg/oejection_msg/ejection_msg
2
:*_msg()  messages
2

2
@eject
2

36
5
4
2
2
*forward*
2
$generic_help
36
5
4
79
2
Generic Database
2
----------------
2
This holds a collection of {string key, datum} pairs, where datum can be anything.  At most one datum may be associated with any given string.  Data may be anything (lists, strings, numbers, objectids).  If you like, you can think of this as an array indexed by strings.
2
Verbs supplied include
2

2
  :find(string)          => datum, $ambiguous_match or $failed_match
2
  :find_key(string)      => full string key,  $ambiguous_match or $failed_match
2
  :find_exact(string)    => datum or $failed_match (no partial matches)
2
  :find_all(string)      => list of all data corresponding to matching strings
2
  :find_all_keys(string) => list of all matching strings
2

2
  :insert(string,datum)  
2
       if the string is already present in the db, 
2
       changes the associated datum and returns {old_datum};
2
       otherwise enters a new {string,datum} pair and return 0.
2
  :delete(string)
2
       if there is a datum associated with string, 
2
       remove this association and return {datum}; otherwise return 0.
2
  :delete2(string,datum)
2
       if the given datum is associated with string, 
2
       removes that association and return {datum}, 
2
       if some other datum is associated with string, just return {other datum}
2
       otherwise return 0.
2
  :clearall([4|3])
2
       removes all associations from the database.
2
       optional argument changes the type of the database 
2
       (4 is normal, 3 is a kludge for when the data are simply boolean flags
2
        i.e., this is a set of strings rather than a string-indexed array;
2
        more on this below)
2

2
  count [entries|chars] in this
2
        provide some vague statistics about how big this thing is.
2

2
N.B.  As entries get made, properties belonging to $generic_db.owner will be created on the db object itself.  These properties will be created having flags as specified by .node_perms, which by default is "r", but can be changed to "" should you want to ensure that randoms don't have access to the raw information.
2

2
Implementation notes
2
 - - - - - - - - - -
2
The representation is as a `trie', a tree in which each internal node corresponds to a prefix shared by two or more strings in the db.
2
Each internal node is kept in a property named " "+<prefix>, where <prefix> is a prefix shared by all strings in the subtree under this node.
2
The property value is a 4 element list
2

2
this.(" "+<prefix>)[1] = <common>
2
   maximal continuation shared by all strings beginning with prefix
2
   i.e., all these names actually begin with <prefix>+<common>
2

2
this.(" "+<prefix>)[2] = <continuations>
2
   string of all characters <c> that can follow <prefix>+<common> for which
2
   there is more than one string in the db beginning with <prefix>+<common>+<c>
2

2
this.(" "+<prefix>)[3] = <exact_matches>
2
   list of all strings in this subtree for which 
2
   the character (or lack thereof) following the <prefix>+<common> substring 
2
   suffices to determine the string.
2

2
this.(" "+<prefix>)[4] = <data>
2
   list of data corresponding to the strings in [3].
2

2
Child nodes are       this.(" "+<prefix>+<common>+<c>) 
2
       for all <c> in this.(" "+<prefix>)[2].
2
The root node is this.(" ").
2
If, e.g., there are 2 or more strings in the db beginning with a, 
2
there will be a node this.(" a").  
2
If all of these strings actually begin with "ani", then this.(" a")[1]=="ni".
2
The db consisting of the 5 correspondences
2

2
  {"animal", #1}
2
  {"anime",  #2}
2
  {"anil",   #3}
2
  {"anile",  #4}
2
  {"banal",  #5}
2

2
would be represented
2

2
this.(" ")    =={"",  "a",  {"banal"},         {#5}}
2
this.(" a")   =={"ni","lm", {},                {}}
2
this.(" anim")=={"",  "",   {"animal","anime"},{#1,#2}}
2
this.(" anil")=={"",  "",   {"anil","anile"},  {#3,#4}}
2

2
In some cases one may merely wish to hold a collection of strings without trying to associate a particular datum with each string.  One may then instead set up a db without the fourth field on each of the properties.  In this case the datum is taken to be the found string itself and that is what gets returned by :find*() in the event of a successful search.   :find and :find_key are then equivalent as are :find_all and :find_all_keys.  To setup the db this way, do a :clearall(3).  :clearall(4) reverts to the above described type of db with a separately kept datum.  Note that you can't change the type without emptying the db.  3 and 4 are currently the only db types allowed.
36
5
4
201
2
The Generic Editor enables a player to edit a list of strings.  While one might contrive to use it directly, it is rather intended as a parent for some actual editor.  It supplies the following commands:
2

2
say         <text>                      w*hat       
2
emote       <text>                      abort       
2
lis*t       [<range>] [nonum]           q*uit,done,pause 
2
ins*ert     [<ins>] ["<text>]           
2
n*ext,p*rev [n] ["<text>]               
2
del*ete     [<range>]                   
2
f*ind       /<str>[/[c][<range>]]       
2
s*ubst      /<str1>/<str2>[/[g][c][<range>]]
2
m*ove,c*opy [<range>] to <ins>          
2
join*l      [<range>]                   
2
fill        [<range>] [@<col>]          
2

2
$editor_help.(cmdname) descrbes cmdname
2
$editor_help.insert    descrbes insertion points (<ins>)
2
$editor_help.ranges    descrbes range specifications (<range>)
2

2
You'll notice that nowhere does it say how to load in a given list of strings or how and where one may save said list away when one is done editing.  These commands are supplied by the child editor object.  The generic editor contains only the code for editing lines, though it defines additional functions for use by the children:
2

2
  :loaded(player)
2
     returns the index (player in this.active) iff text has been loaded
2
     from somewhere, otherwise returns 0.
2

2
     Note that, by default, there is a difference between 
2

2
        having nothing loaded                (:text(who)==0) and 
2
        having loaded something with no text (:text(who)=={}).
2

2
     If you don't care about this distinction in a particular case,
2
     just do (player in this.active) instead of this:loaded(player).  
2
     If you don't want your editor to make this distinction at all, do
2

2
        @stateprop texts={} for <youreditor>
2

2
     which changes the initial value of :text() to {} 
2

2
In all functions below, 'who' is the index returned by :loaded(player) 
2

2
BTW, be careful about using 'player' in non-user (i.e., +x this-none-this) verbs --- much better to have the user verb get the index with :loaded() and then pass that around.  
2

2
Also be careful about suspend() and verbs that call suspend().  In particular, the player's index in the .active list can change during the suspend interval, so you must be sure to obtain the index (e.g., using :loaded()) again after the suspend() returns.
2

2
For your non-user verbs, we have
2

2
  :ok(who)
2
     returns E_PERM if the caller is not an editor verb and E_RANGE
2
     if 'who' does not point to a valid session.
2

2
which should take care of the more egregious security holes (but maybe not the less egregious ones).  For getting and loading text, we have
2

2
  :text(who)    
2
     the current text string list or 0 if nothing loaded yet.
2
  :load(who,text)
2
     loads the given list of strings as the text to be edited.
2
     this also resets the 'changed' flag and pushes the insertion 
2
     point to the end.
2

2
and various flags and properties (all of the set_* routines return E_PERM when not called from an editor verb, E_RANGE if who is out of bounds, E_INVARG if something is wrong with the 2nd arg, or the new value, which may not necessarily be the same as the 2nd arg (e.g., set_insertion(..,37) on a 5 line text buffer returns 6).
2

2
  :changed(who)
2
     has the text been altered since the last save/load?
2
     (the child editor gets to define what "save" means).
2
  :set_changed(who,value)
2
     Any child editor command that is considered to save the text should do a 
2
     :set_changed(who,0).  
2
     Note that if the changed flag is 0, the session will be flushed when 
2
     the player leaves the editor, so you may also want certain commands to
2
     do set_changed(who,1)...
2

2
  :origin(who)
2
     room where the player came from.  
2
  :set_origin(who,room)
2
     can be used to change the room the player will return to when finished
2
     editing.  Since origin gets set even in cases where the player teleports
2
     into the editor you probably won't usually need to do this.
2

2
  :insertion(who)
2
     current insertion point.
2
  :set_insertion(who,linenumber)
2
     linenumber needs to be a positive integer and will get 
2

2
  :readable(who)
2
     whether the current editing session has been made globally readable.
2
  :set_readable(who,boolean)
2
     change the readability of the current editing session.
2
     This is used by the publish/perish verbs.
2

2
We also provide
2

2
  :invoke(...)
2
      If the player has a previous unsaved (i.e., :changed()!=0)
2
      session, we return to it, moving the player to the editor.  
2
      If the player is already in the editor, this has no effect other
2
      than to print a few nasty messages.  In any case a :changed()
2
      session must be aborted or set_changed(,0) before anything else 
2
      can be started
2

2
      Otherwise, we pass the arguments (which are assumed to be the
2
      result of some munging of the command line) to :parse_invoke(),
2
      move the player to the editor and load whatever parse_invoke()
2
      specified.  The only interpretation the generic editor makes on
2
      the arguments is that if the boolean value of the first is true,
2
      this indicates that the player wanted to load something as
2
      opposed to resume a previous session.  Usually a command calling
2
      :invoke will have a true (i.e., nonzero number, nonempty list or
2
      string) first arg iff the command line is nonempty, in which case 
2
      'args' works fine for this purpose.
2

2
      If the command parses sucessfully (:parse_invoke() returns a list),
2
      we move the player to the editor if necessary and then call 
2
      :init_session() to set things up.
2

2
The child editor is assumed to provide
2

2
  :parse_invoke(...)
2
     given :invoke()'s arguments, determines what the player wants to edit.
2
     It either returns 0 and reports syntax errors to player,
2
     or it returns some list that :init_session() will understand.
2

2
  :init_session(who,@spec)
2
     where spec is something that was returned by :parse_invoke().
2
     Loads the text and sets the stateprops (below) to indicate that 
2
     we are working on whatever it is we're suppose to be working on.
2

2
  :working_on(who)   
2
     returns a string X as in "You are working on X."
2
     This is called by the 'w*hat' command, among other things.
2

2
Child editors may have their own properties giving state information for the various editing sessions.  The value of each such property will be a list giving a value for each player in the editor.  For each such property, you should, once the editor object has been created, initialize the property to {} and do one of
2

2
    @stateprop <propname>                 for <editor>
2
    @stateprop <propname>=<default-value> for <editor>
2
               (0 is the default <default-value>)
2

2
Henceforth, adding and deleting new editing sessions will amend the list held by the given property.  The value of the property for a given session can be obtained via this.<propname>[player in this.active] and can be changed with a corresponding listset() call.  The usual idiom for an editor command is
2

2
   if(!(who=this:loaded(player)))
2
     player:tell(nothing_loaded_msg());
2
   else
2
      ... various references to  this.<propname>[who] ...
2
   endif
2

2
To remove such a property from the list of such state properties:
2

2
    @rmstateprop <propname> from <editor>
2

2
Note that you can only do this with properties defined on the child editor itself.  
2

2
Sometimes you may wish to @stateprop a new property on an editor where active editing sessions exist.  @stateprop will fail if the property in question does not hold a list of the correct length (== length(editor.active); one value for each editing session).  You need to either give the @flush command to clear out all sessions and boot all players currently in the editor or somehow manually initialize the property to a list of appropriate values and pray that nobody enters/exits the editor between the property initialization and the @stateprop command --- this problem can be avoided by doing an eval() that does all of the initializations (beware of suspends()) and calls :set_stateprops directly.
2

2
Incidentally, the @flush command may be used at any time to clean out the editor or to remove all sessions older than a given date.
2

2
There are also numerous _msg properties that may be customized
2

2
    @depart          announced at the origin when :invoke() is called. 
2
    @return          announced at the origin the player is returned there.
2
    @nothing_loaded  printed when user attempts editing 
2
                     before anything has been loaded.
2
    @no_text         response to 'list' when :text()=={}
2
    @no_change       printed by 'what' when :changed()==0
2
    @change          printed by 'what' when :changed()==1
2
    @no_littering    printed upon leaving the editor with :changed()==1.
2
    @previous_session  printed by :invoke() when player tries to start a 
2
                     new session without aborting or saving the old one
2

2
The general procedure for creating a child editor:
2

2
. @create $generic_editor named <editor>
2

2
. define additional <editor> verbs/properties
2
    At the very least you need 'edit' and 'save' commands.
2
    Usually you can get away with just having 'edit' call :invoke();
2
    Presumably, you'll need at least a command to load text from somewhere
2
    as well as a command to save it back out.
2

2
. define a verb (somewhere) to invoke the editor 
2
    This could be just a one-liner that calls <editor>:invoke(args,verb).
2
    Either that or
2
      .  you have to set up an exit somewhere whose destination is <editor>
2
      .  you have to advertise the object number so that people can 
2
         teleport to it.
2
  
2
. @stateprop x for <editor>
2

2
. if you want the 'abort' command to boot the player from the editor do
2
    <editor>.exit_on_abort = 1;
2

2
. set <editor>.commands to be the list of additional commands defined
2
    by <editor>.  
2
    Each element of the list is itself a list of the form {name,args}.
2
  set <editor>.commands2 to be the list of commands that should appear
2
    in the `look' listing, and should be a list of strings appearing 
2
    as names in .commands on either <editor> or some editor ancestor.
2
  look at $verb_editor or $note_editor for an example.
2

2
. If you want to have help text for new verbs you define, create a child of 
2
    $generic_help and add properties to this object for each of the topics 
2
    that you want to provide help text.
2
    Finally, set <editor>.help = {this object} so that the help system
2
    knows to consult this object.
36
5
4
87
2
The Help System
2
---------------
2
When a player types help, the following list of objects is consulted for .help properties:  the player itself, all ancestors of player up to and including $player, and, if the current location is a room, the current location together with all ancestors of the current location back to and including $room.  Each help property should have as value either an object or a list of objects (otherwise we just ignore it).  These objects are then strung together as a list of `help databases' to be searched in order for the requested topic.
2

2
A help database (in the sense of anything that is usable by $player:help()) is any object having the following three verbs:
2

2
  :find_topics([string])
2
     where string is a supposed help topic, returns a list of strings,
2
     i.e., actual help topics that this db knows about, or some boolean 
2
     false value in the event that this db is clueless...
2
     If no arguments are given, this should return a list of all topics
2
     in the db
2

2
  :get_topic(string)
2
     given one of the strings returned by :find_topics this either
2
     returns a list of strings (text to be spewed to the player) or
2
     returns 1 to indicate that it has already taken care of printing
2
     information to the player.
2

2
  :dump_topic(string)
2
     like get_topic, but instead returns the raw text of a help topic
2
     as a (download/upload) script
2

2
In short if :find_topic reports that a particular db knows about a given topic
2
it returns the full topic name, so that :get_topic may be called on it later.
2
:dump_topic is used by maintainers (see $wiz:@gethelp) to edit help topics.
2

2
$generic_help and $help
2
-----------------------
2
The Generic Help Database, $generic_help, is the parent class of a particular kind of help database of which $help is an instance.  On help databases of this type, every help topic has a corresponding property, interpreted as follows:
2

2
  this.(topic) = string             
2
      one-line help text.
2

2
  this.(topic) = {"*<verb>*",@args}
2
      call this:<verb>(args,dblist) to get text where dblist is the list of 
2
      help objects that would have been consulted had the topic not been found 
2
      on this object.
2

2
  this.(topic) = other list of strings 
2
      multi-line help text
2

2
For the {"*<verb>*",...} form, the current verbs available are
2

2
  {"*forward*", topic, @rest}   
2
     - get help text for topic and then append the lines of `rest'.  
2
       rest may, in turn, begin with a "*<verb>*"...
2

2
  {"*pass*", topic, @rest}   
2
     - get help text for topic from the first help database after this one
2
       that actually has help text for topic, and then append lines of `rest'.
2
       As with "*forward*" rest may, in turn, begin with a "*<verb>*"...
2

2
  {"*subst*", @lines} 
2
     - All occurences of %[exp] in lines are replaced with the value of exp
2
         which is assumed to evaluate to a string.  
2
       All lines beginning with %;exp are replaced with the value of exp 
2
         which is assumed to evaluate to a list of strings.
2
       Evaluation is done using $no_one's permissions so exp in either case
2
       can only refer to public information.
2

2
  {"*index*", title}
2
     - returns a list of all topics in this database, arranged in columns.
2
       title is used as a heading for this index.
2

2
       In order for your help database to appear in the list presented
2
       by 'help index', your db object must be set to +r.
2

2
  {"*objectdoc*", object}
2
     - gets the documentation for the given object (i.e., object:help_msg())
2
       N.B. as with all other *verb* arguments, object must be a string.
2

2
  {"*verbdoc*", object, verbname}
2
     - gets the documentation for the named verb on the given object
2
       (i.e., any strings at the beginning of said verbcode)
2

2
Individual help dbs are free to define additional verbs that may be used in this context.  $help itself defines the following additional such verbs:
2

2
  {"*index_list*"}
2
     - returns a list of all index topics in all databases in the search list.
2
       An index topic is one whose actual text is {"*index*", something}.
2
       When creating a help db, you should be sure to make an index topic.
2

2
  {"*full_index*"}
2
     - prints indices for all help databases in the search list.
2

2
It should be noted (once again) that help databases need not be children of $generic_help, so long as they have :find_topics/:get_topic/:dump_topic working as specified above.
36
5
4
62
2
Generic Option Package
2
----------------------
2
It occasionally happens that one has a command or set of commands for which one wishes to provide several options/flags that a player can set to customize the command's behavior for him/herself.  Making each option a separate property is a bit expensive, especially when the option in question is merely a boolean flag that gets set to false in most cases.  This package provides an alternative, as well as providing a uniform set of commands for setting these flags/options and checking that the values given are of appropriate types.
2

2
Instead of needing several properties, only one is required to store a list containing values for all of the options.  An "option package" (pkg, below) is then an object of this class, which provides routines for manipulating such lists.
2

2
The set of option names is divided into a set of "real" options, those whose names will actually appear in a given list, and "extras" which are either synonyms for or represent combinations of real options.
2

2
 pkg:add_name(name)      adds name to .names  (remove it from .extras if there)
2
 pkg:add_name(name,1)    adds name to .extras (remove it from .names if there)
2
    => 1 - ok, 0 - already added, E_INVARG - illegal name, E_PERM
2

2
 pkg:remove_name(name)   remove name from either .names or .extras
2
    => 1 - ok, 0 - not present, E_PERM
2

2
For setting or retrieving values we have
2

2
 pkg:get(options,name) 
2
    => value (or 0 if name isn't a real option)
2
 pkg:set(options,name,value)
2
    => revised options (or string error message if something goes wrong)
2

2
By default, a given option can only be a boolean flag, having one of the values 0 (absent from the list), or 1 (present in the list).  :set translates 0/""/{} to 0 and any other non-object value to 1.
2

2
One may however designate a wider range of possible values for an option "foo" by either installing one of
2

2
  pkg.type_foo
2
    -- list of allowed types, 
2
       e.g., {NUM,STR}   => must be a number or a string
2
       e.g., {OBJ,{OBJ}} => must be an object or a list of objects
2
    for anything fancier use:
2

2
  pkg:check_foo(value)
2
    => string error message or {value munged as desired}
2

2
In general, the only restriction on option values is that 0 is the only false value; setting an option to "" or {} sets it to 0.  Every option defaults to 0, and no matter what you install as .type_foo or :check_foo(), 0 will always be a legal value for option "foo".
2

2
When presented with an option that is in .extras, :set will typecheck the value as described, however, then :actual(name, value) will be called to obtain a list of {name-of-real-option, value} pairs indicating which combination of real options should be set.
2

2
Other verbs
2
  pkg:parse(args,...)
2
    parses the command line arguments of a @whatever_option command
2
    => {optionname, value}  if the player wants to set an option
2
    => {optionname}         if the player wants to view an option
2
    => string error message  otherwise
2

2
  one may install pkg:parse_foo to parse arguments for option "foo" 
2
    !foo     => {"foo",0}  (:parse_foo not called)
2
    foo=     => {"foo",0}  (:parse_foo not called)
2
    -foo     => {"foo",0}  (:parse_foo not called)
2
    +foo     => pkg:parse_foo("foo",1)
2
    foo=word => pkg:parse_foo("foo","word")
2
    foo word1 word2    => pkg:parse_foo("foo",{"word1","word2"})
2
    foo is word1 word2 => pkg:parse_foo("foo",{"word1","word2"})
2

2
 pkg:show(options,name|list of names)
2
    => list of strings describing the current value of the named option(s).
2
       calls     pkg:show_foo(options,list of names) or
2
       refers to pkg.show_foo
2
       to describe option "foo"
2

2
(see sources for details...  at some point I'll finish writing this... --Rog)
36
5
4
24
2
Message Sequences
2
-----------------
2
A "message sequence" is a handle by which one may refer to a particular subset of a mail recipient's (player or $mail_recipient-descendant) saved messages.  Routines like rcpt:display_seq_headers or rcpt:display_seq_full need to be supplied with message-sequence arguments to deterimine which headers or full-messages to display.
2

2
Message sequences can in turn be obtained from routines like rcpt:parse_message_seq, which takes a command-line description of a message sequence on that particular recipient and returns the corresponding message sequence handle.
2

2
The actual form of a message sequence (though you shouldn't actually need to make use of this) is that of a set of integers in the format used by $seq_utils (see `help $seq_utils').  It should however be noted that these integers are *not* themselves message numbers, but rather indices into the list of saved messages.  For example, if a particular recipient holds 5 messages numbered 1,3,5,7,9.  Then the message sequence handle representing messages 3,5,7 collectively, would be {2,5} which is $seq_utils-ese for the range 2..4, namely the second, third and fourth messages saved on that recipient.
2

2
The following verbs are available for obtaining indices to use in message sequences
2

2
  :length_all_msgs()    => total number of messages, or equivalently,
2
                        => index of last message
2
  :length_num_le(n)     => number of messages numbered <= n, or equivalently,
2
                        => index of highest numbered message <= n
2
  :exists_num_eq(n)     => 0 unless there exists a message numbered n in which
2
                           case we return the index of that message.
2
  :length_date_le(date) => number of messages dated <= date, or equivalently,
2
                        => index of most recent message dated <= date
2

2
  :length_date_gt(date) => number of messages dated > date
2

2
Note that r:length_date_gt(date) == r:length_all_msgs()-r:length_date_le(date).
2
The only reason :length_date_gt is provided as a separate routine is in order 
2
to do quick checks for the existence of new mail (as @rn needs to do).
36
5
4
24
2
Read verbs
2
----------
2
The following verbs may be used to extract headers/messages from readable mail recipients/players;
2

2
:display_seq_headers (message sequence, current message number, last_read_date)
2
  Does a @mail listing of the given message sequence.  If current message
2
  number is given and the sequence includes it, we mark it with a `>'.
2
  Likewise if the sequence includes any new messages (i.e., dated after 
2
  last_read_date), these are also indicated as such.
2

2
display_seq_full (message sequence, preamble)
2
  Does a @read listing of the given message sequence.  Each message is preceded
2
  by preamble.
2
  => {new current message number, new last_read_date}
2

2
:messages_in_seq (index)
2
  => {n, msg}
2
:messages_in_seq (message sequence)
2
  => {{n_1,msg_1},{n_2,msg_2},...}
2
  where the n_i are message numbers and the msg_i are messages in transmission
2
  format (see `help mail-format')
2

2
:list_rmm ()
2
  Does an `@unrmm list' listing of messages in .messages_going
36
5
4
17
2
Write verbs
2
-----------
2
The following verbs can be used to manipulate writable mail recipients/players:
2

2
:rm_message_seq (message sequence)
2
  Does an @rmmail.  Messages in message sequence are removed from this 
2
  recipient's saved .messages and written to .messages_going.
2

2
:undo_rmm ()
2
  Does an @unrmm.  Messages in .messages_going are copied back to .messages.
2

2
:expunge_rmm ()
2
  Does an @unrmm expunge.  Blows away .messages_going.
2

2
:renumber ()
2
  Does a @renumber.
2

36
5
4
25
2
Search verbs
2
------------
2
The following verbs can be used on a readable mail-recipient/player to search for messages with fields matching a given pattern.
2

2
from_msg_seq (objectid or list [,mask])
2
  => message sequence: messages from (one of) the given objectid(s)
2

2
%from_msg_seq (string or list [,mask])
2
  => message sequence: messages with (one of) the given string(s)
2
     in the From: line
2

2
to_msg_seq (objectid or list [,mask])
2
  => message sequence: messages to (one of) the given objectid(s)
2

2
%to_msg_seq (string or list [,mask])
2
  => message sequence: messages with (one of) the given string(s)
2
     in the To: line
2

2
subject_msg_seq (string [,mask])
2
  => message sequence: messages with given string occurring in Subject:
2

2
body_msg_seq (string [,mask])
2
  => message sequence: messages with given string occurring in body of message
2

2
In all cases `mask' is a message sequence which one may supply to limit the range of the search.  One way of looking at it is that the message sequence to be returned is first intersected with mask.
36
5
4
43
2
The housekeeper is an object that can help keep other objects where they belong.  New MOOs may want to add their own user interface for the housekeeper; here is some information that may be helpful.
2

2
To indicate what objects should be cleaned:
2

2
  :add_cleanup(object[, requestor[, where]])
2
    Ask the housekeeper to clean 'object' for 'requestor' to 'where'.
2
    Requestor defaults to 'player'.
2
    Where defaults to object.location.
2

2
  :remove_cleanup(what[, requestor])
2
    Remove 'what' from the cleanup list at 'requestor's request.
2
    Will remove it only if 'requestor' made the original request and owns
2
    the object or the destination.
2

2
To actually get the housekeeper to clean stuff up:
2

2
  :cleanup([insist])
2
    Clean up player's objects.  Argument is 'up' or 'up!' for manually
2
    requested cleanups.  'up!' means to clean things even if it's against
2
    the housekeeper's better judgement.
2

2
  :replace(object[, insist])
2
    Clean up the indicated object.  'insist' is as in :cleanup.
2

2
  :continuous()
2
    Starts the housekeeper cleaning continuously, killing any previous
2
    continuous task.  This should be called only when starting up a new MOO,
2
    or if something has gone wrong, as normally it will just keep going
2
    without any help.
2

2
  :litterbug()
2
    Clean up all the places in housekeeper.public_places by getting rid of
2
    all contents not in their .residents lists.  This is called by
2
    :continuous, so it doesn't need to be called directly.
2

2
To find out what's being cleaned to where for whom:
2

2
  :cleanup_list([whom])
2
    Show 'player' the personal cleanup list for 'whom', or the housekeeper's
2
    complete list if no argument is given.
2

2
  :clean_status()
2
    Show 'player' a brief summary of eir personal cleanup list.
36
5
4
28
2
$recycler
2
=========
2

2
Rather than having the server built-in recycle() and create() functions handle the creation and destruction of objects, a recycling center has been created to simulate these actions by  changing objects that would have been recycled into children of $garbage (The Generic Garbage Object) and making them owned by Hacker, and then when they're needed again, to avoid a raw create() command, those objects are given to whoever's asking for them.
2

2
Most Useful Verbs
2
-----------------
2

2
$recycler:_recycle( object )
2
  This will effectively recycle an object. (As a point of fact, it changes ownership of the object to Hacker and makes the object a child of $garbage.)  It handles .ownership_quota and .owned_objects properly.  Generally, use this instead of a recycle() in your verbs.
2

2
$recycler:_create( parent object [ , new owner object ] )
2
  This effectively creates an object (with the specified parent, if possible, and with the specified owner, if possible; these are the same restrictions as on the server create() builtin).  This is what should generally be used instead of create() in your programming.
2

2
$recycler:valid ( object )
2
  This is a variant of the server built-in valid() except that it handles the $garbage objects as well.  It returns a 1 if the object specified -is- valid and is -not- a $garbage object.
2

2
Other Notes
2
-----------
2

2
request <object> from <recycler>
2
  This is not an internal verb (it's !x).  It is, however, a command-line verb that can be used to request a specific object from the recycler.  It's also useful for the creation of objects like a Magic Number Repository.  When the object is removed from the recycler, the .announce_removal_msg is announced to the room if it's set (it's piped through $string_utils for pronoun substitution).
2

2
show-history <recycler>
2
  This is a wizardly verb which allows wizards to check the `history list' of the recycler. The history maintains the latest ($recycler.nhist) entries.
2

2
$recycler.orphans
2
  This maintains a list of objects for which the recreation process got mangled. It ought to be checked every once in a while to see what's up.
2
1
4
10
2
$error
2
======
2

2
The Error Generator, $error, may be used to automatically generate errors. This is particularly useful if you are working in a !d verb but have occasion to -want- to crash with traceback. To raise a specific error, use $error:raise(error type) -- for example, $error:raise(E_PERM) will produce traceback resulting from a Permission Denied error.
2

2
Random notes about $error:
2

2
+ The complete list of errors is stored in $error.names.
2
+ The seemingly useless :accept() verb on $error is so that $error:E_RECMOVE and $error:E_NACC will be guaranteed success (success meaning, of course, a termination by traceback).
2
+ There is, unfortunately, no way to raise the error E_NONE.
2
1
4
72
2
Generic BigList Utilities
2
----------------------------
2
$biglist is a collection of routines for maintaining huge persistent (sorted) lists in a format that is less likely to spam the server (which runs into a certain amount of trouble dealing with long ordinary lists --- btw we use `biglist' to refer to the huge data structure we're about to describe and `list' to refer to ordinary MOO lists {...}).  The biglist in question lives on a particular object, to which we will refer in the discussion below as the `home' object, and its various elements appear as leaves of a tree whose nodes are kept in properties of the home object.  It should be noted that the home object does not need to be (and in fact should *not* be) a descendant of $biglist one; $biglist merely provides utilities for manipulating the properties on the home object that are used in a particular biglist manipulation.  
2

2
All of the utilities below refer to `caller' to locate the home object.  Thus verbs to manipulate a given biglist must be located on or inherited by its home object itself.  The home object needs to define the following verbs
2

2
  :_make(@args)     => new property on home object with value args
2
  :_kill(prop)      delete a given property that was created by :_make
2
  :_get(prop)       => home.prop
2
  :_put(prop,@args) set home.prop = args
2
  :_ord(element)    given something that is of the form of a biglist element
2
                    return the corresponding ordinal (for sorting purposes).
2
                    If you never intend to use :find_ord, then this can be a 
2
                    routine that always returns 0 or some other random value.
2

2
See $generic_biglist_home or $big_mail_recipient for examples.
2

2
Those of the following routines that take a biglist argument are expecting
2
either {} (empty biglist) or some biglist returned by one of the other routines
2

2
  :length(biglist)          => length(biglist) (i.e., number of elements)
2
  :find_nth(biglist,n)      => biglist[n]
2
  :find_ord(biglist,k,comp) => n where n is
2
     the largest such that home:(comp)(k,home:_ord(biglist[n])) is false, or
2
     the smallest such that home:(comp)(k,home:_ord(biglist[n+1])) is true.
2
     Always returns a value between 0 and length(biglist) inclusive.
2
     This assumes biglist to be sorted in order of increasing :_ord values 
2
     with respect to home:(comp)().
2
     Standard situation is :_ord returns a number and comp is a < verb.
2

2
  :start(biglist,s,e)  => {biglist[s..?],@handle} or {}
2
  :next(@handle)       => {biglist[?+1..??],@newhandle} or {}
2
     These two are used for iterating over a range of elements of a biglist
2
     The canonical incantation for doing
2
        for elt in (biglist[first..last])
2
          ...
2
        endfor
2
     is
2
        handle = :start(biglist,first,last);
2
        while(handle)
2
          for elt in (handle[1])
2
            ...
2
          endfor
2
          handle = :next(@listdelete(handle,1));
2
        endwhile
2

2
The following all destructively modify their biglist argument(s) L (and M).
2

2
  :set_nth(L,n,value)  =>  L[n] = value
2
     replaces the indicated element
2

2
  :insert_before(L,M,n) => {@L[1..n-1],@M,@L[n..length(L)]}
2
  :insert_after (L,M,n) => {@L[1..n],  @M,@L[n+1..length(L)]}
2
     takes two distinct biglists, inserts one into the other at the given point
2
     returns the resulting consolidated biglist
2

2
  :extract_range(L,m,n) => {{@L[1..m-1],@L[n+1..]}, L[m..n]} 
2
     breaks the given biglist into two distinct biglists.
2

2
  :delete_range(L,m,n[,leafkiller]) => {@L[1..m-1],@L[n+1..]}
2
  :keep_range  (L,m,n[,leafkiller]) => L[m..n]
2
     like extract_range only we destroy what we don't want.
2

2
  :insertlast(L,value)  => {@L,value}
2
     inserts a new element at the end of biglist.  
2
     If find_ord is to continue to work properly, it is assumed that the 
2
     home:_ord(elt) is greater (comp-wise) than all of the :_ord values
2
     of elements currently in the biglist.
2

2
  :kill(L[,leafkiller]) 
2
     destroys all nodes used by biglist.  
2
     Calls home:leafkiller on each element.
36
1
4
17
2
$guest_log
2

2
records guest connect/disconnect events.
2

2
.max_events  -- maximum number of connect/disconnect events kept
2
.connections -- actual list of events, the most recent ones first
2
    each element is of the form
2
      {object, is_connect, time, site}
2
    object is the particular guest that (dis)connected
2
    is_connect 1 or 0 according as this is a connect or not.
2

2
:find(who,when)
2
  => site name of WHO at the particular time
2
     (or 0 if WHO was not logged in then)
2

2
:last(n) 
2
  prints a listing of the last n events
36
5
4
2
2
*forward*
2
mail-resolve
36
5
4
32
2
*subst*
2
$news
2
-----
2
This object is a mail_recipient like any other (see `help $mail_recipient').  One may send messages to it and use the usual recipient manipulation commands (@mail, @read, @rmm,...).  
2

2
Selected messages on this recipient are ordered in reverse date order (i.e., most recent first) and concatenated to produce the "news" that is printed in response to the player `news' command.  Each news item is thus a distinct message.  The default $player:confunc checks to see if any new messages have been selected for inclusion in the "news" since the player last read the news.
2

2
The property $news.current_news holds the message sequence of messages currently considered as comprising "the news".  The following commands are used to change .current_news:
2

2
  @addnews <message-seq> to %[$news]
2
  @rmnews <message-seq> from %[$news]
2
  @setnews %[$news] to <message-seq>
2

2
@addnews includes the specified messages, @rmnews excludes the specified messages, and @setnews changes .current_news to be the given message sequence.  Note that these ONLY change whether a given message is marked as being "in the news" and do not actually add or remove messages from the mail recipient $news.
2

2
The procedure for adding a news article is
2

2
  Send a mail message to %[$mail_agent:name($news)]
2
  @addnews last to %[$news]
2
    This marks the message as belonging to the current newspaper.
2
    This also announces to any player who have not yet read this message 
2
    that there is a new version of the newspaper.
2

2
The preferred method for updating a news items is to send a new version of the item, @rmnews the old version and @addnews the new one.
2

2
The following ordinary mail commands behave differently
2
  @rmm   removes any reference to message from .current_news 
2
         in addition to removing the message itself from .messages
2
  @unrmm completely undoes the effect of the previous @rmm; 
2
         this includes restoring .current_news.
2

2
By default, the newspaper is moderated, however there is the possibility of unmoderating it (see `help MR-access'), letting arbitrary players send mail to it; administrators could then @addnews those items deemed worthy.
36
5
4
2
2
*forward*
2
object-matching
36
5
4
32
2
The mail messages stored in mail recipients may be removed automatically by a weekly expiration task. New core owners who wish to turn this feature on and cut down on the db space used by mail recipients (Remember, players are mail recipients too) should start this task:
2

2
    $wiz_utils:expire_mail_weekly
2

2
When this task runs, it searches through all mail recipients and checks their .expire_period property. This property contains a time, in seconds, that messages should expire after. If this property is set to 0, then no expiration will take place from that recipient. The task, then, will compile a list of messages that are older than the expire period (e.g., if the property is set to 30 days, messages older than 30 days from the current date will expire). The default expiration period for mail recipients is 30 days.
2

2
Normally, when the mail messages are expired from the recipient they are deleted. However, the owner of the recipient may elect to have the messages mailed to an email address prior to their erasure. There are two methods for doing this, one for players and one for children of $mail_recipient.
2

2
Players:
2

2
  Players may completely turn off mail expiration by setting the mail option `expire' off. If it is on, then $mail_agent.player_expire_time is the expire period used for mail on players. 
2
  If a player has a registered email address, he may simply turn the mail option `no_auto_forward' off in order to have the expired messages sent to his email address before they are deleted. (The reversed logic saves on db space). See `help mail-options' and `help @registerme'.
2

2
Mail Recipients:
2

2
  The command to set the expiration period of a mail recipient is:
2

2
    @set_expire <recipient> to <time>
2

2
The <time> specified can be in english format (30 days, 60 days, etc.). If left off (the owner types `@set_expire <recipient> to'), the command will print out the current expiration information for that recipient. A list owner may set the expiration period up to a maximum of 180 days.
2

2
  Similar to players, the owner of a mail recipient may have the mail sent to either his registered email address or to any other address he specifies before it expires. To prevent unsolicited email from going to a random address, confirmation must be made before the owner may set the address to something other than his registered address.
2

2
  The command is:
2

2
    @register <recipient> to <address>
2

2
If the owner leaves off the <address>, the current registered address (if any) and expiration period will be returned. Again, if the address specified is the player's registered address, nothing more need be done. If it is not, then an email message will be sent to that address containing a password. Presumably, the owner can retrieve that password and then log back into the MOO and type:
2

2
   @validate <recipient> with <password>
2

2
which will enable the mail forwarding before expiration.
36
5
4
2
2
*forward*
2
MR-expiration
36
5
4
41
2
Generic Large Capacity Mail Recipient
2
-------------------------------------
2
Since any modifications to large lists entail copying the entire list over, operations on ordinary mail recipients having large numbers of messages, that actually change the content of .messages will take inordinately long.  Thus we have this version which makes use of the $biglist package, scattering the messages onto numerous properties so that write operations involving only a few messages will not require recopying of the entire list.
2

2
In nearly all respects it behaves as the ordinary Mail Recipient, except that it is faster for certain kinds of operations.
2

2
Certain unimplemented verbs, like :date_sort(), and :messages() currently return E_VERBNF.
2

2
To convert an existing $mail_recipient-child (call it #MR) into a $big_mail_recipient-child the basic procedure is
2

2
    ;;something.foo= #MR:messages();
2
    @rmm 1-$ from #MR
2
    @unrmm expunge
2
    @chparent #MR to $big_mail_recipient
2
    ;#MR:receive_batch(@something.foo);
2

2
Reconstructing Damaged Big Mail Recipients
2
------------------------------------------
2
On rare occasions, the tree structure created by $biglist can be corrupted (this can happen on lists sufficiently large that a list-modification operation (e.g., @rmm, @renumber) runs out of ticks/seconds).  In the vast majority of such cases, your messages are all still there; it's simply that the tree we use for finding/searching them is messed up.
2

2
To recover messages from a damaged big mail recipient (#DBMR)
2
 --- read to the end before you start typing any commands ---
2

2
create a fresh $big_mail_recipient (#NEWBMR) and then do the following:
2

2
   ;#NEWBMR:restore_from(#DBMR)
2

2
When this finishes, #NEWBMR will contain all of the mail messages we were able to find.  (note that this will include messages that you had deleted from #DBMR but not expunged).  #NEWMBR should thenceforth be useable in place of #DBMR, however if #DBMR contains custom verbs and non-clear properties, these will also need to be copied over.
2

2
Alternatively, one may do
2

2
   @copyobject #DBMR to #TEMPBMR
2
   ;#DBMR:restore_from(#TEMPBMR)
2

2
to rebuild #DBMR in place.  This, however, will take about twice as long.
2

2
oooooooooooooooooooooooooooooooo
2
WARNING!!! WARNING!!! WARNING!!!
2
oooooooooooooooooooooooooooooooo
2

2
Calling #OBJ:restore_from(...) COMPLETELY AND IRREVOCABLY REMOVES ALL MESSAGES from the object that it is run on (#OBJ); you MUST be sure to EITHER have made a copy of #OBJ OR be doing the restore to a DIFFERENT object.
36
5
4
73
2

2
OBJECT:init_for_core([CORE_VARIANT_SPEC])
2

2
This verb is called in the final stage of core extraction (see $wiz:make-core-database), which occurs after all non-core objects have been recycled, the remaining ones have been renumbered and moved to #-1.  This verbcall then performs any final cleanups to establish the initial state of the object and is (pretty much) the last thing to happen to the object before the new core database is saved.
2

2
What exactly goes in an :init_for_core verb varies hugely.  Some considerations:
2

2
(1)  The :init_for_core verbs are invoked from the top down, i.e., a given object's :init_for_core call verb precedes that of any of its children.  Thus, when a given object's init_for_core() runs, you can safely assume that its entire ancestor chain has already been initialized in this way, and likewise that NONE of the descendants have been initialized yet.
2

2
(2)  For non-ancestral objects, all bets are off --- with a few exceptions, you should not assume that they will be in working order, i.e., only invoke verbs that you know aren't being changed, and don't mess with their properties.   Or if you must, make sure whatever you do works in BOTH the case where the other object's init_for_core has already run AND the case where it has not.
2

2
(3)  The object's own properties, where they contain references to other objects, will be GARBAGE; renumber() does not update object values within properties or lists.  That's your job (i.e., you qua author of :init_for_core).
2

2
(4)  The root object's :init_for_core will copy code from any verb whose name ends in "(core)" to the corresponding verbname obtained by dropping that suffix.  So, for example, if you find yourself writing 'set_verb_code(this, "verbname", {...})', you should instead create a (non-executable) "verbname(core)" verb, so as to have the verbcode in a place where you can edit it in a more readable form.  This means...
2

2
  (4a)  For non-root objects, it is very important that pass(@args) be called.
2
        And yes the @args need to be there, too, since while the 
2
        CORE_VARIANT_SPEC argument is currently unspecified and ignored
2
        by all existing init_for_core verbs, it is intended to mean
2
        mean something someday.
2

2
  (4b)  A given object's init_for_core will be applied to every descendant.
2
        Bracket the parts that only apply to the object itself with 
2

2
	   if ($code_utils:verb_location() == this)
2
	     ... 
2
	   endif
2

2
(5) Oddly enough, init_for_core verbs by default become part of the core database.  You can arrange for them to remove themselves, but in the cases where they're performing generic sorts of initializations that are likely to be applicable to other MOOs, it's best to leave them in place.  This is for the sake of other MOO admins who may, after some amount of their own development, want to (re)extract their own cores.  While they will most likely be modifying the various init_for_core verbs as needed, if they do NOT make such modifications then (ideally) a core extraction should produce the same core they started with.
2

2
Thus,
2

2
   (5a) init_for_core should be IDEMPOTENT; i.e., running it a second time on the
2
        same object should achieve the same result.  So, e.g., rather than
2

2
          player.current_message = {@player.current_message, {this, 0, 0}};
2

2
        which will create a duplicate entry the second time around, do
2

2
          player:set_current_message(this, 0, 0, 1);
2

2
   (5b) init_for_core should not depend on any non-core verbs/properties.  
2
        In particular, if your init_for_core deletes a LambdaMOO-specific 
2
        verb/property and you don't arrange to delete the init_for_core as well,
2
        then you should bracket that call (e.g., with `... ! E_PROPNF,E_VERBNF')
2
        so that it will work elsewhere even after said verb/property is long gone.
2

2
   (5c) if your init_for_core has a large amount of LambdaMOO-specific material, 
2
        consider splitting the verb into 
2

2
        (*) an :init_for_core that eliminates the LambdaMOO-specific material,
2
            and 
2

2
        (*) an :init_for_core(core) that accomplishes the generic initialization
2
            (and will be copied into place by $root_object:init_for_core so that
2
            ONLY the generic stuff escapes to the outside world.).  
2

2
        You can arrange for BOTH verbs to be called as follows:
2

2
	#foo:init_for_core
2
	if (caller_perms().wizard)
2
	  pass(@args);  // copies :init_for_core(core) to this
2

2
	  if ($code_utils:verb_location() == this)
2
	     // wipe LambdaMOO-specific properties/verbs from this object
2
	     ...
2
	     // call init_for_core(core) code
2
	     this:init_for_core()
2
	  endif
2
	endif
2

2
        though again, this depends on the various parent verbs being idempotent
2
        since in this case they will be invoked twice.
36
5
4
2
2
*forward*
2
$core_objects
36
5
4
2
2
*forward*
2
$core_objects
36
5
4
25
2

2
    $core_objects           ([CORE_VARIANT_SPEC])         => object list
2
    OBJECT:proxy_for_core   ([CORE_VARIANT_SPEC, IN_MCD]) => object
2
    OBJECT:include_for_core ([CORE_VARIANT_SPEC])         => property list
2

2
$core_objects() returns a list of those objects currently considered to be part of the core database.  
2
See help 'make-core-database' for a description of the overall core database extraction process.
2

2
The list of core objects is determined by a traversal of properties starting with #0.sysobj (normally == #0).
2

2
If a given property being traversed is not object-valued or the object id is invalid we are done with that property.
2

2
Otherwise the property's value is a valid object and we call its 'proxy_for_core' verb, if one exists.  Any such verb is expected to return an object id which will then be used to update this property and any others encountered in the traversal that likewise were pointing to the same object.  If the verb does not exist we use the original property value (i.e., exactly as if the verbcode had been "return this;").
2

2
If the object thus obtained is valid, we add it to the list of core objects.
2

2
For each object added, we call its 'include_for_core' verb if one exists.  Any such verb is expected to return a list of properties on that object, which are then recursively traversed as above.  If the verb does not exist, no additional properties are traversed (i.e., exactly as if the verb had returned an empty list).
2

2
The traversal ends when there are no further properties to visit.
2

2
The CORE_VARIANT_SPEC argument is reserved for future use.  For now, the value provided to $core_objects() is passed straight through to the various hook verbs (proxy/include) and otherwise ignored.
2

2
Note that the verb '$core_objects()' can be called at any time to see the full list of objects to be included in the core as per the above algorithm.
2

2
Note that proxy_for_core is only called once for any given object during the traversal.  The IN_MCD parameter will be true for calls coming from within an actual run of make-core-database and false in all other invocations of $core_objects().  Thus, provided IN_MCD is true, it is safe for proxy_for_core to create an object to return.
36
5
4
52
2
Syntax:  make-core-database
2

2
!!! NOTE:
2
!!! 
2
!!! This is, by design, an extraordinarily destructive command, 
2
!!! one NOT INTENDED to be run in the live instance of your MOO.
2
!!! 
2
!!! While there are various safeguards to keep it from being run in
2
!!! situations where it looks like this might be the live instance of
2
!!! the MOO (e.g., >1 player connected), there are limits on how
2
!!! idiot-proof we can be.
2
!!!
2
!!! You have been warned.
2

2
The correct use of this command is in a separate process.  
2
That is, once you have identified a database/checkpoint file from which you wish to extract a core, you
2

2
(*) Run a LOCAL moo process reading from that database file,
2
    
2
(*) Connect as $owner (usually $owner == #2).
2

2
(*) Invoke ($wiz:)make-core-database
2

2
Here "LOCAL" means you have open_network_connection() disabled (so that, e.g., spurious registration email doesn't go out) and you either run the moo on a port that is not accessible from the outside world or use one of the single-user/local configurations of the server (e.g., NETWORK_PROTOCOL = NP_SINGLE or -a 127.0.0.1 on the command line) so that no one else can connect while you're destroying the world (and perhaps mess with what eventually gets saved).
2

2
Once you type 'make-core-database', the actual extraction process then goes as follows:
2

2
(1) A particular set of objects, the "core objects" as determined by,
2
    oddly enough, $core_objects(), is identified.  
2
    
2
    See 'help $core_objects' for details on the algorithm used.
2
    
2
(2) Any core object and any property/verb thereon that has a non-core owner
2
    is chowned either to the (assumed wizardly) player or $hacker 
2
    according as the item in question is wizard-owned.
2

2
(3) All non-core objects are mercilessly recycled.
2

2
(4) Core objects are renumbered and max_object is reset,
2
    so as to produce a contiguous array [#0..max_object()] of objects.
2

2
(5) All objects are moved to #-1.
2

2
(6) OBJECT:init_for_core is called on all objects having such verbs.
2
    The sequence of calls is unspecified except in that an object 
2
    is initialized prior to any of its children.
2
    
2
    See 'help init_for_core' for more on what these verbs should look like.
2

2
(7) The byte-quota statistics are redone
2

2
(8) The moo is shut down and the database is saved.
36
5
5
36
5
4
1
2
core-index
36
1
5
36
4
4
1
2
Core Utility Help
36
5
2
Help database for LambdaCore utility objects and generics.
36
5
4
2
0
121534
0
1641541193
36
1
#20
string utilities
24
2
1
-1
0
0
4
0
1
78
4
0
79
space(noansi)
36
173
-1
left(noansi)
36
173
-1
right(noansi)
36
173
-1
centre center
36
173
-1
columnize columnise
36
173
-1
from_list
36
173
-1
english_list
36
173
-1
names_of
36
173
-1
from_seconds
36
173
-1
trim
36
173
-1
triml
36
173
-1
trimr
36
173
-1
strip_chars
36
173
-1
strip_all_but
36
173
-1
uppercase lowercase
36
173
-1
capitalize capitalise
36
173
-1
literal_object
36
173
-1
match
36
173
-1
match_str*ing
36
173
-1
match_object
36
173
-1
match_player
36
173
-1
match_player_or_object
36
173
-1
find_prefix
36
173
-1
index_d*elimited
36
173
-1
is_integer is_numeric
36
173
-1
ordinal
36
173
-1
group_number
36
173
-1
english_number
36
173
-1
english_ordinal
36
173
-1
english_ones
36
173
-1
english_tens
36
173
-1
subst*itute
36
173
-1
substitute_d*elimited
2
13
-1
_cap_property
2
173
-1
pronoun_sub
2
173
-1
pronoun_sub_secure
36
173
-1
pronoun_quote
36
173
-1
alt_pronoun_sub
2
13
-1
explode
36
173
-1
words
36
173
-1
word_start
36
173
-1
to_value
36
173
-1
prefix_to_value
36
173
-1
_tolist
36
173
-1
_unquote
36
173
-1
_toscalar
36
173
-1
parse_command
2
173
-1
from_value
2
173
-1
print print_suspended
36
173
-1
reverse
36
173
-1
char_list
36
173
-1
regexp_quote
36
173
-1
connection_hostname
2
173
-1
from_value_suspended
2
173
-1
end_expression
36
173
-1
first_word
36
173
-1
common
36
173
-1
title_list*c list_title*c
36
173
-1
name_and_number nn name_and_number_list nn_list
36
173
-1
columnize_suspended columnise_suspended
36
173
-1
a_or_an
36
173
-1
index_all
36
173
-1
match_stringlist match_string_list
36
165
-1
from_ASCII
36
173
-1
to_ASCII
36
173
-1
abbreviated_value
36
173
-1
_abbreviated_value
36
173
-1
match_suspended
36
173
-1
incr_alpha
36
173
-1
is_float
36
173
-1
inside_quotes
36
165
-1
strip_all_but_seq
36
173
-1
redirect_ansi left right center centre columnize columnise space
36
165
-1
_tomap
36
173
-1
autofit fit_to_screen
36
173
-1
adjust_column_lengths
36
173
-1
neat
36
173
-1
capitalize_each
36
173
-1
strip_binary
2
173
-1
6
digits
ascii
alphabet
use_article_a
use_article_an
tab
11
2
0123456789
2
5
2
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
2
5
2
abcdefghijklmnopqrstuvwxyz
2
5
4
5
2
unit
2
unix
2
one
2
once
2
utility
36
1
4
0
36
1
2
	
2
5
4
97
2
For a complete description of a given verb, do `help $string_utils:verbname'
2

2
    Conversion routines:
2

2
:from_list    (list [,sep])                          => "foo1foo2foo3"
2
:english_list (str-list[,none-str[,and-str[, sep]]]) => "foo1, foo2, and foo3"
2
:title_list*c (obj-list[,none-str[,and-str[, sep]]]) => "foo1, foo2, and foo3"
2
                                                  or => "Foo1, foo2, and foo3"
2
:from_value   (value [,quoteflag [,maxlistdepth]])   => "{foo1, foo2, foo3}"
2
:print        (value)                                => value in string
2
:abbreviated_value (value, options)                  => short value in string
2

2
:to_value       (string)     => {success?, value or error message}
2
:prefix_to_value(string)     => {rest of string, value} or {0, error message}
2

2
:english_number(42)          => "forty-two"
2
:english_ordinal(42)         => "forty-second"
2
:ordinal(42)                 => "42nd"
2
:group_number(42135 [,sep])  => "42,135"
2
:from_ASCII(65)              => "A"
2
:to_ASCII("A")               => 65
2
:from_seconds(number)        => string of rough time passed in large increments
2

2
:name_and_number(obj [,sep]) => "ObjectName (#obj)"
2
:name_and_number_list({obj1,obj2} [,sep])
2
                             => "ObjectName1 (#obj1) and ObjectName2 (#obj2)"
2
:nn is an alias for :name_and_number.
2
:nn_list is an alias for :name_and_number_list.
2

2
    Type checking:
2

2
:is_integer   (string) => return true if string is composed entirely of digits
2
:is_float     (string) => return true if string holds just a floating point
2

2
    Parsing:
2

2
:explode (string,char) -- string => list of words delimited by char
2
:words   (string)      -- string => list of words (as with command line parser)
2
:word_start (string)   -- string => list of start-end pairs.
2
:first_word (string)   -- string => list {first word, rest of string} or {}
2
:char_list  (string)   -- string => list of characters in string
2

2
:parse_command (cmd_line [,player] => mimics action of builtin parser
2

2
    Matching:
2

2
:find_prefix  (prefix, string-list)=>list index of element starting with prefix
2
:index_delimited(string,target[,case]) =>index of delimited string occurrence
2
:index_all    (string, target string)          => list of all matched positions
2
:common       (first string, second string)  => length of longest common prefix
2
:match        (string, [obj-list, prop-name]+) => matching object
2
:match_player (string-list[,me-object])        => list of matching players
2
:match_object (string, location)               => default object match...
2
:match_player_or_object (string, location) => object then player matching
2
:literal_object (string)                       => match against #xxx, $foo
2
:match_stringlist (string, targets)            => match against static strings
2
:match_string (string, wildcard target,options)=> match against a wildcard
2

2
    Pretty printing:
2

2
:space         (n/string[,filler])     => n spaces
2
:left          (string,width[,filler]) => left justified string in field 
2
:right         (string,width[,filler]) => right justified string in field
2
:center/re     (string,width[,lfiller[,rfiller]]) => centered string in field
2
:columnize/se  (list,n[,width])        => list of strings in n columns
2

2
    Substitutions
2

2
:substitute (string,subst_list [,case])   -- general substitutions.
2
:substitute_delimited (string,subst_list [,case])
2
                                          -- like subst, but uses index_delim
2
:pronoun_sub (string/list[,who[,thing[,location]]])
2
                                          -- pronoun substitutions.
2
:pronoun_sub_secure (string[,who[,thing[,location]]],default)
2
                                          -- substitute and check for names.
2
:pronoun_quote (string/list/subst_list)   -- quoting for pronoun substitutions.
2

2
    Miscellaneous string munging:
2

2
:trim         (string)       => string with outside whitespace removed.
2
:triml        (string)       => string with leading whitespace removed.
2
:trimr        (string)       => string with trailing whitespace removed.
2
:strip_chars  (string,chars) => string with all chars in `chars' removed.
2
:strip_all_but(string,chars) => string with all chars not in `chars' removed.
2
:capitalize/se(string)       => string with first letter capitalized.
2
:uppercase/lowercase(string) => string with all letters upper or lowercase.
2
:names_of     (list of OBJ)  => string with names and object numbers of items.
2
:a_or_an      (word)         => "a" or "an" as appropriate for that word.
2
:reverse      (string)       => "gnirts"
2
:incr_alpha   (string)       => "increments" the string alphabetically
2

2
    A useful property:
2

2
.alphabet                    => "abcdefghijklmnopqrstuvwxyz"
2

2
Suspended versions (with _suspended at end of name) for
2
     :print     :from_value     :columnize/se      :match
2
5
5
2
4
4
2
2
string
2
utils
2
5
4
1
2
This is the string utilities utility package.  See `help $string_utils' for more details.
2
5
4
2
0
109381
0
1648488120
36
1
#21
building utilities
24
2
1
-1
0
0
4
0
1
78
4
0
10
make_exit
2
173
-1
set_names
2
173
-1
recreate
2
173
-1
parse_names
2
173
-1
audit_object_category
2
173
-1
object_audit_string
2
173
-1
do_audit do_prospectus
2
173
-1
do_audit_item
2
173
-1
size_string
2
173
-1
init_for_core
2
173
-1
2
classes
class_string
7
4
12
1
6
1
3
1
7
1
9
1
8
1
5
1
74
1
45
1
30
1
37
1
78
1
68
2
5
4
12
2
p
2
R
2
E
2
N
2
C
2
T
2
F
2
M
2
H
2
D
2
U
2
O
2
5
4
13
2
Verbs useful for building.  For a complete description of a given verb, do `help $building_utils:verbname'.
2

2
make_exit(spec,source,dest[,don't-really-create]) => a new exit
2
          spec is an exit-spec as described in `help @dig'
2

2
set_names(object, spec) - sets name and aliases for an object
2
parse_names(spec) => list of {name, aliases}
2
          in both of these, spec is of the form
2
            <name>[[,:]<alias>,<alias>,...]
2
          (as described in `help @rename')
2

2
recreate(object, newparent) - effectively recycle and recreate object
2
          as a child of newparent
2
5
5
2
4
4
2
2
building
2
utils
2
5
4
1
2
This is the building utilities utility package.  See `help $building_utils' for more details.
2
5
4
2
0
19173
0
1648488120
36
1
#22
Programmer Help
16
36
1
-1
0
0
4
0
1
30
4
0
2
errors
36
173
-1
prepositions
36
173
-1
74
@check-property
@check-chparent
@egrep
regular-expressions
@show
@grep
prog-index
help
prepositions
;
utilities
truth
tasks
statements
programming
precedence
language
functions
expressions
eval
errors
@verb
@setenv
@rmverb
@rmproperty
@prospectus
@property
@program
@list
@kill
@kids
@forked
@display
@dbsize
@copy
@chparent
@chmod
@args
.program
@clearproperty
@disown
@disinherit
@displayoptions
@display-options
@add-feature
@remove-feature
features
examine
mail
#
@programmer-options
@programmeroptions
@progoptions
@prog-options
options
utils
@killquiet
scattering
.flush
@rmverb#
@list#
@program#
@args#
@chmod#
@rename#
@addalias#
@add-alias#
@rmalias#
@rm-alias#
checkpoint-programming
@grepall
@egrepall
@properties
@props
80
4
2
2
*forward*
2
@check-chparent
36
5
4
10
2
Syntax:  @check-property <object>.<propname>
2
         @check-chparent <object> to <newparent>
2
         
2
You cannot add a new property to an object if an ancestor or a descendant already defines a property with the same name.  @check-property will give you the list of all descendants of <object> that that define .<propname>.  
2

2
Likewise you cannot chparent an object to a new parent if the new parent has a property that is also defined on the object or some descendant.  Use @check-chparent to find out all instances of conflicting properties that would interfere with @chparent in this manner.
2

2
Note that @check-property requires either that you own the object or that it be writeable, the same conditions that need to hold if you are to create new properties on the object.  Similarly, @check-chparent requires that you own the object and that the new parent is either fertile or likewise owned by you.
2

2
For objects with large numbers of descendants, these commands can be time-consuming.
36
5
4
2
2
*forward*
2
@grep
36
5
4
162
2
Regular expression matching allows you to test whether a string fits into a specific syntactic shape.  You can also search a string for a substring that fits a pattern.  See also the built-in function match()/rmatch().
2

2
A regular expression describes a set of strings.  The simplest case is one that describes a particular string; for example, the string `foo' when regarded as a regular expression matches `foo' and nothing else.  Nontrivial regular expressions use certain special constructs so that they can match more than one string.  For example, the regular expression `foo%|bar' matches either the string `foo' or the string `bar'; the regular expression `c[ad]*r' matches any of the strings `cr', `car', `cdr', `caar', `cadddar' and all other such strings with any number of `a''s and `d''s.
2

2
Regular expressions have a syntax in which a few characters are special constructs and the rest are "ordinary".  An ordinary character is a simple regular expression that matches that character and nothing else.  The special characters are `$', `^', `.', `*', `+', `?', `[', `]' and `%'.  Any other character appearing in a regular expression is ordinary, unless a `%' precedes it.
2

2
For example, `f' is not a special character, so it is ordinary, and therefore `f' is a regular expression that matches the string `f' and no other string.  (It does *not*, for example, match the string `ff'.)  Likewise, `o' is a regular expression that matches only `o'.
2

2
Any two regular expressions A and B can be concatenated.  The result is a regular expression which matches a string if A matches some amount of the beginning of that string and B matches the rest of the string.
2

2
As a simple example, we can concatenate the regular expressions `f' and `o' to get the regular expression `fo', which matches only the string `fo'.  Still trivial.
2

2
The following are the characters and character sequences that have special meaning within regular expressions.  Any character not mentioned here is not special; it stands for exactly itself for the purposes of searching and matching.
2

2
`.'  is a special character that matches any single character.  Using
2
     concatenation, we can make regular expressions like `a.b', which matches
2
     any three-character string that begins with `a' and ends with `b'.
2

2
`*'  is not a construct by itself; it is a suffix that means that the preceding
2
     regular expression is to be repeated as many times as possible.  In `fo*',
2
     the `*' applies to the `o', so `fo*' matches `f' followed by any number of
2
     `o''s.
2

2
     The case of zero `o''s is allowed: `fo*' does match `f'.
2

2
     `*' always applies to the *smallest* possible preceding expression.  Thus,
2
     `fo*' has a repeating `o', not a repeating `fo'.
2

2
     The matcher processes a `*' construct by matching, immediately, as many
2
     repetitions as can be found.  Then it continues with the rest of the
2
     pattern.  If that fails, it backtracks, discarding some of the matches of
2
     the `*''d construct in case that makes it possible to match the rest of
2
     the pattern.  For example, matching `c[ad]*ar' against the string
2
     `caddaar', the `[ad]*' first matches `addaa', but this does not allow the
2
     next `a' in the pattern to match.  So the last of the matches of `[ad]' is
2
     undone and the following `a' is tried again.  Now it succeeds.
2

2
`+'  is like `*' except that at least one match for the preceding pattern is
2
     required for `+'.  Thus, `c[ad]+r' does not match `cr' but does match
2
     anything else that `c[ad]*r' would match.
2

2
`?'  is like `*' except that it allows either zero or one match for the
2
     preceding pattern.  Thus, `c[ad]?r' matches `cr' or `car' or `cdr', and
2
     nothing else.
2

2
`[ ... ]'
2
     `[' begins a "character set", which is terminated by a `]'.  In the
2
     simplest case, the characters between the two brackets form the set.
2
     Thus, `[ad]' matches either `a' or `d', and `[ad]*' matches any string of
2
     `a''s and `d''s (including the empty string), from which it follows that
2
     `c[ad]*r' matches `car', etc.
2

2
     Character ranges can also be included in a character set, by writing two
2
     characters with a `-' between them.  Thus, `[a-z]' matches any lower-case
2
     letter.  Ranges may be intermixed freely with individual characters, as in
2
     `[a-z$%.]', which matches any lower case letter or `$', `%' or period.
2

2
     Note that the usual special characters are not special any more inside a
2
     character set.  A completely different set of special characters exists
2
     inside character sets: `]', `-' and `^'.
2

2
     To include a `]' in a character set, you must make it the first character.
2
     For example, `[]a]' matches `]' or `a'.  To include a `-', you must use it
2
     in a context where it cannot possibly indicate a range: that is, as the
2
     first character, or immediately after a range.
2

2
`[^ ... ]'
2
     `[^' begins a "complement character set", which matches any character
2
     except the ones specified.  Thus, `[^a-z0-9A-Z]' matches all characters
2
     *except* letters and digits.
2

2
     `^' is not special in a character set unless it is the first character.
2
     The character following the `^' is treated as if it were first (it may be
2
     a `-' or a `]').
2

2
`^'  is a special character that matches the empty string -- but only if at the
2
     beginning of the string being matched.  Otherwise it fails to match
2
     anything.  Thus, `^foo' matches a `foo' which occurs at the beginning of
2
     the string.
2

2
`$'  is similar to `^' but matches only at the *end* of the string.  Thus,
2
     `xx*$' matches a string of one or more `x''s at the end of the string.
2

2
`%'  has two functions: it quotes the above special characters (including `%'),
2
     and it introduces additional special constructs.
2

2
     Because `%' quotes special characters, `%$' is a regular expression that
2
     matches only `$', and `%[' is a regular expression that matches only `[',
2
     and so on.
2

2
     For the most part, `%' followed by any character matches only that
2
     character.  However, there are several exceptions: characters that, when
2
     preceded by `%', are special constructs.  Such characters are always
2
     ordinary when encountered on their own.
2

2
     No new special characters will ever be defined.  All extensions to the
2
     regular expression syntax are made by defining new two-character
2
     constructs that begin with `%'.
2

2
`%|' specifies an alternative.  Two regular expressions A and B with `%|' in
2
     between form an expression that matches anything that either A or B will
2
     match.
2

2
     Thus, `foo%|bar' matches either `foo' or `bar' but no other string.
2

2
     `%|' applies to the largest possible surrounding expressions.  Only a
2
     surrounding `%( ... %)' grouping can limit the grouping power of `%|'.
2

2
     Full backtracking capability exists for when multiple `%|''s are used.
2

2
`%( ... %)'
2
     is a grouping construct that serves three purposes:
2

2
       1. To enclose a set of `%|' alternatives for other operations.  Thus,
2
          `%(foo%|bar%)x' matches either `foox' or `barx'.
2

2
       2. To enclose a complicated expression for a following `*', `+', or `?'
2
          to operate on.  Thus, `ba%(na%)*' matches `bananana', etc., with any
2
          number of `na''s, including none.
2

2
       3. To mark a matched substring for future reference.
2

2
     This last application is not a consequence of the idea of a parenthetical
2
     grouping; it is a separate feature that happens to be assigned as a second
2
     meaning to the same `%( ... %)' construct because there is no conflict in
2
     practice between the two meanings.  Here is an explanation of this
2
     feature:
2

2
`%DIGIT'
2
     After the end of a `%( ... %)' construct, the matcher remembers the
2
     beginning and end of the text matched by that construct.  Then, later on
2
     in the regular expression, you can use `%' followed by DIGIT to mean
2
     "match the same text matched by the DIGIT'th `%( ... %)' construct in the
2
     pattern."  The `%( ... %)' constructs are numbered in the order that their
2
     `%(''s appear in the pattern.
2

2
     The strings matching the first nine `%( ... %)' constructs appearing in a
2
     regular expression are assigned numbers 1 through 9 in order of their
2
     beginnings.  `%1' through `%9' may be used to refer to the text matched by
2
     the corresponding `%( ... %)' construct.
2

2
     For example, `%(.*%)%1' matches any string that is composed of two
2
     identical halves.  The `%(.*%)' matches the first half, which may be
2
     anything, but the `%1' that follows must match the same exact text.
2

2
`%b' matches the empty string, but only if it is at the beginning or end of a
2
     word.  Thus, `%bfoo%b' matches any occurrence of `foo' as a separate word.
2
     `%bball%(s%|%)%b' matches `ball' or `balls' as a separate word.
2

2
     For the purposes of this construct and the five that follow, a word is
2
     defined to be a sequence of letters and/or digits.
2

2
`%B' matches the empty string, provided it is *not* at the beginning or end of
2
     a word.
2

2
`%<' matches the empty string, but only if it is at the beginning of a word.
2

2
`%>' matches the empty string, but only if it is at the end of a word.
2

2
`%w' matches any word-constituent character (i.e., any letter or digit).
2

2
`%W' matches any character that is not a word constituent.
36
5
4
7
2
Syntax:  @show <object>
2
         @show <object>.<prop-name>
2
         @show <object>:<verb-name>
2

2
Displays quite detailed information about an object, property or verb, including its name, owner, permission bits, etc.  The information displayed for an object can be quite long.
2

2
See also @display, which displays different information and is controlled differently.
36
5
4
11
2
Syntax:  @grep     <string> in <object>|{<objectlist>}
2
         @egrep    <regexp> in <object>|{<objectlist>}
2
         @grepall  <string> in <object>|{<objectlist>}
2
         @egrepall <regexp> in <object>|{<objectlist>}
2

2
@grep (@grepall) searches the given object(s) for verbs whose verbcode contains the given string as a substring of one of its lines.  
2
@egrep (@egrepall) searches the given object(s) for verbs whose verbcode contains a substring matching the given regular expression (see `help regular-expressions').
2

2
@grep and @egrep print just the first matching line in each verb found.
2
@grepall and @egrepall printed every matching line.
2

36
5
4
2
2
*index*
2
Programmer Help Topics
36
5
4
15
2
*pass*
2
help
2

2
For programmers, the help system provides the following additional forms:
2

2
  help object:verbname   -- prints any documentation strings that are present
2
                            at the beginning of the program for that verb.
2
  help $<whatever>_utils -- prints general information about one of the 
2
                            $..._utils objects (e.g., $string_utils, 
2
                            $list_utils, etc...), which are all libraries 
2
                            of generally used verbs.
2
  help builtin()         -- prints documentation from the programmers manual
2
                            about the named primitive, for example length()
2

2
For information about how the help system itself works and about how to associate local help databases with specific rooms or player classes, see `help $help'.
36
5
4
3
2
*prepositions*
2
The complete list of prepositions recognized by the command-line parser:
2

36
5
4
2
2
*forward*
2
eval
36
1
4
17
2
The core database has a number of objects serving as libraries of useful verbs.
2
More detailed information can be obtained for (some of) these, via `help $whatever_utils'
2

2
$building_utils -- 
2
$code_utils     -- parsing and manipulating verb code
2
$command_utils  -- reporting matching errors to the player
2
$gender_utils   -- managing gendered objects
2
$list_utils     -- list manipulation
2
$set_utils      -- set manipulation
2
$lock_utils     -- key expression manipulation
2
$match_utils    -- 
2
$object_utils   -- object information 
2
                  (inheritance/location hierarchy, verb/property lists)
2
$perm_utils     -- permissions
2
$string_utils   -- string manipulation
2
$time_utils     -- time (numeric and verbal) manipulation
2
$trig_utils     -- trigonometric and other numerical utilities
36
5
4
5
2
Several kinds of statements, expressions, and functions in the MOO programming language use a notion that some MOO values are 'true' and others 'false'.
2

2
The only values that are considered true are non-zero numbers, non-empty strings, and non-empty lists.
2

2
All other values (i.e., 0, "", {}, objects, and errors) are considered false.
36
1
4
18
2
*subst*
2
A task is an execution of a MOO program.  There are five ways for tasks to be created in LambdaMOO:
2
   + Every time a player types a command, a task is created to execute that command; we call these 'command tasks'.
2
   + Whenever a player connects or disconnects from the MOO, the server starts a task to do whatever processing is necessary, such as printing out 'Munchkin has connected' to all of the players in the same room; these are called 'server tasks'.
2
   + The FORK statement in the programming language creates a task whose execution is delayed for at least some given number of seconds; these are 'forked tasks'.
2
   + The suspend() function suspends the execution of the current task.  A snapshot is taken of whole state of the execution, and the execution will be resumed later.  These are called `suspended tasks'.
2
   + The read() function also suspends the execution of the current task, in this case waiting for the player to type a line of input.  When the line is received, the task resumes with the read() function returning the input line as result.  These are called `reading tasks'.
2

2
The last three kinds of tasks above are collectively known as `queued tasks' or `waiting tasks', since they may not run immediately.
2

2
To prevent a maliciously- or incorrectly-written MOO program from running forever and monopolizing the server, limits are placed on the running time of every task. One limit is on the length of time that tasks are allowed to run: queued tasks are given %[tostr(typeof(bgs = $server_options.bg_seconds) == ERR ? 3 | bgs)], and all other tasks, %[tostr(typeof(fgs = $server_options.fg_seconds) == ERR ? 5 | fgs)] seconds to run, after which they will - if they don't suspend() or end first - raise a 'Task ran out of seconds' traceback and die. But there is a second limit which is on the number of operations a task may execute.
2

2
The server counts down 'ticks' as any task executes.  Roughly speaking, it counts one tick for every expression evaluation (other than variables and literals), one for every `if', `fork' or `return' statement, and one for every iteration of a loop.  If the count gets all the way down to zero, a 'Task ran out of ticks' traceback is raised and the task is immediately and unceremoniously aborted.  Queued tasks begin with %[$string_utils:group_number(typeof(bgt = $server_options.bg_ticks) == ERR ? 10000 | bgt)], and all other tasks with %[$string_utils:group_number(typeof(fgt = $server_options.fg_ticks) == ERR ? 30000 | fgt)] ticks.
2

2
Because queued tasks may exist for long periods of time before they begin execution, there are commands to list the ones that you own and to kill them before they execute.  These commands are covered in the following help topics:
2

2
@forked -- listing the forked tasks that you own
2
@kill -- killing a particular forked task
36
1
4
62
2
The following kinds of statements exist in the MOO programming language:
2

2
        ;
2
The null statement does nothing.
2

2
        expression ;
2
The expression statement evaluates the expression and then discards the value.
2

2
        IF ( expression ) statements ENDIF
2
        IF ( expression ) statements ELSE statements ENDIF
2
        IF ( expression )
2
          statements
2
        ELSEIF ( expression )
2
          statements
2
        ...
2
        ELSE
2
          statements
2
        ENDIF
2
The conditional statement evaluates each expression in turn and executes the statements associated with the first one to return a true value; the ELSE statements are executed if none of the expressions returns a true value.  There can be any number of ELSEIF clauses and the ELSE part is optional.  See 'help truth' for the definition of 'true value'.
2

2
        FOR name IN ( expression ) statements ENDFOR
2
The list iteration statement first evaluates the expression, which must return a list.  It then executes the statements once for each element of that list, each time with the named variable having the value of the corresponding list element.
2

2
        FOR name IN [ expression .. expression ] statements ENDFOR
2
The numeric iteration statement first evaluates the two expressions, both of which must return numbers; call those numbers N1 and N2, respectively.  The statements are then executed once for each integer I such that N1 <= I <= N2, in increasing order; each time, the named variable has the corresponding value of I.
2

2
        WHILE ( expression ) statements ENDWHILE
2
        WHILE name ( expression ) statements ENDWHILE
2
The indefinite iteration statement repeatedly evaluates the expression and, each time it returns a true value, executes the statements.  The loop stops the first time that the expression returns a false value.  The definitions of 'true' and 'false' values is in 'help truth'.
2

2
        BREAK ;
2
        BREAK name ;
2
Each `break' statement indicates a specific surrounding loop; if <name> is not given, the statement refers to the innermost one. If it is given, <name> must be the name appearing right after the `for' or `while' keyword of the desired enclosing loop. When the `break' statement is executed, the indicated loop is immediately terminated and executing continues just as if the loop had completed its iterations normally.
2

2
        CONTINUE ;
2
        CONTINUE name ;
2
Allows you to terminate just the current iteration of a loop, making it immediately go on to the next one if any. 
2

2
        RETURN ;
2
        RETURN expression ;
2
The return statement evaluates the expression, if any, and returns the resulting value (or 0 if there is no expression) to the verb that called the current one.  Execution of the current verb is immediately terminated.
2

2
        TRY
2
          statements-0 ;
2
        EXCEPT variable-1 (codes-1)
2
          statements-1 ;
2
        EXCEPT variable-2 (codes-2)
2
          statements-2 ;
2
        ... (up to 255)
2
        ENDTRY
2
Each of the `statements-x' may be any number or combination of MOO statements and function calls. Each of the `codes-x' may be either the keyword `ANY' or else a comma-separated list of expressions that yield error codes. If the execution of `statements-0' raises an error listed in the `codes-x', then the statements associated in that EXCEPT clause where the code was listed are executed. When this occurs, `variable-x' is assigned this information about the error being raised:  {<error code>, <error message>, <value>, <traceback>}. If the error raised is not listed in any EXCEPT clause (which means the `ANY' keyword was not used), then the error continues to be raised. 
2

2
        TRY
2
          statements-0 ;
2
        FINALLY
2
          statements-last ;
2
        ENDTRY
2
In this construct, `statements-0' are executed. Then, whether an error was raised by their execution or not, `statements-last' are executed. If `statements-0' transfers control somewhere else, that transfer is interrupted so that `statements-last' can be run. If `statements-last' transfers control, then that overrides the first transfer. (Transfers include raising an error, returning from this verb, terminating the current iteration of a surrounding loop). `Statements-last' will always be executed, providing a good place for necessary cleanup code that will run even if `statements-0' doesn't simply run normally to completion.
2

2
        FORK ( expression ) statements ENDFORK
2
        FORK name ( expression ) statements ENDFORK
2
The fork statement first executes the expression, which must return a number; call that number N.  It then creates a new MOO task that will, after at least N seconds, execute the statements.  When the new task begins, all variables will have the values they had at the time the FORK statement was executed.  The task executing the FORK statement immediately continues execution.  If a variable name is given after the FORK keyword, then it is assigned the 'queue ID' of the newly-created task.  The value of this variable is visible both to the task executing the fork statement and to the statements in the newly-created task.  See 'help tasks' for more information about forked tasks.
36
1
4
26
2
MOO contains a rich programming language for the creation of interesting rooms, exits, and other objects.  Help is available on the following topics concerning programming in MOO:
2

2
language -- a brief reference for the syntax and semantics of the MOO language
2
tasks -- a brief description of MOO tasks and their resource limits
2

2
@property -- adding a property to an object
2
@rmproperty -- removing a property from an object
2

2
@verb   -- adding a verb to an object
2
@rmverb -- removing a verb from an object
2
@args   -- changing the syntax of a verb
2
@copy   -- copying a verb from one object to another
2

2
.program/@program -- entering the program for a verb
2
@list -- printing a listing of the program for a verb
2
@edit -- editing verb code
2

2
@show     -- looking at all the details of an object, a property, or a verb
2
@parents  -- listing the ancestors of an object
2
@kids     -- listing the children of an object
2
@contents -- listing the contents of an object
2
@chmod    -- changing the permissions on an object, a property, or a verb
2
@chparent -- changing the parent of an object
2
@rename   -- changing the name of a verb or object
2

2
eval -- executing MOO statements and expressions without writing a verb
36
1
4
18
2
The table below gives the relative precedence of all of the MOO operators; operators on higher lines in the table have higher precedence and those on the same line have identical precedence:
2

2
        !       - (without a left operand)
2
        ^
2
        *       /       %
2
        +       -
2
        ==      !=      <       <=      >       >=      in
2
        &&      ||
2
        ... ? ... | ... (the conditional expression)
2
        =
2

2
Thus, the horrendous expression
2

2
        x = a < b && c > d + e * f ? w in y | - q - r
2

2
would be grouped as follows:
2

2
        x = (((a < b) && (c > (d + (e * f)))) ? (w in y) | ((- q) - r))
36
1
4
5
2
The MOO programming language is described in excruciating detail in the LambdaMOO Programmer's Manual, available for download at http://lambda.moo.mud.org/pub/MOO/html/ProgrammersManual_toc.html.  The online help consists of a few quick reference guides here in the help system under the following topics:
2

2
statements -- the syntax and semantics of the various kinds of MOO statements
2
expressions -- the same for the various kinds of MOO expressions
2
functions -- a list of the primitive functions available to MOO programs
36
1
4
139
2
There are many, many built-in functions available to MOO programmers.  The following list gives a brief summary of the arguments and purpose of each function; for more information, see the LambdaMOO Programmer's Manual.  
2

2
pass(arg, ...)   -- calling a verb defined on this object's parent
2

2
time()           -- current time in seconds since midnight GMT, 1 Jan 70
2
ctime([time])    -- time (or current time) converted to a human-readable string
2

2
eval(string)     -- parsing and executing strings as MOO code
2

2
typeof(value)      -- determining the data type of a value
2
 tostr(value, ...) -- converting any set of values into a string
2
 toint(value)      -- converting any non-list value into an integer
2
 tonum(value)      -- converting any non-list value into an integer (obsolete)
2
 tofloat(value)    -- converting any non-list value into a floating-point
2
 toobj(value)      -- converting any non-list value into an object
2
 toliteral(value)  -- converting any value into a literal string
2
length(value)      -- returns the length of a string or list
2

2
equal(val1, val2)          -- is val1 indistinguishable from val2
2
min(n1, n2, ...)           -- minimum of n1,n2,...
2
max(n1, n2, ...)           -- maximum of n1,n2,...
2
abs(n)                     -- absolute value of n
2
sin(n), cos(n), tan(n)     -- sine, cosine, tangent of n
2
asin(n), acos(n), atan(n)  -- arc-sine, arc-cosine, arc-tangent of n
2
sinh(n), cosh(n), tanh(n)  -- hyperbolic sine, cosine, tangent of n
2
exp(n)                     -- `e' raised to the power of n
2
log(n), log10(n)           -- natural or base 10 logarithm of n (n > 0)
2
sqrt(n)                    -- square root of n, rounded down
2
random(n)                  -- random integer between 1 and n inclusive
2
floatstr(float, precision, sci) -- format a floating-point into string
2
ceil(f)          -- smallest integer > float f as a floating-point
2
floor(f)         -- largest integer < float f as floating-point
2
trunc(f)         -- truncate f at the decimal point, as floating-point
2

2
index(str1, str2 [, case-matters])  -- index of first str2 in str1
2
rindex(str1, str2 [, case-matters]) -- index of last  str2 in str1
2
strcmp(str1, str2) -- case-sensitive string comparison
2
strsub(subject, what, with [, case-matters]) -- substitution in a string
2
match(str1, str2 [, case-matters])  -- match first regular expr str2 in str1
2
rmatch(str1, str2 [, case-matters]) -- match last regular expr str2 in str1
2
substitute(template, subs)          -- perform substitutions on template
2

2
decode_binary(bin-string [, fully]) -- convert from a binary string
2
encode_binary(arg, ...)             -- convert to a binary string
2
      crypt(string [, salt])        -- one-way string encryption
2
string_hash(text)                 -- MD5 cryptographically secure hash of text
2
binary_hash(bin-string)           -- same but for a binary string
2
 value_hash(value)                -- string_hash(toliteral(value))
2

2
 is_member(value, list)           -- is exact value (case sensitive) in list
2
listappend(list, value [, index]) -- adding an element at the end of a list
2
listinsert(list, value [, index]) -- adding an element at the head of a list
2
   listset(list, value, index)    -- updating a list at some index
2
listdelete(list, index)           -- removing an element from a list
2
    setadd(list, element) -- adding an element to a set represented as a list
2
 setremove(list, element) -- removing an element from such a set
2

2
   valid(object)             -- testing whether an object exists
2
  create(parent [, owner(*)])-- creating a new MOO object
2
 recycle(object)             -- destroying a MOO object
2
    move(object, where)      -- altering the object-containment hierarchy
2
chparent(object, new-parent) -- altering the object-inheritance hierarchy
2
  parent(object)             -- object's parent   in the inheritance hierarchy
2
children(object)             -- object's children in the inheritance hierarchy
2
max_object()       -- the highest-numbered object in the MOO
2
renumber(obj)      -- changes an object's number to lowest available one (*)
2
reset_max_object() -- resets max_object() to the largest valid object (*)
2

2
     properties(object) -- a list of the properties defined on an object
2
   add_property(object, prop-name, value, info) -- add a new property
2
delete_property(object, prop-name)              -- remove a property
2
    property_info(object, prop-name)       -- {owner, perms} info on a property
2
set_property_info(object, prop-name, info) -- setting same
2
is_clear_property(object, prop-name) -- find out if a property is "clear"
2
   clear_property(object, prop-name) -- make a property "clear"
2

2
      verbs(object) -- a list of the verbs defined on an object
2
   add_verb(object, info, args)  -- add a verb to an object
2
delete_verb(object, verb-name)   -- remove a verb from an object
2
    verb_info(object, verb-name) -- {owner, perms, names} info for a verb defn.
2
    verb_args(object, verb-name) -- {dobj, prep, iobj} argument info for a verb
2
    verb_code(object, verb-name [, fully-paren [, indent]]) -- program listing
2
set_verb_info(object, verb-name, {owner, perms, names})
2
set_verb_args(object, verb-name, {dobj, prep, iobj})   
2
set_verb_code(object, verb-name, {line, line, ...})
2
disassemble(object, verb-desc)   -- listing of server's internal `compile' 
2

2
        is_player(object) -- testing whether or not object is a player
2
          players()       -- a list of all players, active or not
2
connected_players()       -- a list of all currently-connected players
2
     idle_seconds(player) -- seconds since given player typed anything
2
connected_seconds(player) -- seconds given player has been logged in
2
    boot_player(player)        -- disconnect player from the MOO immediately(*)
2
set_player_flag(player, value) -- set/clear player bit; boot player if clear(*)
2
connection_name(player)   -- a server-assigned name for player's connection
2

2
open_network_connection(@args) -- open a connection to another network site (*)
2
notify(player, string)    -- sending text to a player's terminal
2
read()                    -- reading a line of input from the player (*)
2
buffered_output_length([player])      -- how much output pending
2
force_input(player, str [, at-front]) -- put str in player's output queue
2
flush_input(player [, show-messages]) -- clear a player's output queue
2
output_delimiters(player) -- return {prefix,suffix} set by PREFIX/SUFFIX cmds
2
set_connection_option(player, option, value) -- set I/O options for player
2
   connection_options(player) -- list current I/O options for player
2
    connection_option(player, option) -- return setting of option for player
2

2
   listen(conn, point [, print-messages]) -- create server listening point (*)
2
u nlisten(canon) -- close the server listening point described by canon (*)
2
listeners() -- list of all listening points
2

2
        raise(code [, message [, value]]) -- raise code just like an error
2
call_function(func-name, arg, ...)        -- call func-name
2
function_info([name])   -- descriptions of available built-in functions
2

2
caller_perms()         -- the player whose permissions your caller was using
2
set_task_perms(player) -- changing permissions of the running task (*)
2
callers()      -- list of {obj, verb, owner, vloc, player}: this task's stack
2
suspend([secs])  -- suspending the current task for a number of seconds
2
resume(task [, value]) -- resume the given task with value returned
2
seconds_left() -- number of seconds left in the current task
2
ticks_left()   -- number of ticks   left in the current task
2
task_id()      -- a random number representing the currently-running task
2
queue_info([player]) -- who has tasks, or how many player has
2
queued_tasks() -- list of {id,start,0,20000,owner,obj,verb,line,this}
2
kill_task(id)  -- delete one of your tasks from the queue
2
task_stack(task-id [, include-line-numbers]) -- info about suspended task
2

2
server_log(string) -- add a comment to the server log file
2
server_version() -- a string of three numbers "major.minor.release"
2
memory_usage()   -- {{blocksize, nused, nfree}, ...}, the server's memory stats
2
shutdown(msg)    -- print msg and kill the server (*)
2
dump_database()  -- what it says (*)
2
db_disk_size()   -- size in bytes of recent full database
2

2
 value_bytes(value)  -- memory required to store value
2
object_bytes(object) -- memory required to store object
2

2
(*) => as you might have expected, these usually require wizard permissions.
36
1
4
75
2
The following kinds of expressions exist in the MOO programming language:
2

2
        number
2
        # integer
2
        # - integer
2
        "character string"
2
        error-name
2
Literal expressions return the obvious values: numbers (floating-point or integers), object numbers, strings, and errors.
2

2
        { expression , expression , ... , expression }
2
The list-construction expression evaluates the each of the expressions in turn and returns a list whose elements are the results of those expressions.  Any of the expressions may be prefixed with an at-sign ('@'); in this case, that expression must return a list and, rather than that list becoming an element of the final list, its elements are spliced into the final list.
2

2
        name
2
Variable expressions return the current value of the named variable.  Variable names must start with a letter or underscore ('_') and contain only letters, digits, and underscores.  The following variables are predefined:
2
            OBJ, STR, LIST, ERR, INT, FLOAT, NUM (same as INT)
2
            player, caller, this, verb, args
2
            argstr, dobj, dobjstr, prepstr, iobj, iobjstr
2
Their initial values are described in detail in the LambdaMOO Programmer's Manual.
2

2
        expression . name
2
        expression . ( expression )
2
        $ name
2
Property-reading expressions return the current value of a named property on the object that is the value of the first subexpression.  In the second form, the second subexpression must return a string, the name of the property to be read.  The third form is an abbreviation for '#0.name'.
2

2
        expression : name ( arguments )
2
        expression : ( expression ) ( arguments )
2
Verb-call expressions invoke a named verb on the object that is the value of the first subexpression, passing the given arguments.  In the second form, the second subexpression must return a string, the name of the verb to invoke.  The syntax and semantics of arguments is exactly as in the list-construction expression but no initial or final curly-braces ('{' or '}') are used.
2

2
        function ( arguments )
2
The function-call expression invokes one of the MOO primitive functions, as listed in 'help functions', passing the given arguments.
2

2
        expression [ expression ]
2
The indexing expression first evaluates the two subexpressions; call their values S and N, respectively.  S must be a string or a list and N must be a integer between 1 and the length of S, inclusive.  The Nth element of S is returned.  The elements of a string are themselves one-character strings. The special character `$' maybe used for N as shorthand for the length of the string or list S.
2

2
        expression [ expression .. expression ]
2
The subsequence expression first evaluates the three subexpressions; call their values S, N1, and N2, respecitively.  S must be a string or a list and N1 and N2 must be integers.  If N1 <= N2, then both must be between 1 and the length of S, inclusive (the shorthand character `$' may be used); the subsequence of S beginning at index N1 and continuing through index N2 is returned.  If N1 > N2, the empty sequence of the same type as S is returned, either "" or {}.
2

2
        name = expression
2
        expression . name = expression
2
        expression . ( expression ) = expression
2
        $ name = expression
2
Assignment expressions give new values to variables and object properties.  For the second and third forms, the expressions on the left-hand side of the '=' are evaluated first.  Then the right-hand side expression is evaluated and result is stored in the indicated variable or object property.
2
There is a special kind of assignment involving lists on the left hand side. See `help scattering' for details.
2

2
        expression + expression
2
        expression - expression
2
        expression * expression
2
        expression / expression
2
        expression % expression
2
        - expression
2
        expression ^ expression
2
The arithmetic expressions evaluate the subexpressions, all of which must return numbers of the same type (integer or floating-point), and then perform addition, subtraction, multiplication, division, remaindering, negation, or raising to a power, respectively.  For addition, the subexpressions may both return strings as well; in this case, the result is the concatenation of the two strings. For the last operation, raising to a power, if the first expression is an integer, the second must also be an integer. But if it is floating-point, then the second can be either floating point or an integer. This is the only type mixing permitted. You must do explicit type conversions with built-in functions (toint(), tofloat()) before evaluation mixed expressions on the other operations.
2

2
        expression == expression
2
        expression != expression
2
        expression < expression
2
        expression <= expression
2
        expression > expression
2
        expression >= expression
2
The comparison expressions evaluate the subexpressions and then test whether or not the first result is equal to, unequal to, less than, less than or equal to, greater than, or greater than or equal to the second result, respectively.  If the indicated relation holds then they return 1 and otherwise they return 0.  Comparisons of strings are performed case-insensitively, those of lists are performed on an element-by-element basis, objects are compared by their object numbers, and errors by an ordering given in the LambdaMOO Programmer's Manual.
2

2
        expression ? expression | expression
2
        expression && expression
2
        expression || expression
2
        ! expression
2
The logical expressions each return results based upon the truth value of their first subexpression; call the value of this expression X.  The first of these returns the value of the second subexpression if X is a true value and that of the third expression if X is a false value; the unused subexpression is not evaluated.  The definitions of 'true value' and 'false value' are given in 'help truth'.  The expression 'E1 && E2' is an abbreviation for 'E1 ? E2 | E1' except that E1 is only evaluated once.  The expression 'E1 || E2' is an abbreviation for 'E1 ? E1 | E2' except that E1 is only evaluated once.  The expression '! E' is an abbreviation for 'E ? 0 | 1'.
2

2
        expression IN expression
2
The list-membership expression first evaluates both subexpressions; call their values E and L, respectively.  L must be a list.  If E is an element of L, then the index of the first occurence of E in L is returned.  If E is not an element of L, then 0 is returned.
2

2
        `expression-1 ! codes => expression-2'
2
NOTE: the open- and close-quotation marks are really part of the syntax; they must be typed in. `Codes' is either the keywoard ANY or a comma-separated list of expressions that when evaluated should yield a list of error codes to be caught if they're raised. If `expression-1' is evaluated without raising an error, then its value is the value of the entire expresion. If it raises an error that is listed in `codes', it is caught. If the `=> expression-2' part was included (it is optional), then it is evaluated and its value is the result of the entire expression. If `expression-2' was omitted, then the error is the value of the expression. If the error was not listed and caught, then the error contines to be raised.
2

2
The method for disambiguating the meaning of a complex MOO expression in the absence of sufficient parentheses is described in 'help precedence'.
2

36
1
4
37
2
Syntax:  eval <MOO-code>
2
         ; <MOO-code>
2
         eval-d <MOO-code>
2

2
Evaluates the given piece of MOO code and prints the resulting value.  If the MOO code begins with one of the MOO language keywords ('if', 'for', 'while', 'fork', or 'return') or with the character ';', then the entire piece of code is treated as the program for a verb, with ';' appended to the end.  Otherwise, 'return' is appended to the front and ';' is appended to the end and that string is treated as the code for a verb.  In either case, the resulting verb is invoked and whatever value it returns is printed.
2

2
For programmers, this is such a mind-bogglingly useful thing to do that there is a simple abbreviation for this command; any command beginning with a semicolon (';') is treated as a use of 'eval'.
2

2
Eval treats specially a duplicated semicolon at the beginning.  It enables you to make multi-statement programs within eval (but does not by default print the return value).
2

2
Eval-d (no ";" abbreviation for this) evaluates the following text exactly as eval, except that the "d" debug flag (see programmer's manual for explanation) is turned off.  Thus errors will cause an error return value rather than a traceback.
2

2
If you set the programmer option `eval_time' to 1 (see `help @prog-options'), then eval will print out how many ticks and seconds the program required.
2

2
Examples:
2
   eval 3 + 4
2
   =>  7
2
   ;3+4
2
   =>  7
2
   ;for x in (player.aliases) player:tell(x); endfor
2
   Haakon
2
   Wizard
2
   ArchWizard
2
   =>  0
2
   ;;l = {}; for i in [1..10] l = {@l, i}; endfor return l
2
   =>  {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
2
   eval-d 8 + "foo"
2
   => E_TYPE  (Type mismatch)
2

2
You may customize your evaluation environment.  The player property .eval_env may contain statements to be executed prior to any evaluated program.  Two caveats:  This will throw off the tick count.  You can account for additional ticks inserted by your environment with the .eval_ticks property; just set it to the number of ticks you'd like subtracted from the total.  Additionally, if you make a syntax error in your program, the line reported will be wrong (it will count those initial statements), and if you make an error in the eval_env itself, you can be in deep trouble.  Despite these drawbacks, the eval_env property can be quite useful.  The following is a sample:
2

2
Eval_env:    "me=player;here=player.location;"
2
eval_ticks:  3
2

2
See also @setenv.
2

2
You can also define textual substitutions in a separate property, called eval_subs.  These are discouraged, however, for anything that can be done with variable assignments, because the overhead of replacing the strings in the evaluated program is significant.  However, some things, such as substituting characters which can't be typed easily on one keyboard (e.g. "[]" is difficult to type on some IBM keyboards), can only be done by textual substitutions.  Note that the eval substitutions are also interpreted by the verb editor when "eval_subs" is selected in your .edit_options property (see `help editors').  This adds to their overhead, but again, makes it possible for people to program who otherwise can't type the full character set.  Remember:  Don't use eval_subs unless you really have to!
36
1
4
3
2
*errors*
2
The complete list of error codes:
2

36
5
4
17
2
Syntax:  @verb <object>:<verb-name(s)>
2
         @verb <object>:<verb-name(s)> <dobj> [<prep> [<iobj>]]
2

2
Adds a new verb with the given name(s) to the named object.  If there are multiple names, they should be separated by spaces and all enclosed in quotes:
2

2
        @verb foo:"bar baz mum*ble"
2

2
The direct and indirect object specifiers (<dobj> and <iobj>) must be either 'none', 'this', or 'any'; their meaning is discussed in the LambdaMOO Programmer's Manual.  The preposition specifier (<prep>) must be either 'none', 'any', or one of the prepositional phrases listed in `help prepositions' (a prepositional phrase with more than one word must be enclosed in quotes ("")).  All three specifiers default to 'none'.
2

2
It is also possible to specify the new verb's permissions and owner as part of the same command (rather than having to issue separate @chmod/@chown commands)
2

2
     @verb <object>:<verb-name(s)> <dobj> <prep> <iobj> <permissions>
2
     @verb <object>:<verb-name(s)> <dobj> <prep> <iobj> <permissions> <owner>
2

2
<permissions> are as with @chmod, i.e., must be some subset of "rwxd".  They default to "rd" (specifying "w" for a verb is highly inadvisable).  The owner defaults to the player typing the command; only wizards can create verbs with owners other than themselves.
2

2
You may also use "tnt" in place of "this none this" for the dobj prep iobj arguments.  "this none this" is used to indicate non-command verbs, since the parser can't possibly interpret a command as "this none this".  For these verbs, the permissions default to "rxd"; the "x" bit is set so that they can be called from other programs.  (If they couldn't be used as commands, and they couldn't be called from programs, they wouldn't be good for anything!)
36
1
4
8
2
Syntax:  @setenv <environment string>
2

2
Defines the environment for eval (property player.eval_env).  See "help eval"
2
for more information.
2

2
Example:
2

2
  @setenv me=player;here=player.location;
36
1
4
10
2
Syntax:  @rmverb <object>:<verb-name>
2
         @rmverb <object>:<verb-name>  <dobj> <prep> <iobj>
2
         @rmverb# <object>:<verb-number>
2

2
Removes the named verb from the named object.
2
If there is more than one verb matching the given verb-name, this removes the most recently defined one.
2

2
With the 2nd form of the command the verb removed is the most recent one matching both the given verb-name *and* the given dobj/prep/iobj specifiers.
2

2
To remove the ambiguity in verbs with the same name, @rmverb# is provided where you can specify the verb by its 1-based index in the verbs() list output. Use of this form is strongly encouraged.
36
5
4
3
2
Syntax:  @rmproperty <object>.<prop-name>
2

2
Removes the named property from the named object.  '@rmproperty' may be abbreviated as '@rmprop'.
36
5
4
35
2
Usage:  @prospectus player [from number] [to number]
2

2
Like @audit, but displays more information.  The optional from and to arguments are for restricting the display to specific object numbers, if you happen to know the player only owns objects in the included range.
2

2
Example:
2
   Objects owned by Frand (from #0 to #54949):
2
     P[ 23]    #47 Frand                          [Hyperspace Hovel]
2
     T        #152 Frand's trio of shoes          [Frand]
2
   KfT[ 10]   #391 Frand's notifier class         [Nowhere]
2
     T[  8]   #393 Frand's chessboard             [The Dining Room]
2
   KfT[ 11]   #775 Frand's generic game board     [Nowhere]
2
     T[  6]   #893 Ghost game                     [The Dining Room]
2
     T[ 16]   #894 Frand's mind bender            [The Dining Room]
2
     C        #997 polka-dot hole                 [Hyperspace Hovel]
2
     R[  1]  #1002 Hyperspace Hovel              
2
     E      #11958 out                            Monster Cage->*Dr. Empirico's Lab
2
      ...
2

2
The K in the first column indicates that the object has children owned by other players.  A lowercase k indicates the object has children but owned only by the player.  The second column indicates whether the object is publicly readable or publicly parentable.  An r indicates readability.  A lowercase f indicates the object is both readable and allows children (is fertile).  An uppercase F indicates the object is not readable, yet allows children to be created.  (This is usually an error.)  If the object is readable by the issuer of the @prospectus command (that is, publicly readable or owned by the issuer), then the number in brackets indicates the number of verbs which have been defined on this object (not including any verbs from any parents).
2

2
The third column indicates what type of object this is.
2
        T       Thing
2
        E       Exit
2
        R       Room
2
        C       Container
2
        N       Note
2
        P       Player
2
        F       Feature
2
        M       Mail Recipient
2
        H       Help Database
2
        D       Database
2
        U       Utilities Package
2
        O       Options Package
2
        p       Parent object appropriate for players ("Player class")
2
        blank   Other
36
5
4
13
2
Syntax:  @property <object>.<prop-name>
2
         @property <object>.<prop-name> <initial-value>
2

2
Adds a new property named <prop-name> to the named object.  The initial value is given by the second argument, if present; it defaults to 0.  
2

2
Normally, a property is created with permissions 'rc' and owned by whoever types the command.  However, you may also specify these explicitly
2

2
         @property <object>.<prop-name> <initial-value> <permissions>
2
         @property <object>.<prop-name> <initial-value> <permissions> <owner>
2

2
Only wizards can create properties with owners other than themselves.
2

2
'@property' can be abbreviated as '@prop'.
36
1
4
20
2
Syntax:  @program <object>:<verb-name>
2
         @program <object>:<verb-name> <dobj> <preposition> <iobj>
2
         @program# <object>:<verb-number>
2

2
Changes the MOO program associated with the named verb on the named object.
2
If you provide <dobj> <preposition> and <iobj> as in the second form of this command, then it is the first verb with matching direct object, preposition and indirect object specifiers that is the one getting the new program.  This is useful if you have several verbs matching the same name.
2

2
Or, you can use @program# if you know the verb's number. This is the 1-based index of the verb as it appears in the verbs() (or @verbs) output list.
2

2
Typing the @program command always puts the server into a line-reading mode, in which each line you type is saved away without any action unless said line is one of the following:
2

2
  .
2
  @abort
2
  .<text>
2

2
A period on a line by itself ends the line-reading mode and continues with the command, in this case, the saved lines are considered as a program, checked for syntax errors and, if no errors are found, installed as the new program for the specified verb.  
2

2
@abort causes the command to terminate immediately with no change to any verb's program.  .<text> enters <text> literally as one of the lines to be saved, which is used for when, e.g., you want to enter the line `.' or the line `@abort'.
2

2
Note that this command *always* enters the line-reading mode, even if the indicated verb is not found.  In this case, lines of text are still read but they are ignored.  After any @program command, you always need to type a period or `@abort' to get back into the normal command-reading mode.
36
5
4
25
2
Syntax:  @list <object>:<verb>
2
         @list <object>:<verb> [with|without parentheses|numbers] [all]
2
         @list <object>:<verb> <dobj> <prep> <iobj>
2
         @list <object>:<verb> <start>..<end>
2
         @list# <object>:<verb-number> [any of the above]
2

2
Prints out the code for the MOO program associated with the named verb on the named object.  
2

2
Normally, the code is shown with each line numbered and with only those parentheses that are necessary to show the meaning of the program.  You can e.g., specify `without numbers' to have the numbers omitted or `with parentheses' to include all parentheses or even `with parentheses without numbers' to do both.  You can change the default behavior of this command via @prog-options (which see).
2

2
Normally, the @list command only shows the code for the named verb on the object itself or on the nearest ancestor that defines it; if you give the `all' option, it shows the code for the named verb on every ancestor that defines it, as well as on the object itself.
2

2
The 3rd form of the verb lists the verb matching the given dobj/prep/iobj specification if such exists.  
2
The 4th form prints only those lines in the specified range.
2

2
Example:
2
  Type `@list $room:say' to see the code for the `say' command, or even `@list $prog:@list' to see the code implementing @list itself...
2

2
The 2nd-4th forms may be combined, e.g.,
2

2
  @list frobule:burfle this in front of any without numbers 1..10
2

2
which would be useful if `frobule' had more than one `burfle' verb and we wanted to see the first 10 lines of the one having `this' `in front of' `any' as its respective dobj/prep/iobj specifiers.
2

2
Or, if you know the verb's number, you can use @list# to unambiguously refer to the verb. The number comes from the 1-based index of the verb as it appears in the verbs() (or @verbs) output list.
36
1
4
26
2
Syntax:  @kill task_id
2
         @kill [object]:[verb]
2
         @kill soon [number-of-seconds]
2
         @kill all
2
         @kill %trailing_id
2

2

2
Immediately kills one or more forked tasks.  The '@forked' command is useful for finding out what tasks you have pending; see 'help @forked' for details.  Only the owner of a task may kill it.
2

2
@kill task_id kills only the task with that id.
2

2
@kill object:verb kills all tasks which were scheduled by the object running the verb named.  Both object and verb are optional:  @kill object: kills all tasks scheduled by that object, and @kill :verb kills all tasks which were scheduled by any object running that verb.  This can be useful if you have several similar objects which are running tasks from similarly named verbs.  (Perversely, @kill : kills all tasks...  Any object running any task.)
2

2
@kill soon kills all tasks scheduled within the next minute.  @kill soon number kills all tasks scheduled within that number of seconds, e.g. @kill soon 300 would kill all tasks scheduled within the next five minutes.  This can be useful if you have a runaway task you want to quickly remove, but don't want to kill you later tasks.
2

2
@kill all kills all tasks.  Like @kill soon, but more dramatic.
2

2
@kill %trailing_id expects you to specify the last few digits of a task id.  It then kills all tasks that end with those digits.
2

2
@killq*uiet does all of the above without the pretty printout if more than one task is being killed.  It tells you the number of tasks that have been killed when it's finished.
2

2
Example:
2
  @forked
2
  1359083655  Sep 16 21:45:00 1991  yduJ          #5803:heartbeat (10) [#68]
2
  @kill %655
2
  Killed:   task 1359083655, verb #5803:heartbeat, line 10, this==#68
36
1
4
8
2
Syntax:  @kids object
2

2
A quick way to find out the children of an object.  Prints out the names and object numbers of the found children.  Note: this is not a list of all descendents, just direct children.
2

2
Example:
2
  @kids #3107
2
  Generic Body of Chlorinated Water(#3107) has 3 kids.
2
  The Pool(#1428)   The Hot Tub(#388)   Deep Blue Underground Pool(#17340)
36
5
4
26
2
Syntax:  @forked[-v*erbose] [all wizards]
2

2
Gives a list of all of the forked tasks you own, along with detailed information about each one.  Wizardly characters may specify `all wizards' and see the queued tasks which are owned by a player with .wizard=1. This is useful to find a task that $wiz_utils:random_wizard has put in various queues, and to also find code which is running with wizardly permissions that shouldn't be.
2

2
The information displayed includes the following:
2

2
Queue ID:
2
   A numeric identifier for the task, for use in killing it (see 'help @kill').
2

2
Start Time:
2
   The time after which the task will begin execution.
2

2
Owner:
2
   The player whose permissions under which the task is running.
2
   Unless you are a wizard, @forked will show only your tasks.
2

2
Verb:
2
   The object and verb-name of the code that forked the task.
2

2
Line:
2
   The line number of the first statement that the task will execute when it starts.  Note that the code for the verb in question may have changed since the task was forked; the forked task will use the version that was being executed when it was forked.
2

2
This:
2
   The value of `this' for the forked task, in the case that it is different from (i.e., is a descendant of) the object on which the verb code lives.
2

2
For a more verbose output, use `@forked-v*erbose'. This will display the same information as the above, but for any task which is not a fresh fork or foreground task, a callers()-style listing of the stack trace will be displayed.
36
1
4
42
2
Syntax: @display <object>.[property]
2
                         ,[inherited_property]
2
                         :[verb]
2
                         ;[inherited_verb]
2

2
@display is a fancy version of @show.  As @show, it can select individual verbs or properties to display.  In addition, it can display all the verbs or properties defined on an object, or all the verbs or properties defined on any of the object's ancestors.  Don't specify a property or verbname after the punctuation mark to get the "all" feature.  Its display is more compact than that of @show (it uses a one-line format, and truncates values that don't fit in the value field).
2

2
You may mix properties and verbs on the command line, but the parser may become confused.  (E.g. @display object,: displays all properties including inherited ones plus all locally defined verbs on the object.)
2

2
Examples:
2
Individual property:
2
  @display poolsweep.count
2
  .count                   yduJ (#68)            r c    8
2

2
Individual verb:
2
  @display poolsweep:tell
2
  #3560:tell                     yduJ (#68)           rxd    this none this
2

2
All properties, including one truncated value:
2
  @display poolsweep.
2
  poolsweep (#3560) [ readable ]
2
    Owned by yduJ (#68).
2
    Child of generic thing (#5).
2
    Location The Pool (#1428).
2
  .gagged                  yduJ (#68)            r c    0
2
  .count                   yduJ (#68)            r c    8
2
  .messages                yduJ (#68)            r c    {"The poolsweep stir..
2
  .index                   yduJ (#68)            r c    2
2
  .quantum                 yduJ (#68)            r c    20
2

2
Inherited verbs, edited for brevity, showing verbs from various parents, with owners, permissions, and argument lists.
2
  @d poolsweep;
2
  poolsweep (#3560) [ readable ]
2
   #3560:tell                     yduJ (#68)           rxd    this none this
2
   #3560:description              yduJ (#68)           rxd    this none this
2
      #5:"g*et t*ake"             Haakon (#2)          rxd    this none none
2
      #5:"d*rop th*row"           Haakon (#2)          rxd    this none none
2
      #5:moveto                   Haakon (#2)          rxd    this none this
2
      #1:description              Haakon (#2)          rxd    this none this
2
      #1:look_self                Haakon (#2)          rxd    this none this
2

2
Some aspects of @display can be customized (see `help @display-options').
36
5
4
3
2
Syntax:  @dbsize
2

2
@dbsize goes through the entire database, counting the valid and invalid objects, giving a summary at the end.  This information can be useful, but because this command is cpu intensive, it should be used sparingly.
36
5
4
14
2
Syntax:  @copy <object>:<verb> to [<newobject>][:<newverb>]
2
         @copy-move <object>:<verb> to [<newobject>][:<newverb>]
2

2
Copies the code of the named verb to the new object and verbname.  Permissions, and arguments of the new verb are set to match those of the old verb in the event that the new verb does not already exist.  One of <newobject> or :<newverb> must be supplied.  If no new verbname is given, the old name is retained.  Likewise, <newobject> defaults to <object> if not given.
2

2
@copy-move will delete the old verb after it has copied.  Useful for restructuring code/object hierarchies.
2

2
Examples:
2
  @copy me:verbname to myobject
2
  @copy me:test_verb to myobject:real_verb
2

2
In general, @copy'ing verbs is a bad idea.  In the vast majority of cases, the desired effect can be accomplished with parenting (i.e., having <object> be an ancestor of <newobject>), which has the advantage that if a verb is updated or fixed, this immediately becomes available to child objects that inherit this verb.  In such a case, copies that were made using @copy have to be tracked down and fixed by hand.
2

2
This facility is provided for those rare occasions where one has no choice but to actually copy the verb.
36
5
4
7
2
Syntax:  @chparent <object> to <new parent>
2

2
Changes the parent of the named object to be the named parent.  The object acquires all the verb and property definitions of its parent.  Newly acquired properties are initilialized with `clear' values so that they inherit whatever values are currently assigned to the parent's corresponding properties (see `help @clearproperty').
2

2
If the player does not own <new parent>, it must have been set `fertile'.  <object> must be owned by the player.  Neither <object> nor any descendant can define any property which already exist on <new parent>.  Use @check-chparent (see `help @check-chparent') to list such property conflicts.
2

2
It is also sometimes the case that you will own some object and want to @chparent some child of that object that you do not own.  Use @disinherit (see `help @disinherit') in such situations.
36
5
4
28
2
Syntax:  @chmod <object> <object-permissions>
2
         @chmod <object>.<prop-name> <property-permissions>
2
         @chmod <object>:<verb-name> <verb-permissions>
2
         @chmod# <object>:<verb-number> <verb-permissions>
2

2
Changes the permissions of an object, property or verb, to those given.  The following table shows what permission bits are allowed for each form of the command:
2
        <object-permissions>        r, w, f
2
        <property-permissions>      r, w, c
2
        <verb-permissions>          r, w, x, d
2

2
See the LambdaMOO Programmer's Manual for their meanings.
2

2
The form @chmod# is used to unambiguously refer to a verb by its 1-based index as it appears in the verbs() (or @verbs()) output list.
2

2
To clear all of the permissions for an object, verb, or property, use "" as the second argument.
2

2
@chmod also accepts +, !, and - as modifiers for a single permission to add or subtract that permission from the current set.  (! and - are the same.)
2

2
Examples:
2

2
Set a verb to be Readable and Callable:
2
  @chmod chair:sit rx
2

2
Set a verb to be not Callable, without changing its other permissions:
2
  @chmod cookies:eat !x
2

2
Set an object to be Fertile in addition to any current bits:
2
  @chmod table +f
36
5
4
9
2
Syntax:  @args <object>:<verb-name> <dobj>
2
         @args <object>:<verb-name> <dobj> <prep>
2
         @args <object>:<verb-name> <dobj> <prep> <iobj>
2
         @args# <object>:<verb-number> [any above combinations]
2

2
Changes the direct object, preposition, and/or indirect object specifiers for the named verb on the named object.  Any specifiers not provided on the command line are not changed.  The direct and indirect object specifiers (<dobj> and <iobj>) must be either 'none', 'this', or 'any'.  The preposition specifier (<prep>) must be either 'none', 'any', or one of the prepositional phrases listed in `help prepositions'.
2

2
To unambiguously refer to the verb on the object, in case there are more than one with the same name, use @args#. This takes the 1-based index of the verb as it appears in the verbs() (or @verbs()) output list.
2

36
1
4
13
2
Syntax:  .program <object>:<verb-name>
2
              :
2
              :
2
              <lines of MOO code>
2
              :
2
              :
2
         .
2

2
Provides or changes the MOO program associated with the named verb on the named object.
2

2
This command is mostly obsolete.  Use @program instead.  The only reason this command still exists is that it is a server builtin command that will continue to work in the (unlikely) event that @program gets trashed ...
2

2
This command works differently from most other MOO commands, in that it actually changes how the server will interpret later lines that you type to it.  After typing the '.program' line, you are in 'programming mode'.  All lines that you type in this mode are simply saved away in the server until you type a line containing only a single period ('.').  At that point, those lines are interpreted as a MOO program and are checked for syntax errors.  If none are found, a message to that effect is printed and the code you typed is installed as the program for the verb in question.  In any case, after typing the '.' line, you are returned to the normal input-handling mode.
36
1
4
32
2
Syntax:   @clearproperty <object>.<prop-name>
2

2
This clears <object>'s <prop-name> property.  That is the property value becomes `clear' and all further references to this property will use the value of the same property on the parent object.  Note that you can only clear inherited properties.  Nor is this the same as removing a property; the property continues to exist.
2

2
`@clearproperty' can be abbreviated as `@clearp'.
2

2
Example:
2

2
  @create #1 named foo
2
  You now have foo with object number #42 and parent Root Class (#1).
2
    [foo, as a child of #1 has a .description property which starts out clear]
2
  ;#1.description
2
  => ""
2
  ;#1.description = "You see nothing special"
2
  => "You see nothing special"
2
  ;#42.description  
2
  => "You see nothing special"
2
  ;#42.description = "Something special"
2
  => "Something special"
2
   [foo.description is now no longer clear; it has a value of its own]
2
  ;#1.description = "Boring"
2
  => "Boring"
2
  ;#42.description  
2
  => "Something special"
2
   
2
  @clearp foo.description
2
  Property #42.description cleared; value is now "Boring".
2
   [foo.description is now clear again]
2
  ;#1.description = ""
2
  => ""
2
  ;#42.description
2
  => ""
36
5
4
2
2
*forward*
2
@disinherit
36
5
4
11
2
Syntax:   @disinherit <object> 
2
          @disinherit <object> [from <parent>]
2

2
Synonym:  @disown
2

2
This command is used to remove an unwanted child from an object you own.  If you owned said child, you could use @chparent; this command is to cover the other case, namely where you don't own the child.  
2

2
Both forms of this command chparent <object> to its grandparent, provided you own the parent.  The second form matches the string you supply for <object> against the list of children of the given <parent>.
2

2
Turning off the fertile bit (.f) for a particular object prevents others from creating children of it or chparenting to it (see `help @chmod').
2
Note also that, though the name might seem to indicate otherwise, this command does not change the ownership of any object.
36
5
4
2
2
*forward*
2
@display-options
36
5
4
24
2
Syntax:  @display-option
2
         @display-option <option>
2

2
Synonym:  @displayoption
2

2
The display options customize the behavior of the @display command to your particular taste.  The first form of this command displays all of your display options.  The second form displays just that one option, one of the flags listed below.
2

2
The remaining forms of this command are for setting your display options:
2

2
         @display-option +<flag>
2
         @display-option -<flag>
2
         @display-option !<flag>           (equivalent to -<flag>)
2

2
These respectively set and reset the specified flag
2

2
-blank_tnt     Show the verb args on all verbs.
2
+blank_tnt     Don't show the verb args on `this none this' verbs.
2
-shortprep     Use full prepositions  (e.g., "on top of/on/onto/upon")
2
+shortprep     Use short prepositions (e.g., "on")
2
-thisonly      Specifying . (:) to retrieve all properties (verbs) will go
2
               up the ancestor chain until it finds a readable object with
2
               properties (verbs) defined on it.
2
+thisonly      Specifying . (:) to retrieve all properties (verbs) will only
2
               display properties (verbs) defined on the object itself.
36
5
4
24
2
*pass*
2
@add-feature
2

2
Note to programmers: @add-feature and @remove-feature are front-ends for player:add_feature and :remove_feature.
2

2
:add_feature returns
2

2
 * E_PERM unless caller == this || $perm_utils:controls(caller_perms())
2

2
 * E_INVARG if feature is not an object or is invalid
2

2
 * E_PERM if the object is not feature_ok
2

2
 * a true value otherwise
2

2
and calls feature:feature_add, if the verb exists.
2

2
:remove_feature returns
2

2
 * E_PERM unless caller == this || $perm_utils:controls(caller_perms()) || caller_perms() == feature.owner
2

2
 * a true value otherwise
2

2
and calls feature:feature_remove, if the verb exists.
36
5
4
2
2
*forward*
2
@add-feature
36
5
4
6
2
*pass*
2
features
2

2
Note to programmers: In order to be available for general use as a feature, an object must have a verb or property named "feature_ok" which returns a true value.
2

2
When a feature is added to a player's features list, feature:feature_add is called, if it exists, with the player in question as its argument.  Likewise, when a feature is removed, feature:feature_remove is called.
36
5
4
4
2
*pass*
2
examine
2

2
[Note to programmers: the 'obvious' verbs are those that can be invoked as commands and are not specified by the :hidden_verbs verb.  The default definition of "hidden" is "not readable".  You can override this definition with a :hidden_verbs verb that gets the default list with pass(@args) and then alters that list.]
36
5
4
5
2
*pass*
2
mail
2
 - - - - -
2
See `help mail-system' for a description of the programming interface to the mail system.
2
In particular, see `help $mail_recipient' for information on creating new mail collections.
36
5
4
7
2
#<string>[.<property>|.parent] [exit|player|inventory] [for <code>] returns information about the object (we'll call it <thing>) named by string.  String is matched in the current room unless one of exit|player|inventory is given.
2
If neither .<property>|.parent nor <code> is specified, just return <thing>.
2
If .<property> is named, return <thing>.<property>.  .parent returns parent(<thing>).
2
If <code> is given, it is evaluated, with the value returned by the first part being substituted for %# in <code>.
2
For example, the command
2
  #JoeFeedback.parent player for toint(%#)
2
will return 26026 (unless Joe has chparented since writing this).
36
5
4
2
2
*forward*
2
@prog-options
36
5
4
2
2
*forward*
2
@prog-options
36
5
4
2
2
*forward*
2
@prog-options
36
5
4
38
2
Syntax:  @prog-option
2
         @prog-option <option>
2

2
Synonyms:  @progoption, @programmer-option @programmeroption
2

2
The first form displays all of your programmer options
2
The second displays just that one option, which may be one of the flags listed below.  The programmer options control various annoying details of your programming commands (e.g., @list, eval, @copy, ...)
2

2
The remaining forms of this command are for setting your programmer options:
2

2
         @prog-option +<flag>
2
         @prog-option -<flag>
2
         @prog-option !<flag>           (equivalent to -<flag>)
2

2
These respectively set and reset the specified flag
2

2
 -list_all_parens    @list shows only necessary parentheses by default
2
 +list_all_parens    @list shows all parentheses by default
2
 -list_no_numbers    @list gives line numbers by default
2
 +list_no_numbers    @list does not give line numbers by default
2
 -eval_time          eval does not show ticks/seconds consumed.
2
 +eval_time          eval shows ticks/seconds consumed.
2
 -copy_expert        @copy prints warning message.
2
 +copy_expert        @copy prints no warning message.
2
 -list_show_permissions  @list does not display permissions in header
2
 +list_show_permissions  @list displays permissions in header
2

2
All flags default to the `-' settings.  
2
Finally, we have
2

2
         @prog-option verb_args [is] <dobj> <prep> <iobj>
2
         @prog-option verb_args="<dobj> <prep> <iobj>"
2
         @prog-option -verb_args
2
                      (equivalent to verb_args="none none none")
2
         @prog-option +verb_args
2
                      (equivalent to verb_args="this none this")
2

2
which all serve to specify the (direct/indirect)-object and preposition to use in a @verb command for which these are not given at all.
36
5
4
5
2
*pass*
2
options
2

2
  @prog-options    --- programming commands (@list, @verb, ...)
2
  @display-options --- @display (*)
36
5
4
2
2
*forward*
2
utilities
36
5
4
2
2
*forward*
2
@kill
36
5
4
54
2
It is often the case in MOO programming that you will want to access the elements of a list individually, with each element stored in a separate variables.  This desire arises, for example, at the beginning of almost every MOO verb, since the arguments to all verbs are delivered all bunched together in a single list.  In such circumstances, you could write statements like these:
2

2
first = args[1];
2
second = args[2];
2
if (length(args) > 2)
2
  third = args[3];
2
else
2
  third = 0;
2
endif
2

2
This approach gets pretty tedious, both to read and to write, and it's prone to errors if you mistype one of the indices. Also, you often want to check whether or not any extra list elements were present, adding to the tedium.
2

2
MOO provides a special kind of assignment expression, called `scattering assignment' made just for cases such as these. A scattering assignment expression looks like this:
2

2
{<target>, ...} = <expr>
2

2
where each <target> describes a place to store elements of the list that results from evaluating <expr>. A <target> has one of the following forms:
2

2
`variable'
2
   This is the simplest target, just a simple variable; the list element in the corresponding position is assigned to the variable.  This is called a `required' target, since the assignment is required to put one of the list elements into the variable.
2

2
`?variable'
2
   This is called an `optional' target, since it doesn't always get assigned an element. If there are any list elements left over after all of the required targets have been accounted for (along with all of the other optionals to the left of this one), then this variable is treated like a required one and the list element in the corresponding position is assigned to the variable. If there aren't enough elements to assign one to this target, then no assignment is made to this variable, leaving it with whatever its previous value was.
2

2
`?variable' = `default-expr'
2
   This is also an optional target, but if there aren't enough list elements available to assign one to this target, the result of evaluating `default-expr' is assigned to it instead. Thus, `default-expr' provides a default value for the variable. The default value expressions are evaluated and assigned working from left to right -after- all of the other assignments have been performed.
2

2
`@variable'
2
   By analogy with the @ syntax in list construction, this variable is assigned a list of all of the `leftover' list elements in this part of the list after all of the other targets have been filled in. It is assigned the empty list if there aren't any elements left over. This is called a `rest' target, since it gets the rest of the elements. There may be at most one rest target in each scattering assignment expression.
2

2
If there aren't enough list elements to fill all of the required targets, or if there are more than enough to fill all of the required and optional targets but there isn't a rest target to take the leftover ones, then E_ARGS is raised.
2

2
Here are some examples of how this works.  Assume first that the verb me:foo() contains the following code:
2

2
b = c = e = 17;
2
{a, ?b, ?c = 8, @d, ?e = 9, f} = args;
2
return {a, b, c, d, e, f};
2

2
Then the following calls return the given values:
2

2
me:foo(1)                        error-->   E_ARGS
2
me:foo(1, 2)                     =>   {1, 17, 8, {}, 9, 2}
2
me:foo(1, 2, 3)                  =>   {1, 2, 8, {}, 9, 3}
2
me:foo(1, 2, 3, 4)               =>   {1, 2, 3, {}, 9, 4}
2
me:foo(1, 2, 3, 4, 5)            =>   {1, 2, 3, {}, 4, 5}
2
me:foo(1, 2, 3, 4, 5, 6)         =>   {1, 2, 3, {4}, 5, 6}
2
me:foo(1, 2, 3, 4, 5, 6, 7)      =>   {1, 2, 3, {4, 5}, 6, 7}
2
me:foo(1, 2, 3, 4, 5, 6, 7, 8)   =>   {1, 2, 3, {4, 5, 6}, 7, 8}
2

2
Using scattering assignment, the example at the begining of this section could be rewritten more simply, reliably, and readably:
2

2
{first, second, ?third = 0} = args;
2

2
It is good MOO programming style to use a scattering assignment at the top of nearly every verb, since it shows so clearly just what kinds of arguments the verb expects.
36
5
4
5
2
Syntax:  .flush
2

2
Clear out all recent lines of input that haven't been processed yet by the server. Useful when you change your mind about lines you have typed that haven't run yet.
2

2
This command name can be changed by the `set_connection_option()' built-in function, or if $server_options.default_flush_command exists and is non-empty, that value is used. If it exists and -is- empty, then no flush command exists at all.
36
5
4
2
2
*forward*
2
@rmverb
36
5
4
2
2
*forward*
2
@list
36
5
4
2
2
*forward*
2
@program
36
5
4
2
2
*forward*
2
@args
36
5
4
2
2
*forward*
2
@chmod
36
5
4
2
2
*pass*
2
@rename
36
5
4
2
2
*pass*
2
@addalias
36
5
4
2
2
*pass*
2
@addalias
36
5
4
2
2
*pass*
2
@rmalias
36
5
4
2
2
*pass*
2
@rmalias
36
5
4
7
2
The MOO checkpoint is created by a UNIX system fork() call, which creates a separate process but with the same memory image as the running the MOO.  That process then writes that information into a database.
2

2
The act of calling this separate-but-equal process is intrinsically laggy because the MOO server memory is already saturated by the running version of the MOO.  Adding an equal size process to the mix results in heavy swapping between memory and harddrive.  It would therefore be considered wise not to run any processor or memory intensive MOOcode during checkpoint.
2

2
If you wish to alter any of your code to avoid executing during a checkpoint, you can check the value of $login.checkpoint_in_progress, which returns 1 during checkpoint and 0 otherwise.  This value is itself toggled by the verbs $sysobj:checkpoint_started and $sysobj:checkpoint_finished.
2

2
Also see help on:   dump_database()   @dump-database   checkpoint
36
1
4
2
2
*forward*
2
@grep
36
5
4
2
2
*forward*
2
@grep
36
5
4
3
2
*verbdoc*
2
$prog
2
@properties
2
1
4
2
2
*forward*
2
@properties
2
1
5
36
5
4
1
2
prog-index
36
1
5
36
4
4
1
2
Programmer Help
36
5
2
This provides help on the programmer commands available on $prog and related topics.
36
5
4
2
0
103085
0
1641541193
36
1
#23
Wizard Help
16
36
1
-1
0
0
4
0
1
30
4
0
0
52
@guests
@log
@egrep
@unnewt
@denewt
@newt
@grep
$site_db
graylist
blacklist
@recycle
wiz-index
@dump-database
@players
@net-who
@@who
@quota
@detoad
@untoad
@toad
@grepcore
@who-calls
@abort-shutdown
@shutdown
@programmer
@shout
@chown
redlist
@blacklist
@graylist
@redlist
@make-guest
@spooflist
spooflist
@make-player
@register
@new-password
@deprogrammer
forked-tasks
mail-lists
@grant
adding-help-text
further-reading
@temp-newt
site-info
recycling-players
advertised
news-items
routine_tasks
@chown#
@grepall
@egrepall
58
4
6
2

2
@guests now  [shows information about currently connected guests]
2
@guests all  [shows all entries in $guest_log]
2
@guests <n>  [shows the last <n> entries of $guest_log]
2

2
Note, some wizards prefer to use verbs on $guest_log manually, particularly :last().
36
5
4
11
2
Syntax:  @log <message>
2
         @log
2

2
The first form enters <message> as a one-line comment in the server log.
2
The second form prompts for a sequence of lines to be collectively entered as an extended comment.  This uses $command_utils:read_lines so all of those conventions apply, i.e., a period on a line by itself ends the text, `@abort' aborts the command, etc...).  Example:  If Wizard (#2) types
2

2
    @log I did $dump_interval=3600
2

2
the following line appears in the server log
2

2
    Aug 19 22:36:52:  COMMENT:  from Wizard (#2):  I did $dump_interval=3600
36
5
4
2
2
*forward*
2
@grep
36
5
4
2
2
*forward*
2
@denewt
36
5
4
10
2
Syntax:    @denewt <player> [commentary]
2

2
Synonyms:  @unnewt
2
           @get-better
2

2
@denewt reverses the effects of @newt, removing the player from $login.newted, and if appropriate, $login.temporary_newts.
2

2
Mail is sent to $newt_log including any commentary you provide.  E.g.,
2

2
  @denewt Twit  He promises not to do it again.
36
5
4
28
2
*subst*
2
Syntax:  @newt <player> [commentary]
2
         @temp-newt <player> for <period>
2

2
The @newt command temporarily prevents logins on a given player.
2
It works by adding the player to $login.newted, and for @temp-newt, also adding the player and an end time to $login.temporary_newts.  $login will deny connection to any player in $login.newted, unless they are temporarily newted and their time has expired, in which case it will clean up---denewt them---and allow the connection attempt.  Use @denewt to reverse this.
2

2
You must give either the player's full name or its object number.
2
Also, this command does not let you @newt yourself.
2

2
Mail will be sent to $newt_log, listing the player's .all_connect_places and including any commentary you provide.  E.g.,
2

2
  @newt Twit  did real annoying things.
2

2
As with @toad and @programmer, there are messages that one may set
2

2
@newt  [%[$wiz.newt_msg]]
2
  Printed to everyone in the room in which the victim is being @newted.
2
  If you're worried about accidentally newting yourself in the process of
2
  setting this message, you can't (see above).
2

2
@newt_victim  [%[$wiz.newt_victim_msg]]
2
  Printed to the victim.  
2
  This is followed by $login:newt_registration_string().
2

2
See `help @toad' if you need something more drastic.
2

2
The @temp-newt variant of @newt permits you to specify a time period during which this player may not use the MOO.  Time units must be acceptable to $time_utils:parse_english_time_interval.
36
5
4
12
2
*pass*
2
@grep
2

2
For wizards, the following forms are also available for doing full-db searches
2

2
         @grep  <pattern>
2
         @grep  <pattern> from [#]<n>
2

2
and likewise for @egrep, @grepall, and @egrepall.
2
The first searches all objects in the database while the second searches the range [#<n>..max_object()]
2

2
See also:  @grepcore, @who-calls.
36
5
4
21
2
Database of places
2
------------------
2
i.e., places people have connected from.
2

2
  :add(sitename,player)
2
      records the fact that player connected from sitename.
2
  :load()
2
      clears the db and reloads all of the player connection info.
2

2
  .domain
2
      default domain for unqualified sitenames given to :add.
2
      
2
For each domain we keep a list of players and subdomains. 
2
For example, :add("doc.ic.ac.uk",#666) enters #666 on the lists for "doc.ic.ac.uk", and, if we have to create an entry for "doc.ic.ac.uk", we enter "doc" on the list for "ic.ac.uk", "ic" on the list for "ac.uk", etc....  In this case, :find("ic") will return the "ic.ac.uk" list if there is no other domain in $site_db starting with "ic".  Note that the "ic.ac.uk" list may contain both objects, i.e., namely players that have connected from the site "ic.ac.uk", and strings, i.e., subdomains of "ic.ac.uk" like "doc".
2

2
  :find_exact(string)    => player/subdomain list or $failed_match
2
  :find_all_keys(string) => list of all domains that begin with string
2
  :find_key     (string) => unique domain that begins with string, 
2
                            $ambiguous_match or $failed_match
2

2
The other $generic_db functions (:find, :find_all) are also available, though admittedly less useful.
36
5
4
2
2
*forward*
2
blacklist
36
5
4
35
2

2
The Site Blacklist
2
------------------
2
$login maintains three lists of hosts/domains to support player registration schemes and blocking of connections from highly untrusted hosts:
2

2
  .redlist   -- all connections from these sites are disabled 
2
  .blacklist -- player creation and guest logins are disabled
2
  .graylist  -- advisory list of potential trouble spots (putting a site on the
2
                .graylist merely annotates it in @net-who listings).
2
  .spooflist -- guests from these sites cannot use @request to request 
2
                a character
2

2
The lists are kept in a special format so it is highly recommended that you 
2
either use $wiz:@*list/@un*list or the following verbs to query/update the 
2
respective lists rather than bash them directly:
2

2
  $login:*listed     (host)              is host is on .*list?
2
  $login:*list_add   (domain or subnet)  add domain or subnet to .*list
2
  $login:*list_remove(domain or subnet)  remove domain or subnet from .*list
2

2
where `*' is one of `black', `red', `gray', or `spoof'.
2

2
There are also temporary versions of the above four lists, stored in associated $login.temporary_*list in the same format, except two additional bits of data are stored.  The time the temporary *listing started, and the duration that it will last.  In addition there exists:
2

2
  $login:*list_add_temp(domain or subnet, start time, duration)
2
  $login:*list_remove_temp(domain or subnet)
2

2
When the normal $login:*listed verb is called, both the regular *list and the temporary *list are checked.  If the host is on the temporary list, then the length of MOO up time since the start time is checked against the duration.  If expired, the host is removed from the temporary *list and a false value is returned (meaning that the host is not *listed).
2

2
One may either specify a domain name (e.g., "baz.edu") or a numeric IP address (e.g., "36.0.23.17").  Domain names match all hosts underneath that domain, so, e.g., puting "baz.edu" on a list effectively adds "x.bax.edu" for all x as well.  
2
Likewise, an incomplete numeric address, e.g., "128.42" will match that entire subnet, in this case all hosts whose IP numbers have the form "128.42.m.n" for arbitrary integers m and n.
2

2
One may also give a domain name containing a wildcard ("*"), e.g., "fritz*.baz.edu", in which case all hostnames matching in the sense of $string_utils:match_string() are considred to be on the list.  Wildcard matching should be avoided since it is more time-consuming.
2

2
It should be noted that, since there is no direct access to the domain name service from within the MOO, it is possible for a host to be blacklisted or redlisted via its domain name, and yet have someone be able to connect from that host (and, in the case of a blacklisted host, create a character) --- this can happen if the name service is down and connection_name() on that player thus has given the numeric IP address rather than the domain name.  Similarly, if you list a host by IP number alone, it will still be possible to get in via the site's domain name.  Thus to be completely assured of shutting out a site, you need to list it both by domain name and IP number.
36
5
4
6
2
*pass*
2
@recycle
2

2
Of course, wizards are allowed to @recycle anything at all.
2

2
There is, however, a block (in $player:recycle) against recycling actual players, i.e., descendants of $player that have the player flag set.  This is mainly to prevent stupid mistakes.  If, for some reason, you want to recycle a player, you need to @toad it first.
36
5
4
2
2
*index*
2
Wizard Help Topics
36
5
4
3
2
Syntax:  @dump-database
2

2
Invokes the builtin dump_database(), which requests that the server checkpoint the database at its next opportunity.  It is not normally necessary to call this function; the server automatically checkpoints the database at regular intervals; see the chapter on server assumptions about the database for details.
36
5
4
3
2
Syntax:  @players [with objects]
2

2
Hmmm... what *does* this do, anyway?
36
5
4
9
2
Syntax:  @net-who [<player>...]
2
         @net-who from [<domain>]
2

2
Synonym: @@who
2

2
@net-who without any arguments prints all connected users and hosts.  If one or more <player> arguments are given, the specified users are printed along with their current or most recent connected hosts.  If any of these hosts are mentioned on $login.blacklist or $login.graylist (see `help blacklist'), 
2
an annotation appears.
2

2
With a `from...' argument, this command consults $site_db and prints all players who have ever connected from the given domain.
36
5
4
2
2
*forward*
2
@net-who
36
5
4
7
2
*pass*
2
@quota
2

2
 - - - - - - - - - - - - - - - - - - - - - - - - - -
2
Syntax:  @quota <player> is [public] [+]<number> [<reason>]
2

2
This second and more interesting form of the verb is used to set a player's quota.  Mail will be sent to $quota_log, and also $local.public_quota_log if there is one and if the "public" argument is given; if a reason is supplied, it will be included in the message.  If the number is prefixed with a +, it's taken as an amount to add to the player's current quota; if not, it's an absolute amount.
36
5
4
2
2
*forward*
2
@untoad
36
5
4
13
2
Syntax:  @untoad <object> [as <name>,<alias>,<alias>...]
2

2
Synonym: @detoad
2

2
Turns the object into a player.  
2
If the name/alias... specification is given, the object is also renamed.
2
In order for this to work, the object must be a nonplayer descendant of $player and the new object name (or the original name if none is given in the command line) must be available for use as a player name.  As with ordinary player @renaming, any aliases which are unavailable for use as player names are eliminated.
2

2
If the object is a descendant of $guest, then it becomes a new guest character.
2
Otherwise the object is chowned to itself.  In the latter case, it is advisable to check that the .password property has something nontrivial in it.
2

2
If the object is a descendant of $prog, then its .programmer flag is set.
2
Note that the .wizard flag is not set under any circumstances.
36
5
4
26
2
*subst*
2
Syntax:  @toad   <player>  [graylist|blacklist|redlist]
2
         @toad!  <player>
2
         @toad!! <player>
2

2
Resets the player flag of <player> (thus causing <player> to be booted), resets the .programmer and .wizard flags, chowns the player object to $hacker, and removes all of its names and aliases from $player_db.
2

2
You must give either the player's full name or its object number.
2
Also, this command does not let you @toad yourself.
2

2
In some cases you may wish to add the player's last connected site to the site graylist, blacklist or redlist --- see `help blacklist' --- in order to invoke various kinds of blocking on that site (e.g., if player creation is enabled, you may want to enter the player on the blacklist to keep him from immediately creating a new character).  Specifying one of the listnames `graylist', `blacklist' or `redlist' will do this.
2

2
@toad!  <player>  is synonymous with  @toad <player> blacklist
2
@toad!! <player>  is synonymous with  @toad <player> redlist
2

2
There are messages that one may set to customize toading.  After all, a toading is (supposed to be) a rare event and you will doubtless want to put on a good show.  Thus we have
2

2
@toad  [%[$wiz.toad_msg]]
2
  Printed to everyone in the room in which the victim is being @toaded.
2
  If you're worried about accidentally toading yourself in the process of
2
  setting this message, see above.
2

2
@toad_victim  [%[$wiz.toad_victim_msg]]
2
  Printed to the victim.
2

2
These are pronoun_subbed with victim == dobj.
36
5
4
6
2
Syntax:  @grepcore <pattern>
2
         @who-calls <verbname>
2

2
@grepcore pattern is @grep pattern in {all core objects}.  Core objects are computed for you by #0:core_objects().
2

2
@who-calls greps for the verbname + "(", hoping to catch it as a verb call.  Currently @who-calls does not allow you to restrict the search as @grep does.  (Volunteers?)
36
5
4
2
2
*forward*
2
@grepcore
36
5
4
3
2
Syntax:  @abort-sh*utdown [<text>]
2

2
This aborts any shutdown currently in progress (i.e., set in motion by @shutdown).  All players are notified that no shutdown will actually occur; <text>, if given will be included in this notification.
36
5
4
5
2
Syntax:  @shutdown [in <m>] [<text>]
2

2
This is the friendly way to do a server shutdown; it arranges for the actual shutdown to take place `m' minutes hence (default two).  Shutdown is preceded by a sequence of warnings to all connected players.  Warnings are likewise given to all players who connect during this time.  <text>, if given is included in these warning messages, perhaps as an explanation for why the server is being shut down.
2

2
Shutdown may be aborted at any time by using @abort-shutdown.
36
5
4
16
2
*subst*
2
Syntax:  @programmer <player>
2

2
Sets the programmer flag on the indicated player and sends mail to $new_prog_log.  
2

2
If the player is not already a descendant of $prog, we @chparent him/her to $prog.  In this case, if $prog has a larger .ownership_quota than its ancestors, then we raise the player's quota by the difference between $prog.ownership_quota and the .ownership_quota of the common ancestor of player and $prog, be this $player or some intermediate class.
2

2
There are messages that one may set to customize how the granting of a programmer bit looks to the victim and to any onlookers.  After all, this is a seminal event in a MOOer's life...  Thus we have
2

2
@programmer  [%[$wiz.programmer_msg]]
2
  Printed to everyone in the room with the victim being @programmer'ed.
2

2
@programmer_victim  [%[$wiz.programmer_victim_msg]]
2
  Printed to the victim.
2

2
These are pronoun subbed with victim == dobj.
36
5
4
3
2
Syntax:  @shout <text>
2

2
Broadcasts the given text to all connected players.
36
5
4
14
2
Syntax:  @chown <object>            [to] <owner>
2
         @chown <object>.<propname> [to] <owner>
2
         @chown <object>:<verbname> [to] <owner>
2
         @chown# <object>:<verbnumber> [to] <owner>
2

2
Changes the ownership of the indicated object, property or verb.
2

2
Verb ownership changes are fairly straightforward, being merely a matter of changing the verb_info() on a single verb. Referring to a verb isn't as straightforward since two verbs on the same object can have the same name. So, @chown# is provided where you can refer to a verb by it's 1-based index in the output of the verbs() builtin.
2

2
Changing an object ownership includes changing the ownership on all +c properties on that object.  Note that @chown will not change the ownership of any other properties, nor will it change verb ownerships.  Use @grant if you need to do a more complete ownership change.  The quota of the former owner is increased by one, as is the quota of the new owner decreased by one.
2

2
Changing a property ownership is truly hairy.  If the property is +c one shouldnot be doing this, unless it is to correct a past injustice which caused the property to be owned by the wrong player.  In the case of -c properties, the property ownership is changed on all descendent objects (currently, if +c instances of a -c property are found in the traversal of all of the descendants, these are not changed, being deemed sufficiently weird that they should be handled on a case-by-case basis...).
2

2
If there's any justice, a future version of the server will prevent occurrences of (1) +c properties being owned by someone other than the object owner (2) -c properties with different owners on descendant objects (3) -c properties that are +c on some descendants.
36
5
4
2
2
*forward*
2
blacklist
36
5
4
18
2
Syntax:  @redlist   [<domain or subnet> [for <duration>] [commentary]]
2
         @blacklist [<domain or subnet> [for <duration>] [commentary]]
2
         @graylist  [<domain or subnet> [for <duration>] [commentary]]
2
         @spooflist [<domain or subnet> [for <duration>] [commentary]]
2

2
Syntax:  @unredlist   [<domain or subnet> [commentary]]
2
         @unblacklist [<domain or subnet> [commentary]]
2
         @ungraylist  [<domain or subnet> [commentary]]
2
         @unspooflist [<domain or subnet> [commentary]]
2

2
With no argument, the current contents of the corresponding list are printed.
2
Otherwise, the specified domain or subnet is added to or removed from the list and mail will be sent to $site_log.
2

2
To add a domain or subnet to a *list only temporarily, include a `for <duration>' statement before any commentary.  The <duration> should be in english form such as 1 day or 1 month 2 weeks or 1 year 3 months 2 weeks 4 days.  No commas should separate increments in the duration.  See `help $time_utils:parse_english_time_interval' for more details.  If you are not temporarily *listing a domain or subnet, but are including a commentary, be sure that the commentary does not start with the word `for'.
2

2
If the given domain or subnet has subdomains/subsubnets that are already on the list, you will be prompted as to whether you want to remove them.  Note that adding an entry for a particular domain or subnet effectively adds all subdomains/subsubnets, so unless there's some reason for keeping an explicit entry for a particular subdomain, chances are you will indeed want to remove them.  One reason to keep an explicit entry for a subdomain would be if you intended to unlist the full domain later but wanted to be sure you didn't unlist the subdomain in the process.
2

2
See `help blacklist' for a description of the functions of these lists.
36
5
4
2
2
*forward*
2
@blacklist
36
5
4
2
2
*forward*
2
@blacklist
36
5
4
9
2
Syntax:  @make-guest <adjective>
2

2
This creates a new guest character.  For example,
2
  @make-guest Loud
2
creates a child of $guest, owned by $hacker, named Loud_Guest and with aliases Loud and Loud_Guest.
2

2
Note that in order to have `connect guest' connect to a guest character, there needs to exist some guest character having "Guest" as a name or alias.
2

2
See also `help @make-player'.
36
5
4
2
2
*forward*
2
@blacklist
36
5
4
2
2
*forward*
2
blacklist
36
5
4
11
2
@make-player name [email-address [commentary]]
2
Creates a player.
2
Generates a random password for the player.
2
Email-address is stored in $registration_db and on the player object.
2
Comments should be enclosed in quotes.
2

2
Example: @make-player George sanford@frobozz.com "George shares email with Fred Sanford (Fred #5461)"
2

2
If the email address is already in use, prompts for confirmation.  If the name is already in use, prompts for confirmation.  (Say no, this is a bug: it will break if you say yes.)  If you say no at one of the confirming prompts, character is not made.
2

2
If network is enabled (via $network.active) then asks if you want to mail the password to the user after character is made.
36
5
4
5
2
Information about $wizard:@register
2
----
2
Registers a player.
2
Syntax:  @register name email-address [additional commentary]
2
Email-address is stored in $registration_db and on the player object.
36
5
4
4
2
@new-password player is [password]
2
Sets a player's password; omit password string to have one randomly generated.  Prints the encrypted old string when done for error recovery.  [No current software will allow you to give the encrypted string as input.]
2

2
Offers to send mail to the user with the new password, if the user has a registered email address and the network is enabled.
36
5
4
5
2
Information about $wiz:@deprog*rammer
2
----
2
@deprogrammer victim [for <duration>] [reason]
2

2
Removes the prog-bit from victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. He will be automatically removed the first time he asks for a progbit after the duration expires.  Either with or without the duration you can specify a reason, or you will be prompted for one. However, if you don't have a duration, don't start the reason with the word `For'.
36
5
4
3
2
If you are a wizard, '@forked' with no arguments will spam you with all the forked tasks that there are (this is useful sometimes, but it's nice to know ahead of time).
2

2
To see just your own, type '@forked me'.  To see just one player's, type '@forked <player>'.
36
5
4
9
2
You probably want to subscribe to (or at least be familiar with) the following mailing lists:
2

2
*Player-Creation-Log
2
*New-Prog-Log
2
*Quota-Log
2
*News
2
*Site-Locks
2
*Password-Change-Log
2

36
5
4
9
2
Information about generic wizard(#218):@grant/@grants*/@transfer
2
----
2
@grant <object> to <player>
2
@grants <object> to <player>   --- same as @grant but may suspend.
2
@transfer <expression> to <player> -- like 'grant', but evalutes a possible list of objects to transfer.
2

2
Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).
2

2
This verb does the transfer whether the recipient has enough quota for it or not.
36
5
4
5
2
For information about how the help system itself works and about how to associate local help databases with specific rooms or player classes, see `help $help'.
2

2
To get a list of the object numbers associated with various $help databases, type 'help index'.
2

2
If you need to modify existing help text, and need to find which help database the relevant property is defined on, use 'help full-index'.  (Note, it's spammy, but tells you what you need to know.)
36
5
4
7
2
Other topics of interest to wizards:
2

2
$login
2
$guest_log
2
$no_one
2
$recycler
2
$help
36
5
4
5
2
Information about $wiz:@temp-newt
2
----
2
@temp-newt victim [for duration] [reason]
2

2
Temporarily newts victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. E will be automatically removed the first time e tries to connect after the duration expires.  You will be prompted for a reason for the newting, but as of this writing, specifying a reason from the command line isn't an option.
36
5
4
1
2
To look at where a player is currently connecting from, use @netwho.  To see previous connect sites, look at <player>.all_connect_places.
36
5
4
7
2
General procedure:
2

2
  Make sure e doesn't own anything.
2
  @toad em
2
  @recycle em
2

2
It makes a real mess if you don't clean up .owned_objects.  See $wiz_utils:initialize_owned, but note, running this verb takes maybe three hours (at last report) and adds to lag.  This is why we frown so severely on leaving blood on the carpet.
36
5
4
9
2
Some wizards choose not to be among those listed when a player types '@wizards' (or similar).
2

2
The property $wiz.advertised defaults to 1; set it to 0 to remove yourself from the list.
2

2
To keep your non-wizard character off the list, set your wizard character's .public_identity character to 0.  To get it back on, set .public_identity to the object number of your non-wizard character.
2

2
$wiz_utils:is_wizard returns true for the wizard and the corresponding .public_identity player.  Both will likewise appear in $wiz_utils:connected_wizards_unadvertised() and $wiz_utils:all_wizards_unadvertised().
2

2
:is_wizard is for checking permissions on wizard feature-objects and the like, while :all/connected_wizards_unadvertised wouble be for things like wizard-shouts (e.g., the one issued by $player:recycle).
36
5
4
12
2
*subst*
2
To add a news item:
2

2
Send regular mail to *news with the message you want in the news.  Then:
2

2
  @addnews <message-number> to %[tostr($news)]
2

2
To remove a news item:
2

2
  @rmnews <message-number> from %[tostr($news)]
2

2
Note, the message date doesn't show up, so you might consider adding a date to the message body itself.
36
5
4
29
2
There are a number of routine daily or weekly tasks that can help keep your MOO clean or otherwise well-maintained.
2

2

2
$byte_quota_utils:schedule_measurement_task
2
        If you are using byte quota, this will schedule your quota measurement task.  Every night, every item on the moo which has not been measured in the last $byte_quota_utils.cycle_days will be measured.  A report will be mailed to $byte_quota_utils.report_recipients.  You may wish to edit this verb to change the time that it runs---it will run at midnight PST.
2

2
$wiz_utils:expire_mail_weekly
2
        If you wish to expire old mail from users and mailing lists, run this verb.  Once a week (scheduled from the first time you type ;$wiz_utils:expire_mail_weekly(), not at a particular hour) it will go through and expire mail based on players' @mail-options settings.
2

2
$wiz_utils:flush_editors
2
        Once a week this will remove all sessions which were begun more than 30 days ago in the note, verb, and mail editors.  Schedule is from when first typed.
2

2
$paranoid_db:semiweeklyish
2
        This will go through the @paranoid database and remove entries for players who have not connected within the past three days, and for those users who have turned off the @paranoid function.  Schedule is at 11pm PST.
2

2
$login:sample_lag
2
        This will provide an estimate of the CPU portion of what is normally called "lag"---that is, the delay between entering a command and having that command fulfilled.
2

2
$housekeeper:continuous
2
        If you wish to provide players with the ability to have individual items transported to a known starting location, use this verb.
2

2

2
Additionally, there are tasks that you don't have to start manually, but which get started by various actions in the MOO.
2

2
$network:add_queued_mail
2
        This indicates that there was a temporary failure to deliver email.  If this task is constantly in the queue, it is worth checking $network.queued_mail, deleting those which will never be delivered.  Queued mail does not expire.
2

2
$housekeeper:move_players_home
2
        This task is used to consolidate the tasks spawned by disconnecting players---they get a 5 minute grace period to log back in before they are moved back home.
36
5
4
2
2
*forward*
2
@chown
36
5
4
2
2
*forward*
2
@grep
36
5
4
2
2
*forward*
2
@grep
36
5
5
36
5
4
1
2
wiz-index
36
1
5
36
4
4
1
2
Wizard Help
36
5
4
1
2
This describes the various commands available on $wiz.
36
5
4
2
0
36730
0
1641541193
36
1
#24
Wizard Utilities
16
2
1
-1
0
0
4
0
1
78
4
0
42
set_programmer
2
173
-1
set_player
2
173
-1
set_owner
2
173
-1
set_property_owner
2
173
-1
unset_player
2
173
-1
set_property_flags
2
173
-1
_set_property_flags
2
173
-1
random_password
2
173
-1
queued_tasks
2
173
-1
isnewt
2
173
-1
initialize_owned
2
173
-1
verify_owned_objects
2
173
-1
connected_wizards connected_wizards_unadvertised
36
173
-1
all_wizards_advertised all_wizards all_wizards_unadvertised
36
173
-1
rename_all_instances
2
173
-1
missed_help
2
173
-1
show_missing_help
2
173
-1
init_for_core
2
173
-1
show_netwho_listing
2
173
-1
show_netwho_from_listing
2
173
-1
check_player_request check_reregistration
2
173
-1
make_player
2
173
-1
send_new_player_mail
2
173
-1
do_make_player
2
93
-2
do_register
2
173
-1
do_new_password
2
173
-1
set_owner_new
2
173
-1
boot_idlers
2
173
-1
grant_object
2
173
-1
connection_hash
2
173
-1
newt_player
2
173
-1
unset_programmer
2
173
-1
is_wizard
36
173
-1
expire_mail
2
13
-1
expire_mail_weekly
2
173
-1
check_prog_restricted
2
173
-1
expire_mail_players
2
173
-1
expire_mail_lists
2
173
-1
flush_editors
2
173
-1
random_wizard
2
173
-1
set_email_address
2
173
-1
get_email_address
2
173
-1
24
default_programmer_quota
default_player_quota
missed_help_strings
missed_help_counters
record_missed_help
programmer_restricted
boot_task
boot_exceptions
programmer_restricted_temp
suicide_string
next_perm_index
wizards
old_task_perms_user
expiration_progress
system_chars
new_core_message
chparent_restricted
rename_restricted
change_password_restricted
expiration_recipient
registration_domain_restricted
shutdown_task
shutdown_message
gripe_recipients
29
0
7
2
5
0
7
2
5
4
0
2
1
4
0
2
1
0
0
2
5
4
0
2
5
0
585440461
2
5
4
0
2
5
4
0
2
5
2
You don't *really* want to commit suicide, do you?
2
5
0
1
2
5
4
1
1
2
2
5
4
2
1
8060
1
39
2
5
1
-1
2
5
4
3
1
36
1
38
1
71
2
5
4
145
2
Getting Started with your LambdaCore MOO
2
========================================
2

2
Thank you for choosing LambdaCore!
2

2
Initial Setup Notes
2
-------------------
2

2
The "welcome" screen, seen when a player connects.
2
  -- this is stored in $login.welcome_message
2

2
Do you want on-line character creation?
2
  -- this is stored in $login.create_enabled
2
     for more detailed information, edit $login:player_creation_enabled
2

2
Do you want to limit the number of players on the MOO at once?
2
  -- look at $login.max_connections
2
     the `connection_limit' message on $login is the message printed
2
     when this limit is reached.
2

2
Do you want a different default player class?
2
  -- set $player_class to a different value
2
     *do not* change $player
2

2
You should also set the following:
2
  $network.postmaster
2
    -- your email address, or the email address of the person who will 
2
       handle your email
2
  $network.site
2
    -- the machine your MOO is running on (e.g. "lambda.moo.mud.org")
2
  $network.port
2
    -- the port your MOO is running on (e.g. 8888)
2
  $network.MOO_Name
2
    -- the name of your MOO (e.g. "LambdaMOO")
2
  $site_db.domain
2
  -- this is set to the `domain' of your address
2
     (eg `foo.com' for `moo.foo.com')
2

2
If you compiled the server with open_network_connection() enabled (allowing the MOO to open up connections with other computers on the network), then you should set
2
  $network.active = 1
2
     This will enable @newpassword, @registerme, @password, @mailme, @netforward, and others to send mail from the MOO.
2

2
-------------------------------------------------------------------
2

2
Setting Yourself Up
2
-------------------
2

2
Set a password for yourself.
2
  -- @password <new-password>
2

2
Set a description for yourself.
2
  -- @describe me as <anything>
2

2
Set a gender for yourself.
2
  -- @gender <gender>
2

2
There are, also, a large number of messages you can set on yourself.  Setting them will enhance the virtual reality.
2

2
-------------------------------------------------------------------
2

2
About Guests
2
------------
2

2
To make a new Guest character:
2
  -- @make-guest <guestname>
2
     will make a new guest with the name you specify with `_Guest' appended
2
     and some other standard but useful aliases
2

2
This is the easiest way to make Guest characters.  The most important things to remember about Guests, if you want to make them yourself, are:
2
  -- make them owned by nonwizards, and not owned by themselves
2
  -- make sure they've got .password == 0, and that .password is nonclear
2
  -- at least one Guest must always be named `Guest'; this can be an alias
2

2
To set the default description and gender for a guest:
2
  -- set .default_description to the description the guest should start with
2
  -- set .default_gender to the gender the guest should start with
2
  -- remember to set .description and .gender too, for the guest's first use
2

2
-------------------------------------------------------------------
2

2
Adding to the Newspaper
2
-----------------------
2

2
The newspaper is a special mailing list.  To add a post to the newspaper, send mail to it (as *News or $news), and then note the number of your post (let's call it <x> and:
2
  -- @addnews <x> to *News
2
... in general, `@addnews $ to *News' will work as well.
2

2
-------------------------------------------------------------------
2

2
Quota
2
-----
2

2
By default, LambdaCore runs with byte-based quota, an in-DB quota system, limiting users by total database space as opposed to total objects.  You'll need to do two things:
2
  -- decide on the default quota:
2
     ;$byte_quota_utils.default_quota[1] = <a number of bytes>
2
  -- start the measurement task; see `help routine_tasks' for more information (Note: this help topic contains information about more than just the quota task; it should be read regardless of how quota is set).
2

2
If you prefer the quota system documented in the LambdaMOO Programmer's Manual, directly supported by the server, you can enable object-based quota:
2
  -- set $quota_utils to $object_quota_utils
2

2
It's best that you make this switch before users start, because converting existing users is an awkward (and inherently arbitrary and political) move.
2

2
-------------------------------------------------------------------
2

2
Making Programmers
2
------------------
2

2
The command to turn someone into a programmer is `@programmer'  Its syntax is `@programmer <user>'.  For example:
2
  -- @programmer Haakon
2
The `@programmer' verb will prompt you if the user isn't set up with a description and a gender.
2

2
No code to automatically grant programmer bits is included with LambdaCore.
2

2
Making Wizards
2
--------------
2

2
THINK CAREFULLY.
2

2
Be very careful before giving someone a wizard bit.  That person can do gross damage to your database, and fixable but serious damage to the machine it runs on.  That person can quite possibly open outbound network connections from your machine, and thus commit acts for which your host system will be blamed.  That person can ruin your MOO's as-yet-untarnished reputation.
2

2
Wizards have technical power, the ability to change anything within the database, to create anything within the database.  Be careful with the idea of a `Social Wizard' -- a nontechnical person holding a wizard bit is fairly likely to, at some point, accidentally do something destructive.  It's a good idea not to socialize as your wizard character, for the same reason, to make it less likely to be accidentally destructive.
2

2
That said, in general you don't turn an existing character into a wizard, you make a -new- character to be the wizard.  This is because the existing character probably owns code and objects which could be destructive if suddenly made wizardly; it's a good security measure to make a fresh player.  So, to make a fresh player:
2
  -- @make-player (see `help @make-player' for more information)
2
     this will make you a new player. for this example, #123
2

2
To make #123 a wizard:
2
  -- @programmer #123
2
     (a nonprogrammer wizard is a truly strange beast)
2
  -- ;#123.wizard = 1;
2
  -- @chparent #123 to $wiz
2
  -- ;#123.public_identity = <the player's nonwizard character's object number>
2

2
-------------------------------------------------------------------
2

2
Good luck with your new LambdaCore database!
2

2
Visit us at LambdaMOO: lambda.moo.mud.org 8888
2

2
Join the international mailing list for MOO coders: send an email message to moo-cows-request@the-b.org with the word `subscribe' as the body of your message.
2

2
Do good things.
2

2
The LambdaMOO Wizards
2
[authored February 15, 1999]
2
1
4
0
2
0
4
0
36
0
4
0
2
0
4
1
1
2
2
5
0
0
2
5
3
0
2
5
2

2
5
4
1
1
2
2
5
4
36
2
Wizard Utilities
2
----------------
2
The following functions are substitutes for various server builtins.
2
Anytime one feel tempted to use one of the expressions on the right,
2
use the corresponding one on the left instead.  This will take care
2
of various things that the server (for whatever reason) does not handle.
2

2
:set_programmer(object)             object.programmer = 1;
2
    chparent object to $prog
2
    send mail to $prog_log
2

2
:set_player(object[,nochown])       set_player_flag(object,1);
2
    set player flag, 
2
    add name/aliases to $player_db,
2
    and maybe do a self chown.
2

2
:unset_player(object[,newowner])    set_player_flag(object,0);
2
    unset player flag,
2
    remove name/aliases from $player_db
2
    chown to newowner if given
2

2
:set_owner(object, newowner)        object.owner = newowner;
2
    change ownership on object
2
    change ownership on all +c properties
2
    juggle .ownership_quotas
2

2
:set_property_owner(object, property, newowner[, suspend-ok])
2
    change owner on a given property
2
    if this is a -c property, we change the owner on all descendants
2
    for which this is also a -c property.
2
    Polite protest if property is +c and newowner != object.owner.
2

2
:set_property_flags(object, property, flags[, suspend-ok])
2
    change the permissions on a given property and propagate these to 
2
    *all descendants*.  property ownership is changed on descendants 
2
    where necessary.
2
5
5
2
4
4
1
2
Wizard Utilities
2
5
4
1
2
This is the Wizard Utilities utility package.  See `help $wiz_utils' for more details.
2
5
4
2
0
75226
0
1648488120
36
1
#25
Site DB
0
36
1
-1
0
0
4
0
1
37
4
0
11
find* _only* _every*
36
173
-1
add
36
173
-1
load
2
173
-1
domain_literal
36
173
-1
init_for_core
2
173
-1
prune_alpha
2
173
-1
report_prune_progress
2
173
-1
prune_fixup
2
173
-1
prune_numeric
2
173
-1
schedule_prune
2
173
-1
prune_reset
2
173
-1
8
domain
prune_progress
prune_stop
total_pruned_people
total_pruned_sites
prune_task
alphabet
 l
15
2
localdomain
36
1
2
aaa
36
4
2
zzz
36
5
0
0
36
5
0
0
36
5
0
298000796
36
5
2
abcdefghijklmnopqrstuvwxy0123456789_z
36
5
4
4
2
ocal
2

4
2
2
localdomain
2
localhost.localdomain
4
2
4
1
2
localhost
4
1
1
2
36
0
2

36
5
5
36
1
4
4
2

2
l
4
0
4
0
36
0
0
0
36
4
4
3
2
sitedb
2
site
2
db
36
5
4
2
2
This object holds a db of places from which players have connected (see `help $site_db').
2
The site blacklist and the graylist live as well (see `help blacklist').
36
5
4
2
0
18428
0
1641541193
36
1
#26
Math Utilities
16
36
1
-1
0
0
4
0
1
78
4
0
40
xsin
36
173
-1
xcos
36
173
-1
factorial
36
173
-1
fibonacci
36
173
-1
geometric
36
173
-1
divmod
36
173
-1
combinations
36
173
-1
permutations
36
173
-1
simpson
36
173
-1
parts
36
173
-1
div
36
173
-1
mod
36
173
-1
exp
36
173
-1
aexp
36
173
-1
random
36
173
-1
random_range
36
173
-1
is_prime
36
173
-1
NOT
36
173
-1
BLFromInt
36
173
-1
IntFromBL
36
173
-1
gcd greatest_common_divisor
36
173
-1
lcm least_common_multiple
36
173
-1
are_rel_prime are_relatively_prime
36
173
-1
base_conversion
36
173
-1
norm
36
173
-1
sin
36
173
-1
cos
36
173
-1
tan
36
173
-1
arcsin asin
36
173
-1
arccos acos
36
173
-1
arctan atan
36
173
-1
deg2rads deg2rad
36
173
-1
rads2deg rad2deg
36
173
-1
precision
36
173
-1
round
36
173
-1
mean average
36
173
-1
sum_float
36
173
-1
sum_int sum
36
173
-1
rint
36
173
-1
to_percent
36
173
-1
10
base_alphabet
tangents
factor
taylor
sines
pi
piscale
phi
e
e_string
15
2
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
36
5
4
45
0
174
0
349
0
524
0
699
0
874
0
1051
0
1227
0
1405
0
1583
0
1763
0
1943
0
2125
0
2308
0
2493
0
2679
0
2867
0
3057
0
3249
0
3443
0
3639
0
3838
0
4040
0
4244
0
4452
0
4663
0
4877
0
5095
0
5317
0
5543
0
5773
0
6008
0
6248
0
6494
0
6745
0
7002
0
7265
0
7535
0
7812
0
8097
0
8390
0
8692
0
9004
0
9325
0
9656
0
10000
36
5
0
10000
36
5
0
100
36
5
4
361
0
175
0
349
0
523
0
698
0
872
0
1045
0
1219
0
1392
0
1564
0
1736
0
1908
0
2079
0
2250
0
2419
0
2588
0
2756
0
2924
0
3090
0
3256
0
3420
0
3584
0
3746
0
3907
0
4067
0
4226
0
4384
0
4540
0
4695
0
4848
0
5000
0
5150
0
5299
0
5446
0
5592
0
5736
0
5878
0
6018
0
6157
0
6293
0
6428
0
6561
0
6691
0
6820
0
6947
0
7071
0
7193
0
7314
0
7431
0
7547
0
7660
0
7771
0
7880
0
7986
0
8090
0
8192
0
8290
0
8387
0
8480
0
8572
0
8660
0
8746
0
8829
0
8910
0
8988
0
9063
0
9135
0
9205
0
9272
0
9336
0
9397
0
9455
0
9511
0
9563
0
9613
0
9659
0
9703
0
9744
0
9781
0
9816
0
9848
0
9877
0
9903
0
9925
0
9945
0
9962
0
9976
0
9986
0
9994
0
9998
0
10000
0
9998
0
9994
0
9986
0
9976
0
9962
0
9945
0
9925
0
9903
0
9877
0
9848
0
9816
0
9781
0
9744
0
9703
0
9659
0
9613
0
9563
0
9511
0
9455
0
9397
0
9336
0
9272
0
9205
0
9135
0
9063
0
8988
0
8910
0
8829
0
8746
0
8660
0
8572
0
8480
0
8387
0
8290
0
8192
0
8090
0
7986
0
7880
0
7771
0
7660
0
7547
0
7431
0
7314
0
7193
0
7071
0
6947
0
6820
0
6691
0
6561
0
6428
0
6293
0
6157
0
6018
0
5878
0
5736
0
5592
0
5446
0
5299
0
5150
0
5000
0
4848
0
4695
0
4540
0
4384
0
4226
0
4067
0
3907
0
3746
0
3584
0
3420
0
3256
0
3090
0
2924
0
2756
0
2588
0
2419
0
2250
0
2079
0
1908
0
1736
0
1564
0
1392
0
1219
0
1045
0
872
0
698
0
523
0
349
0
175
0
0
0
-175
0
-349
0
-523
0
-698
0
-872
0
-1045
0
-1219
0
-1392
0
-1564
0
-1736
0
-1908
0
-2079
0
-2250
0
-2419
0
-2588
0
-2756
0
-2924
0
-3090
0
-3256
0
-3420
0
-3584
0
-3746
0
-3907
0
-4067
0
-4226
0
-4384
0
-4540
0
-4695
0
-4848
0
-5000
0
-5150
0
-5299
0
-5446
0
-5592
0
-5736
0
-5878
0
-6018
0
-6157
0
-6293
0
-6428
0
-6561
0
-6691
0
-6820
0
-6947
0
-7071
0
-7193
0
-7314
0
-7431
0
-7547
0
-7660
0
-7771
0
-7880
0
-7986
0
-8090
0
-8192
0
-8290
0
-8387
0
-8480
0
-8572
0
-8660
0
-8746
0
-8829
0
-8910
0
-8988
0
-9063
0
-9135
0
-9205
0
-9272
0
-9336
0
-9397
0
-9455
0
-9511
0
-9563
0
-9613
0
-9659
0
-9703
0
-9744
0
-9781
0
-9816
0
-9848
0
-9877
0
-9903
0
-9925
0
-9945
0
-9962
0
-9976
0
-9986
0
-9994
0
-9998
0
-10000
0
-9998
0
-9994
0
-9986
0
-9976
0
-9962
0
-9945
0
-9925
0
-9903
0
-9877
0
-9848
0
-9816
0
-9781
0
-9744
0
-9703
0
-9659
0
-9613
0
-9563
0
-9511
0
-9455
0
-9397
0
-9336
0
-9272
0
-9205
0
-9135
0
-9063
0
-8988
0
-8910
0
-8829
0
-8746
0
-8660
0
-8572
0
-8480
0
-8387
0
-8290
0
-8192
0
-8090
0
-7986
0
-7880
0
-7771
0
-7660
0
-7547
0
-7431
0
-7314
0
-7193
0
-7071
0
-6947
0
-6820
0
-6691
0
-6561
0
-6428
0
-6293
0
-6157
0
-6018
0
-5878
0
-5736
0
-5592
0
-5446
0
-5299
0
-5150
0
-5000
0
-4848
0
-4695
0
-4540
0
-4384
0
-4226
0
-4067
0
-3907
0
-3746
0
-3584
0
-3420
0
-3256
0
-3090
0
-2924
0
-2756
0
-2588
0
-2419
0
-2250
0
-2079
0
-1908
0
-1736
0
-1564
0
-1392
0
-1219
0
-1045
0
-872
0
-698
0
-523
0
-349
0
-175
0
0
0
175
36
5
9
3.141592653589793116
36
5
9
0.008726646259971640798
36
5
9
1.618033988749894903
36
5
9
2.718281828459049976
36
5
2
2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921817413596629043572900334295260595630738132328627943490763233829880753195251019
36
5
4
51
2
Trigonometric/Exponential functions:
2
  sin(a),cos(a),tan(a) -- returns 10000*(the value of the corresponding
2
       trigonometric function) angle a is in degrees.
2
  arctan([x,]y) -- returns arctan(y/x) in degrees in the range -179..180.
2
       x defaults to 10000.  Quadrant is that of (x,y).
2
  exp(x[,n]) -- calculates e^x with an nth order taylor polynomial
2
  aexp(x) -- calculates 10000 e^(x/10000)
2

2
Statistical functions:
2
  combinations(n,r) -- returns the number of combinations given n objects
2
       taken r at a time.
2
  permutations(n,r) -- returns the number of permutations possible given
2
       n objects taken r at a time.
2

2
Number decomposition:
2
  div(n,d) -- correct version of / (handles negative numbers correctly)
2
  mod(n,d) -- correct version of % (handles negative numbers correctly)
2
  divmod(n,d) -- {div(n,d),mod(n,d)}
2
  parts(n,q[,i]) -- returns a list of two elements {integer,decimal fraction}
2

2
Other math functions:
2
  factorial(x) -- returns x!
2
  norm(a,b,c,d,...) -- returns sqrt(a^2+b^2+c^2+...)
2
  sum(a,b,c,d,...) -- returns the sum of all arguments.
2

2
Series:
2
  fibonacci(n) -- returns the 1st n fibonacci numbers in a list
2
  geometric(x,n) -- returns the value of the nth order geometric series at x
2

2
Integer Properties:
2
  gcd(a,b) -- find the greatest common divisor of the two numbers
2
  lcm(a,b) -- find the least common multiple of the two numbers
2
  are_relatively_prime(a,b) -- return 1 if a and b are relatively prime
2
  is_prime(n) -- returns 1 if the number is a prime and 0 otherwise
2
  
2
Miscellaneous:
2
  random(n) -- returns a random number from 0..n if n > 0 or n..0 if n < 0
2
  random_range(n[,mean]) -- returns a random number from mean - n..mean + n
2
      with mean defaulting to 0
2
  simpson({a,b},{f(a),f((a+b)/2),f(b)}) -- returns the numerical
2
      approximation of an integral using simpson's rule
2
  base_conversion(num|string, oldbase, newbase [,sens]) -- converts the number
2
      given as first arg from oldbase to the newbase.
2

2
Bitwise Arithmetic:
2
  NOT(x) -- returns the complement of x
2
      All bitwise manipulation is of 32-bit values.
2

2
Bitwise Conversions:
2
  BlFromInt(d) -- converts a decimal number d to a list of 1's and 0's, 32-bit
2
  IntFromBl(b) -- converts a list of 1's and 0's (any precision) to decimal
36
5
5
36
4
4
4
2
Math Utilities
2
Math_Utils
2
trigonometric utilites
2
trig_utils
36
5
4
1
2
This is the Math Utilities utility package.  See `help $math_utils' for more details.
36
5
4
2
0
44800
0
1641541193
36
1
#27
Set Utilities
16
36
1
-1
0
0
4
0
1
78
4
0
8
union
36
173
-1
intersection
36
173
-1
diff*erence
36
173
-1
contains
36
173
-1
exclusive_or xor
36
173
-1
difference_suspended diff_suspended
36
173
-1
equal
36
173
-1
intersection_preserve_case
36
173
-1
0
5
4
22
2
This object is useful for operations that treat lists as sets (i.e.,
2
without concern about order and assuming no duplication).
2

2
 union(set, set, ...)        => union
2
 intersection(set, set, ...) => intersection
2
 intersection_preserve_case(base set, set, set, ...)
2
        => intersection with the case of the base set's elements preserved
2

2
 diff*erence(set1, set2, ..., setn)
2
        => result of removing all elements of sets 2..n from set 1.
2

2
 difference_suspended(set1, set2, ..., setn)
2
        => same as above except it suspends as needed.
2

2
 exclusive_or(set, set, set, ...)
2
        => all elements that are contained in exactly one of the sets
2

2
 contains(set1, set2, ..., setn)
2
        => true if and only if all of sets 2..n are subsets of set 1
2

2
 equal(set1, set2)
2
        => true if and only if set1 and set2 are equal
36
5
5
36
4
4
2
2
Set Utilities
2
set_utilities
36
5
4
1
2
This is the Set Utilities utility package.  See `help $set_utils' for more details.
36
5
4
2
0
8102
0
1641541193
36
1
#28
Builtin Function Help
16
36
1
-1
0
0
4
0
1
30
4
0
0
129
match()
rmatch()
substitute()
sqrt()
server_log()
pass()
builtin-index
open_network_connection()
connection_name()
shutdown()
dump_database()
memory_usage()
reset_max_object()
renumber()
server_version()
output_delimiters()
callers()
kill_task()
queued_tasks()
read()
suspend()
task_id()
seconds_left()
ticks_left()
caller_perms()
set_task_perms()
eval()
boot_player()
notify()
idle_seconds()
connected_seconds()
connected_players()
set_player_flag()
is_player()
players()
set_verb_code()
verb_code()
delete_verb()
add_verb()
set_verb_args()
verb_args()
set_verb_info()
verb_info()
verbs()
delete_property()
add_property()
set_property_info()
property_info()
properties()
move()
max_object()
recycle()
children()
parent()
valid()
chparent()
create()
setremove()
setadd()
listset()
listdelete()
listinsert()
listappend()
strcmp()
rindex()
index()
crypt()
strsub()
length()
ctime()
time()
random()
abs()
max()
min()
toobj()
tonum()
tostr()
typeof()
clear_property()
is_clear_property()
set_connection_option()
queue_info()
is_member()
equal()
toliteral()
value_bytes()
acos()
asin()
atan()
binary_hash()
string_hash()
buffered_output_length()
call_function()
ceil()
connection_options()
connection_option()
sin()
cos()
tan()
sinh()
cosh()
tanh()
db_disk_size()
decode_binary()
disassemble()
encode_binary()
exp()
floatstr()
floor()
flush_input()
force_input()
function_info()
listen()
listeners()
log()
log10()
object_bytes()
raise()
resume()
task_stack()
tofloat()
toint()
trunc()
unlisten()
value_hash()
load_server_options()
verb_cache_stats()
log_cache_stats()
135
4
22
2
Syntax:  match (STR <subject>, STR <pattern> [, <case-matters>])  => LIST
2
         rmatch (STR <subject>, STR <pattern> [, <case-matters>])  => LIST
2

2
The function `match()' (`rmatch()') searches for the first (last) occurrence of the regular expression <pattern> in the string <subject>.  If <pattern> is syntactically malformed, then E_INVARG is raised. The process of matching can in some cases consume a great deal of memory in the server; should this memory consumption become excessive, then the matching process is aborted and E_QUOTA is raised.
2

2
If no match is found, the empty list is returned; otherwise, these functions return a list containing information about the match (see below).  By default, the search ignores upper/lower case distinctions.  If <case-matters> is provided and true, then case is treated as significant in all comparisons.
2

2
The list that `match()' (`rmatch()') returns contains the details about the match made.  The list is in the form:
2

2
     {<start>, <end>, <replacements>, <subject>}
2

2
where <start> is the index in STRING of the beginning of the match, <end> is the index of the end of the match, <replacements> is a list described below, and <subject> is the same string that was given as the first argument to the `match()' or `rmatch()'.
2

2
The <replacements> list is always nine items long, each item itself being a list of two numbers, the start and end indices in <subject> matched by some parenthesized sub-pattern of <pattern>.  The first item in <replacements> carries the indices for the first parenthesized sub-pattern, the second item carries those for the second sub-pattern, and so on.  If there are fewer than nine parenthesized sub-patterns in <pattern>, or if some sub-pattern was not used in the match, then the corresponding item in <replacements> is the list {0, -1}.  See the discussion of `%)' in `help regular-expressions', for more information on parenthesized sub-patterns.
2

2
   match("foo", "f*o")          =>  {1, 2, {{0, -1}, ...}, "foo"}
2
   match("foo", "fo*")          =>  {1, 3, {{0, -1}, ...}, "foo"}
2
   match("foobar", "o*b")       =>  {2, 4, {{0, -1}, ...}, "foobar"}
2
   rmatch("foobar", "o*b")      =>  {4, 4, {{0, -1}, ...}, "foobar"}
2
   match("foobar", "f%(o*%)b")  =>  {1, 4, {{2, 3}, {0, -1}, ...}, "foobar"}
2

2
See `help regular-expressions' for information on the syntax and semantics of patterns.
36
5
4
2
2
*forward*
2
match()
36
5
4
9
2
Syntax:  substitute (STR <template>, LIST <subs>)  => STR
2

2
Performs a standard set of substitutions on the string <template>, using the information contained in <subs>, returning the resulting, transformed <template>.  <Subs> should be a list like those returned by `match()' or `rmatch()' when the match succeeds.
2

2
In <template>, the strings `%1' through `%9' will be replaced by the text matched by the first through ninth parenthesized sub-patterns when `match()' or `rmatch()' was called.  The string `%0' in <template> will be replaced by the text matched by the pattern as a whole when `match()' or `rmatch()' was called. The string '%%' will be replaced by a single '%' sign. If '%' appears in <template> followed by any other character, E_INVARG will be raised.
2

2
     subs = match("*** Welcome to LambdaMOO!!!", "%(%w*%) to %(%w*%)");
2
     substitute("I thank you for your %1 here in %2.", subs)
2
             =>   "I thank you for your Welcome here in LambdaMOO."
36
5
4
3
2
Syntax:  sqrt (FLOAT <x>)  => FLOAT
2

2
Returns the square root of <x>.  If <x> is negative, then E_INVARG is raised.
36
5
4
3
2
Syntax:  server_log (STR <message> [, <is-error>])  => none
2

2
The text in <message> is sent to the server log.  If the programmer is not a wizard, then E_PERM is raised.  If <is-error> is provided and true, then <message> is marked in the server log as an error.
36
5
4
13
2
Syntax:  pass (<arg>, ...)   => value
2

2
Often, it is useful for a child object to define a verb that *augments* the behavior of a verb on its parent object. For example, the root object (an ancestor of every other object) defines a :description() verb that simply returns the value of `this.description'; this verb is used by the implementation of the `look' command. In many cases, a programmer would like the description of some object to include some non-constant part; for example, a sentence about whether or not the object was `awake' or `sleeping'.  This sentence should be added onto the end of the normal description.  The programmer would like to have a means of calling the normal `description' verb and then appending the sentence onto the end of that description.  The function `pass()' is for exactly such situations.
2

2
`Pass()' calls the verb with the same name as the current verb but as defined on the parent of the object that defines the current verb.  The arguments given to the called verb are the ones given to pass() and the returned value of the called verb is returned from the call to pass(). The initial value of `this' in the called verb is the same as in the calling verb.
2

2
Thus, in the example above, the child-object's :description() verb might have the following implementation:
2

2
    return pass(@args) + "  It is " + (this.awake ? "awake." | "sleeping.");
2

2
That is, it calls its parent's :description() verb and then appends to the result a sentence whose content is computed based on the value of a property on the object.
2

2
In the above example, `pass()' would have worked just as well, since :description() is not normally given any arguements.  However, it is a good idea to get into the habit of using `pass(@args)' rather than `pass(args[1])' or `pass()' even if the verb being pass()ed to is already known to take a set number of arguments or none at all.  For one thing, though the args may be irrelevant to the code that you've written, it may be that the corresponding verb on the parent has been rewritten to take additional arguments, in which case you will want your verb to continue to work...
36
5
4
2
2
*index*
2
Server Built-in Functions
36
5
4
15
2
Syntax:  open_network_connection (<value>, ... [, <use_ipv6>, <listener>])   => obj
2

2
Establishes a network connection to the place specified by the arguments and more-or-less pretends that a new, normal player connection has been established from there.  The new connection, as usual, will not be logged in initially and will have a negative object number associated with it for use with `read()', `notify()', and `boot_player()'.  This object number is the value returned by this function.
2

2
If the programmer is not a wizard or if the `OUTBOUND_NETWORK' compilation option was not used in building the server, then `E_PERM' is raised.  If the network connection cannot be made for some reason, then other errors will be returned, depending upon the particular network implementation in use.
2

2
For the TCP/IP network implementations (the only ones as of this writing that support outbound connections), there must be at least two arguments, a string naming a host (possibly using the numeric Internet syntax) and an integer specifying a TCP port.  If a connection cannot be made because the host does not exist, the port does not exist, the host is not reachable or refused the connection, `E_INVARG' is raised.  If the connection cannot be made for other reasons, including resource limitations, then `E_QUOTA' is raised.
2

2
An optional third agument can be supplied indicating that the connection should be created on the destination's IPv6 interface rather than IPv4.
2

2
Finally, an optional fourth argument may be supplied, `listener' must be an object, whose listening verbs will be called at appropriate points.  See the description in `listen()' for more details.
2

2
The outbound connection process involves certain steps that can take quite a long time, during which the server is not doing anything else, including responding to user commands and executing MOO tasks.  See the chapter on server assumptions about the database for details about how the server limits the amount of time it will wait for these steps to successfully complete.
2

2
It is worth mentioning one tricky point concerning the use of this function.  Since the server treats the new connection pretty much like any normal player connection, it will naturally try to parse any input from that connection as commands in the usual way.  To prevent this treatment, you should use `set_connection_option()' to set the `hold-input' option true on the connection.
36
5
4
13
2
Syntax:  connection_name (obj <player> [, <method>])   => str
2

2
Returns a network-specific string identifying the connection being used by the given player.  If the programmer is not a wizard and not <player>, then E_PERM is raised.  If <player> is not currently connected, then E_INVARG is raised.
2

2
For the TCP/IP networking configurations, for in-bound connections, the string contains the resolved DNS hostname of the connection.
2

2
If <method> is set to 1, the string will always contain the numeric IP address of the connection.
2

2
If <method> is set to 2, the string will contain the full legacy connection_name string with the form:
2

2
  "port <lport> from <host>, port <port>"
2

2
where <lport> is the listening port on which the connection arrived, <host> is either the name or decimal TCP address of the host to which the connection was opened, and <port> is the decimal TCP port of the connection on that host.
36
5
4
3
2
Syntax:  shutdown ([STR <message>])   => none
2

2
Requests that the server shut itself down at its next opportunity.  Before doing so, the given <message> is printed to all connected players.  If the programmer is not a wizard, then E_PERM is raised.
36
5
4
3
2
Syntax:  dump_database ()   => none
2

2
Requests that the server checkpoint the database at its next opportunity.  It is not normally necessary to call this function; the server automatically checkpoints the database at regular intervals; see the chapter on server assumptions about the database for details.  If the programmer is not a wizard, then E_PERM is raised.
36
5
4
17
2
Syntax:  memory_usage ()   => list
2

2
On some versions of the server, this returns statistics concerning the server
2
consumption of system memory.  The result is a list of lists, each in the
2
following format:
2

2
    {<block-size>, <nused>, <nfree>}
2

2
where <block-size> is the size in bytes of a particular class of memory
2
fragments, <nused> is the number of such fragments currently in use in the
2
server, and <nfree> is the number of such fragments that have been reserved
2
for use but are currently free.
2

2
On servers for which such statistics are not available, `memory_usage()'
2
returns `{}'.  The compilation option `USE_SYSTEM_MALLOC' controls
2
whether or not statistics are available; if the option is provided, statistics
2
are not available.
36
5
4
5
2
Syntax:  reset_max_object ()   => none
2

2
The server's idea of the highest object number ever used is changed to be the highest object number of a currently-existing object, thus allowing reuse of any higher numbers that refer to now-recycled objects.  If the programmer is not a wizard, then E_PERM is raised.
2

2
This operation is intended for use in making new versions of the LambdaCore database from the then-current LambdaMOO database, and other similar situations.  Its use requires great care.
36
5
4
7
2
Syntax:  renumber (OBJ <object>)   => OBJ
2

2
The object number of the object currently numbered <object> is changed to be the least nonnegative object number not currently in use and the new object number is returned.  If <object> is not valid, then E_INVARG is raised.  If the programmer is not a wizard, then E_PERM is raised. If there are no unused nonnegative object numbers less than <object>, then <object> is returned and no changes take place.
2

2
The references to <object> in the parent/children and location/contents hierarchies are updated to use the new object number, and any verbs, properties and/or objects owned by <object> are also changed to be owned by the new object number.  The latter operation can be quite time consuming if the database is large.  No other changes to the database are performed; in particular, no object references in property values or verb code are updated.
2

2
This operation is intended for use in making new versions of the LambdaCore database from the then-current LambdaMOO database, and other similar situations.  Its use requires great care.
36
5
4
22
2
Syntax:  server_version ()   => str
2

2
Returns a string giving the version number of the MOO server in the following
2
format:
2

2
    "<major>.<minor>.<release>"
2

2
where <major>, <minor>, and <release> are all decimal numbers.
2

2
The major version number changes very slowly, only when existing MOO code might
2
stop working, due to an incompatible change in the syntax or semantics of the
2
programming language, or when an incompatible change is made to the database
2
format.
2

2
The minor version number changes more quickly, whenever an upward-compatible
2
change is made in the programming language syntax or semantics.  The most
2
common cause of this is the addition of a new kind of expression, statement, or
2
built-in function.
2

2
The release version number changes as frequently as bugs are fixed in the
2
server code.  Changes in the release number indicate changes that should only
2
be visible to users as bug fixes, if at all.
36
5
4
3
2
Syntax:  output_delimiters (OBJ <player>)   => LIST
2

2
Returns a list of two strings, the current "output prefix" and "output suffix" for <player>.  If <player> does not have an active network connection, then E_INVARG is raised.  If either string is currently undefined, the value `""' is used instead.  See the discussion of the `PREFIX' and `SUFFIX' commands in the LambdaMOO Programmers Manual for more information about the output prefix and suffix.
36
5
4
14
2
Syntax:  callers ([include-line-numbers])   => list
2

2
Returns information on each of the verbs and built-in functions currently waiting to resume execution in the current task.  When one verb or function calls another verb or function, execution of the caller is temporarily suspended, pending the called verb or function returning a value.  At any given time, there could be several such pending verbs and functions: the one that called the currently executing verb, the verb or function that called that one, and so on.  The result of `callers()' is a list, each element of which gives information about one pending verb or function in the following format:
2

2
  {<this>, <verb-name>, <programmer>, <verb-loc>, <player>, <line-number>}
2

2
For verbs, <this> is the initial value of the variable `this' in that verb, <verb-name> is the name used to invoke that verb, <programmer> is the player with whose permissions that verb is running, <verb-loc> is the object on which that verb is defined, and <player> is the initial value of the variable `player' in that verb, and <line-number> indicates which line of the verb's code is executing. The <line-number> element is included only if the `include-line-numbers' argument was provided and is true.
2

2
For functions, <this>, <programmer>, and <verb-loc> are all #-1, <verb-name> is the name of the function, and <line-number> is an index used internally to determine the current state of the built-in function. The simplest correct test for a built-in function entry is
2

2
(VERB-LOC == #-1 && PROGRAMMER == #-1 && VERB-NAME != "")
2

2

2
The first element of the list returned by `callers()' gives information on the verb that called the currently-executing verb, the second element describes the verb that called that one, and so on.  The last element of the list describes the first verb called in this task.
36
5
4
3
2
Syntax:  kill_task (INT <task-id>)   => none
2

2
Removes the task with the given <task-id> from the queue of waiting tasks. If the programmer is not the owner of that task and not a wizard, then E_PERM is raised.  If there is no task on the queue with the given <task-id>, then E_INVARG is raised.
36
5
4
10
2
Syntax:  queued_tasks ()   => LIST
2

2
Returns information on each of the background tasks (i.e., forked, suspended, or reading)  owned by the programmer (or, if the programmer is a wizard, all queued tasks). The returned value is a list of lists, each of which encodes certain information about a particular queued task in the following format:
2

2
    {<task-id>, <start-time>, <ticks>, <clock-id>,
2
     <programmer>, <verb-loc>, <verb-name>, <line>, <this>, <task-size>}
2

2
where <task-id> is a numeric identifier for this queued task, <start-time> is the time after which this task will begin execution (in `time()' format), <ticks> is the number of ticks this task will have when it starts (always 20,000 now, though this is changeable. This makes this value obsolete and no longer interesting), <clock-id> is a number whose value is no longer interesting, <programmer> is the permissions with which this task will begin execution (and also the player who "owns" this task), <verb-loc> is the object on which the verb that forked this task was defined at the time, <verb-name> is that name of that verb, <line> is the number of the first line of the code in that verb that this task will execute, and <this> is the value of the variable `this' in that verb. For reading tasks, <start-time> is `-1'.  <task-size> is in bytes, and is the size of memory in use by the task for local variables, stack frames, etc.
2

2
The <ticks> and <clock-id> fields are now obsolete and are retained only for backward-compatibility reasons.  They may disappear in a future version of the server.
36
5
4
15
2
Syntax:  read ([OBJ <conn> [, non-blocking]])   => STR
2

2
Reads and returns a line of input from the connection <conn> (or, if not provided, from the player that typed the command that initiated the current task). If <non-blocking> is false or not provided, this function suspends the current task, resuming it when there is input available to be read. If <non-blocking> is provided and true, this function never suspends the calling task; if there is no input currently available for input, `read()' simply returns 0 immediately.
2

2
If <conn> is provided, then the programmer must either be a wizard or the owner of <conn>, if <conn> is not provided, then `read()' may only be called by a wizard and only in the task that was last spawned by a command from the connection in question. Otherwise, E_PERM is raised. If the given <conn> is not currently connected and has no pending lines of input, or if the connection is closed while a task is waiting for input but before any lines of input are received, then `read()' raises E_INVARG.
2

2
The restriction on the use of `read()' without any arguments preserves the following simple invariant: if input is being read from a player, it is for the task started by the last command that the player typed. This invariant adds responsibility to the programmer, however. If your program calls another verb before doing a `read()', then either that verb must not suspend, or else you must arrange that no commands will be read from the connection in the meantime. The most straightforward way to do this is to call
2

2
  set_connection_option(<conn>, "hold-input", 1)
2

2
before any task suspension could happen, then make all of your calls to `read()' and other code that might suspend, and finally call
2

2
  set_connection_option(<conn>, "hold-input", 0)
2

2
to allow commands once again to be read and interpreted normally.
36
5
4
38
2
Syntax:  suspend ([INT <seconds>])   => value
2

2
Suspends the current task, and resumes it after at least <seconds> seconds. (If <seconds> is not provided, the task is suspended indefinitely; such a task can only be resumed by use of the `resume()' function.) When the task is resumed, it will have a full quota of ticks and seconds.  This function is useful for programs that run for a long time or require a lot of ticks.  If <seconds> is negative, then E_INVARG is raised. `Suspend()' returns zero unless it was resumed via `resume()' in which case it returns the second argument given to that function.
2

2
In some sense, this function forks the `rest' of the executing task.  However, there is a major difference between the use of `suspend(<seconds>)' and the use of the `fork (<seconds>)'.  The `fork' statement creates a new task (a "forked task") while the currently-running task still goes on to completion, but a `suspend()' suspends the currently-running task (thus making it into a "suspended task").  This difference may be best explained by the following examples, in which one verb calls another:
2

2
    .program   #0:caller_A
2
    #0.prop = 1;
2
    #0:callee_A();
2
    #0.prop = 2;
2
    .
2

2
    .program   #0:callee_A
2
    fork(5)
2
      #0.prop = 3;
2
    endfork
2
    .
2

2
    .program   #0:caller_B
2
    #0.prop = 1;
2
    #0:callee_B();
2
    #0.prop = 2;
2
    .
2

2
    .program   #0:callee_B
2
    suspend(5);
2
    #0.prop = 3;
2
    .
2

2
Consider `#0:caller_A', which calls `#0:callee_A'.  Such a task would assign 1 to `#0.prop', call `#0:callee_A', fork a new task, return to `#0:caller_A', and assign 2 to `#0.prop', ending this task.  Five seconds later, if the forked task had not been killed, then it would begin to run; it would assign 3 to `#0.prop' and then stop.  So, the final value of `#0.prop' (i.e., the value after more than 5 seconds) would be 3.
2

2
Now consider `#0:caller_B', which calls `#0:callee_B' instead of `#0:callee_A'.  This task would assign 1 to `#0.prop', call `#0:callee_B', and suspend.  Five seconds later, if the suspended task had not been killed, then it would resume; it would assign 3 to `#0.prop', return to `#0:caller', and assign 2 to `#0.prop', ending the task. So, the final value of `#0.prop' (i.e., the value after more than 5 seconds) would be 2.
2

2
A suspended task, like a forked task, can be described by the `queued_tasks()' function and killed by the `kill_task()' function. Suspending a task does not change its task id.  A task can be suspended again and again by successive calls to `suspend()'.
2

2
Once `suspend()' has been used in a particular task, then the `read()' function will always raise E_PERM in that task.  For more details, see the description of `read()'.
2

2
By default, there is no limit to the number of tasks any player may suspend, but such a limit can be imposed from within the database. See the chapter in the LambdaMOO Programmers Manual on server assumptions about the database for details.
36
5
4
3
2
Syntax:  task_id ()   => INT
2

2
Returns the numeric identifier for the currently-executing task.  Such numbers are randomly selected for each task and can therefore safely be used in circumstances where unpredictability is required.
36
5
4
2
2
*forward*
2
ticks_left()
36
5
4
4
2
Syntax:  ticks_left ()   => INT
2
       seconds_left ()   => INT
2

2
These two functions return the number of ticks or seconds (respectively) left to the current task before it will be forcibly terminated.  These are useful, for example, in deciding when to fork another task to continue a long-lived computation.
36
5
4
6
2
Syntax:  caller_perms ()   => obj
2

2
Returns the permissions in use by the verb that called the currently-executing
2
verb.  If the currently-executing verb was not called by another verb (i.e., it
2
is the first verb called in a command or server task), then
2
`caller_perms()' returns `#-1'.
36
5
4
5
2
Syntax:  set_task_perms (OBJ <player>)   => none
2

2
Changes the permissions with which the currently-executing verb is running to be those of <player>.  If <player> is not of type OBJ, then E_INVARG is raised.  If the programmer is neither <player> nor a wizard, then E_PERM is raised.
2

2
Note: This does not change the owner of the currently-running verb, only the permissions of this particular invocation.  It is used in verbs owned by wizards to make themselves run with lesser (usually non-wizard) permissions.
36
5
4
23
2
Syntax:  eval (str <string>)   => list
2

2
The MOO-code compiler processes <string> as if it were to be the program associated with some verb and, if no errors are found, that fictional verb is invoked.  If the programmer is not, in fact, a programmer, then E_PERM is raised.  The normal result of calling `eval()' is a two element list. The first element is true if there were no compilation errors and false otherwise.  The second element is either the result returned from the fictional verb (if there were no compilation errors) or a list of the compiler's error messages (otherwise).
2

2
When the fictional verb is invoked, the various built-in variables have values as shown below:
2

2
    player    the same as in the calling verb
2
    this      #-1
2
    caller    the same as the initial value of `this' in the calling verb
2

2
    args      {}
2
    argstr    ""
2

2
    verb      ""
2
    dobjstr   ""
2
    dobj      #-1
2
    prepstr   ""
2
    iobjstr   ""
2
    iobj      #-1
2

2
The fictional verb runs with the permissions of the programmer and as if its `d' permissions bit were on.
2

2
    eval("return 3 + 4;")   =>   {1, 7}
36
5
4
9
2
Syntax:  boot_player (obj <player>)   => none
2

2
Immediately terminates any currently-active connection to the given <player>.  The connection will not actually be closed until the currently-running task returns or suspends, but all MOO functions (such as notify(), connected_players(), and the like) immediately behave as if the connection no longer exists. If the programmer is not either a wizard or the same as <player>, then `E_PERM' is returned.  If there is no currently-active connection to <player>, then this function does nothing.
2

2
If there was a currently-active connection, then the following verb call is made when the connection is actually closed:
2

2
$user_disconnected(player)
2

2
It is not an error if this verb does not exist; the corresponding call is simply skipped.
36
5
4
7
2
Syntax:  notify (OBJ conn, STR string [, no-flush]) => 0 or 1
2

2
Enqueues <string> for output (on a line by itself) on the connection <conn>. If the programmer is not <conn> or a wizard, then E_PERM is raised. If <conn> is not a currently-active connection, then this function does nothing. Output is normally written to connections only between tasks, not during execution.
2

2
The server will not queue an arbitrary amount of output for a connection; the `MAX_QUEUED_OUTPUT' compilation option (in `options.h') controls the limit. When an attempt is made to enqueue output that would take the server over its limit, it first tries to write as much output as possible to the connection without having to wait for the other end. If that doesn't result in the new output being able to fit in the queue, the server starts throwing away the oldest lines in the queue until the new output will fit. The server remembers how many lines of output it has `flushed' in this way and, when next it can succeed in writing anything to the connection, it first writes a line like `>> Network buffer overflow; X lines of output to you have been lost <<' where <X> is the number of of flushed lines.
2

2
If <no-flush> is provided and true, then `notify()' never flushes any output from the queue; instead it immediately returns false. `Notify()' otherwise always returns true.
36
5
4
2
2
*forward*
2
connected_seconds()
36
5
4
4
2
Syntax:  connected_seconds (obj <player>)   => int
2
              idle_seconds (obj <player>)   => int
2

2
These functions return the number of seconds that the currently-active connection to <player> has existed and been idle, respectively.  If <player> is not the object number of a player object with a currently-active connection, then E_INVARG is raised.
36
5
4
3
2
Syntax:  connected_players ([include-all])   => LIST
2

2
Returns a list of the object numbers of those player objects with currently-active connections. If <include-all> is provided and true, includes the object numbers associated with all current connections, including those that are outbound and/or not yet logged-in.
36
5
4
7
2
Syntax:  set_player_flag (OBJ <object>, <value>)   => none
2

2
Confers or removes the ``player object'' status of the given <object>, depending upon the truth value of <value>.  If <object> is not valid, E_INVARG is raised.  If the programmer is not a wizard, then E_PERM is raised.
2

2
If <value> is true, then <object> gains (or keeps) "player object" status: it will be an element of the list returned by `players()', the expression `is_player(<object>)' will return true, and users can connect to <object> by name when they log into the server.
2

2
If <value> is false, the <object> loses (or continues to lack) "player object" status: it will not be an element of the list returned by `players()', the expression `is_player(<object>)' will return false, and users cannot connect to <object> by name when they log into the server.  In addition, if a user is connected to <object> at the time that it loses ``player object'' status, then that connection is immediately broken, just as if `boot_player(<object>)' had been called (see the description of `boot_player()' below).
36
5
4
3
2
Syntax:  is_player (OBJ <object>)   => INT
2

2
Returns a true value if the given <object> is a player object and a false value otherwise.  If <object> is not valid, E_INVARG is raised.
36
5
4
3
2
Syntax:  players ()   => list
2

2
Returns a list of the object numbers of all player objects in the database.
36
5
4
2
2
*forward*
2
verb_code()
36
5
4
8
2
Syntax:  verb_code (OBJ <object>, STR <verb-name> [, <fully-paren> [, <indent>]])   => LIST
2
     set_verb_code (OBJ <object>, STR <verb-name>, LIST <code>)   => LIST
2

2
These functions get and set (respectively) the MOO-code program associated with the verb named <verb-name> on <object>.  The program is represented as a list of strings, one for each line of the program; this is the kind of value returned by `verb_code()' and expected as the third argument to `set_verb_code()'.  For `verb_code()', the expressions in the returned code are usually written with the minimum-necessary parenthesization; if <fully-paren> is true, then all expressions are fully parenthesized. Also for `verb_code()', the lines in the returned code are usually not indented at all; if <indent> is true, each line is indented to better show the nesting of statements.
2

2
If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised.  If the programmer does not have read (write) permission on the verb in question, then `verb_code()' (`set_verb_code()') raises E_PERM.  If the programmer is not, in fact, a programmer, then E_PERM is raised.
2

2
For `set_verb_code()', the result is a list of strings, the error messages generated by the MOO-code compiler during processing of <code>.  If the list is non-empty, then `set_verb_code()' did not install <code>; the program associated with the verb in question is unchanged.
36
5
4
3
2
Syntax:  delete_verb (obj <object>, str <verb-name>)   => none
2

2
Removes the verb named <verb-name> from the given <object>.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have write permission on <object>, then E_PERM is raised. If <object> does not define a verb named <verb-name>, then E_VERBNF is raised.
36
5
4
5
2
Syntax:  add_verb (obj <object>, list <info>, list <args>)   => int
2

2
Defines a new verb on the given <object>.  The new verb's owner, permission bits and name(s) are given by <info> in the same format as is returned by `verb_info()'.  The new verb's direct-object, preposition, and indirect-object specifications are given by <args> in the same format as is returned by `verb_args()'.  The new verb initially has the empty program associated with  it; this program does nothing but return an unspecified value.  
2

2
If <object> is not valid, or <info> does not specify a valid owner and well-formed permission bits and verb names, or <args> is not a legitimate syntax specification, then `E_INVARG' is raised.  If the programmer does not have write permission on <object> or if the owner specified by <info> is not the programmer and the programmer is not a wizard, then `E_PERM' is raised.  Otherwise, this function returns a positive integer representing the new verb's index in this object's `verbs()' list.  
36
5
4
2
2
*forward*
2
verb_args()
36
5
4
12
2
Syntax:  verb_args (OBJ <object>, STR <verb-name>)   => LIST
2
     set_verb_args (OBJ <object>, STR <verb-name>, LIST <args>)   => none
2

2
These two functions get and set (respectively) the direct-object, preposition, and indirect-object specifications for the verb named <verb-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised.  If the programmer does not have read (write) permission on the verb in question, then `verb_args()' (`set_verb_args()') raises E_PERM.  Verb args specifications have the following form:
2

2
    {<dobj>, <prep>, <iobj>}
2

2
where <dobj> and <iobj> are strings drawn from the set `"this"', `"none"', and `"any"', and <prep> is a string that is either `"none"', `"any"', or one of the prepositional phrases listed much earlier in the description of verbs in the first chapter.  This is the kind of value returned by `verb_info()' and expected as the third argument to `set_verb_info()'.  Note that for `set_verb_args()', <prep> must be only one of the prepositional phrases, not (as is shown in that table) a set of such phrases separated by `/' characters.  `Set_verb_args()' raises E_INVARG if any of the <dobj>, <prep>, or <iobj> strings is illegal.
2

2
    verb_args($container, "take")
2
                        =>   {"any", "out of/from inside/from", "this"}
2
    set_verb_args($container, "take", {"any", "from", "this"})
36
5
4
2
2
*forward*
2
verb_info()
36
5
4
8
2
Syntax:  verb_info (OBJ <object>, STR <verb-name>)   => LIST
2
     set_verb_info (OBJ <object>, STR <verb-name>, LIST <info>)   => none
2

2
These two functions get and set (respectively) the owner, permission bits, and name(s) for the verb named <verb-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised. If the programmer does not have read (write) permission on the verb in question, then `verb_info()' (`set_verb_info()') raises E_PERM.  Verb info has the following form:
2

2
    {<owner>, <perms>, <names>}
2

2
where <owner> is an object, <perms> is a string containing only characters from the set `r', `w', `x', and `d', and <names> is a string.  This is the kind of value returned by `verb_info()' and expected as the third argument to `set_verb_info()'. The latter function raises E_INVARG if <owner> is not valid, if <perms> contains any illegal characters, or if <names> is the empty string or consists entirely of spaces; it raises E_PERM if <owner> is not the programmer and the programmer is not a wizard.
36
5
4
3
2
Syntax:  verbs (OBJ <object>)   => LIST
2

2
Returns a list of the names of the verbs defined directly on the given <object>, not inherited from its parent.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have read permission on <object>, then E_PERM is raised.
36
5
4
3
2
Syntax:  delete_property (obj <object>, str <prop-name>)   => none
2

2
Removes the property named <prop-name> from the given <object> and all of its descendants.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have write permission on <object>, then E_PERM is raised.  If <object> does not directly define a property named <prop-name> (as opposed to inheriting one from its parent), then `E_PROPNF' is raised.
36
5
4
3
2
Syntax:  add_property (obj <object>, str <prop-name>, <value>, list <info>)   => none
2

2
Defines a new property on the given <object>, inherited by all of its descendants; the property is named <prop-name>, its initial value is <value>, and its owner and initial permission bits are given by <info> in the same format as is returned by `property_info()'. If <object> is not valid or <object> already has a property named <prop-name> or <info> does not specify a legitimate owner and permission bits, then E_INVARG is raised.  If the programmer does not have write permission on <object> or if the owner specified by <info> is not the programmer and the programmer is not a wizard, then E_PERM is raised.
36
5
4
2
2
*forward*
2
property_info()
36
5
4
8
2
Syntax:  property_info (OBJ <object>, STR <prop-name>)   => LIST
2
     set_property_info (OBJ <object>, STR <prop-name>, LIST <info>)   => none
2

2
These two functions get and set (respectively) the owner and permission bits for the property named <prop-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> has no non-built-in property named <prop-name>, then E_PROPNF is raised.  If the programmer does not have read (write) permission on the property in question, then `property_info()' (`set_property_info()') raises E_PERM.  Property info has the following form:
2

2
    {<owner>, <perms> [, new-name]}
2

2
where <owner> is an object and <perms> is a string containing only characters from the set `r', `w', and `c', and <new-name> is a string; <new-name> is never part of the value returned by `property_info()', but it may optionally be given as part of the value provided to `set_property_info()'.  This list is the kind of value returned by `property_info()' and expected as the third argument to `set_property_info()'; the latter function raises E_INVARG if <owner> is not valid or <perms> contains any illegal characters, or, when <new-name> is given, if <prop-name> is not defined directly on <object> or <new-name> names an existing property defined on <object> or any of its ancestors or descendants.
36
5
4
3
2
Syntax:  properties (OBJ <object>)   => LIST
2

2
Returns a list of the names of the properties defined directly on the given <object>, not inherited from its parent.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have read permission on <object>, then E_PERM is raised.
36
5
4
23
2
Syntax:  move (OBJ <what>, OBJ <where>)   => none
2

2
Changes <what>'s location to be <where>.  This is a complex process because a number of permissions checks and notifications must be performed. The actual movement takes place as described in the following paragraphs.
2

2
<what> should be a valid object and <where> should be either a valid object or `#-1' (denoting a location of 'nowhere'); otherwise E_INVARG is raised.  The programmer must be either the owner of <what> or a wizard; otherwise, E_PERM is raised.
2

2
If <where> is a valid object, then the verb-call
2

2
    <where>:accept(<what>)
2

2
is performed before any movement takes place.  If the verb returns a false value and the programmer is not a wizard, then <where> is considered to have refused entrance to <what>; `move()' raises E_NACC.  If <where> does not define an `accept' verb, then it is treated as if it defined one that always returned false.
2

2
If moving <what> into <where> would create a loop in the containment hierarchy (i.e., <what> would contain itself, even indirectly), then E_RECMOVE is raised instead.
2

2
The `location' property of <what> is changed to be <where>, and the `contents' properties of the old and new locations are modified appropriately.  Let <old-where> be the location of <what> before it was moved.  If <old-where> is a valid object, then the verb-call
2

2
    <old-where>:exitfunc(<what>)
2

2
is performed and its result is ignored; it is not an error if <old-where> does not define a verb named `exitfunc'.  Finally, if <where> and <what> are still valid objects, and <where> is still the location of <what>, then the verb-call
2

2
    <where>:enterfunc(<what>)
2

2
is performed and its result is ignored; again, it is not an error if <where> does not define a verb named `enterfunc'.
36
5
4
6
2
Syntax:  max_object ()   => obj
2

2
Returns the largest object number yet assigned to a created object.  Note that
2
the object with this number may no longer exist; it may have been recycled.
2
The next object created will be assigned the object number one larger than the
2
value of `max_object()'.
36
5
4
5
2
Syntax:  recycle (OBJ <object>)   => none
2

2
The given <object> is destroyed, irrevocably.  The programmer must either own <object> or be a wizard; otherwise, E_PERM is raised.  If <object> is not valid, then E_INVARG is raised.  The children of <object> are reparented to the parent of <object>.  Before <object> is recycled, each object in its contents is moved to `#-1' (implying a call to <object>'s `exitfunc' verb, if any) and then <object>'s `recycle' verb, if any, is called with no arguments.
2

2
After <object> is recycled, if the owner of the former object has a property named `ownership_quota' and the value of that property is a number, then `recycle()' treats that value as a "quota" and increments it by one, storing the result back into the `ownership_quota' property.
36
5
4
2
2
*forward*
2
parent()
36
5
4
4
2
Syntax:  parent (OBJ <object>)   => OBJ
2
       children (OBJ <object>)   => LIST
2

2
These functions return the parent and a list of the children of <object>, respectively.  If <object> is not valid, then E_INVARG is raised.
36
5
4
6
2
Syntax:  valid (OBJ <object>)   => INT
2

2
Returns a non-zero integer (i.e., a true value) if <object> is a valid object (one that has been created and not yet recycled) and zero (i.e., a false value) otherwise.
2

2
    valid(#0)    =>   1
2
    valid(#-1)   =>   0
36
5
4
7
2
Syntax:  chparent (obj <object>, obj <new-parent>)   => none
2

2
Changes the parent of <object> to be <new-parent>. If <object> is not valid, or if <new-parent> is neither valid nor equal to #-1, then E_INVARG is raised. If the programmer is neither a wizard or the owner of <object>, or if <new-parent> is not fertile (i.e., its `f' bit is not set) and the programmer is neither the owner of <new-parent> nor a wizard, then `E_PERM' is raised.  If <new-parent> is equal to <object> or one of its current ancestors, E_RECMOVE is raised. If <object> or one of its descendants defines a property with the same name as one defined either on <new-parent> or on one of its ancestors, then `E_INVARG' is returned.
2

2
Changing an object's parent can have the effect of removing some properties from and adding some other properties to that object and all of its descendants (i.e., its children and its children's children, etc.).  Let <common> be the nearest ancestor that <object> and <new-parent> have in common before the parent of <object> is changed.  Then all properties defined by ancestors of <object> under <common> (that is, those ancestors of <object> that are in turn descendants of <common>) are removed from <object> and all of its descendants.  All properties defined by <new-parent> or its ancestors under <common> are added to <object> and all of its descendants.  As with `create()', the newly-added properties are given the same permission bits as they have on <new-parent>, the owner of each added property is either the owner of the object it's added to (if the `c' permissions bit is set) or the owner of that property on <new-parent>, and the value of each added property is "clear"; see the description of the built-in function `clear_property()' for details.  All properties that are not removed or added in the reparenting process are completely unchanged.
2

2
If <new-parent> is equal to #-1, then <object> is given no parent at all; it becomes a new root of the parent/child hierarchy. In this case, all formerly inherited properties on <object> are simply removed.
36
5
4
22
2
Syntax:  create (obj <parent> [, obj <owner>])   => obj
2

2
Creates and returns a new object whose parent is <parent> and whose owner is as described below.  Either the given <parent> object must be fertile (i.e., its `f' bit must be set) or else the programmer must own <parent> or be a wizard; otherwise `E_PERM' is raised. `E_PERM' is also raised if <owner> is provided and not the same as the programmer, unless the programmer is a wizard.  After the new object is created, its `initialize' verb, if any, is called with no arguments.
2

2
The new object is assigned the least non-negative object number that has not yet been used for a created object.  Note that no object number is ever reused, even if the object with that number is recycled.
2

2
The owner of the new object is either the programmer (if <owner> is not provided), the new object itself (if <owner> was given as `#-1'), or <owner> (otherwise).
2

2
The other built-in properties of the new object are initialized as follows:
2
    name         ""
2
    location     #-1
2
    contents     {}
2
    programmer   0
2
    wizard       0
2
    r            0
2
    w            0
2
    f            0
2

2
In addition, the new object inherits all of the other properties on <parent>.  These properties have the same permission bits as on <parent>.  If the `c' permissions bit is set, then the owner of the property on the new object is the same as the owner of the new object itself; otherwise, the owner of the property on the new object is the same as that on <parent>.  The initial value of every inherited property is "clear"; see the description of the built-in function `clear_property()' for details.
2

2

2
If the intended owner of the new object has a property named `ownership_quota' and the value of that property is a number, then `create()' treats that value as a "quota".  If the quota is less than or equal to zero, then the quota is considered to be exhausted and `create()' raises `E_QUOTA' instead of creating an object. Otherwise, the quota is decremented and stored back into the `ownership_quota' property as a part of the creation of the new object.
36
5
4
2
2
*forward*
2
setadd()
36
5
4
10
2
Syntax:  setadd (LIST <list>, <value>)   => LIST
2
      setremove (LIST <list>, <value>)   => LIST
2

2
Returns a copy of <list> with the given <value> added or removed, as appropriate.  `Setadd()' only adds <value> if it is not already an element of <list>; <list> is thus treated as a mathematical set. <value> is added at the end of the resulting list, if at all.  Similarly, `setremove()' returns a list identical to <list> if <value> is not an element.  If <value> appears more than once in <list>, only the first occurrence is removed in the returned copy.
2

2
    setadd({1, 2, 3}, 3)         =>   {1, 2, 3}
2
    setadd({1, 2, 3}, 4)         =>   {1, 2, 3, 4}
2
    setremove({1, 2, 3}, 3)      =>   {1, 2}
2
    setremove({1, 2, 3}, 4)      =>   {1, 2, 3}
2
    setremove({1, 2, 3, 2}, 2)   =>   {1, 3, 2}
36
5
4
8
2
Syntax:  listset (LIST <list>, <value>, INT <index>)   => LIST
2

2
Returns a copy of <list> with the <index>th element replaced by <value>.  If <index> is not in the range `[1..length(<list>)]', then E_RANGE is raised.
2

2
    x = {"foo", "bar", "baz"};
2
    listset(x, "mumble", 2)   =>   {"foo", "mumble", "baz"}
2

2
This function exists primarly for historical reasons; it was used heavily before the server supported indexed assignments like x[i] = v. New code should always use indexed assignment instead of `listset()' wherever possible.
36
5
4
6
2
Syntax:  listdelete (LIST <list>, INT <index>)   => LIST
2

2
Returns a copy of <list> with the <index>th element removed.  If <index> is not in the range `[1..length(<list>)]', then E_RANGE is raised.
2

2
    x = {"foo", "bar", "baz"};
2
    listdelete(x, 2)   =>   {"foo", "baz"}
36
5
4
20
2
Syntax:  listinsert (LIST <list>, <value> [, INT <index>])   => list
2
         listappend (LIST <list>, <value> [, INT <index>])   => list
2

2
These functions return a copy of <list> with <value> added as a new element.  `listinsert()' and `listappend()' add <value> before and after (respectively) the existing element with the given <index>, if provided.
2

2
The following three expressions always have the same value:
2

2
    listinsert(<list>, <element>, <index>)
2
    listappend(<list>, <element>, <index> - 1)
2
    {@<list>[1..<index> - 1], <element>, @<list>[<index>..length(<list>)]}
2

2
If <index> is not provided, then `listappend()' adds the <value> at the end of the list and `listinsert()' adds it at the beginning; this usage is discouraged, however, since the same intent can be more clearly expressed using the list-construction expression, as shown in the examples below.
2

2
    x = {1, 2, 3};
2
    listappend(x, 4, 2)   =>   {1, 2, 4, 3}
2
    listinsert(x, 4, 2)   =>   {1, 4, 2, 3}
2
    listappend(x, 4)      =>   {1, 2, 3, 4}
2
    listinsert(x, 4)      =>   {4, 1, 2, 3}
2
    {@x, 4}               =>   {1, 2, 3, 4}
2
    {4, @x}               =>   {4, 1, 2, 3}
36
5
4
2
2
*forward*
2
listinsert()
36
5
4
3
2
Syntax:  strcmp (STR <str1>, STR <str2>)   => INT
2

2
Performs a case-sensitive comparison of the two argument strings.  If <str1> is lexicographically less than <str2>, the `strcmp()' returns a negative number.  If the two strings are identical, `strcmp()' returns zero.  Otherwise, `strcmp()' returns a positive number.  The ASCII character ordering is used for the comparison.
36
5
4
2
2
*forward*
2
index()
36
5
4
10
2
Syntax:  index (STR <str1>, STR <str2> [, <case-matters>])   => INT
2
        rindex (STR <str1>, STR <str2> [, <case-matters>])   => INT
2

2
The function `index()' (`rindex()') returns the index of the first character of the first (last) occurrence of <str2> in <str1>, or zero if <str2> does not occur in <str1> at all.  By default the search for an occurrence of <str2> is done while ignoring the upper/lower case distinction.  If <case-matters> is provided and true, then case is treated as significant in all comparisons.
2

2
    index("foobar", "o")        =>   2
2
    rindex("foobar", "o")       =>   3
2
    index("foobar", "x")        =>   0
2
    index("foobar", "oba")      =>   3
2
    index("Foobar", "foo", 1)   =>   0
36
5
4
12
2
Syntax:  crypt (str <text> [, str <salt>])   => str
2

2
Encrypts the given <text> using the standard UNIX encryption method.  If provided, <salt> should be a two-character string for use as the extra encryption ``salt'' in the algorithm.  If <salt> is not provided, a random pair of characters is used.  In any case, the salt used is also returned as the first two characters of the resulting encrypted string.  
2

2
Aside from the possibly-random selection of the salt, the encryption algorithm is entirely deterministic.  In particular, you can test whether or not a given string is the same as the one used to produced a given piece of encrypted text; simply extract the first two characters of the encrypted text and pass the candidate string and those two characters to `crypt()'.  If the result is identical to the given encrypted text, then you've got a match.  
2

2
    crypt("foobar")         =>   "J3fSFQfgkp26w"
2
    crypt("foobar", "J3")   =>   "J3fSFQfgkp26w"
2
    crypt("mumble", "J3")   =>   "J3D0.dh.jjmWQ"
2
    crypt("foobar", "J4")   =>   "J4AcPxOJ4ncq2"
2

2
Note: As of version 1.8.3, the entire salt (of any length) is passed to the operating system's low-level crypt function.  It is unlikely, however, that all operating systems will return the same string when presented with a longer salt.  Therefore, identical calls to `crypt()' may generate different results on different platforms, and your password verification systems will fail.  Use a salt longer than two characters at your own risk.
36
5
4
7
2
Syntax:  strsub (STR <subject>, STR <what>, STR <with> [, <case-matters>])   => STR
2

2
Replaces all occurrences in <subject> of <what> with <with>, performing string substitution.  The occurrences are found from left to right and all substitutions happen simultaneously.  By default, occurrences of <what> are searched for while ignoring the upper/lower case distinction. If <case-matters> is provided and true, then case is treated as significant in all comparisons.
2

2
    strsub("%n is a fink.", "%n", "Fred")   =>   "Fred is a fink."
2
    strsub("foobar", "OB", "b")             =>   "fobar"
2
    strsub("foobar", "OB", "b", 1)          =>   "foobar"
36
5
4
8
2
Syntax:  length (<list or string>)   => int
2

2
Returns the number of characters in <list or string>.  
2

2
    length("foo")       =>   3
2
    length("")          =>   0
2
    length({1, 2, 3})   =>   3
2
    length({})          =>   0
36
5
4
13
2
Syntax:  ctime ([INT <time>])   => str
2

2
Interprets <time> as a time, using the same representation as given in the description of `time()', and converts it into a 28-character, human-readable string in the following format:
2

2
    Mon Aug 13 19:13:20 1990 PDT
2

2
If the current day of the month is less than 10, then an extra blank appears between the month and the day:
2

2
    Mon Apr  1 14:10:43 1991 PST
2

2
If <time> is not provided, then the current time is used.
2

2
Note that `ctime()' interprets <time> for the local time zone of the computer on which the MOO server is running.
36
5
4
3
2
Syntax:  time ()   => INT
2

2
Returns the current time, represented as the number of seconds that have elapsed since midnight on 1 January 1970, Greenwich Mean Time.
36
5
4
3
2
Syntax:  random ([INT <mod>])   => INT
2

2
<Mod> must be a positive integer; otherwise, E_INVARG is raised.  An integer is chosen randomly from the range `[1..<mod>]' and returned. If <mod> is not provided, it defaults to the largest MOO integer, 2147483647.
36
5
4
3
2
Syntax:  abs (num <x>)   => num
2

2
Returns the absolute value of <x>.  If <x> is negative, then the result is `-<x>'; otherwise, the result is <x>. The number x can be either integer or floating-point; the result is of the same kind.
36
5
4
2
2
*forward*
2
min()
36
5
4
4
2
Syntax:  min (num <x>, ...)   => num
2
         max (num <x>, ...)   => num
2

2
These two functions return the smallest or largest of their arguments, respectively.  All of the arguments must be numbers of the same kind (i.e., either integer or floating-point); otherwise E_TYPE is raised.
36
5
4
8
2
Syntax:  toobj (<value>)   => OBJ
2

2
Converts the given MOO value into an object number and returns that object number.  The conversions are very similar to those for `toint()' except that for strings, the number *may* be preceded by `#'.
2

2
    toobj("34")       =>   #34
2
    toobj("#34")      =>   #34
2
    toobj("foo")      =>   #0
2
    toobj({1, 2})     -error->   E_TYPE
36
5
4
12
2
Syntax:  toint (<value>)   => INT
2
         tonum (<value>)   => INT
2

2
Converts the given MOO value into an integer and returns that integer. Floating-point numbers are rounded toward zero, truncating their fractional parts. Object numbers are converted into the equivalent integers, strings are parsed as the decimal encoding of a real number which is then converted to an integer. Errors are converted into integers obeying the same ordering (with respect to `<=' as the errors themselves.) `Toint()' raises E_TYPE if <value> is a LIST.  If <value> is a string but the string does not contain a syntactically-correct number, then `toint()' returns 0.
2

2
    toint(34.7)        =>   34
2
    toint(-34.7)       =>   34
2
    toint(#34)         =>   34
2
    toint("34")        =>   34
2
    toint("34.7")      =>   34
2
    toint(" - 34  ")   =>  -34
2
    toint(E_TYPE)      =>    1
36
5
4
13
2
Syntax:  tostr (<value>, ...)   => STR
2

2
Converts all of the given MOO values into strings and returns the concatenation of the results.
2

2
    tostr(17)                  =>   "17"
2
    tostr(1.0/3.0)             =>   "0.333333333333333"
2
    tostr(#17)                 =>   "#17"
2
    tostr("foo")               =>   "foo"
2
    tostr({1, 2})              =>   "{list}"
2
    tostr(E_PERM)              =>   "Permission denied"
2
    tostr("3 + 4 = ", 3 + 4)   =>   "3 + 4 = 7"
2

2
Note that `tostr()' does not do a good job of converting lists into strings; all lists, including the empty list, are converted into the string `"{list}"'. The function `toliteral()' is better for this purpose.
36
5
4
11
2
Syntax:  typeof (<value>)   => INT
2

2
Takes any MOO value and returns a number representing the type of <value>. The result is the same as the initial value of one of these built-in variables: `INT', `FLOAT', `STR', `LIST', `OBJ', or `ERR'.  Thus, one usually writes code like this:
2

2
    if (typeof(x) == LIST) ...
2

2
and not like this:
2

2
    if (typeof(x) == 4) ...
2

2
because the former is much more readable than the latter.
36
5
4
4
2
Syntax:  clear_property (OBJ <object>, STR <prop-name>)  => none
2
      is_clear_property (OBJ <object>, STR <prop-name>)  => INT
2

2
These two functions test for clear and set to clear, respectively, the property named <prop-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> has no non-built-in property named <prop-name>, then E_PROPNF is raised.  If the programmer does not have read (write) permission on the property in question, then `is_clear_property()' (`clear_property()') raises E_PERM. If a property is clear, then when the value of that property is queried the value of the parent's property of the same name is returned.  If the parent's property is clear, then the parent's parent's value is examined, and so on. If <object> is the definer of the property <prop-name>, as opposed to an inheritor of the property, then `clear_property()' raises E_INVARG.
36
5
4
2
2
*forward*
2
clear_property()
36
5
4
38
2
Syntax:  set_connection_option (OBJ conn, STR option, value)   => none
2

2
Controls a number of optional behaviors associated the connection <conn>. Raises `E_INVARG' if <conn> does not specify a current connection and `E_PERM' if the programmer is neither <conn> nor a wizard. Unless otherwise specified below, options can only be set (<value> is true) or unset (otherwise). The following values for <option> are currently supported:  
2

2
"binary"
2
   When set, the connection is in `binary mode', in which case both input from and output to <conn> can contain arbitrary bytes. Input from a connection in binary mode is not broken into lines at all; it is delivered to either the read() function or normal command parsing as `binary strings', in whatever size chunks come back from the operating system. (See the early section in the LambdaMOO Programmers Manual on MOO value types for a description of the binary string representation.) For output to a connection in binary mode, the second argument to `notify()' must be a binary string; if it is malformed, `E_INVARG' is raised.
2

2
   Fine point: If the connection mode is changed at any time when there is pending input on the connection, said input will be delivered as per the previous mode (i.e., when switching out of binary mode, there may be pending ``lines'' containing tilde-escapes for embedded linebreaks, tabs, tildes and other characters; when switching into binary mode, there may be pending lines containing raw tabs and from which nonprintable characters have been silently dropped as per normal mode. Only during the initial invocation of `$do_login_command()' on an incoming connection or immediately after the call to `open_network_connection()' that creates an outgoing connection is there guaranteed not to be pending input. At other times you will probably want to flush any pending input immediately after changing the connection mode.
2

2
"hold-input"
2
   When set, no input received on <conn> will be treated as a command; instead, all input remains in the queue until retrieved by calls to `read()' or until this connection option is unset, at which point command processing resumes. Processing of out-of-band input lines is unaffected by this option.
2

2
"disable-oob"
2
   When set, disables all out of band processing. All subsequent input lines until the next command that unsets this option will be made available for reading tasks or normal command parsing exactly as if the out-of-band prefix and the out-of-band quoting prefix had not been defined for this server.
2

2
"client-echo"
2
   The setting of this option is of no significance to the server. However calling `set_connection_option()' for this option sends the Telnet Protocol `WONT ECHO' or `WILL ECHO' command, depending on whether <value> is true or false, respectively. For clients that support the Telnet Protocol, this should toggle whether or not the client echoes locally the characters typed by the user. Note that the server itself never echoes input characters under any circumstances. (This option is only available under the TCP/IP networking configurations.)
2

2
"flush-command"
2
   This option is string-valued. If <value> is a non-empty string, then it becomes the new `flush' command for this connection, by which the player can flush all queued input that has not yet been processed by the server. If the string is empty, then <conn> is set to have no flush command at all. `set_connection_option' also allows specifying a non-string <value> which is equivalent to specifying the empty string. The default value of this option can be set via the property `$server_options.default_flush_command'; see the chapter in the LambdaMOO Programmers Manual on server assumptions about the database for details.
2

2
"intrinsic-commands"
2
   This option value is a list of strings, each being the name of one of the available server intrinsic commands (see the section in the LambdaMOO Programmers Manual on Command Lines That Receive Special Treatment). Commands not on the list are disabled, i.e., treated as normal MOO commands to be handled by `$do_command' and/or the built-in command parser. `set_connection_option' also allows specifying an integer <value> which, if zero, is equivalent to specifying the empty list, and otherwise is taken to be the list of all available intrinsic commands (the default setting).  
2

2
   Thus, one way to make the verbname `PREFIX' available as an ordinary command is as follows:
2

2
    set_connection_option(player, "intrinsic-commands",
2
      setremove(connection_option(player, "intrinsic-commands"), "PREFIX"));
2

2
   Note that `connection_option()' always returns the list, even if `set_connection_option' was previously called with a numeric value.  Thus,
2

2
    save = connection_option(player,"intrinsic-commands");
2
    set_connection_option(player, "intrinsic-commands, 1);
2
    full_list = connection_option(player,"intrinsic-commands");
2
    set_connection_option(player,"intrinsic-commands", save);
2
    return full_list;
2

2
   is a way of getting the full list of intrinsic commands available in the server while leaving the current connection unaffected.
36
5
4
3
2
queue_info([obj user])
2

2
Returns the number of forked tasks that <user> has at the moment.  Since it doesn't say which tasks, security is not a significant issue.  If no argument is given, then gives a list of all users with task queues in the server.  (Essentially all connected players + all open connections + all users with tasks running in the background.)
36
5
4
9
2
Syntax:  is_member (ANY value, LIST list)   => INT
2

2
Returns true if there is an element of <list> that is completely indistinguishable from <value>. This is much the same operation as "<value> in <list>" except that, unlike `in', the `is_member()' function does not treat upper- and lower-case characters in strings as equal.
2

2
Raises E_ARGS if two values are given or if more than two values are given. Raises E_TYPE if the second argument is not a list. Otherwise returns the index of <value> in <list>, or 0 if it's not in there.
2

2
  is_member(3, {3, 10, 11})                 => 1
2
  is_member("a", {"A", "B", "C"})           => 0
2
  is_member("XyZ", {"XYZ", "xyz", "XyZ"})   => 3
36
5
4
9
2
Syntax:  equal(value1, value2)   => INT
2

2
Returns true if <value1> is completely indistinguishable from <value2>. This is much the same operation as "<value1> == <value2>" except that, unlike ==, the `equal()' function does not treat upper- and lower-case characters in strings as equal.
2

2
Raises E_ARGS if none, one, or more than two arguments are given.
2

2
equal(1, 2)                   => 0
2
equal("ChIcKeN", "chicken")   => 0
2
equal("ABC123", "ABC123")     => 1
36
5
4
10
2
Syntax:  toliteral (<value>)   => STR
2

2
Returns a string containing a MOO literal expression that, when evaluated, would be equal to <value>. If no arguments or more than one argument is given, E_ARGS is raised.
2

2
Examples:
2
toliteral(43)                       =>  "43"
2
toliteral(1.0/3.0)                  =>  "0.33333333333333"
2
toliteral(#17)                      =>  "#17"
2
toliteral(E_PERM)                   =>  "E_PERM"
2
toliteral({"A", "B", {"C", 123}})   =>  "{\"A\", \"B\", {\"C\", 123}}"
36
5
4
3
2
Syntax:  value_bytes(<value>)   => INT
2

2
Returns the number of bytes of the server's memory required to store the given <value>.
36
5
4
3
2
Syntax:  acos (FLOAT <x>)   => FLOAT
2

2
Returns the arc-cosine (inverse cosine) of x, in the range [0..pi]. Raises E_INVARG if x is outside the range [-1.0..1.0].
36
5
4
3
2
Syntax:  asin (FLOAT <x>)   => FLOAT
2

2
Returns the arc-sine (inverse sine) of x, in the range [-pi/2..pi/2]. Raises E_INVARG if x is outside the range [-1.0..1.0].
36
5
4
3
2
Syntax:  atan (FLOAT <y> [, FLOAT <x>])   => FLOAT
2

2
Returns the arc-tangent (inverse tangent) of y in the range [-pi/2..pi/2] if x is not provided, or of y/x in the range [-pi..pi] if x is provided.
36
5
4
12
2
Syntax:  binary_hash (STR bin-string)   => STR
2
         string_hash (STR text)         => STR
2

2
Returns a 32-character hexadecimal string encoding the result of applying the MD5 cryptographically secure hash function to the contents of the string `text' or the binary string `bin-string'. MD5, like other such functions, has the property that, if
2

2
string_hash(x) == string_hash(y)
2

2
then, almost certainly
2

2
equal(x, y)
2

2
This can be useful, for example, in certain networking applications:  after sending a large piece of text across a connection, also send across the result of applying string_hash() to the text; if the destination site also applies string_hash() to the text and gets the same result, you can be quite confident that the large text has arrived unchanged.
36
5
4
2
2
*forward*
2
binary_hash()
36
5
4
3
2
Syntax:  buffered_output_length ([OBJ conn])   => INT
2

2
Returns the number of bytes currently buffered for output to the connection `conn'.  If conn is not provided, returns the maximum number of bytes that will be buffered up for output on any connection.
36
5
4
3
2
Syntax:  call_function (STR func-name, arg, ...)   => value
2

2
Calls the built-in function named `func-name', passing the given arguments, and returns whatever that function returns. Raises E_INVARG if func-name is not recognized as the name of a known built-in function. This allows you to compute the name of the function to call and, in particular, allows you to write a call to a built-in function that may or may not exist in the particular version of the server you're using.
36
5
4
3
2
Syntax:  ceil (FLOAT <x>)   => FLOAT
2

2
Returns the smallest integer not less than x, as a floating-point number.
36
5
4
3
2
Syntax:  connection_options (OBJ conn)   => LIST
2

2
Return a list of (<name>, <value>) pairs describing the current settings of all of the allowed options for the connection <conn>. Raises E_INVARG if <conn> does not specify a current connection and E_PERM if the programmer is neither <conn> nor a wizard.
36
5
4
3
2
Syntax:  connection_option (OBJ conn, STR name)   => value
2

2
Returns the current setting of the option <name> for the connection <conn>. Raises E_INVARG if <conn> does not specify a current connection and E_PERM if the programmer is neither <conn> nor a wizard.
36
5
4
5
2
Syntax:  cos (FLOAT x)   => FLOAT
2
         sin (FLOAT x)   => FLOAT
2
         tan (FLOAT x)   => FLOAT
2

2
Returns the cosine, sine, or tangent of <x>, respectively.
36
5
4
2
2
*forward*
2
sin()
36
5
4
2
2
*forward*
2
sin()
36
5
4
5
2
Syntax:  cosh (FLOAT x)   => FLOAT
2
         sinh (FLOAT x)   => FLOAT
2
         tanh (FLOAT x)   => FLOAT
2

2
Returns the hyperbolic cosine, sine, or tangent of <x>, respectively.
36
5
4
2
2
*forward*
2
sinh()
36
5
4
2
2
*forward*
2
sinh()
36
5
4
3
2
Syntax:  db_disk_size()   => INT
2

2
Returns the total size, in bytes, of the most recent full representation of the database as one or more disk files. Raises E_QUOTA if, for some reason, no such on-disk representation is currently available.
36
5
4
9
2
Syntax:  decode_binary (STR bin-string [, fully])   => LIST
2

2
Returns a list of strings and/or integers representing the bytes in the binary string <bin-string> in order. If <fully> is false or omitted, the list contains an integer only for each non-printing, non-space byte; all other characters are grouped into the longest possible contiguous substrings. If <fully> is proved and true, the list contains only integers, one for each byte represented in <bin-string>. Raises E_INVARG if <bin-string> is not a properly-formed binary string. (See the LambdaMOO programmer's manual on MOO value types for a full description of binary strings.)
2

2
decode_binary("foo")               =>  {"foo"}
2
decode_binary("~~foo")             =>  {"~foo"}
2
decode_binary("foo~0D~0A")         =>  {"foo", 13, 10}
2
decode_binary("foo~0Abar~0Abaz")   =>  {"foo", 10, "bar", 10, "baz"}
2
decode_binary("foo~0D~0A", 1)      =>  {102, 111, 111, 13, 10}
36
5
4
19
2
Syntax:  disassemble (OBJ object, STR verb-desc)   => LIST
2

2
Returns a (longish) list of strings giving a listing of the server's internal "compiled" form of the verb as specified by <verb-desc> on <object>. This format may indeed change from release to release, but some programmers may nonetheless find the output of `disassemble()' interesting to peruse as a way to gain a deeper appreciation of how the server works.
2

2
If <object> is not valid, then E_INVARG is raised. If <object> does not define a verb as specified by <verb-desc>, then E_VERBNF is raised. If the programmer does not have read permission on the verb in question, then disassemble() raises E_PERM.
2

2
Each line of output roughly follows the form: <frame number>: <opcode byte> <opcode arguments (if any)> <ticks?> <human readable opcode mnemonic and arguments>
2

2
For example:
2

2
1: 004 000 022	* FORK_NAMED 0 foo
2
	1: Frame number
2
	2. Opcode byte 4
2
	3. ARGUMENT 1: Forked vector number to switch to.
2
	4. ARGUMENT 2: Reference to the fork's label.
2
	5. *, indicating that the tick counter will be decremented.
2
	6. The human readable name of the opcode.
2
	7. ARGUMENT 1: The forked vector number to switch to.
2
	8. ARGUMENT 2: The name of the fork's label.
36
5
4
7
2
Syntax:  encode_binary(arg, ...)   => STR
2

2
Each argument must be an integer between 0 and 255, a string, or a list containing only legal arguments for this function. This function translates each integer and string in turn into its binary string equivalent, returning the concatenation of all these substrings into a single binary string. (See the early sections in the LambdaMOO Programmer's Manual on MOO value types for a full description of binary strings.)
2

2
encode_binary("~foo")                     =>  "~7Efoo"
2
encode_binary({"foo", 10}, {"bar", 13})   =>  "foo~0Abar~0D"
2
encode_binary("foo", 10, "bar", 13)       =>  "foo~0Abar~0D"
36
5
4
3
2
Syntax:  exp (FLOAT x)   => FLOAT
2

2
Returns `e' raised to the power of <x>.
36
5
4
3
2
Syntax:  floatstr (FLOAT x, INT precision [, scientific])   => STR
2

2
Converts <x> into a string with more control than provided by either `tostr()' or `toliteral()'. <Precision> is the number of digits to appear to the right of the decimal point, capped at 4 more than the maximum available precision, a total of 19 on most machines; this makes it possible to avoid rounding errors if the resulting string is subsequently read back as a floating-point value. If <scientific> is false or not provided, the result is a string in the form "MMMMMMM.DDDDDD", preceded by a minus sign if and only if <x> is negative. If <scientific> is provided and true, the result is a string in the form "M.DDDDDDe+EEE", again preceded by a minus sign if and only if <x> is negative.
36
5
4
3
2
Syntax:  floor (FLOAT x)   => FLOAT
2

2
Returns the largest integer not greater than x, as a floating-point number.
36
5
4
3
2
Syntax:  flush_input (OBJ conn [, show-messages])   => none
2

2
Performs the same actions as if the connection <conn>'s definied flush command had been received on that connection, i.e., removes all pending lines of input from <conn>'s queue and, if <show-messages> is provided and true, prints a messages to <conn> listing the flushed lines, if any.  See the chapter in the LambdaMOO Programmer's Manual on server assumptions about the database for more information about a connection's defined flush command.
36
5
4
3
2
Syntax:  force_input (OBJ conn, STR line [, at-front])   => none
2

2
Inserts the string <line> as an input task in the queue for the connection <conn>, just as if it had arrived as input over the network. If <at-front> is provided and true, then the new line of input is put at the front of <conn>'s queue, so that it will be the very next line of input processed even if there is already some other input in that queue. Raises E_INVARG if <conn> does not specify a current connection and E_PERM if the programmer is neither <conn> nor a wizard.
36
5
4
17
2
Syntax:  function_info ([STR name])   => LIST
2

2
Returns descriptions of the various built-in functions available on the server. If <name> is provided, only the description of the function with that name is returned. If <name> is omitted, a list of descriptions is returned, one for each function available on the server. E_INVARG is raised if <name> is provided but no function with that name is available on the server.
2

2
Each function description is a list of the following form:
2

2
  {<name>, <min-args>, <max-args>, <types>}
2

2
where <name> is the name of the built-in function, <min-args> is the minimum number of arguments that must be to the function, <max-args> is the maximum number of arguments that can be provided to the function or -1 if there is no maximum, and <types> is a list of <max-args> integers (or <min-args> if <max-args> is -1), each of which represents the type of argument required in the corresponding position. Each type number is as would be returned from the `typeof()' built-in function except that -1 indicates that any type of value is acceptable and -2 indicates that either integers or floating-point numbers may be given. For example, here are several entries from the list:
2

2
  {"listdelete", 2, 2, {4, 0}}
2
  {"suspend", 0, 1, {0}}
2
  {"server_log", 1, 2, {2, -1}}
2
  {"max", 1, -1, {-2}}
2
  {"tostr", 0, -1, {}}
2

2
`Listdelete()' takes exactly 2 arguments, of which the first must be a list (LIST == 4) and the second must be an integer (INT == 0). `Suspend()' has one optional argument that, if provided, must be an integer. `Server_log()' has one required argument that must be a string (STR == 2) and one optional argument that, if provided, may be of any type. `Max()' requires at least one argument but can take any number above that, and the first argument must be either an integer or a floating-point number; the type(s) required for any other arguments can't be determined from this description. Finally, `tostr()' takes any number of arguments at all, but it can't be determined from this description which argument types would be acceptable in which positions.
36
5
4
13
2
Syntax:  listen (OBJ object, point [, print-messages, use_ipv6])   => value
2

2
Create a new point at which the server will listen for network connections, just as it does normally. <Object> is the object whose verbs `do_login_command', `do_command', `do_out_of_band_command', `user_connected', `user_created', `user_reconnected', `user_disconnected', and `user_client_disconnected' will be called at appropriate points asthese verbs are called on #0 for normal connections. (See the chapter in the LambdaMOO Programmer's Manual on server assumptions about the database for the complete story on when these functions are called.) <Point> is a network-configuration-specific parameter describing the listening point. If <print-messages> is provided and true, then the various database-configurable messages (also detailed in the chapter on server assumptions) will be printed on connections received at the new listening point. `Listen()' returns <canon>, a `canonicalized' version of <point>, with any configuration-specific defaulting or aliasing accounted for.
2

2
This raises E_PERM if the programmer is not a wizard, E_INVARG if <object> is invalid or there is already a listening point described by <point>, and E_QUOTA if some network-configuration-specific error occurred.
2

2
For the TCP/IP configurations, <point> is a TCP port number on which to listen and <canon> is equal to <point> unless <point> is zero, in which case <canaon> is a port number assigned by the operating system.
2

2
For the local multi-user configurations, <point> is the UNIX file name to be used as the connection point and <canon> is always equal to <point>.
2

2
In the single-user configuration, there can be only one listening point at a time; <point> can be any value at all and <canon> is always zero.
2

2
If <use_ipv6> is true, the connection will listen on the IPv6 interface.  
36
5
4
9
2
Syntax:  listeners ([<obj>])  => LIST
2

2
Returns a list of maps describing all existing listening points, including the default one set up automatically by the server when it was started (unless that one has since been destroyed by a call to `unlisten()'). Each element of the list has the following keys:
2

2
[<object>, <port>, <print-messages>, <ipv6>]
2

2
where <object> is the first argument given in the call to `listen()' to create this listening point, <print-messages> is true if the third argument in that call was provided and true, <ipv6> is true if the connection is listening on the IPv6 interface, and <port> was the value returned by that call. (For the initial listening point, <object> is #0, <port> is determined by the command-line arguments or a network-configuration-specific default, and <print-messages> is true.)
2

2
An optional argument, <obj>, can be supplied to filter the list of listeners by that object only.
36
5
4
4
2
Syntax:  log (FLOAT x)     => FLOAT
2
         log10 (FLOAT x)   => FLOAT
2

2
Returns the natural or base 10 logarithm of <x>. Raises E_INVARG if <x> is not positive.
36
5
4
2
2
*forward*
2
log()
36
5
4
3
2
Syntax:  object_bytes (OBJ object)   => INT
2

2
Returns the number of bytes of the server's memory required to store the given <object>, including the space used by the values of all its non-clear properties and by the verbs and properties defined directly on the object. Raises E_INVARG if <object> is not a valid object and E_PERM if the programmer is not a wizard.
36
5
4
3
2
Syntax:  raise (code [, STR message [, value]])   => none
2

2
Raises <code> as an error in the same way as other MOO expressions, statements, and functions do. <Message>, which defaults to the value `tostr(<code>)', and <value>, which defaults to zero, are made available to any `try-except' statements to catch the error. If the error is not caught, then <message> will appear on the first line of the traceback printed to the user.
36
5
4
3
2
Syntax:  resume (INT task-id [, value])   => none
2

2
Immediately ends the suspension of the suspended task with the given <task-id>; that task's call to `suspend()' will return <value>, which defaults to zero. `Resume()' raises E_INVARG if <task-id> does not specify an existing suspended task and E_PERM if the programmer is neither a wizard nor the owner of the specified task.
36
5
4
3
2
Syntax:  task_stack (INT task-id [, include-line-numbers])  => LIST
2

2
Returns information like that returned by the `callers()' function, but for the suspended task with the given <task-id>; the <include-line-numbers> argument has the same meaning as in `callers()'. Raises E_INVARG if <task-id> does not specify an existing suspended task and E_PERM if the programmer is neither a wizard nor the owner of the specified task.
36
5
4
9
2
Syntax:  tofloat (value)   => FLOAT
2

2
Converts the given MOO value into a floating-point number and returns that number. Integers and objects numbers are converted into the corresponding integral floating-point numbers. Strings are parsed as the decimal encoding of a real number which is then represented as closely as possible as a floating-point number. Errors are first converted to integers as in `toint()' and then converted as integers are. `Tofloat()' raises E_TYPE if <value> is a LIST. If <value> is a string but the string does not contain a syntactically-correct number, then `tofloat()' raises E_INVARG.
2

2
  tofloat(34)       =>  34.0
2
  tofloat(#34)      =>  34.0
2
  tofloat("34")     =>  34.0
2
  tofloat("34.7")   =>  34.7
2
  tofloat(E_TYPE)   =>  1.0
36
5
4
2
2
*forward*
2
tonum()
36
5
4
3
2
Syntax:  trunc (FLOAT <x>)   => FLOAT
2

2
Returns the integer obtained by truncating <x> at the decimal point, as a floating-point number. For negative <x>, this is equivalent to `ceil()'; otherwise, it is equivalent to `floor()'.
36
5
4
3
2
Syntax:  unlisten (<canon>)   => none
2

2
Stop listening for connections on the point described by <canon>, which should be the second element of some element of the list returned by `listeners()'. Raises E_PERM if the programmer is not a wizard and E_INVARG if there does not exist a listener with that description.
36
5
4
3
2
Syntax:  value_hash (<value>)   => STR
2

2
Returns the same string as `string_hash(toliteral(<value>))'; see the description of `string_hash()' for details.
36
5
4
3
2
Syntax:  load_server_options ()   => none
2

2
After modifying properties on $server_options, wizards must call `load_server_options()'.  Changes made may not take effect until this function is called.  This allows the server to cache option values internally; this significantly speeds up built-in function invocation.  If the programmer is not a wizard, then E_PERM is raised.
36
5
4
8
2
Syntax:  verb_cache_stats ()   => LIST
2
         log_cache_stats ()    => none
2

2
As of version 1.8.1, the server caches verbname-to-program lookups to improve performance.  These functions respectively return or write to the server log file the current cache statistics.  For `verb_cache_stats' the return value will be a list of the form
2

2
    {<hits>, <negative_hits>, <misses>, <table_clears>, <histogram>}
2

2
though this may change in future server releases.  The cache is invalidated by any builtin function call that may have an effect on verb lookups (e.g., `delete_verb()').
36
5
4
2
2
*forward*
2
verb_cache_stats()
36
5
5
36
5
4
1
2
builtin-index
36
1
5
36
4
4
1
2
Builtin Function Help
36
5
4
32
2
A help database (in the sense of anything that is usable by $player:help()) is any object having the following two verbs:
2

2
  :find_topics(string)
2
     returns a list of strings or some boolean false value.
2

2
  :get_topic(string)
2
     given one of the strings returned by :find_topics this either
2
     returns a list of strings (text to be spewed to the player) or
2
     returns 1 to indicate that it has already taken care of printing
2
     information to the player.
2

2
$player:help() consults any .help properties that exist on the player, its ancestors, player.location and its ancestors (in that order).  These properties are assumed to have values that are objects or lists of objects, each object itself assumed to be a help database in the above sense.  The main help database ($help) is placed at the end of the list of databases to be consulted.
2

2
The Generic Help Database (this object) is the standard model help database of which the actual help database itself ($help) is an instance.  On help databases of this type, every help topic has a corresponding property, interpreted as follows:
2

2
this.(topic) = string           - one-line help text.
2
this.(topic) = {"*verb*",@args} - call this:verb(@args) to get text
2
this.(topic) = any other list   - multi-line help text
2

2
For the {"*verb*",...} form, the current verbs available are
2

2
  {"*forward*", topic2, @rest}   
2
     - get topic2 help text and then append rest.  
2
       rest may, in turn, begin with a "*verb*"...
2

2
  {"*subst*", @lines} 
2
     - all occurences of %[exp] in lines are replaced with value of exp.  
2
       exp is assumed to evaluate to a string.  Evaluation is done using 
2
       $no_one's permissions so exp can only refer to public information.
2

2
  {"*index*"}
2
     - returns a list of all topics in this database, arranged in columns.
36
5
4
2
0
107206
0
1641541193
36
1
#29
New-Prog-Log
0
2
1
46
0
0
4
0
1
45
4
0
7
init_for_core
2
173
-1
receive_message
2
173
-1
display_seq_headers display_seq_full
2
173
-1
from_msg_seq
2
173
-1
to_msg_seq
2
173
-1
%to_msg_seq subject_msg_seq
2
173
-1
%from_msg_seq
2
173
-1
1
keyword
23
2
PROGRAMMER
2
5
4
0
2
5
0
0
36
1
4
1
4
2
0
0
4
1
4
2
0
1
4
4
0
1541028136
1
2
1
98
2
Anti-Wizard
36
0
0
1
2
5
2
%n (%#) can't send to moderated list %t (%[#t]) directly.
2
5
4
0
2
5
4
0
2
5
4
1
1
2
36
1
4
0
36
1
0
2592000
36
1
0
1541028136
36
1
4
0
36
0
5
2
5
5
2
5
4
0
36
1
5
36
0
5
36
0
5
36
0
5
2
4
4
3
2
New-Prog-Log
2
New_Prog_Log
2
NPL
36
1
2
Record of who's been made a @programmer.
2
5
4
2
0
9347
0
1648488120
36
1
#30
Generic Help Database
144
36
1
-1
0
0
4
0
1
1
4
12
1
60
1
44
1
28
1
23
1
22
1
19
1
84
1
85
1
92
1
101
1
116
1
86
12
find_topics
2
173
-1
get_topic
2
173
-1
sort_topics
36
173
-1
columnize
36
173
-1
forward pass
36
173
-1
subst
36
173
-1
index
36
173
-1
initialize
2
173
-1
verbdoc
2
173
-1
dump_topic
2
173
-1
objectdoc
36
173
-1
find_index_topics
36
173
-1
2
index
index_cache
6
4
0
36
5
4
0
36
1
5
36
4
4
1
2
Generic Help Database
36
5
2
A help database of the standard form in need of a description. See `help $generic_help'...
36
5
4
2
0
13690
0
1641541193
36
1
#31
Generic Guest
16
36
1
-1
0
0
4
0
1
88
4
0
22
boot
2
173
-1
disfunc
2
173
-1
defer
2
173
-1
mail_catch_up
2
173
-1
create
36
89
-2
eject
36
173
-1
log
36
173
-1
confunc
2
173
-1
log_disconnect
2
173
-1
@last-c*onnection
2
29
-1
my_huh
2
173
-1
@read @peek
36
89
-2
set_current_folder
36
173
-1
init_for_core
2
173
-1
set_name set_aliases
2
173
-1
extra_confunc_msg
2
173
-1
do_reset
2
173
-1
@request
2
89
-2
connection_name_hash
2
173
-1
@subscribe*-quick @unsubscribed*-quick
2
89
-2
current_folder
2
173
-1
notify
2
173
-1
5
default_gender
default_description
request
extra_confunc_msg
free_to_use
95
2
neuter
36
1
4
1
2
By definition, guests appear nondescript.
36
1
0
0
2
0
2

36
5
0
1
36
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
5
5
36
5
5
36
5
5
36
1
5
36
5
5
36
4
5
36
5
5
36
5
2
%t (%[#t]) is a guest character.
36
5
4
0
36
5
5
36
5
5
36
5
5
36
4
5
36
4
5
98
1
5
98
1
5
98
1
4
2
1
90
1
89
36
1
5
2
0
5
2
0
5
2
1
0
0
36
5
5
36
5
5
36
1
5
36
1
5
36
0
5
36
1
5
2
1
0
79
36
1
5
36
4
5
2
0
5
2
0
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
2
1
0
0
36
0
1
62
36
5
0
0
2
0
5
36
5
0
1
36
5
5
36
5
5
2
1
4
4
0
0
0
0
0
0
0
0
36
0
5
2
0
5
2
0
5
2
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
4
4
1
2
Generic Guest
2
1
4
1
2
By definition, guests appear nondescript.
36
5
4
2
0
22493
0
1641541193
36
1
#32
Mr. Spell
16
36
1
-1
0
0
4
0
1
1
4
0
5
valid
36
173
-1
get_input
2
173
-1
guess_words
36
173
-1
help_msg
36
13
-1
proxy_for_core
2
173
-1
0
4
5
36
4
4
2
2
Mr. Spell
2
spell
36
5
2
For help on using the speller, use 'help spelling' and 'help @spell'.
36
5
4
2
0
6242
0
1641541193
36
1
#33
sequence utilities
16
36
1
-1
0
0
4
0
1
78
4
0
21
add remove
36
173
-1
contains
36
173
-1
complement
36
173
-1
union
36
173
-1
tostr
36
173
-1
for
2
173
-1
extract
36
173
-1
tolist
36
173
-1
from_list
36
173
-1
from_sorted_list
36
173
-1
first
36
173
-1
last
36
173
-1
size
36
173
-1
from_string
36
173
-1
firstn
36
173
-1
lastn
36
173
-1
range
36
173
-1
expand
36
173
-1
contract
36
173
-1
_union
36
173
-1
intersection
36
173
-1
0
5
4
38
2
A sequence is a set of integers (*)
2
This package supplies the following verbs:
2

2
  :add      (seq,f,t)  => seq with [f..t] interval added
2
  :remove   (seq,f,t)  => seq with [f..t] interval removed
2
  :range    (f,t)      => sequence corresponding to [f..t]
2
  {}                   => empty sequence
2
  :contains (seq,n)    => n in seq
2
  :size     (seq)      => number of elements in seq
2
  :first    (seq)      => first integer in seq or E_NONE
2
  :firstn   (seq,n)    => first n integers in seq (as a sequence)
2
  :last     (seq)      => last integer in seq  or E_NONE
2
  :lastn    (seq,n)    => last n integers in seq (as a sequence)
2

2
  :complement   (seq)         => sequence consisting of integers not in seq
2
  :union        (seq,seq,...) => union of all sequences
2
  :intersection (seq,seq,...) => intersection of all sequences
2
  :contract (seq,cseq)              (see `help $seq_utils:contract')
2
  :expand   (seq,eseq[,include])    (see `help $seq_utils:expand')
2
  
2
  :extract(seq,array)           => array[@seq]
2
  :for([n,]seq,obj,verb,@args)  => for s in (seq) obj:verb(s,@args); endfor
2

2
  :tolist(seq)            => list corresponding to seq
2
  :tostr(seq)             => contents of seq as a string
2
  :from_list(list)        => sequence corresponding to list
2
  :from_sorted_list(list) => sequence corresponding to list (assumed sorted)
2
  :from_string(string)    => sequence corresponding to string
2

2
For boolean expressions, note that
2
  the representation of the empty sequence is {} (boolean FALSE) and
2
  all non-empty sequences are represented as nonempty lists (boolean TRUE).
2

2
The representation used works better than the usual list implementation for sets consisting of long uninterrupted ranges of integers.  
2
For sparse sets of integers the representation is decidedly non-optimal (though it never takes more than double the space of the usual list representation).
2

2
(*) i.e., integers in the range [$minint+1..$maxint].  The implementation depends on $minint never being included in a sequence.
2

36
5
5
36
4
4
3
2
sequence utilities
2
seq_utils
2
squ
36
5
4
1
2
This is the sequence utilities utility package.  See `help $seq_utils' for more details.
36
5
4
2
0
23817
0
1641541193
36
1
#34
Quota-Log
0
2
1
46
0
0
4
0
1
45
4
0
1
init_for_core
2
173
-1
0
22
4
0
2
5
0
0
36
1
4
1
4
2
0
0
4
1
4
2
0
1
4
6
0
1541028153
2
Wizard (#2)
2
*Quota-Log (#34)
2
@quota Anti-Wizard (#98) 1000000 (from 20000)
2

2
Reason for quota increase: (none).
36
0
0
1
2
5
2
%n (%#) can't send to moderated list %t (%[#t]) directly.
2
5
4
0
2
5
4
0
2
5
4
1
1
2
36
1
4
0
36
1
0
2592000
36
1
0
1541028153
36
1
4
0
36
0
5
2
5
5
2
5
4
0
36
1
5
36
0
5
36
0
5
36
0
5
2
4
4
4
2
Quota-Log
2
Quota_Log
2
QL
2
Quota
36
1
2
Record of whose quota has been messed with and why.
2
5
4
2
0
2326
0
1648488120
36
1
#35
you
16
36
1
-1
0
0
4
0
1
94
4
0
5
verb_sub
36
173
-1
say_action
36
165
-1
fixpos
36
173
-1
reflexive
36
173
-1
say_action_reflexive
2
165
-1
2
conjugations
help_msg
18
4
4
4
2
2
is
2
are
4
2
2
was
2
were
4
2
2
does
2
do
4
2
2
has
2
have
36
1
4
16
2
This object is useful for announcing messages that switch between third and second person when addressed to the appropriate parties in a room.
2

2
Verbs:
2

2
  :verb_sub(STR verbspec) -> conjugates the given verb into singular form
2
  :say_action(message [,who [,thing, [,where]]]) -> appropriately pronoun 
2
      substituted message announced to where, which defaults to who.location
2
      where who defaults to player.
2
  Ex:  if player=#123 (Munchkin), dobj=#456 (Frebblebit), and iobj=#789
2
       (Bob) and they are all in the same room,
2
       $you:say_action("%N %<waves> happily to %d and %i.") would do this:
2

2
Munchkin sees:       You wave happily to Frebblebit and Bob.
2
Frebblebit sees:     Munchkin waves happily to you and Bob.
2
Bob sees:            Munchkin waves happily to Frebblebit and you.
2
Everyone else sees:  Munchkin waves happily to Frebblebit and Bob.
36
5
2
2nd
36
5
2
Yours
36
5
2
yours
36
5
2
Your
36
5
2
your
36
5
2
Yourself
36
5
2
yourself
36
5
2
You
36
5
2
you
36
5
2
You
36
5
2
you
36
5
5
36
5
5
36
4
4
1
2
you
36
5
4
1
2
An object useful for pronoun substitution for switching between third and second person.  See `help $you' for details.
36
5
4
2
0
9767
0
1641541193
36
1
#36
Hacker
19
36
1
-1
0
0
4
0
1
58
4
0
1
init_for_core
2
173
-1
0
95
5
36
1
5
36
1
5
36
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
0
0
36
1
5
36
5
5
36
5
5
36
5
5
36
1
5
36
5
5
36
4
5
36
5
5
2
1
4
1
1
2
36
5
4
0
36
5
5
36
5
5
36
5
5
36
4
5
36
4
5
98
1
5
98
1
4
0
98
1
4
2
1
90
1
89
36
1
5
2
0
5
2
0
0
2147483647
2
1
0
0
36
5
5
36
5
5
36
1
5
36
1
5
36
0
5
36
1
0
0
2
1
5
36
1
5
36
4
5
2
0
5
2
0
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
2
1
0
37331
36
0
1
-1
36
5
5
2
0
5
36
5
5
36
5
5
36
5
0
2147483647
2
1
4
4
0
100000008
0
-28350490
0
1008125633
0
1510998
36
0
5
2
0
5
2
0
5
2
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
4
4
1
2
Hacker
2
1
2
A system character used to own non-wizardly system verbs , properties, and objects in the core.
36
5
4
2
0
4196
0
1641541193
36
1
#37
Generic Database
144
36
1
-1
0
0
4
0
1
1
4
3
1
16
1
25
1
39
20
find find_key
36
173
-1
find_exact
36
173
-1
find_all find_all_keys
36
173
-1
_only
36
173
-1
_every
36
173
-1
_every_key
36
173
-1
insert
36
173
-1
delete
36
173
-1
delete2
36
173
-1
set_node
36
173
-1
make_node
2
173
-1
kill_node
2
173
-1
clearall
2
173
-1
clearall_big
36
173
-1
_kill_subtrees
36
173
-1
depth
36
173
-1
count_entries
36
173
-1
count_chars
36
173
-1
count
36
153
3
proxy_for_core
2
173
-1
3
node_perms
data
 
7
2
r
36
5
0
4
36
1
4
4
2

2

4
0
4
0
36
0
5
36
4
4
1
2
Generic Database
36
5
2
A generic `database' (well, really more like a string-indexed array if you want the truth...). See `help $generic_db' for details.
36
5
4
2
0
24015
0
1641541193
36
1
#38
Everyman
19
36
1
-1
0
0
4
0
1
40
4
0
6
eval
2
173
-1
moveto
36
173
-1
eval_d
2
173
-1
call_verb
2
173
-1
bad_eval
2
173
-1
set_*
36
173
-1
1
queued_task_limit
65
0
0
2
1
5
36
5
4
0
36
4
5
36
5
5
2
1
2
Everyman ($no_one) can not receive mail.
36
5
4
0
36
5
5
36
5
4
0
36
5
5
36
4
4
0
36
4
5
98
1
5
98
1
4
0
98
1
5
36
1
5
2
0
2

2
0
0
2147483647
2
1
0
0
36
5
5
36
5
5
36
1
5
36
1
5
36
0
5
36
1
4
0
2
1
5
36
1
5
36
4
5
2
0
5
2
0
5
36
5
5
36
5
5
36
5
5
36
5
2
... no one out there to see it.
36
5
5
36
5
5
2
1
0
-10000
36
0
1
-1
36
5
5
2
0
5
36
5
5
36
5
5
36
5
0
2147483647
2
1
4
4
0
0
0
0
0
1648488120
0
0
36
0
5
2
0
5
2
0
5
2
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
4
4
4
2
Everyman
2
everyone
2
no_one
2
noone
2
1
2
The character used for "safe" evals.
36
5
4
2
0
8606
0
1641541193
36
1
#39
Player Database
16
36
1
-1
0
0
4
0
1
37
4
0
7
load
36
173
-1
check
36
45
-1
init_for_core
36
173
-1
available
36
173
-1
suspend_restart
2
173
-1
why_bad_name
2
173
-1
insert
2
173
-1
7
stupid_names
frozen
reserved
 H
 e
 n
 Ev
14
4
28
2
with
2
using
2
at
2
to
2
in
2
into
2
on
2
onto
2
upon
2
out
2
from
2
inside
2
over
2
through
2
under
2
underneath
2
beneath
2
behind
2
beside
2
for
2
about
2
is
2
as
2
off
2
of
2
me
2
you
2
here
36
5
0
0
36
5
4
0
36
1
4
4
2

2

4
2
2
Hacker
2
housekeeper
4
2
1
36
1
71
36
1
4
4
2

2
v
4
1
2
Editor_Owner
4
1
1
96
36
1
4
4
2
o
2

4
2
2
noone
2
no_one
4
2
1
38
1
38
36
1
4
4
2
ery
2

4
2
2
everyone
2
Everyman
4
2
1
38
1
38
36
1
5
36
5
5
36
1
4
4
2

2
Hen
4
4
2
programmer
2
generic
2
Core
2
Wizard
4
4
1
98
1
98
1
98
1
2
36
0
0
0
36
4
4
3
2
player_db
2
plyrdb
2
pdb
36
5
4
2
2
A database containing all player names and aliases.  
2
See `help $player_db' for more information.
36
5
4
2
0
12464
0
1641541193
36
1
#40
Generic Mail Receiving Player
144
2
1
-1
0
0
4
0
1
100
4
2
1
88
1
38
60
mail_forward
2
173
-1
receive_message
2
173
-1
display_message
2
173
-1
parse_message_seq from_msg_seq %from_msg_seq to_msg_seq %to_msg_seq subject_msg_seq body_msg_seq kept_msg_seq unkept_msg_seq display_seq_headers display_seq_full messages_in_seq list_rmm new_message_num length_num_le length_date_le length_date_gt length_all_msgs exists_num_eq msg_seq_to_msg_num_list msg_seq_to_msg_num_string rm_message_seq undo_rmm expunge_rmm renumber keep_message_seq
2
173
-1
msg_summary_line
36
173
-1
msg_text
2
173
-1
notify_mail
2
173
-1
current_message
2
173
-1
get_current_message
2
173
-1
set_current_message
2
173
-1
make_current_message
2
173
-1
kill_current_message
2
173
-1
current_folder
2
173
-1
set_current_folder
2
173
-1
parse_folder_spec
2
173
-1
parse_mailread_cmd
2
173
-1
@mail
2
93
-2
@read @peek
2
93
-2
@next @prev
2
89
-2
@rmm*ail
2
89
-2
@renumber
2
25
-1
@unrmm*ail
2
89
-2
@send
2
93
-2
@answer @repl*y
2
89
-2
@forward
2
93
-2
@gripe
2
89
-2
@typo @bug @suggest*ion @idea @comment
2
89
-2
@skip
2
89
-2
@subscribe*-quick @unsubscribed*-quick
2
89
-2
mail_catch_up
2
173
-1
@rn check_mail_lists @subscribed @rn-full
2
13
-1
mail_option
2
173
-1
@unsub*scribe
2
89
-2
send_self_netmail
2
173
-1
@netforw*ard
2
93
-2
@@sendmail
2
89
-2
@keep-m*ail @keepm*ail
2
89
-2
my_match_recipient
2
173
-1
expire_old_messages
2
173
-1
msg_full_text
2
173
-1
@resend
2
89
-2
expirable_msg_seq
2
173
-1
format_for_netforward
2
173
-1
format_for_netforward_debug
2
173
-1
@nn
2
13
-1
@unread
2
89
-2
@refile @copym*ail
2
89
-2
@quickr*eply @qreply
2
89
-2
@mail-all-new*-mail
2
13
-1
@read-all-new*-mail @ranm
2
29
-1
@quick*send @qsend
2
89
-2
init_for_core
2
173
-1
confunc
2
173
-1
@add-notify
2
89
1
mail_notify
2
173
-1
@unsend
2
89
5
do_unsend
2
173
-1
@annotate*mail
2
89
-2
annotate_message_seq
2
173
-1
check_mail
2
173
-1
10
_mail_task
messages_going
mail_lists
mail_notify
mail_forward
mail_options
message_keep_date
messages_kept
current_message
messages
64
0
0
2
5
4
0
2
4
4
0
2
5
4
2
4
0
4
0
2
1
4
0
2
5
4
0
2
5
0
0
2
5
4
0
2
5
4
2
0
0
0
0
2
4
4
0
2
4
5
98
1
5
98
1
5
98
1
5
36
1
5
2
0
5
2
0
5
2
1
1
85
2
5
5
2
5
5
36
1
5
36
1
5
36
0
5
36
1
5
2
1
5
36
1
5
2
4
5
2
0
5
2
0
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
1
5
36
0
1
62
2
5
5
2
0
5
2
5
5
2
5
5
2
5
5
2
1
5
36
0
5
2
0
5
2
0
5
2
1
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
0
0
2
4
4
1
2
Generic Mail Receiving Player
2
1
5
2
5
4
2
0
99754
0
1648488120
36
1
#41
gender utilities
16
36
1
-1
0
0
4
0
1
78
4
0
8
set
2
173
-1
add
2
173
-1
get_pronoun
36
173
-1
get_conj*ugation
36
173
-1
_verb_plural
36
173
-1
_verb_singular
36
173
-1
_do
36
173
-1
pronoun_sub
2
173
-1
15
is_plural
have
be
pronouns
genders
ps
po
pp
pq
pr
psc
poc
ppc
pqc
prc
20
4
11
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
1
0
1
0
1
0
1
36
5
4
11
2
has
2
has
2
has
2
has
2
has
2
has
2
have
2
have
2
have
2
have
2
have
36
5
4
11
2
is
2
is
2
is
2
is
2
is
2
is
2
are
2
am
2
are
2
are
2
are
36
5
4
10
2
ps
2
po
2
pp
2
pq
2
pr
2
psc
2
poc
2
ppc
2
pqc
2
prc
36
5
4
10
2
neuter
2
male
2
female
2
either
2
Spivak
2
splat
2
plural
2
egotistical
2
royal
2
2nd
36
5
4
10
2
it
2
he
2
she
2
s/he
2
e
2
*e
2
they
2
I
2
we
2
you
36
5
4
10
2
it
2
him
2
her
2
him/her
2
em
2
h*
2
them
2
me
2
us
2
you
36
5
4
10
2
its
2
his
2
her
2
his/her
2
eir
2
h*
2
their
2
my
2
our
2
your
36
5
4
10
2
its
2
his
2
hers
2
his/hers
2
eirs
2
h*s
2
theirs
2
mine
2
ours
2
yours
36
5
4
10
2
itself
2
himself
2
herself
2
(him/her)self
2
emself
2
h*self
2
themselves
2
myself
2
ourselves
2
yourself
36
5
4
10
2
It
2
He
2
She
2
S/He
2
E
2
*E
2
They
2
I
2
We
2
You
36
5
4
10
2
It
2
Him
2
Her
2
Him/Her
2
Em
2
H*
2
Them
2
Me
2
Us
2
You
36
5
4
10
2
Its
2
His
2
Her
2
His/Her
2
Eir
2
H*
2
Their
2
My
2
Our
2
Your
36
5
4
10
2
Its
2
His
2
Hers
2
His/Hers
2
Eirs
2
H*s
2
Theirs
2
Mine
2
Ours
2
Yours
36
5
4
10
2
Itself
2
Himself
2
Herself
2
(Him/Her)self
2
Emself
2
H*self
2
Themselves
2
Myself
2
Ourselves
2
Yourself
36
5
4
18
2
Defines the list of standard genders, the default pronouns for each, and routines for adding or setting pronoun properties on any gendered object.
2

2
Properties:
2
  .genders  -- list of standard genders
2
  .pronouns -- list of pronoun properties
2
  .ps .po .pp .pq .pr .psc .poc .ppc .pqc .prc 
2
            -- lists of pronouns for each of the standard genders
2

2
  If foo is of gender this.gender[n], 
2
  then the default pronoun foo.p is this.p[n] 
2
  (where p is one of ps/po/pp/pq...)
2

2
Verbs:
2
  :set(object,newgender) -- changes pronoun properties to match new gender.
2
  :add(object[,perms[,owner]]) -- adds pronoun properties to object.
2

2
  :get_pronoun     (which,object) -- return pronoun for a given object
2
  :get_conj*ugation(verbspec,object) -- return appropriately conjugated verb
36
5
5
36
4
4
1
2
Gender_Utilities
36
5
4
1
2
This is the gender utilities utility package.  See `help $gender_utils' for more details.
36
5
4
2
0
18117
0
1641541193
36
1
#42
permissions utilities
24
2
1
-1
0
0
4
0
1
78
4
0
4
controls
2
173
-1
apply
36
173
-1
caller
2
173
-1
controls_prop*erty controls_verb
2
173
-1
0
5
4
16
2
Miscellaneous routines for permissions checking
2

2
For a complete description of a given verb, do `help $perm_utils:verbname'
2

2
:controls(who,what) -- can who write on object what
2
:controls_property(who,what,propname) -- can who write on what.propname
2
These routines check write flags and also the wizardliness of `who'.
2

2
(these last two probably belong on $code_utils)
2

2
:apply(permstring,mods)
2
  -- used by @chmod to apply changes (e.g., +x) 
2
     to a given permissions string
2

2
:caller()
2
  -- returns the first caller in the callers() stack distinct from `this'
2
5
5
2
4
5
2
5
4
1
2
This is the permissions utilities utility package.  See `help $perm_utils' for more details.
2
5
4
2
0
4950
0
1648488120
36
1
#43
time utilities
16
36
1
-1
0
0
4
0
1
78
4
0
18
day
36
13
-1
month
36
13
-1
ampm
36
13
-1
to_seconds
36
173
-1
sun
36
173
-1
from_ctime
36
173
-1
dhms dayshoursminutesseconds
36
173
-1
english_time
36
173
-1
from_day
36
173
-1
from_month
36
173
-1
dst_midnight
36
173
-1
time_sub
36
173
-1
mmddyy ddmmyy
36
173
-1
parse_english_time_interval
36
173
-1
seconds_until_date
36
165
-1
seconds_until_time
36
165
-1
rfc822_ctime
2
173
-1
mmddyyyy ddmmyyyy
36
173
-1
17
monthlens
timezones
stsd
ctcd
ct
corr
dayabbrs
days
months
monthabbrs
zones
time_units
day
hour
minute
week
month
22
4
12
0
31
0
28
0
31
0
30
0
31
0
30
0
31
0
31
0
30
0
31
0
30
0
31
36
5
4
15
4
2
2
AuEST
0
-10
4
2
2
AuCST
0
-9
4
2
2
AuWST
0
-8
4
2
2
WET
0
-1
4
2
2
GMT
0
0
4
2
2
AST
0
4
4
2
2
EDT
0
4
4
2
2
EST
0
5
4
2
2
CDT
0
5
4
2
2
CST
0
6
4
2
2
MDT
0
6
4
2
2
MST
0
7
4
2
2
PDT
0
7
4
2
2
PST
0
8
4
2
2
HST
0
10
36
5
0
2427
36
5
0
7276
36
5
0
7934
36
5
0
-122
36
5
4
7
2
Sun
2
Mon
2
Tue
2
Wed
2
Thu
2
Fri
2
Sat
36
5
4
7
2
Sunday
2
Monday
2
Tuesday
2
Wednesday
2
Thursday
2
Friday
2
Saturday
36
5
4
12
2
January
2
February
2
March
2
April
2
May
2
June
2
July
2
August
2
September
2
October
2
November
2
December
36
5
4
12
2
Jan
2
Feb
2
Mar
2
Apr
2
May
2
Jun
2
Jul
2
Aug
2
Sep
2
Oct
2
Nov
2
Dec
36
5
4
5
4
2
4
4
2
est
2
edt
2
Massachusetts
2
MA
0
10800
4
2
4
2
2
cst
2
cdt
0
7200
4
2
4
2
2
mst
2
mdt
0
3600
4
2
4
5
2
pst
2
pdt
2
California
2
CA
2
Lambda
0
0
4
2
4
1
2
gmt
0
28800
36
5
4
7
4
5
0
31536000
2
year
2
years
2
yr
2
yrs
4
5
0
2628000
2
month
2
months
2
mo
2
mos
4
5
0
604800
2
week
2
weeks
2
wk
2
wks
4
5
0
86400
2
day
2
days
2
dy
2
dys
4
5
0
3600
2
hour
2
hours
2
hr
2
hrs
4
5
0
60
2
minute
2
minutes
2
min
2
mins
4
5
0
1
2
second
2
seconds
2
sec
2
secs
36
5
0
86400
36
5
0
3600
36
5
0
60
36
5
0
604800
36
5
0
2592000
36
5
4
30
2
    Converting from seconds-since-1970    
2
dhms          (time)                 => string ...DD:HH:MM:SS
2
english_time  (time[, reference time)=> string of y, m, d, h, m, s
2

2
    Converting to seconds
2
to_seconds    ("hh:mm:ss")           => seconds since 00:00:00
2
from_ctime    (ctime)                => corresponding time-since-1970
2
from_day      (day_of_week, which)   => time-since-1970 for the given day*
2
from_month    (month, which)         => time-since-1970 for the given month*
2
    (* the first midnight of that day/month)
2
parse_english_time_interval("n1 u1 n2 u2...")
2
                                     => seconds in interval
2
seconds_until_time("hh:mm:ss")       => number of seconds from now until then
2
seconds_until_date("month",day,"hh:mm:ss",flag 
2
                                     => number of seconds from now until then
2
                                        (see verb help for details)
2

2
    Converting to some standard English formats
2
day           ([c]time)              => what day it is
2
month         ([c]time)              => what month it is
2
ampm          ([c]time[, precision]) => what time it is, with am or pm
2
mmddyy        ([c]time)              => date in format MM/DD/YY
2
ddmmyy        ([c]time)              => date in format DD/MM/YY
2

2
    Substitution
2
time_sub      (string, time)         => substitute time information
2

2
    Miscellaneous
2
sun           ([time])               => angle between sun and zenith
2
dst_midnight  (time)                 
36
5
5
36
4
4
2
2
time utilities
2
time
36
5
4
1
2
This is the time utilities utility package.  See `help $time_utils' for more details.
36
5
4
2
0
31463
0
1641541193
36
1
#44
Editor Help
16
36
1
-1
0
0
4
0
1
30
4
0
0
45
summary
edit-index
emote
say
delete
insert
view
depublish
perish
unpublish
publish
mode
enter
quit
unsubscribe
subscribe
reply-to
moo
find
edit
compile
save
showlists
subject
to
also-to
who
print
send
list
next
prev
subst
join
fill
move
copy
what
abort
done
pause
ranges
cc
uncc
not-to
51
4
11
2
You are inside an editor.  Do
2

2
look          -- for list of commands
2
what          -- to find out what you're editing.
2
list          -- to list out some portion of the text
2
say / emote   -- to add new text to whatever you're editing
2

2
help edit-index -- for a full list of editor help topics
2
help editors    -- for a general discussion about editors
2
help moo        -- for the general MOO help summary (i.e., what you get by 
2
                   typing `help' with no arguments from outside the editor).
36
5
4
2
2
*index*
2
Editor Help Topics
36
5
4
19
2
Syntax: emote <text>
2
        :<text>
2

2
(EDITOR)
2
Appends <text> to the end of the line before the insertion point.
2
The second form is equivalent to the first except that it doesn't strip leading blanks off of <text> (just as with the normal `emote' and `:' commands).
2
The insertion point is left unmoved.
2

2
    >list .
2
    _37_ Hello there
2
    ^38^ Oh, I'm fine.
2
    >:, how are you
2
    Appended to line 37.
2
    >:?
2
    Appended to line 37.
2
    >list .
2
    _37_ Hello there, how are you?
2
    ^38^ Oh, I'm fine.
2

36
5
4
17
2
Syntax: say <text>
2
        "<text>
2

2
(EDITOR)
2
Adds <text> to whatever you are editing.
2
The second form is equivalent to the first except in that it doesn't strip leading blanks off of <text> (just as with the normal `say' and `"' commands).
2

2
The added text appears as a new line at the insertion point.  The insertion point, in turn, gets moved so as to be after the added text.  For example:
2

2
    >"first line
2
    Line 1 added.
2
    >"  second line"
2
    Line 2 added.
2
    >list
2
      1: first line
2
    __2_   second line"
2
    ^^^^
36
5
4
5
2
Syntax:  del*ete [<range>] 
2

2
(EDITOR)
2
Deletes the specified range of lines
2
<range> defaults to the line *before* the current insertion point.
36
5
4
21
2
Syntax:  ins*ert [<ins>] ["<text>]
2
         .                    (`.' == `insert' without arguments)
2

2
(EDITOR)
2
Many editor commands refer to an "insertion point" which is (usually) the place right below where the most recent line was inserted.  The insertion point should really be thought of as sitting *between* lines.  In listings, the line above the insertion point is marked with `_' while the one below is marked with `^'.
2

2
The `insert' command, when given an argument, sets the insertion point.
2
If <text> is provided, a new line will be created and inserted as with `say'.
2
<ins>, both here and in other commands that require specifying an insertion point (e.g., copy/move), can be one of
2
          
2
    ^n   above line n
2
     n   above line n
2
    _n   below line n
2
     $   at the end
2
    ^$   before the last line
2
   n^$   n lines before the end
2
     .   the current insertion point  (i.e., `insert .' is a no-op)
2
    +n   n lines below the current insertion point.
2
    -n   n lines above the current insertion point.
2

2
For the truly perverse, there are other combinations that also work due to artifacts of the parsing process, but these might go away...
36
5
4
10
2
Syntax:  view <player> [<range>] [nonum]
2
         view
2

2
Prints some subset of the specified player's text.
2
Said player must have previously made his text readable with `publish'.
2
<ranges> are specified as in other commands (see `help ranges').
2
References to the insertion point refer to wherever the other player has set his/her insertion point; you have no control over it.
2
The default range is as in list.
2

2
If no arguments are given, this lists all of the players that have published anything in this editor.
36
5
4
2
2
*forward*
2
unpublish
36
5
4
2
2
*forward*
2
unpublish
36
5
4
5
2
Syntax:  unpub*lish
2
         depub*lish
2
         perish
2

2
This command reverses the effects of `publish', making your text readable only by you.
36
5
4
6
2
Syntax:  pub*lish
2

2
By default, only you (and wizards) can read the text you are editing.
2
This command makes your text readable by the entire world (see `help view').
2
This is useful if you need help from someone or if you just want to show off your programming acumen.
2
Use `unpublish' to make your text private again.
36
5
4
12
2
(NOTE EDITOR)
2
Syntax:  mode
2
         mode string
2
         mode list
2
         
2
There are (currently) two modes the note editor can be in.
2
One is string mode, in which if the text being edited is one line or less, 
2
it will be saved as a single string (or an empty string) rather than as a list.
2
The other is list mode, in which text is always saved as a list of strings.
2
The mode is set when the text is first loaded (string mode if the text is a string, list mode otherwise), but can be changed using this command.
2

2
The first form above (i.e., without any arguments) reports the current mode.
36
5
4
12
2
Syntax:  enter
2

2
(EDITOR)
2
Enters a sequence of lines at the insertion point (see `help insert').
2
This is similar to .program in that every line you type after the `enter' command is inserted verbatim into the text until you type a line with a single period (`.') on it.  This command is essentially for if you don't like the idea of putting " at the beginning of each line you type.  The only exceptions, i.e., lines that are not entered verbatim (aside from the `.' line), are
2

2
 - If you type a line whose sole text is `@abort', 
2
   that aborts this command without making any changes to the text.  
2
 - Any line whose first nonblank character is `.' and has additional text
2
   is entered but with its first `.' stripped off.  
2

2
Thus, to enter a line whose text is `@abort', you could enter it as `.@abort'.
36
5
4
7
2
Syntax:  q*uit
2
         done
2
         pause  
2

2
(EDITOR)
2
Leaves the editor.  If you have unsaved text it will be there when you return (and in fact you will not be able to do anything else with this editor until you 'abort' or save the text).
2

36
5
4
9
2
Syntax: unsubscribe from <list-name>
2
        unsubscribe <name>... from <list-name>
2

2
(MAILROOM)
2
Remove yourself from the given mailing list.
2
The second form removes arbitrary people from a mailing list.
2
You can only do this if you own whatever is being removed or you own the list.
2

2
Use the `who' command to determine if you are on a given mailing list.
36
5
4
11
2
Syntax: subscribe to <list-name>
2
        subscribe [<name>...] to <list-name>
2

2
(MAILROOM)
2
Add yourself to the given mailing list.  
2
The second form adds arbitrary people to a mailing list.
2
You can only do this if you own the list or if it is listed as [Public] and you own whatever is being added.
2

2
The first form of this command is probably obsolete since if <list-name> is public, you can already read it via `@mail on *<list-name>' and it's much better for the MOO if you do so.  `@mail-option +sticky' makes this even easier.
2

2
Use the `who' command to determine if you are on a given mailing list.
36
5
4
11
2
Syntax:  reply-to [<recipients>]
2

2
(MAIL ROOM)
2
Reports the current contents of the Reply-to: field of your message.
2
With arguments, adds (or changes) the Reply-to: field.
2

2
When someone @answers a message, the Reply-to: field is checked first when determining to whom the reply should be sent --- see `help @answer'.
2

2
To clear the Reply-to: field, do
2

2
         reply-to ""
36
5
4
2
2
*pass*
2

36
5
4
9
2
Syntax:  f*ind  /<str>[/[c][<ins>]]
2
         /<str>[/[c][<ins>]]
2

2
Searches for the first line after <ins> containing <str>.  <ins> defaults to  the current insertion point (see `help insert' for how to specify other places).  With the first form, any character (not just `/') may be used as a delimiter.
2
For the second form, you must use '/'.
2

2
The 'c' flag, if given, indicates that case is to be ignored while searching.
2

2
[Bug: With the second form, there are problems if the search string contains quotes, backslashes or a run of spaces.  The first whitespace will always be treated as a single space.  Likewise, quotes and backslashes occuring in the first word of the command (i.e., the "verb") need to be escaped with `\'.  Unfortunately it will not be possible to fix this until we get a new command parser.]
36
5
4
17
2
(VERB EDITOR)
2
Syntax:  edit <object>:<verb>
2

2
Changes what verb you are editing and loads the code for that verb
2
into the editor. 
2
Equivalent to @edit <object>:<verb>.
2

2
(NOTE EDITOR)
2
Syntax:  edit <note-object>
2
         edit <object>.<property>
2

2
Changes to a different note or a different object text property and 
2
loads its text into the editor.
2
These are equivalent to @notedit <note> or @notedit <object>.<property>
2
respectively.
2

2
For both the verb-editor and note-editor commands, <object> will match on the room you came from, though if the room you came from was another editor, then all bets are off...
36
5
4
5
2
Syntax:  compile [as <object>:<verb>]
2

2
(VERB EDITOR)
2
Installs the new program into the system if there are no syntax errors.
2
If a new object:verb is specified and actually turns out to exist, that <object>:<verb> becomes the default for subsequent compilations.
36
5
4
5
2
Syntax:  save [<note-object>]
2
         save [<object>.<property>]
2

2
(NOTE EDITOR)
2
Installs the freshly edited text.  If <note> or <object>.<property> is specified, text is installed on that note or property instead of the original one.  In addition the new note or property becomes the default for future save commands.
36
5
4
4
2
Syntax:  showlists
2

2
(MAIL ROOM)
2
Print a list of the publically available mailing lists/archives and other non-player entities that can receive mail.
36
5
4
4
2
Syntax:  subj*ect [<text>]
2

2
(MAIL ROOM)
2
Specifies a Subject: line for your message.  If <text> is "", the Subject: line is removed.
36
5
4
6
2
Syntax:  to [<recipients>]
2

2
(MAIL ROOM)
2
Specifies a new set of recipients (the To: line) for your message.
2
Recipient names not beginning with * are matched against the list of players.
2
Recipient names beginning with * are interpreted as mailing-lists/archives/other types of non-person addresses and are matched against all such publically available objects (see `help showlists').  If the list you want to use isn't in the database (i.e., isn't located in the database ($mail_agent)) you need to refer to it by object id.
36
5
4
7
2
Syntax:  also-to [<recipients>]
2

2
Synonym: cc
2

2
(MAIL ROOM)
2
Adds additional recipients to the To: line of your message.
2
Same rules apply as for the `to' command.
36
5
4
7
2
Syntax:  who 
2
         who <rcpt>...
2

2
(MAIL ROOM)
2
Invokes $mail_agent's mail-forwarding tracer and determines who (or what) is actually going to receive your message.  The resulting list will not include destinations that will simply forward the message without :receive_message()'ing a copy for themselves.
2

2
The second form expands an arbitrary list of recipients, for if e.g., you're curious about the members of particular mailing list.
36
5
4
6
2
Syntax:  pri*nt
2

2
Display your text without line numbers.
2

2
(MAIL ROOM)
2
Display your message including headers.
36
5
4
8
2
Syntax:  send
2

2
(MAIL ROOM)
2
Send the message, then exit the mail room if all of the addresses on the To: line turn out to be valid and usable (you can use the `who' command to check these in advance, though the status of recipients may change without warning).
2
If the To: line turns out to contain invalid recipients or recipients that are not usable by you, the message will not be sent and you will remain in the mail room.
2
It may be, however, that valid addresses on your To: line will forward to other addresses that are bogus; you'll receive warnings about these, but in this case your message will still be delivered to those addresses that are valid.
2

2
Note that there may be particularly long delays when sending to recipients with large forwarding/notification lists or when sending on occasions when the MOO is heavily loaded in general.  In such a case, it is possible to continue editing the message while the send is in progress; any such edits affect only the text in the editor.  In particular, the text of the message currently being sent remains as it was when you first typed the send command.  However, any editing will mark the text as "changed" meaning that you will need to explicitly `abort' or `quit' in order to leave the mail room even if the send concludes successfully.
36
5
4
8
2
Syntax:  lis*t [<range>] [nonum]
2

2
Prints some subset of the current verb text.
2
The default range is some reasonable collection of lines around the current insertion point:  currently this is 8_-8^, ie., 8 lines above the insertion point to 8 lines below it unless this runs up against the beginning or end of file, in which case we just take the first or last 16 lines, or just 1-$ if there aren't that many.  (See `help ranges' for how to specify line numbers and ranges.)
2

2
`nonum' prints without line numbers.
2

2
Yes, window heights will be customizable some day.
36
5
4
4
2
Syntax:  n*ext [n] ["<text>]
2

2
Moves the insertion point down n lines.  If <text> is provided, inserts a new line there just like `say'.
2
Equivalent to `insert +n'.  As one might expect, n defaults to 1.
36
5
4
4
2
Syntax:  p*rev [n] ["<text>]
2

2
Moves the insertion point up n lines.  If <text> is provided, a new line is inserted as with `say'.
2
Equivalent to `insert -n'.  As one might expect, n defaults to 1.
36
5
4
20
2
Syntax:  s*ubst/<str1>/<str2>[/[g][c][r][<range>]]
2

2
Substitutes <str2> for <str1>, in all of the lines of <range>.
2
Any character (not just `/') may be used to delimit the strings. 
2
If <str1> is blank, <str2> is inserted at the beginning of the line.  
2
(For inserting a string at the end of a line use emote/:).
2

2
Normally, only one substitution is done per line in the specified range, but if the 'g' flag is given, *all* instances of <str1> are replaced.
2
The 'c' flag indicates that case is not significant when searching for substitution instances.
2

2
The `r' flag means that the command will be grepped and matched using regular expressions. This is how you perform a regexp subst:
2

2
The <str1> field will be understood as a regular expression. If you are unfamiliar with regexp protocol, read `help regular-expressions'.
2
In cases where successful matches are made, the <str2> string will be run through the substitute() builtin, with the match() info as an argument, before replacing the old string.
2
So, in short. If `match(line, <str1>)' returns something, then `substitute(<str2>, match result)' is subbed in its place. The `g' and `c' arguments are still applicable.
2

2
<range> defaults to the line *before* the insertion point.
2

2
You do *not* need a space between the verb and the delimeter before <str1>.
2
[Bug: If you omit the space and the first whitespace in <str1> is a run of more than one space, those spaces get treated as one.  Likewise, quotes and backslashes occuring in the first word of the command (i.e., the "verb") need to be escaped with `\'.  The fix on this will have to wait for a new command parser.]
36
5
4
4
2
Syntax:  join        [<range>]
2
         joinliteral [<range>]
2

2
combines the lines in the specified range.  Normally, spaces are inserted and double space appears after periods and colons, but 'joinliteral' (abbreviates to 'joinl') supresses this and joins the lines as is.  <range> defaults to the two lines surrounding the insertion point.
36
5
4
3
2
Syntax:  fill [<range>] [@ c]
2

2
combines the specified lines as in join and then splits them so that no line is more than c characters (except in cases of pathological lines with very long words).  c defaults to 70.  <range> defaults to the single line preceding the insertion point.
36
5
4
6
2
Syntax:  m*ove [<range>] to <ins>
2

2
Moves the range of lines to place specified by <ins>.
2
If <ins> happens to be the current insertion point, the insertion point is moved to the end of the freshly moved lines.  If the range of lines contains the insertion point, the insertion point is carried over to the range's new location.
2

2
See `help insert' for a list of possibilities for <ins>.
36
5
4
7
2
Syntax:  c*opy [<range>] to <ins>
2

2
Copies the specified range of lines to place given by <ins>.
2
If <ins> happens to be the current insertion point, the insertion 
2
point moves to the end of the inserted lines.
2

2
See `help insert' for a list of possibilities for <ins>.
36
5
4
3
2
Syntax:  w*hat
2

2
Prints information about the editing session.
36
5
4
3
2
Syntax:  abort
2

2
Abandons this editing session and any changes.
36
5
4
2
2
*forward*
2
quit
36
5
4
2
2
*forward*
2
quit
36
5
4
20
2
Most editor commands act upon a particular range of lines.
2
Essentially, one needs to specify a first line and a last line.
2
Line numbers may be given in any of the following forms
2
  
2
  n      (i.e., the nth line of text)
2
  n^     n-th line after/below  the current insertion point
2
  n_     n-th line before/above the current insertion point
2
  n$     n-th line before the end.
2

2
In the latter three, n defaults to 1, so that `^' by itself refers to the line below the current (i.e., the line that gets `^' printed before it), and likewise for `_' while `$' refers to the last line.  Note that the usage depends on whether you are specifying a line or an insertion point (space between lines). `^5' is the space above/before line 5, while `5^' is the fifth line after/below the current insertion point.
2

2
Ranges of lines may be specified in any of the
2
following ways:
2

2
  <line>                  just that line
2
  from <line> to <line>   what it says; the following two forms are equivalent:
2
  <line>-<line>            
2
  <line> <line>
2

2
With the `from l to l' form, either the from or the to can be left off and it will default to whatever is usual for that command (usually a line above or below the insertion point).  Actually I was thinking of punting the `from'/`to' specifications entirely because they're so verbose.  Opinions?
36
5
4
2
2
*forward*
2
also-to
36
5
4
2
2
*forward*
2
not-to
36
5
4
6
2
Syntax:  not-to [<recipients>]
2

2
Synonym: uncc
2

2
(MAIL ROOM)
2
Removes the specified recipients from the To: line of your message.
36
5
5
36
5
4
1
2
edit-index
36
1
5
36
4
4
1
2
Editor Help
36
5
0
0
36
5
4
2
0
26270
0
1641541193
36
1
#45
Generic Mail Recipient
144
36
1
-1
0
0
4
0
1
1
4
5
1
34
1
29
1
14
1
70
1
61
40
set_aliases
36
173
-1
look_self
36
173
-1
is_writable_by is_annotatable_by
36
173
-1
is_readable_by
36
173
-1
is_usable_by
36
173
-1
mail_notify
36
173
-1
mail_forward
36
173
-1
moderator_forward
36
173
-1
add_forward
36
173
-1
delete_forward
36
173
-1
add_notify
36
173
-1
delete_notify
36
173
-1
receive_message
36
173
-1
ok
36
173
-1
ok_write
36
173
-1
parse_message_seq from_msg_seq %from_msg_seq to_msg_seq %to_msg_seq subject_msg_seq body_msg_seq kept_msg_seq unkept_msg_seq display_seq_headers display_seq_full messages_in_seq list_rmm new_message_num length_num_le length_date_le length_all_msgs exists_num_eq msg_seq_to_msg_num_list msg_seq_to_msg_num_string
36
173
-1
length_date_gt
36
173
-1
rm_message_seq
36
173
-1
undo_rmm expunge_rmm renumber keep_message_seq set_message_body_by_index
36
173
-1
own_messages_filter
36
173
-1
messages
36
173
-1
date_sort
36
173
-1
_fix_last_msg_date
36
173
-1
moderator_notify
36
173
-1
msg_summary_line
36
173
-1
__check
36
173
-1
__fix
2
173
-1
init_for_core
2
173
-1
initialize
2
173
-1
mail_name_old mail_name short_mail_name
36
173
-1
mail_names
36
173
-1
expire_old_messages
2
173
-1
moveto
36
173
-1
msg_full_text
36
173
-1
@set_expire
36
109
1
@register @netregister
2
109
1
@validate
36
109
0
set_name
36
173
-1
ok_annotate
2
173
-1
annotate_message_seq
2
173
-1
18
moderator_notify
last_msg_date
messages_going
moderated
moderator_forward
writers
readers
mail_notify
mail_forward
expire_period
last_used_time
messages
rmm_own_msgs
guests_can_send_here
messages_kept
registered_email
email_validated
validation_password
22
4
0
36
5
0
0
36
1
4
0
36
0
4
0
36
5
2
%n (%#) can't send to moderated list %t (%[#t]) directly.
36
5
4
0
36
5
4
0
36
5
4
0
36
1
2
%t (%[#t]) is a generic recipient.
36
1
0
2592000
36
1
0
0
36
1
4
0
36
0
0
1
36
5
0
0
36
5
4
0
36
1
2

36
0
0
1
36
0
2

36
0
5
36
4
4
1
2
Generic Mail Recipient
36
1
2
This can either be a mailing list or a mail folder, depending on what mood you're in...
36
5
4
2
0
45731
0
1641541193
36
1
#46
Mail Distribution Center
16
36
1
-1
0
0
4
5
1
17
1
29
1
34
1
61
1
70
1
1
4
0
56
resolve_addr
36
173
-1
sends_to
36
173
-1
send_message
36
173
-1
raw_send
2
173
-1
mail_forward mail_notify
36
173
-1
touch
36
173
-1
look_self
36
173
-1
acceptable
36
173
-1
check_names
36
173
-1
match_old match
36
173
-1
match_recipient
36
173
-1
match_failed
36
173
-1
make_message
36
173
-1
name
36
173
-1
name_list
36
173
-1
parse_address_field
36
173
-1
display_seq_full
2
173
-1
display_seq_headers
2
173
-1
rm_message_seq
2
173
-1
undo_rmm
2
173
-1
expunge_rmm list_rmm
2
173
-1
renumber
2
173
-1
msg_summary_line
36
173
-1
parse_message_seq
2
173
-1
_parse_from _parse_to
36
173
-1
_parse_date
36
173
-1
new_message_num
2
173
-1
length_all_msgs
2
173
-1
length_date_le
2
173
-1
length_date_gt
2
173
-1
length_num_le
2
173
-1
exists_num_eq
2
173
-1
from_msg_seq
2
173
-1
%from_msg_seq
2
173
-1
to_msg_seq
2
173
-1
%to_msg_seq
2
173
-1
subject_msg_seq
2
173
-1
body_msg_seq
2
173
-1
messages_in_seq
2
173
-1
__convert_new
2
173
-1
to_text
36
173
-1
is_readable_by is_writable_by is_usable_by
36
173
-1
reserved_pattern
36
173
-1
is_recipient
36
173
-1
keep_message_seq
2
173
-1
kept_msg_seq unkept_msg_seq
2
173
-1
msg_seq_to_msg_num_string
2
173
-1
msg_seq_to_msg_num_list
2
173
-1
send_log_message
36
173
-1
parse_misc_headers
36
173
-1
resend_message
2
173
-1
init_for_core
2
165
-1
time
36
173
-1
set_message_body_by_index
2
173
-1
get_message_body_by_index
2
173
-1
message_body_by_index
2
173
-1
9
options
reserved_patterns
player_expire_time
player_default_@mail
max_mail_notify
max_list_aliases
player_default_@unsend
last_mail_time
time_collisions
13
4
11
2
include
2
noinclude
2
all
2
sender
2
nosubject
2
expert
2
enter
2
sticky
2
@mail
2
manymsgs
2
replyto
36
5
4
0
36
1
0
2592000
36
5
2
last:15
36
5
0
15
36
5
0
8
36
5
2
last:1
2
1
0
0
36
1
4
2
0
0
0
0
36
1
5
36
4
4
2
2
Mail Distribution Center
2
Postmaster
36
5
4
5
2
This is the database of mailing-list/mail-folder objects.
2
The basic procedure for creating a new list/folder is to create a child of $mail_recipient (Generic Mail Recipient) assign it a suitable name&aliases, set a suitable .mail_forward/.mail_notify (or create suitable :mail_forward() and :mail_notify() verbs) and then teleport it here.
2

2
Avaliable aliases:
2

36
5
4
2
0
71767
0
1641541193
36
1
#47
Mail Room
16
36
1
-1
0
0
4
0
1
50
4
0
25
working_on
36
173
-1
parse_invoke
36
173
-1
init_session
36
173
-1
pri*nt
36
25
-1
message_with_headers
36
173
-1
subj*ect:
36
89
-2
set_subject
36
173
-1
sending
36
173
-1
to*:
36
89
-2
also*-to: cc*:
36
89
-2
not-to*: uncc*:
36
89
-2
parse_recipients
36
173
-1
recipient_names
36
173
-1
make_message
36
173
-1
name_list
36
173
-1
parse_msg_headers
36
173
-1
check_answer_flags
36
173
-1
reply-to*: replyto*:
36
89
-2
send
2
9
-1
who
36
29
-1
showlists
36
25
-1
unsubsc*ribe
36
89
5
retain_session_on_exit
36
173
-1
no_littering_msg
36
173
-1
local_editing_info
36
173
-1
4
replytos
recipients
subjects
sending
42
4
0
36
0
4
0
36
0
4
0
36
0
4
0
36
0
4
0
96
1
4
0
96
1
4
2
4
12
2
say
2
emote
2
lis*t
2
ins*ert
2
n*ext,p*rev
2
enter
2
del*ete
2
f*ind
2
s*ubst
2
m*ove,c*opy
2
join*l
2
fill
4
12
2
y*ank
2
w*hat
2
subj*ect
2
to
2
also-to
2
reply-to
2
showlists,unsubscribe
2
who
2
pri*nt
2
send
2
abort
2
q*uit,done,pause
36
5
4
0
36
5
2
Message body is empty.
36
5
4
8
4
2
2
subj*ect
2
[<text>]
4
2
2
to
2
[<rcpt>..]
4
2
2
also-to
2
[<rcpt>..]
4
2
2
reply-to
2
[<rcpt>..]
4
2
2
who
2
[<rcpt>..]
4
2
2
pri*nt
2

4
2
2
send
2

4
2
2
showlists,unsubscribe
2

36
5
0
0
96
1
0
1
36
5
2
You need to either SEND it or ABORT it before you can start another message.
36
5
4
8
4
2
2
sending
0
0
4
2
2
replytos
4
0
4
2
2
recipients
4
0
4
2
2
subjects
2

4
2
2
texts
4
0
4
2
2
changes
0
0
4
2
2
inserting
0
1
4
2
2
readable
0
0
96
1
2
%N flattens out into a largish postage stamp and floats away.
36
5
2
A largish postage stamp floats into the room and fattens up into %n.
36
5
4
4
2
Saving your message so that you can finish it later.
2
To come back, give the `@send' command with no arguments.
2
Please come back and SEND or ABORT if you don't intend to be working on this
2
message in the immediate future.  Keep Our MOO Clean!  No Littering!
36
5
5
36
5
5
36
5
2
You're not editing anything!
36
5
4
0
96
0
4
0
96
1
4
0
96
0
4
0
96
0
4
0
96
1
2
%L [mailing]
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
0
1
36
5
4
1
1
16500
36
4
1
-1
36
5
0
2043059065
36
5
4
0
36
4
5
36
5
5
36
5
5
36
4
4
1
2
Mail Room
36
5
5
36
5
4
2
0
31309
0
1641541193
36
1
#48
Note Editor
16
96
1
-1
0
0
4
0
1
50
4
0
12
e*dit
96
25
-1
save
96
25
-1
init_session
96
173
-1
working_on
96
173
-1
parse_invoke
96
173
-1
note_text
2
173
-1
set_note_text
2
173
-1
note_match_failed
96
173
-1
w*hat
96
9
-1
mode
96
25
-1
local_editing_info
36
173
-1
set_*
96
173
-1
2
strmode
objects
40
4
0
96
1
4
0
96
5
4
0
96
1
4
0
96
1
4
2
4
12
2
say
2
emote
2
lis*t
2
ins*ert
2
n*ext,p*rev
2
enter
2
del*ete
2
f*ind
2
s*ubst
2
m*ove,c*opy
2
join*l
2
fill
4
7
2
y*ank
2
w*hat
2
mode
2
e*dit
2
save
2
abort
2
q*uit,done,pause
96
5
4
0
96
5
2
Note is devoid of text.
96
5
4
3
4
2
2
e*dit
2
<note>
4
2
2
save
2
[<note>]
4
2
2
mode
2
[string|list]
96
5
0
0
96
1
5
96
5
2
You need to ABORT or SAVE this note before editing any other.
96
5
4
6
4
2
2
strmode
0
0
4
2
2
objects
0
0
4
2
2
texts
0
0
4
2
2
changes
0
0
4
2
2
inserting
0
1
4
2
2
readable
0
0
96
1
2
A small swarm of 3x5 index cards arrives, engulfs %n, and carries %o away.
96
5
2
A small swarm of 3x5 index cards blows in and disperses, revealing %n.
96
5
4
3
2
Partially edited text will be here when you get back.
2
To return, give the `@notedit' command with no arguments.
2
Please come back and SAVE or ABORT if you don't intend to be working on this text in the immediate future.  Keep Our MOO Clean!  No Littering!
96
5
2
Note has not been modified since the last save.
96
5
2
There are changes.
96
5
2
Use the EDIT command to select a note.
96
5
4
0
96
0
4
0
96
1
4
0
96
0
4
0
96
0
4
0
96
1
2
%L [editing notes]
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
0
1
96
5
4
1
1
5750
96
4
1
-1
96
5
0
2137271057
96
5
4
0
96
4
5
96
5
5
96
5
5
96
4
4
2
2
Note Editor
2
nedit
96
5
5
96
5
4
2
0
15810
0
1648488120
36
1
#49
Verb Editor
16
96
1
-1
0
0
4
0
1
50
4
0
13
e*dit
96
25
-1
com*pile save
96
73
-2
working_on
96
173
-1
init_session
96
173
-1
parse_invoke
96
173
-1
fetch_verb_code
2
173
-1
set_verb_code
2
173
-1
local_editing_info
2
173
-1
verb_name
2
173
-1
verb_args
2
173
-1
comment
96
89
-2
uncomment
96
89
-2
fetch_verb_args
2
173
-1
2
objects
verbnames
40
4
0
96
0
4
0
96
0
4
0
96
1
4
0
96
1
4
2
4
12
2
say
2
emote
2
lis*t
2
ins*ert
2
n*ext,p*rev
2
enter
2
del*ete
2
f*ind
2
s*ubst
2
m*ove,c*opy
2
join*l
2
fill
4
6
2
y*ank
2
w*hat
2
e*dit
2
com*pile
2
abort
2
q*uit,done,pause
96
5
4
0
96
5
2
Verb body is empty.
96
5
4
2
4
2
2
e*dit
2
<obj>:<verb>
4
2
2
com*pile
2
[as <obj>:<verb>]
96
5
0
0
96
1
5
96
5
2
You need to either COMPILE or ABORT this verb before you can start on another.
96
5
4
6
4
2
2
objects
0
0
4
2
2
verbnames
0
0
4
2
2
texts
0
0
4
2
2
changes
0
0
4
2
2
inserting
0
1
4
2
2
readable
0
0
96
1
2
You hear the bips of keyclick, the sliding of mice and the hum of computers in the distance as %n fades slowly out of view, heading towards them.
96
5
2
There are the light bips of keyclick and the sliding of mice as %n fades into view, shoving %r away from the console, which promptly fades away.
96
5
4
3
2
Keeping your verb for later work.  
2
To return, give the `@edit' command with no arguments.
2
Please come back and COMPILE or ABORT if you don't intend to be working on this verb in the immediate future.  Keep Our MOO Clean!  No Littering!
96
5
2
The verb has no pending changes.
96
5
2
You have changed the verb since last successful compile.
96
5
2
First, you have to select a verb to edit with the EDIT command.
96
5
4
0
96
0
4
0
96
1
4
0
96
0
4
0
96
0
4
0
96
1
2
%L [editing verbs]
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
0
1
96
5
4
1
1
5749
96
4
1
-1
96
5
0
665095404
96
5
4
0
96
4
5
96
5
5
96
5
5
96
4
4
4
2
Verb Editor
2
vedit
2
verbedit
2
verb edit
96
5
5
96
5
4
2
0
21037
0
1648488120
36
1
#50
Generic Editor
144
96
1
-1
0
0
4
0
1
3
4
4
1
49
1
48
1
47
1
95
71
say
96
93
-2
emote
96
93
-2
enter
96
25
-1
lis*t view
96
89
-2
ins*ert n*ext p*revious .
96
25
-1
del*ete
96
89
-2
f*ind
96
93
-2
m*ove c*opy
96
89
-2
join*literal
96
89
-2
fill
96
89
-2
pub*lish perish unpub*lish depub*lish
96
9
-1
w*hat
96
13
-1
abort
96
9
-1
done q*uit pause
96
13
-1
huh2
2
173
-1
insertion
96
173
-1
set_insertion
96
173
-1
changed retain_session_on_exit
96
173
-1
set_changed
96
173
-1
origin
96
173
-1
set_origin
96
173
-1
readable
96
173
-1
set_readable
96
173
-1
text
96
173
-1
load
96
173
-1
working_on
96
173
-1
ok
96
173
-1
loaded
96
173
-1
list_line
96
173
-1
insert_line
96
173
-1
append_line
96
173
-1
join_lines
96
173
-1
parse_number
96
173
-1
parse_range
96
173
-1
parse_insert
96
173
-1
parse_subst
96
173
-1
invoke
96
173
-1
suck_in
96
173
-1
new_session
2
173
-1
kill_session
2
173
-1
reset_session
2
173
-1
kill_all_sessions
2
173
-1
acceptable
96
173
-1
enterfunc
96
173
-1
exitfunc
96
173
-1
@flush
96
109
-2
@stateprop
96
153
11
@rmstateprop
96
153
5
initialize
96
173
-1
init_for_core
2
173
-1
set_stateprops
96
173
-1
description
96
173
-1
commands_info
96
173
-1
match_object
96
173
-1
who_location_msg
96
173
-1
nothing_loaded_msg no_text_msg change_msg no_change_msg no_littering_msg depart_msg return_msg previous_session_msg
96
173
-1
announce announce_all announce_all_but tell_contents
96
173
-1
fill_string(noansi)
96
173
-1
here_huh
96
173
-1
match
2
173
-1
get_room
96
173
-1
invoke_local_editor
2
173
-1
_stateprop_length
2
173
-1
print
2
9
-1
accept
96
173
-1
y*ank
2
89
-2
do_flush
96
173
-1
s*ubst
96
93
-2
subst_regexp
96
173
-1
include_for_core
96
173
-1
fill_string
2
165
-1
21
readable
times
commands2
help
no_text_msg
commands
invoke_task
exit_on_abort
previous_session_msg
stateprops
depart_msg
return_msg
no_littering_msg
no_change_msg
change_msg
nothing_loaded_msg
texts
active
changes
inserting
original
38
4
0
96
1
4
0
96
1
4
2
4
11
2
say
2
emote
2
lis*t
2
ins*ert
2
n*ext,p*rev
2
del*ete
2
f*ind
2
s*ubst
2
m*ove,c*opy
2
join*l
2
fill
4
4
2
y*ank
2
w*hat
2
abort
2
q*uit,done,pause
96
5
1
44
96
5
2
There are no lines of text.
96
5
4
16
4
2
2
say
2
<text>
4
2
2
emote
2
<text>
4
2
2
lis*t
2
[<range>] [nonum]
4
2
2
ins*ert
2
[<ins>] ["<text>]
4
2
2
n*ext,p*rev
2
[n] ["<text>]
4
2
2
del*ete
2
[<range>]
4
2
2
f*ind
2
/<str>[/[c][<range>]]
4
2
2
s*ubst
2
/<str1>/<str2>[/[g][c][r][<range>]]
4
2
2
m*ove,c*opy
2
[<range>] to <ins>
4
2
2
join*l
2
[<range>]
4
2
2
fill
2
[<range>] [@<col>]
4
2
2
w*hat
2

4
2
2
abort
2

4
2
2
q*uit,done,pause
2

4
2
2
enter
2

4
2
2
y*ank
2
from <text-source>
96
5
0
0
96
1
0
0
96
5
2

96
5
4
4
4
2
2
texts
0
0
4
2
2
changes
0
0
4
2
2
inserting
0
1
4
2
2
readable
0
0
96
1
2
%N heads off to the Generic Editing Room.
96
5
2
%N comes back from the Generic Editing Room.
96
5
2
Keeping your [whatever] for later work.  Since this the Generic Editor, you have to do your own :set_changed(0) so that we'll know to get rid of whatever it you're working on when you leave.  Please don't litter... especially in the Generic Editor.
96
5
2
There have been no changes since the last save.
96
5
2
Text has been altered since the last save.
96
5
2
You're not currently editing anything.
96
5
4
0
96
0
4
0
96
1
4
0
96
0
4
0
96
0
4
0
96
1
2
%L [editing]
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
0
1
96
5
4
1
1
5751
96
4
1
-1
96
5
0
1399008566
96
5
5
96
4
5
96
5
5
96
5
5
96
4
4
3
2
Generic Editor
2
gedit
2
edit
96
5
4
0
96
5
4
2
0
77149
0
1648488120
36
1
#51
matching utilities
16
36
1
-1
0
0
4
0
1
78
4
0
8
match
36
173
-1
match_nth
36
173
-1
match_verb
2
173
-1
match_list
36
173
-1
parse_ordinal_reference parse_ordref
36
173
-1
parse_possessive_reference
36
173
-1
object_match_failed
36
165
-1
init_for_core
2
173
-1
4
ordn
ordw
ordinal_regexp
matching_room
9
4
10
2
first
2
second
2
third
2
fourth
2
fifth
2
sixth
2
seventh
2
eighth
2
ninth
2
tenth
36
5
4
10
2
1st
2
2nd
2
3rd
2
4th
2
5th
2
6th
2
7th
2
8th
2
9th
2
10th
36
5
2
%<%(first%|second%|third%|fourth%|fifth%|sixth%|seventh%|eighth%|ninth%|tenth%|1st%|2nd%|3rd%|4th%|5th%|6th%|7th%|8th%|9th%|10th%)%>
36
5
1
-1
36
1
4
11
2
$match_utils defines the following verbs:
2

2
match
2
match_nth
2
match_verb
2
match_list
2
parse_ordinal_reference (alias parse_ordref)
2
parse_possessive_reference
2
object_match_failed
2

2
For more documentation, see help $match_utils:<specific verb>.
36
5
5
36
4
4
1
2
matching utilities
36
5
5
36
5
4
2
0
12908
0
1641541193
36
1
#52
object utilities
16
2
1
-1
0
0
4
0
1
78
4
0
31
has_property
2
173
-1
all_properties all_verbs
2
173
-1
has_verb
2
173
-1
has_callable_verb
2
173
-1
match_verb
2
173
-1
isa
36
173
-1
ancestors
36
173
-1
ordered_descendants
36
173
-1
contains
36
173
-1
all_contents
36
173
-1
findable_properties
2
173
-1
owned_properties
2
173
-1
property_conflicts
2
173
-1
descendants_with_property_suspended
2
173
-1
locations
2
173
-1
all_properties_suspended all_verbs_suspended
2
173
-1
connected
36
173
-1
isoneof
36
173
-1
defines_verb
2
173
-1
defines_property
2
173
-1
has_any_verb has_any_property
2
173
-1
has_readable_prop*erty hrp
2
173
-1
descendants descendents
36
173
-1
leaves
36
173
-1
branches
36
173
-1
descendants_suspended descendents_suspended
2
173
-1
leaves_suspended
2
173
-1
branches_suspended
2
173
-1
disown disinherit
2
173
-1
accessible_verbs
2
173
-1
accessible_prop*erties accessible_props
2
173
-1
0
5
4
45
2
These routines are useful for finding out information about individual objects.
2

2
Examining everything an object has defined on it:
2
  all_verbs          (object) => like it says
2
  all_properties     (object) => likewise
2
  findable_properties(object) => tests to see if caller can "find" them
2
  owned_properties   (object[, owner]) => tests for ownership
2

2
Investigating inheritance:
2
  ancestors(object[,object...]) => all ancestors
2
  descendants      (object)     => all descendants
2
  ordered_descendants(object)   => descendants, in a different order
2
  leaves           (object)     => descendants with no children
2
  branches         (object)     => descendants with children 
2
  isa        (object,class) => true iff object is a descendant of class (or ==)
2
  property_conflicts (object,newparent) => can object chparent to newparent?
2
  isoneof     (object,list)     => true if object :isa class in list of parents
2

2
Considering containment:
2
  contains      (obj1, obj2) => Does obj1 contain obj2 (nested)?
2
  all_contents      (object) => return all the (nested) contents of object
2
  locations         (object) => list of location hierarchy above object
2

2
Verifying verbs and properties:
2
  has_property(object,pname) => false/true   according as object.(pname) exists
2
  has_readable_property(object,pname) => false/true if prop exists and is +r
2
  defines_property(object,pname) => does object *define* this property
2
  has_verb    (object,vname) => false/{#obj} according as object:(vname) exists
2
  has_callable_verb          => same, but verb must be callable from a program
2
  defines_verb(object,vname) => does this object *define* this verb
2
  match_verb  (object,vname) => false/{location, newvname}
2
                               (identify location and usable name of verb)
2
  accessible_verbs(object)   => a list of verb names (or E_PERM) regardless of 
2
                                readability of object
2

2
Player checking:
2
  connected         (object) => true if object is a player and is connected
2

2
Suspending:
2
  Many of the above verbs have ..._suspended versions to assist with very large object hierarchies.  The following exist:
2
   descendants_suspended              
2
   branches_suspended                 
2
   leaves_suspended                   
2
   all_properties_suspended           
2
   descendants_with_property_suspended
2
5
5
2
4
4
1
2
object utilities
2
5
4
1
2
This is the object utilities utility package.  See `help $object_utils' for more details.
2
5
4
2
0
31061
0
1648488120
36
1
#53
lock utilities
16
2
1
-1
0
0
4
0
1
78
4
0
11
init_scanner
2
173
-1
scan_token
2
173
-1
canonicalize_spaces
2
173
-1
parse_keyexp
2
173
-1
parse_E
2
173
-1
parse_A
2
173
-1
eval_key
2
173
-1
match_object
2
173
-1
unparse_key
2
173
-1
eval_key_new
2
173
-1
parse_A_new
2
173
-1
5
player
input_index
input_length
input_string
index_incremented
10
0
0
2
5
0
0
2
5
0
0
2
5
2

2
5
0
0
2
5
4
13
2
These routines are used when locking objects, and when testing an object's lock before allowing use (such as in an exit).
2

2
:parse_keyexp   (string keyexpression, object player)
2
        => returns an object or list for the new key as defined by the
2
           keyexpression or a string describing the error if it failed.
2

2
:eval_key       (LIST|OBJ key, testobject)
2
        => returns true if the given testobject satisfies the key.
2

2
:unparse_key    (LIST|OBJ key)
2
        => returns a string describing the key in english/moo-code terms.
2

2
For more information on keys and locking, read `help locking', `help keys', and `help @lock'.
2
5
5
2
4
4
1
2
lock utilities
2
5
2
This the lock utilities package, used by the MOOwide locking mechanisms. See `help $lock_utils' for more details.
2
5
4
2
0
13652
0
1648488120
36
1
#54
generic letter
144
2
1
-1
0
0
4
0
1
9
4
0
3
burn
2
41
-1
burn_succeeded_msg oburn_succeeded_msg burn_failed_msg oburn_failed_msg
2
173
-1
do_burn
2
173
-1
4
oburn_succeeded_msg
oburn_failed_msg
burn_failed_msg
burn_succeeded_msg
19
2
stares at %t; %[tps] bursts into flame and disappears, leaving no ash.
2
5
0
0
2
5
2
%T might be damp.  In any case, %[tps] won't burn.
2
5
2
%T burns with a smokeless flame and leaves no ash.
2
5
5
2
5
5
36
4
5
2
4
5
2
5
5
2
5
5
2
5
5
2
5
5
36
5
5
36
5
5
36
5
2
This is a private letter.
36
5
5
36
4
4
1
2
generic letter
36
5
2
Some writing on the letter explains that you should 'read letter', and when you've finished, 'burn letter'.
36
5
4
2
0
3699
0
1648488120
36
1
#55
list utilities
16
36
1
-1
0
0
4
0
1
78
4
0
43
make
36
173
-1
range
36
173
-1
map_prop*erty
2
173
-1
map_verb
2
173
-1
map_arg*s
2
173
-1
map_builtin
2
173
-1
find_insert
36
173
-1
remove_duplicates
36
173
-1
arrayset
36
173
-1
setremove_all
36
173
-1
append
36
173
-1
reverse
36
173
-1
_reverse
36
173
-1
compress
36
173
-1
sort
36
173
-1
sort_suspended
2
173
-1
slice
36
173
-1
assoc
36
173
-1
iassoc
36
173
-1
iassoc_suspended
2
173
-1
assoc_prefix
36
173
-1
iassoc_prefix
36
173
-1
iassoc_sorted
36
173
-1
sort_alist
36
173
-1
sort_alist_suspended
2
173
-1
randomly_permute
36
173
-1
count
2
173
-1
flatten
36
173
-1
longest shortest
36
173
-1
reverse_suspended
2
173
-1
_reverse_suspended
2
173
-1
randomly_permute_suspended
2
173
-1
swap_elements
36
173
-1
random_item random_element
36
173
-1
assoc_suspended
2
173
-1
amerge
36
173
-1
passoc
36
165
-1
setmove
36
173
-1
iassoc_new
36
173
-1
build_alist
36
173
-1
flatten_suspended
36
173
-1
max_length
2
165
-1
make_alist
2
173
-1
0
5
4
45
2
append            (list,list,..) => result of concatenating the given lists
2
reverse           (list)         => reversed list
2
remove_duplicates (list)         => list with all duplicates removed
2
compress          (list)         => list with consecutive duplicates removed
2
setremove_all     (list,elt)     => list with all occurrences of elt removed
2
find_insert       (sortedlist,e) => index of first element > e in sortedlist
2
sort              (list[,keys])  => sorted list
2
count             (elt,list)     => count of elt found in list.
2
flatten           (list)         => flatten all recursive lists into one list
2
randomly_permute  (list)         => list with elements randomly permuted
2
longest           (list)         => longest in list (consisting of str or list)
2
shortest          (list)         => shortest in list (as above)
2

2
make              (n[,e])        => list of n copies of e
2
range             (m,n)          => {m,m+1,...,n}
2

2
arrayset   (list,val,i[,j,k...]) => array modified so that list[i][j][k]==val
2

2
-- Mapping functions (take a list and do something to each element):
2

2
map_prop ({o...},prop)              => list of o.(prop)            for all o
2
map_verb ({o...},verb[,args])        => list of o:(verb)(@args)     for all o
2
map_arg  ([n,]obj,verb,{a...},args) => list of obj:(verb)(a,@args) for all a
2
map_builtin (objectlist, function)  => applies function to all in objectlist
2

2
-- Association list functions --
2

2
An association list (alist) is a list of pairs (2-element lists), though the following functions have been generalized for lists of n-tuples (n-element lists).  In each case i defaults to 1.
2

2
assoc        (targ,alist[,i]) => 1st tuple in alist whose i-th element is targ
2
iassoc       (targ,alist[,i]) => index of same.
2
assoc_prefix (targ,alist[,i]) => ... whose i-th element has targ as a prefix
2
iassoc_prefix(targ,alist[,i]) => index of same.
2
iassoc_sorted(targ,slist[,i]) => index of last element in sortedlist <= targ
2
slice             (alist[,i]) => list of i-th elements
2
sort_alist        (alist[,i]) => alist sorted on i-th elements.
2
amerge  (alist,[tind,[dind]]) => merges tuples of alist with matching i-th elt
2
build_alist          (list,N) => make an alist of N-intervals from list
2

2
-- Functions that suspend --
2

2
Each of these either suspends(0) as needed or takes an interval in seconds for the suspend as a first argument. See help $list_utils:<verb>.
2

2
sort_suspended          iassoc_suspended          sort_alist_suspended
2
reverse_suspended       randomly_permute_suspended
36
5
5
36
4
4
1
2
list_utilities
36
5
4
1
2
This is the list utilities utility package.  See `help $list_utils' for more details.
36
5
4
2
0
42043
0
1641541193
36
1
#56
command utilities
16
2
1
-1
0
0
4
0
1
78
4
0
17
object_match_failed
2
173
-1
player_match_result player_match_failed
2
173
-1
read
2
173
-1
read_lines
2
173
-1
yes_or_no
2
173
-1
read_lines_escape
2
173
-1
suspend
2
173
-1
running_out_of_time
36
173
-1
suspend_if_needed
2
173
-1
dump_lines
36
173
-1
explain_syntax
2
173
-1
do_huh
2
165
-1
task_info
2
173
-1
init_for_core
2
173
-1
kill_if_laggy
36
173
-1
validate_feature
36
173
-1
reading_input
2
173
-1
2
lag_samples
feature_task
7
4
0
2
1
4
9
0
433306530
2
1
4
2
2
|.
2
2
2
|. 2
1
-3
2
|. 2
2

1
-1
2

36
0
4
38
2
$command_utils is the repository for verbs that are of general usefulness to authors of all sorts of commands.  For more details about any of these verbs, use `help $command_utils:<verb-name>'.
2

2
Detecting and Handling Failures in Matching
2
-------------------------------------------
2
:object_match_failed(match_result, name)
2
    Test whether or not a :match_object() call failed and print messages if so.
2
:player_match_failed(match_result, name)
2
    Test whether or not a :match_player() call failed and print messages if so.
2
:player_match_result(match_results, names)
2
    ...similar to :player_match_failed, but does a whole list at once.
2

2
Reading Input from the Player
2
-----------------------------
2
:read()         -- Read one line of input from the player and return it.
2
:yes_or_no([prompt])
2
                -- Prompt for and read a `yes' or `no' answer.
2
:read_lines()   -- Read zero or more lines of input from the player.
2
:dump_lines(lines) 
2
                -- Return list of lines quoted so that feeding them to 
2
                   :read_lines() will reproduce the original lines.
2
:read_lines_escape(escapes[,help])
2
                -- Like read_lines, except you can provide more escapes
2
                   to terminate the read.
2

2
Feature Objects
2
---------------
2
:validate_feature -- compare command line against feature verb argument spec
2

2
Utilities for Suspending
2
------------------------
2
:running_out_of_time()
2
                -- Return true if we're low on ticks or seconds.
2
:suspend_if_needed(time)
2
                -- Suspend (and return true) if we're running out of time.
2

2
Client Support for Lengthy Commands
2
-----------------------------------
2
:suspend(args)  -- Handle PREFIX and SUFFIX for clients in long commands.
2
5
5
2
4
5
2
5
4
1
2
This is the command utilities utility package.  See `help $command_utils' for more details.
2
5
4
2
0
26184
0
1648488120
36
1
#57
generic wizard
16
2
1
-1
0
0
4
0
1
58
4
1
1
2
40
@chown*#
2
89
-2
@shout
2
89
-2
@grant @grants* @transfer
2
89
1
@programmer
2
25
-1
make-core-database
2
25
-1
@shutdown
2
89
-2
@dump-d*atabase
2
9
-1
@who-calls
2
89
-2
mcd_2
2
13
-1
@toad @toad! @toad!!
2
89
-2
@untoad @detoad
2
89
-2
@quota
2
89
12
@players
2
89
-2
kill_aux_wizard_parse
2
173
-1
@grepcore @egrepcore
2
89
-2
@net-who @@who
2
89
-2
@make-player
2
89
-2
@abort-sh*utdown
2
89
-2
toad_msg toad_victim_msg programmer_msg programmer_victim_msg newt_msg newt_victim_msg
2
173
-1
moveto
2
173
-1
@newt
2
89
-2
@unnewt @denewt @get-better
2
89
-2
@register
2
89
-2
@new-password @newpassword
2
89
12
@log
2
89
-2
@guests
2
25
-1
@rn mail_catch_up check_mail_lists current_message set_current_message get_current_message make_current_message kill_current_message @nn
2
13
-1
@blacklist @graylist @redlist @unblacklist @ungraylist @unredlist @spooflist @unspooflist
2
89
-2
@corify
2
89
13
@make-guest
2
25
-1
@temp-newt
2
89
11
@deprog*rammer
2
89
-2
display_list
2
173
-1
parse_templist_duration
36
173
-1
check_site_entries
2
173
-1
@lock-login @unlock-login @lock-login!
2
89
-2
__fix
2
173
-1
toad_cleanup
2
173
-1
@code-replace
2
9
-1
@update-toaststunt-help
2
89
-2
9
newt_victim_msg
newt_msg
public_identity
programmer_msg
programmer_victim_msg
toad_victim_msg
toad_msg
mail_identity
advertised
104
2

2
5
2
%n @newts %d (%[#d])
2
5
1
-1
2
5
2
%d is now a programmer.
2
5
2
You are now a programmer.
2
5
2
Have a nice life...
2
5
2
%n @toads %d (%[#d])
2
5
1
-1
2
4
0
1
2
5
5
36
1
5
36
1
5
36
1
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
2
5
5
2
5
5
2
5
5
36
1
5
2
5
5
2
4
5
2
5
5
2
5
5
2
5
4
0
2
5
5
2
5
5
2
5
5
2
4
5
2
4
5
98
1
5
98
1
5
98
1
4
2
1
90
1
89
36
1
5
2
0
5
2
0
5
2
1
1
23
2
5
5
2
5
5
36
1
5
36
1
5
36
0
5
36
1
5
2
1
5
36
1
5
2
4
5
2
0
5
2
0
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
1
5
36
0
1
62
2
5
2
really impossible password to type
2
0
5
2
5
5
2
5
5
2
5
5
2
1
5
36
0
5
2
0
5
2
0
5
2
1
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
4
4
1
2
player
2
1
2
You see a wizard who chooses not to reveal its true appearance.
2
5
4
2
0
85474
0
1648488120
36
1
#58
generic programmer
144
2
1
-1
0
0
4
0
1
4
4
4
1
57
1
36
1
71
1
98
39
@prop*erty
2
89
-2
@chmod*#
2
89
-2
@args*#
2
89
-2
eval*-d
2
89
-2
@rmprop*erty
2
89
-2
@verb
2
89
-2
@rmverb*#
2
25
-1
@forked*-verbose
2
25
-1
@kill @killq*uiet
2
25
-1
@copy @copy-x @copy-move
2
89
1
_kill_task_message
2
173
-1
@prog*ram @program#
2
89
-2
@setenv
2
89
-2
@pros*pectus pros*pectus
2
93
-2
@d*isplay
2
25
-1
@db*size
2
9
-1
@gethelp
2
93
-2
@grep*all @egrep*all
2
89
-2
@s*how
2
89
-2
@check-p*roperty
2
25
-1
set_eval_env
36
173
-1
@clearp*roperty @clprop*erty
2
25
-1
@disown @disinherit
2
89
-2
eval_cmd_string
2
173
-1
@dump
2
89
-2
#*
2
89
-2
eval_value_to_string
2
173
-1
@progo*ptions @prog-o*ptions @programmero*ptions @programmer-o*ptions
2
89
-2
prog_option
2
173
-1
set_prog_option
2
173
-1
@list*#
2
89
-2
set_eval_subs
2
13
-1
@verbs*
2
25
-1
@old-forked-v*erbose
2
25
-1
@props @properties
2
81
-2
@add-option
2
89
1
@ref*erence
2
89
-2
@remove-option @rmoption @rm-option
2
89
5
@toaststunt-commits @server-commits
2
9
-1
4
eval_subs
eval_ticks
eval_env
prog_options
95
4
0
36
1
0
3
36
1
2
here=player.location;me=player
36
1
4
0
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
2
5
5
2
5
5
2
5
5
36
1
5
2
5
5
2
4
5
2
5
5
2
5
5
2
5
4
0
2
5
5
2
5
5
2
5
5
2
4
5
2
4
5
98
1
5
98
1
5
98
1
4
2
1
90
1
89
36
1
5
2
0
5
2
0
5
2
1
4
6
1
86
1
22
1
28
1
18
1
19
1
116
2
5
5
2
5
5
36
1
5
36
1
5
36
0
5
36
1
5
2
1
5
36
1
5
2
4
5
2
0
5
2
0
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
1
0
0
36
0
1
62
2
5
5
2
0
5
2
5
5
2
5
5
2
5
5
2
1
5
36
0
5
2
0
5
2
0
5
2
1
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
4
4
2
2
generic
2
programmer
2
1
2
You see a player who is too experienced to have any excuse for not having a description.
2
5
4
2
0
86428
0
1648488120
36
1
#59
code utilities
16
36
1
-1
0
0
4
0
1
78
4
0
61
eval_d
2
85
-2
toint tonum
36
173
-1
toobj
36
173
-1
toerr
36
173
-1
error_name
36
173
-1
show_object
2
173
-1
show_property
2
173
-1
show_verbdef
2
173
-1
explain_verb_syntax
2
173
-1
verb_p*erms verb_permi*ssions
2
173
-1
verb_loc*ation
36
173
-1
verb_documentation
2
173
-1
set_verb_documentation
2
173
-1
parse_propref
2
173
-1
parse_verbref
2
173
-1
parse_argspec
36
173
-1
prepositions
36
173
-1
short_prep
36
173
-1
full_prep
36
173
-1
get_prep
36
173
-1
_fix_preps
36
173
1
find_verb_named
2
165
-1
find_last_verb_named
2
173
-1
find_callable_verb_named
2
173
-1
find_verbs_containing find_verbs_matching find_verb_lines_containing find_verb_lines_matching
2
173
-1
_find_verbs_containing _find_verbs_matching
2
173
-1
_grep_verb_code
2
173
-1
_egrep_verb_code
2
173
-1
_parse_audit_args
36
173
-1
help_db_list
2
173
-1
help_db_search
36
173
-1
corify_object
36
173
-1
inside_quotes
2
173
-1
verb_or_property
2
173
-1
task_valid
2
173
-1
task_owner
2
173
-1
argstr
2
173
-1
verbname_match
36
173
-1
substitute
36
173
-1
show_who_listing
2
173
-1
_egrep_verb_code_all
2
173
-1
_grep_verb_code_all
2
173
-1
verb_usage
2
173
-1
verb_frame
36
173
-1
verb_all_frames
36
173
-1
move_verb
2
173
-1
move_prop*erty
2
173
-1
eval_d_util
2
165
-1
display_callers
2
173
-1
callers_text
2
173
-1
set_property_value set_verb_or_property
2
165
-1
owns_task
2
173
-1
dflag_on
2
173
-1
type_str
36
173
-1
dump_properties
2
173
-1
dump_preamble
2
173
-1
dump_verbs
2
173
-1
_find_verb_lines_containing _find_verb_lines_matching
2
173
-1
commentify
2
173
-1
parse_sysobj_map
2
173
-1
uncommentify
2
173
-1
10
_version
_multi_preps
_other_preps_n
_other_preps
_short_preps
_all_preps
builtin_props
error_names
error_list
prepositions
15
2
2.7.0_20
36
5
4
7
2
off
2
from
2
out
2
on
2
on top
2
in
2
in front
36
5
4
13
0
1
0
2
0
4
0
4
0
5
0
5
0
5
0
6
0
6
0
9
0
9
0
12
0
15
36
5
4
13
2
using
2
at
2
inside
2
into
2
on top of
2
onto
2
upon
2
out of
2
from inside
2
underneath
2
beneath
2
about
2
off of
36
5
4
15
2
with
2
to
2
in front of
2
in
2
on
2
from
2
over
2
through
2
under
2
behind
2
beside
2
for
2
is
2
as
2
off
36
5
4
28
2
with
2
using
2
at
2
to
2
in front of
2
in
2
inside
2
into
2
on top of
2
on
2
onto
2
upon
2
out of
2
from inside
2
from
2
over
2
through
2
under
2
underneath
2
beneath
2
behind
2
beside
2
for
2
about
2
is
2
as
2
off
2
off of
36
5
4
11
2
name
2
r
2
w
2
f
2
programmer
2
wizard
2
owner
2
location
2
contents
2
last_move
2
a
2
1
4
19
2
E_NONE
2
E_TYPE
2
E_DIV
2
E_PERM
2
E_PROPNF
2
E_VERBNF
2
E_VARNF
2
E_INVIND
2
E_RECMOVE
2
E_MAXREC
2
E_RANGE
2
E_ARGS
2
E_NACC
2
E_INVARG
2
E_QUOTA
2
E_FLOAT
2
E_FILE
2
E_EXEC
2
E_INTRPT
36
5
4
19
3
3467820585508143104
3
1
3
8391718368071122946
3
94240172408835
3
94240172408836
3
94240172408837
3
94240172408838
3
94240172408839
3
94240172408840
3
94240172408841
3
94240172408842
3
94240172408843
3
94240172408844
3
94240172408845
3
94240172408846
3
94240172408847
3
94240172408848
3
94240172408849
3
94240172408850
36
5
4
15
2
with/using
2
at/to
2
in front of
2
in/inside/into
2
on top of/on/onto/upon
2
out of/from inside/from
2
over
2
through
2
under/underneath/beneath
2
behind
2
beside
2
for/about
2
is
2
as
2
off/off of
36
5
4
65
2
parse_propref("foo.bar")  => {"foo","bar"} (or 0 if arg. isn't a property ref.)
2
parse_verbref("foo:bar")  => {"foo","bar"} (or 0 if arg. isn't a verb ref.)
2
parse_argspec("any","in","front","of","this","baz"...)
2
                          => {{"any", "in front of", "this"},{"baz"...}} 
2
                                           (or string if args don't parse)
2

2
toint(string)           => integer (or E_TYPE if string is not a integer)
2
toobj(string)           => object (or E_TYPE if string is not an object)
2
toerr(number or string) => error value (or 1 if out of range or unrecognized)
2
error_name(error value) => name of error (e.g., error_name(E_PERM) => "E_PERM")
2

2
verb_perms()      => the current task_perms (as set by set_task_perms()).
2
verb_location()   => the object where the current verb is defined.
2
verb_frame()      => callers()-style frame for the current verb.
2
verb_all_frames() => entire callers() stack including current verb.
2
verb_usage([object,verbname]) => returns first line of verb doc, usually usage
2
verb_documentation([object,verbname]) => documentation at beginning of
2
           verb code, if any -- default is the calling verb
2
set_verb_documentation(object,verbname,text) => sets text at beginning of verb
2

2
   Preposition routines
2

2
prepositions()     => full list of prepostions
2
full_prep ("in")   => "in/inside/into"
2
short_prep("into") => "in"
2
short_prep("in/inside/into") => "in"
2
get_prep  ("off", "of", "the", "table") => {"off of", "the", "table"}
2

2
   Verb routines
2

2
verbname_match (fullname,name) => can `name' be used to call `fullname'
2
find_verb_named          (object,name[,n]) => verb number or 0 if not found
2
find_last_verb_named     (object,name[,n]) => verb number of last verb match
2
find_callable_verb_named (object,name[,n]) => verb number or 0 if not found
2
find_verbs_containing (pattern[,object|objlist]) => does work for @grep
2
find_verbs_matching (pattern[,object|objlist]) => does work for @egrep
2
move_verb (from obj,name,to obj[,newname]) => move a verb from object to object
2

2
move_prop (from obj,name,to obj[,newname]) => move a property to another object
2

2
   Verbs that do the actual dirty work for command lines verbs:
2

2
@show           => show_object  (object)
2
                   show_property(object,propname)
2
                   show_verbdef (object,verbname)
2
explain_syntax  => explain_verb_syntax(thisname,verbname,@verbargs)
2
eval*-d         => eval_d(code)
2
help            => help_db_list([player])
2
                   help_db_search(string topic, dblist)
2
@who            => show_who_listing(players [,more_players])
2
@check-full     => display_callers([callers() output])
2
@dump           => dump_preamble(object)
2
                => dump_properties(object, create_flag)
2
                => dump_verbs(object, create_flag)
2

2
   Random but useful verbs
2

2
verb_or_property(object,name[,@args]) => result of verb or property call,
2
                                         or E_PROPNF
2
corify_object(object)     => if the object is corified, returns $<name>
2
task_valid(INT task_id)   => returns true if task_id is currently running.
2
task_owner(INT task_id)   => returns owner of task_id, if running
2
owns_task(NUM task_id,OBJ who) => returns whether who owns task_id (if running)
2
argstr(verb,args[,argstr] => returns a corrected argstr (see full verb help)
2
substitute(string,subs)   => subs in form {{"target", "sub"}, {...}, ...}
36
5
5
36
4
4
2
2
code
2
utils
36
5
4
1
2
This is the code utilities utility package.  See `help $code_utils' for more details.
36
5
4
2
0
83718
0
1641541193
36
1
#60
Help Database
16
36
1
-1
0
0
4
0
1
30
4
0
9
player_quota
2
173
-1
prog_quota
2
173
-1
get_topic
2
173
-1
find_topics
2
173
-1
full_index
36
173
-1
index_list
36
173
-1
wizard_list
2
173
-1
dump_topic
36
173
-1
find_full_index_topic
36
173
-1
120
@uptime
wizard-list
@wrap
full-index
 index
gen-index
@pagelength
@more
programming
@linelength
@gaglist
::
@comment

spoofing
privacy
@examine
security
@sweep
@paranoid
@check
@eject
@quit
whereis
@suggest
@idea
@bug
@typo
@notedit
editors
@memory
"
:
@lastlog
@version
miscellaneous
insert
information
?
put
remove
burn
letters
decrypt
encrypt
delete
erase
write
read
examine
hand
throw
take
@messages
pronouns
messages
descriptions
@describe
tinymud
@gripe
@listgag
@ungag
@gag
go
@password
@sethome
@who
introduction
give
news
gagging
@move
inventory
@gender
@rename
notes
look
drop
get
manipulation
help
movement
home
say
whisper
page
emote
players
summary
@edit-options
@editoptions
@add-feature
@remove-feature
@features
features
@rmalias
@addalias
commands
 name
@request-character
player-names
@registerme
@eject!
options
@age
@edit
@addfeature
communication
objects
 aliases
@check-full
@users
alias
@add-alias
@mode
wizard-names
backspace
spivak
@owner
checkpoint
126
4
4
2
Syntax:  @uptime
2

2
   The @uptime command displays the amount of time since the last restart of the server.
2
   Note to programmers:  The last restart time of the server is stored in $last_restart_time.
36
5
4
4
2
*subst*
2

2
%;this:wizard_list()
2

36
5
4
2
2
*forward*
2
@linelength
36
1
4
1
2
*full_index*
36
5
4
1
2
*index_list*
36
5
4
2
2
*index*
2
General Help Topics
36
5
4
21
2
Syntax:  @pagelength <number>
2
         @pagelength
2

2
If the lines you see scroll off the top of your screen too quickly for you to
2
read and your client program is such that any lines scrolling off the top are
2
gone forever, you can use the @pagelength command to invoke page buffering to
2
limit the number of lines sent at a time.  E.g., if your terminal has a 24 line
2
screen, you can do @pagelength 24 and output will stop every 24 lines if you
2
don't type any other commands.
2

2
You will need to use the @more command to continue reading output once it 
2
has been stopped.  Make sure you read `help @more' before setting @pagelength.
2

2
@pagelength 0 means no page buffering will be done by the MOO.
2

2
By default the MOO will assume you have an infinitely wide terminal screen, so
2
you may wish to set @linelength as well, and ensure wrapping is on with @wrap
2
on.  (See help @linelength and help @wrap.)  As with word wrapping, you are
2
best off running a client that can do its own page buffering; the MOO server's
2
page buffering is inherently slower and many MUD's do not have page buffering
2
at all.
2
1
4
19
2
*subst*
2
Syntax:  @more
2
         @more rest
2
         @more flush
2

2
If you have @pagelength set (see `help @pagelength') and some combination of events or commands produces sufficiently many lines of output, you will see a message of the form
2

2
%[strsub(player.more_msg,"%%n","37")]
2

2
indicating (in this case) 37 more lines of text waiting to be read.  
2
At this point, you should give one of the @more commands above.  
2

2
@more without arguments prints sufficiently many lines to fill your screen,
2
assuming you've set @pagelength correctly, unless there are not that many
2
lines left to print.
2

2
@more rest will print all of the remaining lines, regardless of your @pagelength setting.  
2

2
@more flush discards all remaining lines
2
1
4
3
2
MOO contains a rich programming language for the creation of interesting rooms, exits, and other objects.
2

2
Not every player is allowed to program in MOO, including (at the moment, anyway) you.  If you would like to be, find a wizard and convince them that you've got good ideas that the MOO needs.  Good luck!
36
5
4
22
2
Syntax:  @wrap <on|off>
2
         @wrap
2

2
         @linelength <number>
2
         @linelength
2

2
If the lines you see get cut off at the edge of your screen (you don't have
2
word-wrap), you can get the MOO to split lines for you.  The @linelength
2
command tells the MOO how many columns you have on your screen--you probably
2
want @linelength 79--and "@wrap on" tells the MOO you want it to do word-
2
wrap.
2

2
It's better if you can fix this problem without the MOO's help, though,
2
because the MOO's solution will be slower than a local solution, and
2
because not all MUDs are willing to do word-wrap.
2

2
If you don't want the MOO to split lines for you, there might still be some
2
use for the @linelength command.  Certain commands, like @who and @check,
2
print truncated lines so they can print in neat columns.  The default for
2
these is generally about 79 columns, which looks fine if you have an
2
eighty-column screen.  If your screen is a different width, though, you
2
can set @linelength and some of these commands will react accordingly.
36
5
4
2
2
*forward*
2
@listgag
36
5
4
2
2
*forward*
2
emote
36
5
4
2
2
*forward*
2
@typo
36
5
4
5
2
*forward*
2
summary
2

2
Type 'help <topic>' for information on a particular topic.
2

36
5
4
2
2
*forward*
2
security
36
1
4
15
2
Some things you should be aware of:
2

2
 -*-*- OMNISCIENT WIZARDS AND SYSADMINS: -*-*-
2
Wizards can look at absolutely *anything* in the MOO database.  
2
The arch-wizard and the sysadmin for the MOO-server host have complete access not only to the MOO database itself but to many other possibly-relevant things.
2
The above mentioned parties (wizards et al), while they will endeavor to be discreet about anything incidental that turns up, nevertheless reserve the right to look at anything they want, if only for the sake of being able to resolve technical problems.
2

2
 -*-*- LOGGING: -*-*- 
2
Some client programs (the "client" is the program you use to connect to the MOO, e.g., telnet, tinytalk, tinyfugue, emacs with mud.el...) are capable of logging everything that happens to the corresponding player.  In fact, with some clients this happens by default.  If a given player's client has logging enabled and said player is either in the room with you or is monitoring an object that is in the room with you, then *everything* you say and emote gets recorded.  Also, if you are in a room owned by someone else, all bets are off.  There is *no way* that the MOO server can know about what client a given player is using; thus, anyone who can hear you is a potential logger.
2

2
In and of itself this would not be a problem --- indeed, logs are often useful for reference purposes.  However, there is no guarantee that the log will not end up someplace where you'd rather it didn't, e.g., posted on the rec.games.mud Usenet newsgroup.  While it is considered bad form (i.e., rude) to circulate or post a log without having the permission of at least the major participants in the activities logged, there is not a whole lot we can do on the technical side to prevent it from happening.
2

2
Be aware of the problem.  The @sweep command (see `help @sweep') attempts to determine what players can be listening at any given moment.  If anything, it errs on the side of paranoia.  Even so, it doesn't cover *all* possible avenues of eavesdropping, and there's no hope for it covering the situations like the one where someone manages to convince one of the participants in your discussion who kept a log that it really doesn't need to be kept private after all.
2

2
If you've got something really sensitive to discuss, you are best off doing it by encrypted email or in person.
36
5
4
12
2
Syntax:  @examine <object>
2
         @exam <object>
2

2
Prints several useful pieces of information about the named object, including the following:
2
        + its full name, aliases, and object number
2
        + its owner's name and object number
2
        + its description
2
        + its key expression (if it is locked and if you own it)
2
        + its contents and their object numbers
2
        + the 'obvious' verbs defined on it
2

2
[Note to programmers: the 'obvious' verbs are those that are readable and that can be invoked as commands.  To keep a verb off this list, either make it unreadable (see 'help @chmod') or, if it shouldn't be used as a command, give it 'args' of 'this none this' (see 'help @args').]
36
5
4
5
2
There are several commands available to determine the origins of messages and to check that your communications with other players are secure. Help is available on the following topics:
2

2
@paranoid -- keeping a record of messages your character hears.
2
@check    -- looking at that record to determine responsibility for messages.
2
@sweep    -- checking who is listening in on your conversation.
36
5
4
3
2
Syntax: @sweep
2

2
Used when you wish to have a private conversation, and are concerned someone may be listening in. @sweep tries to list the avenues by which information may be leaving the room. In a manner analogous to @check, it assumes that you don't want to hear about your own verbs, or those belonging to wizards, who presumably wouldn't stoop to bugging.
36
5
4
9
2
Syntax:  @paranoid
2
         @paranoid off
2
         @paranoid immediate
2
         @paranoid <number>
2

2
In immediate mode, the monitor prepends everything you hear with the name of 
2
the character it considers responsible for the message. Otherwise, it keeps 
2
records of the last <number> (defaults to 10) lines you have heard. These 
2
records can be accessed by the @check command.
36
5
4
23
2
Syntax:   @check <options>
2

2
where <options> is one or more of:
2
-- the number of lines to be displayed
2
-- a player's name, someone to be "trusted" during the assignment of responsibility for the message.
2
-- a player's named prefixed by !, someone not to be "trusted".
2

2
          @check-full <options>
2
where <options is either 
2
-- the number of lines to be displayed
2
-- a search string: only lines containing that string will be displayed.
2

2
Used when you are suspicious about the origin of some of the messages your character has just heard.
2

2
Output from @check is in columns that contain, in order, the monitor's best guess as to:
2
    what object the message came from,
2
    what verb on that object that was responsible,
2
    whose permissions that verb was running with, and
2
    the beginning of the actual message.
2

2
Output from @check-full is in columns that contains a description of all the verbs that were responsible for the noise heard, not just the best guess as to who was responsible.
2

2
@check operates by examining the list of verbs that were involved in delivering the message, and assigning responsibility to the first owner it sees who is not "trusted".  By default, it trusts you and all the wizards.  It uses the records maintained by @paranoid, so you must have used that command before you received the message.
36
5
4
11
2
Syntax: @eject[!] <object> [from <place>]
2

2
This command is used to remove unwanted objects from places you own.  Players thus removed are unceremoniously dumped in their homes (unless that's this room, in which case they are dumped in the default player starting place).  Other kinds of objects are checked for a .home property and sent there if possible, otherwise they get thrown into #-1.  Unlike @move, @eject does *not* check to see if the object wants to be moved, and with the destination being what it is, there is no question of the destination refusing the move, either.  Generally, you should only resort to @eject if @move doesn't work.
2

2
`@eject <object>' removes <object> from the current room, whereas `@eject <object> from <place>' removes the object from the specified location (in most cases, <place> will need to be specified as an object number).  In either case, this command only works if you own the room/entity from which the object is being ejected.
2

2
`@eject ... from me' suffices to get rid of some unwanted object in your inventory.
2

2
The verbs @eject! and @eject!! are provided for those rare situations in which @eject does not work.  @eject! does not check for .home properties, sending the offending object to #-1 immediately, but with a notification.  @eject!! is just like @eject! but provides no notification to the object.
2

2
See 'help room-messages' for a list of messages one can set regarding the @eject command.
36
5
4
3
2
Syntax:  @quit
2

2
Disconnect from the MOO.  This breaks your network connection and leaves your player sleeping.  Disconnecting in most parts of the MOO automatically returns your player to its designated home (see 'help home').
36
1
4
4
2
Syntax:  whereis [<player> [<player>...]]
2
        @whereis [<player> [<player>...]]
2

2
Returns the current location of each of the specified players, or of all players if not arguments given.
36
5
4
2
2
*forward*
2
@typo
36
5
4
2
2
*forward*
2
@typo
36
5
4
2
2
*forward*
2
@typo
36
5
4
12
2
Syntax:  @typo    [<text>]
2
         @bug     [<text>]
2
         @suggest [<text>]
2
         @idea    [<text>]
2
         @comment [<text>]
2

2
If <text> is given, a one-line message is sent to the owner of the room, presumably about something that you've noticed.  If <text> is not given, we assume you have more to say than can fit comfortably on a single line; the usual mail editor is invoked.  The convention is that @typo is for typographical errors on the room or objects found therein, @bug is for anomalous or nonintuitive behaviour of some sort, @idea/@suggest for any particular brainstorms or criticisms you might happen to have, and @comment for anything else.
2

2
If you're sending a bug report to someone because you got an error traceback when you used some object of theirs, please give them enough information to work on the problem.  In particular, please tell them *exactly* what you typed and *all* of the error messages that were printed to you, including the entire traceback, up to the line `(End of traceback.)'.  Without this information, it is nearly impossible for the programmer to discover, let alone fix, the problem.
2

2
The usual mail editor is only invoked for this command when in rooms that allow free entry, i.e., rooms that are likely to allow you back after you are done editing your message.  Otherwise these commands will require <text> and only let you do one-line messages.  
2
Most adventuring scenario rooms fall into this latter category.
36
5
4
8
2
Syntax:  @notedit <note-object>
2
         @notedit <object>.<property>
2

2
Enters the MOO Note Editor to edit the text on the named object
2
For the first form, <note-object> must be a descendant of $note.  
2
For the second form, <object>.<property> can be any string-valued or text-valued (i.e., list of strings) property on any object.
2

2
See 'help editors' for more detail.
36
5
4
40
2
One can always enter an editor by teleporting to it, or you can use one of the commands provided
2

2
    @edit     <object>:<verb>    invokes the Verb Editor (edits verb code)
2
    @notedit  <note_object>      invokes the Note Editor (edits note text)
2
    @notedit  <object>.<prop>    invokes the Note Editor (edits text property)
2
    @send     <list of recipients>        invokes the Mailer (edits a mail msg)
2
    @answer   [<msg_number>] [<flags>...] invokes the Mailer (edits a reply)
2

2
This will transport you to one of several special rooms that have editing commands available.  These editors are admittedly not as good as EMACS, but for those with no other editing capability on their host systems, they are better than nothing.
2

2
There is a generic editor that provides basic editing commands that are applicable to all editors.  Documentation for these commands can be obtained by typing `help <topic>' within the editor:
2

2
    abort              emote/:            pause              send      (M) 
2
    also-to (M)        fill               prev               showlists (M) 
2
    compile (V)        insert             print     (M)      subject   (M) 
2
    copy               join               quit               subst         
2
    delete             list               ranges             to    (M)     
2
    done               move               save      (N)      what          
2
    edit    (V,N)      next               say/"              who   (M)     
2

2
In addition, individual editors provide their own additional commands for loading text from places, saving text to places, and various other specialized functions which are denoted in the above list with (M),(N),(V) according as they apply to the mail editor, the note editor, or the verb editor, respectively.
2

2
Note that a given editor only allows you one session at a time (ie. one verb, one note, or one mail message).  If you leave an editor without either aborting or compiling/saving/sending the item you're working on, that editor remembers what you are doing next time you enter it, whether you enter it by teleporting or by using the appropriate command.  Note that editors are periodically flushed so anything left there for sufficiently long will eventually go away.
2

2
A player may have his own .edit_options property which is a list containing one or more (string) flags from the following list
2

2
  quiet_insert
2
      suppresses those annoying "Line n added." or "Appended..." messages
2
      that one gets in response to 'say' or 'emote'.  This is useful if you're
2
      entering a long list of lines, perhaps via some macro on your client,
2
      and you don't want to see an equally long list of "Line n added..."
2
      messages.  What you do want, however is some indication that this all
2
      got through, which is why the "." command is an abbreviation for insert.
2

2
  eval_subs
2
      Enables the verb editor to process your eval_subs property when
2
      compiling your verb.  See `help eval' for more information about
2
      the eval_subs property.
2

2
There will be more options, some day.
36
5
4
3
2
Syntax:  @memory
2

2
Prints out all information available on the current memory-usage behavior of the MOO server.  Probably only a wizard, if anyone, cares about this.
36
1
4
2
2
*forward*
2
say
36
1
4
2
2
*forward*
2
emote
36
1
4
6
2
Syntax:  @lastlog
2
         @lastlog <player>
2

2
The first form prints out a list of all players, roughly sorted by how long it's been since that player last connected to the MOO.  For each player, the precise time of their last connection is printed.
2

2
The second form only shows the last-connection time for the named player.
36
1
4
3
2
Syntax:  @version
2

2
Prints out the version number for the currently-executing MOO server.
36
1
4
4
2
Here are a few commands of occasional utility that didn't fit into any of the neat categories for the rest of the help system:
2

2
@version -- printing the MOO server version number
2
@lastlog -- finding out when some player last connected to the MOO
36
1
4
2
2
*forward*
2
put
36
1
4
2
2
*forward*
2
help
36
1
4
2
2
*forward*
2
help
36
1
4
4
2
Syntax:  put <object> into <container>
2
         insert <object> in <container>
2

2
Moves the named object into the named container.  Sometimes the owners of the object and/or the container will not allow you to do this.
36
1
4
2
2
*forward*
2
take
36
1
4
3
2
Syntax:  burn <letter>
2

2
Destroy the named letter irretrievably.  Only players who can read the letter can do this.
36
1
4
1
2
A letter is a special kind of note (see 'help notes') with the added feature that it can be recycled by anyone who can read it.  This is often useful for notes from one player to another.  You create the letter as a child of the generic letter, $letter (see 'help @create' and 'help write'), encrypt it so that only you and the other player can read it (see 'help encrypt') and then either give it to the player in question or leave it where they will find it.  Once they've read it, they can use the 'burn' command to recycle the letter; see 'help burn' for details.
36
1
4
3
2
Syntax:  decrypt <note>
2

2
Removes any restriction on who may read the named note or letter.  Only the owner of a note may do this.
36
1
4
3
2
Syntax:  encrypt <note> with <key-expression>
2

2
Restricts the set of players who can read the named note or letter to those for whom the given key expression is true.  See 'help keys' for information on the syntax and semantics of key expressions.  Only the owner of a note may do this.
36
1
4
3
2
Syntax:  delete <line-number> from <note>
2

2
Removes a single line of text from a note.  The first line of text is numbered 1, the second is 2, and so on.  Only the owner of a note may do this.
36
1
4
3
2
Syntax:  erase <note>
2

2
Deletes all of the text written on a note or letter.  Only the owner of a note may do this.
36
1
4
3
2
Syntax:  write "<any text>" on <note>
2

2
Adds a line of text to the named note or letter.  Only the owner of a note may do this.
36
1
4
3
2
Syntax:  read <note>
2

2
Prints the text written on the named object, usually a note or letter.  Some notes are encrypted so that only certain players may read them.
36
1
4
10
2
Syntax:  examine <object>
2
         exam <object>
2

2
Prints several useful pieces of information about the named object, including the following:
2
        + its full name, object number, and aliases
2
        + its owner's name
2
        + its description
2
        + its key expression (if it is locked and if you own it)
2
        + its contents
2
        + the 'obvious' verbs defined on it
36
1
4
2
2
*forward*
2
give
36
1
4
2
2
*forward*
2
drop
36
1
4
9
2
Syntax:  take <object>
2
         get <object>
2
         take <object> from <container>
2
         get <object> from <container>
2
         remove <object> from <container>
2

2
The first two forms pick up the named object and place it in your inventory.  Sometimes the owner of the object won't allow it to be picked up for some reason.
2

2
The remaining forms move the named object from inside the named container (see 'help containers') into your inventory.  As before, sometimes the owner of an object will not allow you to do this.
36
1
4
3
2
Syntax:  @messages <object>
2

2
List all of the messages that can be set on the named object and their current values.  See 'help messages' for more details.
36
1
4
67
2
Some kinds of messages are not printed directly to players; they are allowed to contain special characters marking places to include the appropriate pronoun for some player.  For example, a builder might have a doorway that's very short, so that people have to crawl to get through it.  When they do so, the builder wants a little message like this to be printed:
2

2
        Balthazar crawls through the little doorway, bruising his knee.
2

2
The problem is the use of 'his' in the message; what if the player in question is female?  The correct setting of the 'oleave' message on that doorway is as follows:
2

2
        "crawls through the little doorway, bruising %p knee."
2

2
The '%p' in the message will be replaced by either 'his', 'her', or 'its', depending upon the gender of the player.  
2

2
As it happens, you can also refer to elements of the command line (e.g., direct and indirect objects) the object issuing the message, and the location where this is all happening.  In addition one can refer to arbitrary string properties on these objects, or get the object numbers themselves.
2

2
The complete set of substitutions is as follows:
2

2
        %% => `%'  (just in case you actually want to talk about percentages).
2
    Names:
2
        %n => the player
2
        %t => this object (i.e., the object issuing the message,... usually)
2
        %d => the direct object from the command line
2
        %i => the indirect object from the command line
2
        %l => the location of the player
2
    Pronouns:
2
        %s => subject pronoun:          either `he',  `she', or `it'
2
        %o => object pronoun:           either `him', `her', or `it'
2
        %p => posessive pronoun (adj):  either `his', `her', or `its'  
2
        %q => posessive pronoun (noun): either `his', `hers', or `its'
2
        %r => reflexive pronoun:  either `himself', `herself', or `itself'
2
    General properties:
2
        %(foo) => player.foo 
2
        %[tfoo], %[dfoo], %[ifoo], %[lfoo]
2
               => this.foo, dobj.foo, iobj.foo, and player.location.foo
2
    Object numbers:
2
        %#  => player's object number
2
        %[#t], %[#d], %[#i], %[#l]
2
            => object numbers for this, direct obj, indirect obj, and location.
2

2
In addition there is a set of capitalized substitutions for use at the 
2
beginning of sentences.  These are, respectively, 
2

2
   %N, %T, %D, %I, %L for object names, 
2
   %S, %O, %P, %Q, %R for pronouns, and
2
   %(Foo), %[dFoo] (== %[Dfoo] == %[DFoo]),... for general properties
2

2
Note: there is a special exception for player .name's which are assumed to
2
already be capitalized as desired.
2

2
There may be situations where the standard algorithm, i.e., upcasing the first letter, yields something incorrect, in which case a "capitalization" for a particular string property can be specified explicitly.  If your object has a ".foo" property that is like this, you need merely add a ".fooc" (in general .(propertyname+"c")) specifying the correct capitalization.  This will also work for player .name's if you want to specify a capitalization that is different from your usual .name
2

2
Example:  
2
Rog makes a hand-grenade with a customizable explode message.
2
Suppose someone sets grenade.explode_msg to:
2

2
  "%N(%#) drops %t on %p foot.  %T explodes.  
2
   %L is engulfed in flames."
2

2
If the current location happens to be #3443 ("yduJ's Hairdressing Salon"),
2
the resulting substitution may produce, eg.,
2

2
  "Rog(#4292) drops grenade on his foot.  Grenade explodes.  
2
   YduJ's Hairdressing Salon is engulfed in flames."
2

2
which contains an incorrect capitalization.  
2
yduJ may remedy this by setting #3443.namec="yduJ's Hairdressing Salon".
2

2
Note for programmers:  
2
 In programs, use $string_utils:pronoun_sub().
2
 %n actually calls player:title() while %(name) refers to player.name directly.
36
1
4
18
2
Most objects have messages that are printed when a player succeeds or fails in manipulating the object in some way.  Of course, the kinds of messages printed are specific to the kinds of manipulations and those, in turn, are specific to the kind of object.  Regardless of the kind of object, though, there is a uniform means for listing the kinds of messages that can be set and then for setting them.
2

2
The '@messages' command prints out all of the messages you can set on any object you own.  Type 'help @messages' for details.
2

2
To set a particular message on one of your objects use a command with this form:
2
        @<message-name> <object> is "<message>"
2
where '<message-name>' is the name of the message being set, <object> is the name or number of the object on which you want to set that message, and <message> is the actual text.
2

2
For example, consider the 'leave' message on an exit; it is printed to a player when they successfully use the exit to leave a room.  To set the 'leave' message on the exit 'north' from the current room, use the command
2
        @leave north is "You wander in a northerly way out of the room."
2

2
[Note to programmers: This class of commands automatically applies to any property whose name ends in '_msg'.  Thus, in the example above, the command is setting the 'leave_msg' property of the named exit.  You can get such a command to work on new kinds of objects simply by giving the appropriate properties names that end in '_msg'.  Additionally, in many cases the _msg property is accompanied by a _msg verb, which defaultly returns the named property, but which is available to be customized in more complex ways than allowed by simple string substitution.  You should check for the particular property you're considering whether the verb form exists (typically with @list).]
2

2
The following help topics describe the uses of the various messages available on standard kinds of objects:
2

2
container-messages -- the messages on objects that can contain other objects
2
exit-messages -- the messages on exit objects
2
thing-messages -- the messages on objects that can be taken and dropped
36
1
4
5
2
Most objects have one or more descriptive pieces of text associated with them; these texts are printed under various circumstances depending on the kind of text.  For example, every object has a 'description' text that is printed whenever a player looks at the object.  The following help topics discuss the commands for manipulating these descriptive texts on your objects:
2

2
@rename -- setting the name and aliases of your objects
2
@describe -- setting what others see when they look at your objects
2
messages -- listing and setting the other descriptive texts on an object
36
1
4
13
2
Syntax:  @describe <object> as <description>
2

2
Sets the description string of <object> to <description>.  This is the string that is printed out whenever someone uses the 'look' command on <object>.  To describe yourself, use 'me' as the <object>.
2

2
Example:
2
Munchkin types this:
2
  @describe me as "A very fine fellow, if a bit on the short side."
2
People who type 'look Munchkin' now see this:
2
  A very fine fellow, if a bit on the short side.
2

2
Note for programmers:
2
The description of an object is kept in its .description property.  
2
For descriptions of more than one paragraph, .description can be a list of strings.
36
1
4
45
2
This is yduJ's table of tinymud commands and their equivalents in LambdaMOO.  A longer document, with discussions of the different verbs and how they have changed, is available via FTP from ftp.lambda.moo.mud.org as pub/MOO/contrib/docs/TinyMUD-LambdaMOO-equivs.  All the commands mentioned here have help nodes on LambdaMOO.
2

2
The following commands are basically the same in MOO and MUD.
2

2
    drop(throw), get(take), go, help, home, inventory, look, news, say (",:)
2

2

2
The following commands have no equivalent:
2

2
    kill, rob, score, @force
2

2

2
The following commands have the same names and do similar things, but are changed in some way (both syntactic and semantic differences, sometimes quite substantial differences):
2

2
    @examine, give, page, read, whisper, @create, @dig,
2
    @lock, @password, @unlock, @describe
2

2

2
The following commands have rough equivalents in LambdaMOO but the name is different:
2

2
    TinyMUD name            LambdaMOO name
2
    ------------            --------------
2
    QUIT                    @quit
2
    gripe                   @gripe
2
    goto/move               go
2
    WHO                     @who
2
    @fail                   @take_failed, @nogo, @drop_failed
2
    @find                   @audit
2
    @link                   @dig, @sethome, @add-exit, @add-entrance
2
    @name                   @rename
2
    @ofail                  @otake_failed, @onogo, @odrop_failed
2
    @open                   @dig
2
    @osuccess               @oleave, @oarrive, @otake_succeeded, 
2
                            @odrop_succeeded
2
    @success                @leave, @arrive, @take_succeeded
2
                            @drop_succeeded
2
    @teleport               @move
2

2

2
Here are some commands for which no equivalent exists, or for which the equivalent is a complicated set of actions.
2

2
    @set, @stats, @unlink
2

2

2
Documentation on most of the LambdaMOO commands mentioned above can be acquired using 'help <command-name>'.  A notable exception is the commands like @oarrive and @take_failed that set textual messages on objects.  These are described under 'help messages'.
36
1
4
13
2
Syntax:  @gripe <anything> ...
2

2
Puts you into the MOO mail system to register a complaint (or, conceivably, a compliment) with the wizards.  The rest of the command line (the <anything> ... part) is used as the subject line for the message.  More information on using the MOO mail system is given once you're in it.
2

2
You may hear back from the wizards eventually; see 'help @mail' for how to read their reply.
2

2
Example:
2
Munchkin types:
2
  @gripe The little bird
2
  "How come I can't ever see the little bird in the cuckoo clock?
2
  "        -- A frustrated player
2
  send
2
and, somewhat later, the wizards reply with a note about being sure to look while the clock is chiming.
36
5
4
4
2
Syntax:  @listgag [all]
2
         @gaglist [all]
2

2
Shows you a list of the players and objects currently on your 'gag list'.  You don't see any messages that result from actions initiated by the players or objects on this list.  In particular, you will not hear them if they try to speak, emote, or whisper to you.  See 'help gagging' for an explanation of gagging in general.  With the optional "all" parameter it will also scan the database for players who are gagging you.  This may induce lag, so caution is advised with this option.
36
1
4
9
2
Syntax:  @ungag <player or object>
2
         @ungag everyone
2

2
Remove the given player or object (or, in the second form, everyone) from your 'gag list'.  You will once again see any messages that result from actions initiated by the ungagged player(s) or objects.  In particular, you will once again be able to hear them if they speak, emote, or whisper to you.  See 'help gagging' for an explanation of gagging in general.
2

2
Example:
2
Munchkin types:
2
  @ungag Grover
2
and is once again able to hear Grover's witty remarks.  Sigh...
36
1
4
12
2
Syntax:  @gag <player or object> [<player or object>...]
2

2
Add the given players to your 'gag list'.  You will no longer see any messages that result from actions initiated by these players.  In particular, you will not hear them if they try to speak, emote, or whisper to you.  See 'help gagging' for an explanation of gagging in general.
2

2
Example:
2
Munchkin types:
2
  @gag Grover
2
and no longer hears anything that Grover says.  What a relief!
2

2
If you specify an object, then any text originating from that object will not be printed.  Example:  Noisy Robot prints "Hi there" every 15 seconds.   In order to avoid seeing that, Munchkin types:
2
  @gag Noisy
2
and no longer hears that robot!  (Munchkin must be in the same room as Noisy Robot for this to work, or know its object number.)
36
1
4
8
2
Syntax: go <direction> ...
2

2
Invokes the named exits in the named order, moving through many rooms in a single command.
2

2
Example:
2
Munchkin types:
2
  go n e e u e e s e
2
and moves quite rapidly from the Living Room all the way to the Bovine Illuminati Atrium, all in one command.
36
1
4
9
2
Syntax: @password <old-password> <new-password>
2

2
Changes your player's password (as typed in the 'connect' command when you log in to the MOO) to <new-password>.  For security reasons, you are required to type your current (soon to be old) password as the first argument.
2

2
Your password is stored in an encrypted form in the MOO database; in principle, not even the wizards can tell what it is, though they can change it, of course.  It is recommended that your password not be your name or a common word; MOO passwords have been stolen or cracked in the past and characters have been made unhappy by such theft.  Your password is your security; choose a safe one.
2

2
If your character does get stolen, a wizard can change it for you and tell you the new password in secret.  You may have to provide your email address for verification.
2

2
Only the first 8 characters of a password are significant.
36
1
4
3
2
Syntax: @sethome
2

2
Sets your designated home (see `help home') to be the room you're in now.  If the current room wouldn't allow you to teleport in, then the `@sethome' command nicely refuses to set your home there.  This avoids later, perhaps unpleasant, surprises.  Additionally, your home must be a room that will allow you to stay there.  Rooms which you own will do this, as will rooms to which you have been added as a resident.  See the @resident command for help on adding someone as a resident to a room you own.
36
1
4
11
2
*subst*
2
Syntax: @who
2
        @who <player> [<player> ... ]
2

2
The first form lists all of the currently-connected players, along with the amount of time they've been connected, the amount of time they've been idle, and their present location in the MOO.
2

2
The second form, in which a list of player names is given, shows information for just those players.  For any listed players that are not connected, we show the last login time instead of the connect/idle times.
2

2
@who refers to the @who_location message (see 'help messages') on each player's location in order to determine what should be printed in the location column.  Pronoun substitutions are done on this string in the usual manner (see 'help pronouns').  The default value is "%[$room.who_location_msg]" (i.e., the room name).
2

2
If the list of players to display is longer than 100, this command will not show its normal output, since it can be quite expensive to compute.  In such cases, you might want to use the @users command instead; see `help @users' for more information.
36
1
4
17
2
LambdaMOO is a kind of virtual reality, in which players move about from place to place manipulating their environment in what we hope are amusing, entertaining, or enlightening ways.
2

2
LambdaMOO is more of a pastime than a game in the usual sense; there is no `score' kept, there are no specific goals to attain in general, and there's no competition involved.  LambdaMOO participants explore the virtual world, talk to the other participants, try out the weird gadgets that others have built, and create new places and things for others to encounter and enjoy.
2

2
Most commands have the form of simple English sentences:
2
    <verb>
2
    <verb>  <direct object>
2
    <verb>  <direct object>  <preposition>  <indirect object>
2
Don't use English articles (e.g. 'a', 'an', or 'the') in your commands; the MOO won't understand them.  You can refer to yourself as 'me' and the room you're in as 'here'.
2

2
The first five kinds of commands you'll want to know are listed below.  Type 'help <topic-name>' for details on any of them:
2

2
look -- getting a description of the current room or any other object
2
say -- speaking to the other players in the same room as you
2
@who -- showing which players are currently connected to the MOO
2
movement -- how to move around in the MOO, from room to room
2
@quit -- disconnecting from the MOO
36
1
4
4
2
Syntax:  give <object> to <player>
2
         hand <object> to <player>
2

2
Move an object from your contents to that of another player.  This doesn't change the ownership of the object.  Some players may refuse to accept gifts and some objects may refuse to be given.
36
5
4
10
2
*subst*
2
Syntax: news
2
        news all
2
        news new
2
        news contents
2
        news archive
2

2
Read the latest edition of the %[$network.MOO_name] Newspaper, which carries articles concerning recent changes to the MOO server or to the main public classes, or other articles of interest to the MOO at large.
2

2
The default behavior for the `news' command is to act like `news new' but this may be changed by setting the @mail-option news to one of `all' or `new' or `contents'.  `news all' displays all current news articles.  `news new' only displays articles you have not yet read.  `news contents' displays the authors and subjects of all current news.  `news archive' displays back issues of the newspaper which are deemed worth reading by every citizen at any time.
36
5
4
5
2
Occasionally, you may run into a situation in which you'd rather not hear from certain other players.  It might be that they're being annoying, or just that whatever they're doing makes a lot of noise.  Gagging a player will stop you from hearing the results of any task initiated by that player.  You can also gag a specific object, if you want to hear what the owner of that object says, but not the output from their noisy robot.  The commands to use gagging are listed below; detailed help is available on each of them:
2

2
@gag -- add one or more players to your gag list
2
@ungag -- remove a player from your gag list
2
@listgag -- list the players you currently have gagged
36
5
4
5
2
Syntax:  @move <thing> to <place>
2

2
Move the specified object to the specified location.  This is not guaranteed to work; in particular, the object must agree to be moved and the destination must agree to allow the object in.  This is usually the case, however.  The special case where <thing> is 'me' is useful for teleporting yourself around.
2

2
If @move doesn't work and you own the room where the object is located, try using @eject instead.
36
5
4
4
2
Syntax:  inventory
2
         i
2

2
Prints a list showing every object you're carrying.
36
5
4
8
2
Syntax: @gender <gender>
2
        @gender
2

2
The first form, with an argument, defines your player to have the gender <gender>.  If <gender> is one of the standard genders (e.g., 'male', 'female', 'neuter',...), your various pronouns will also be set appropriately, making exits and certain other objects behave more pleasantly for you.
2

2
The second form tells you the current definition of your player's gender, your current pronouns, and the complete list of standard genders.
2

2
It should be noted that some of the "genders" on the standard gender list need verb conjugation in order to work properly and much of the MOO isn't set up for this (...yet).  For example, you should expect to see `they is' a fair amount if you @gender yourself `plural'.
36
5
4
27
2
Syntax: @rename <object>        to [name-and-alias],<alias>,...,<alias>
2
        @rename <object>        to [name]:<alias>,...,<alias>
2
        @rename <object>.<property> to <new-property-name>
2
        @rename <object>:<verb-name> to <new-verb-name>
2
        @rename# <object>:<verb-number> to <new-verb-name>
2

2
The first two forms are used to change the name and aliases of an object. The name is what will be used in most printed descriptions of the object. The aliases are the names by which players can refer to the object in commands. Typically you want to include the name in the aliases, as the MOO parser only checks .aliases when matching, so the first syntax is generally preferred.
2

2
If you leave out the "name" part of the list, @rename will leave the object's name as it is, and only change the aliases.
2

2
Note that for renaming players, more stringent rules apply.  See `help player-names'.  Certain other kinds of objects (e.g., mail recipients) also enforce their own rules w.r.t what they can be named.
2

2
Examples:
2
Munchkin names his dog:
2
  @rename #4237 to "Rover the Wonder Dog":Rover,dog
2
Now we'll see 'Rover the Wonder Dog' if we're in the same room as him and we can refer to him as either 'Rover' or just 'dog' in our commands, like 'pet dog'.  Note, however, that it will be impossible to use "Rover the Wonder Dog" to rever to the dog: if you don't include the name in the aliases, confusion can result.  It might have been better to start off with
2
  @rename #4237 to "Rover the Wonder Dog",Rover,dog
2

2
Since he didn't, Munchkin now changes his dog's aliases:
2
  @rename #4237 to ,Rover,dog,Rover the Wonder Dog
2
The name remains the same--we still see 'Rover the Wonder Dog'--but now any of 'Rover', 'dog', or 'Rover the Wonder Dog' can be used to refer to him.  This can help reduce confusion.
2

2
The third form of the @rename command is also for use by programmers, to change the name of a property they own to <new-property-name>.
2

2
The fourth form of the @rename command is for use by programmers, to change the name of a verb they own. If the <new-verb-name> contains spaces, the verb will have multiple names, one for each space-separated word.
2

2
The fifth form, @rename#, is for unambiguously referring to a verb on an object in case there is more than one with the same name. The verb number is the 1-based index of the verb as it appears in the verbs() (or @verbs) output list.
36
5
4
15
2
Notes are objects that can have text written on them to be read later.  They are useful for leaving messages to people, or for documenting your creations.
2

2
The following help topics cover verbs that can be used with notes:
2

2
read -- reading the text on the note
2
write -- adding text to a note
2
erase -- removing all the text from a note
2
delete -- deleting one line of text from a note
2

2
@notedit -- general editing on the text of a note
2

2
encrypt -- restricting who can read a note
2
decrypt -- undoing a previous encryption
2

2
You can make a note by creating a child of the standard note, $note (see 'help @create').  Note that, like most objects, only the owner of a note can recycle it.  If you'd like to make it possible for a reader of your note to destroy it (this is a common desire for notes to other individual players), then you might want to look at 'help letters'.
36
5
4
11
2
Syntax: look
2
        look <object>
2
        look <object> in <container>
2

2
Show a description of something.
2

2
The first form, with no arguments, shows you the name and description of the room you're in, along with a list of the other objects that are there.
2

2
The second form lets you look at a specific object.  Most objects have descriptions that may be read this way.  You can look at your own description using 'look me'.  You can set the description for an object or room, including yourself, with the 'describe' command (see 'help describe').
2

2
The third form shows you the description of an object that is inside some other object, including objects being carried by another player.
36
5
4
4
2
Syntax:  drop <object>
2
         throw <object>
2

2
Remove an object you are carrying from your inventory and put it in your current room.  Occasionally you may find that the owner of the room won't allow you to do this.
36
5
4
2
2
*forward*
2
take
36
5
4
17
2
Objects usually have verbs defined on them that allow players to manipulate and use them in various ways. Standard ones are:
2

2
get  -- pick an object up and place it in your inventory
2
drop -- remove an object from your inventory and place it in the room
2
put  -- take an object from your inventory and place it in a container
2
give -- hand an object to some other player
2
look -- see what an object looks like
2

2
You can see what objects you're carrying with the 'inventory' command; see 'help inventory' for details.
2

2
Some specialized objects will have other commands. The programmer of the object will usually provide some way for you to find out what the commands are.  One way that works for most objects is the 'examine' command; see 'help examine' for details.
2

2
The following specialized objects have help entries you should consult:
2

2
notes -- objects that allow text to be written on them and read later
2
letters -- notes that a recipient can burn after reading
2
containers -- objects that may contain other objects
36
5
4
18
2
Syntax:  help
2
         help <topic>
2
         help index
2

2
Print out entries from the online documentation system.  The commands `?' and `information' (usually abbreviated `info') are synonyms for `help'.
2

2
The first form prints out a summary table of contents for the entire help system.  
2

2
The second form prints out the documentation available on the given topic.  Many help system entries contain references to other entries accessible in this way.  The topic name may be abbreviated; if there is no topic exactly matching the name you give, the help system checks for topics for which the name is a prefix, perhaps with the addition or omission of an initial `@', or perhaps with some confusion beween dashes (-) and underscores (_), e.g., 
2
      `bui' instead of `building', 
2
      `who' instead of `@who', 
2
     `@wri' instead of `write',
2
  `add_ent' instead of `@add-entrance',
2
 `unlock-'  instead of `@unlock_for_open'
2

2
If the abbreviation you give is ambiguous, you will be presented with a list of the matching complete topic names.
2

2
The `help index' commands prints out a list of indices for the various help databases.  Each index gives a list of topics available on that database.  It is sometimes easier to find the topics you're interested in this way, rather than tracing through the chain of cross references.
36
1
4
5
2
The descriptions of most rooms outline the directions in which exits exist.  Typical directions include the eight compass points ('north', 'south', 'east', 'west', 'northeast', 'southeast', 'northwest', and 'southwest'), 'up', 'down', and 'out'.
2

2
To go in a particular direction, simply type the name of that direction (e.g, 'north', 'up').  The name of the direction can usually be abbreviated to one or two characters (e.g., 'n', 'sw').  You can also type 'go <direction>' to move; this is particularly useful if you know you're going to type several movement commands in a row (see 'help go').
2

2
In addition to such vanilla movement, some areas may contain objects allowing teleportation and almost all areas permit the use of the 'home' command to teleport you to your designated home (see 'help home' for more details).
36
1
4
6
2
*subst*
2
Syntax: home
2

2
Instantly teleports you to your designated home room.
2
Initially, this room is %[tostr($player_start.name," (",$player_start,")")].
2
You can change your designated home; see 'help @sethome' for details.
36
1
4
12
2
Syntax:  say <anything> ...
2
         "<anything> ...
2

2
Says <anything> out loud, so that everyone in the same room hears it.  This is so commonly used that there's a special abbreviation for it: any command-line beginning with a double-quote ('"') is treated as a 'say' command.
2

2
Example:
2
Munchkin types this:
2
  "This is a great MOO!
2
Munchkin sees this:
2
  You say, "This is a great MOO!"
2
Others in the same room see this:
2
  Munchkin says, "This is a great MOO!"
36
1
4
2
2
whisper "<text>" to <player>
2
sends the message "<yourname> whispers, "<text>" to you " to <player>, if they are in the room.
36
1
4
27
2
*subst*
2
Syntax:  page <player> [[with] <text>]
2

2
Sends a message to a connected player, telling them your location and, optionally, <text>.
2

2
Example:
2
Munchkin types:
2
        page Frebble with "Where are you?"
2
Frebble sees:
2
        You sense that Munchkin is looking for you in the Kitchen.
2
        He pages, "Where are you?"
2
Munchkin sees:
2
        Your message has been received.
2

2
Advanced Features:
2
Page refers to the following messages on the players involved (see 'help messages'):
2

2
@page_origin [%[$player.page_origin_msg]]
2
  Determines how the recipient is told of your location.
2

2
@page_echo   [%[$player.page_echo_msg]]
2
  Determines the response received by anyone who pages you.
2

2
@page_absent [%[$player.page_absent_msg]]
2
  Determines the response received by anyone who tries to page you when you aren't connected.
2

2
All of these undergo the usual pronoun substitutions (see 'help pronouns') except that in both cases the direct object (%d) refers to the recipent of the page and the indirect object (%i) refers to the sender.  You should only change these messages if you want to add to the Virtual Reality feel of the MOO for your character.
36
1
4
18
2
Syntax:  emote <anything> ...
2
         :<anything> ...
2
         ::<anything> ...
2

2
Announces <anything> to everyone in the same room, prepending your name.  This is commonly used to express various non-verbal forms of communication.  In fact, it is so commonly used that there's a special abbreviation for it: any command-line beginning with ':' is treated as an 'emote' command.
2

2
The alternate form, '::' (less commonly 'emote :'), does not insert the space between the player name and the text.
2

2
Examples:
2
Munchkin types this:
2
  :wishes he were much taller...
2
Everyone in the same room sees this:
2
  Munchkin wishes he were much taller...
2

2
Munchkin types this:
2
  ::'s eyes are green.
2
Everyone in the same room sees this:
2
  Munchkin's eyes are green.
36
1
4
8
2
There are a number of commands for modifying various characteristics of the object representing you in the MOO, your 'player'.  Help on them is available in the following topics:
2

2
@describe -- setting what others see when they look at you
2
@gender -- changing your player's gender
2
@password -- changing your player's password
2
@sethome -- changing your designated home room
2
@rename -- changing your name and/or aliases
2
@linelength -- adding word-wrap to the lines you see
36
1
4
18
2
Help is available on the following general topics:
2

2
introduction -- what's going on here and some basic commands
2
index -- index into the help system
2

2
players -- setting characteristics of yourself
2
movement -- moving yourself between rooms
2
communication -- communicating with other players
2
manipulation -- moving or using other objects
2
miscellaneous -- commands that don't fit anywhere else
2

2
building -- extending the MOO
2
programming -- writing code in the MOO programming language
2
editors -- editing text and code in the MOO
2

2
@pagelength -- what to do if lines scroll off your screen too fast
2
@linelength -- what to do if lines are truncated
2
tinymud -- a list of equivalences between MOO and TinyMUD concepts/commands
36
5
4
26
2
Syntax:  @edit-option
2
         @edit-option <option>
2

2
Synonym:  @editoption
2

2
The edit options customize the behavior of the various editors (mail editor, verb editor, etc...) to your particular taste.  The first form of this command displays all of your edit options.  The second form displays just that one option, one of the flags listed below.
2

2
The remaining forms of this command are for setting your edit options:
2

2
         @edit-option +<flag>
2
         @edit-option -<flag>
2
         @edit-option !<flag>           (equivalent to -<flag>)
2

2
These respectively set and reset the specified flag
2

2
-quiet_insert    insert (") and append (:) echo back the line numbers
2
+quiet_insert    insert (") and append (:) produce no output
2
-eval_subs       (VERB EDITOR) ignore .eval_subs when compiling verbs
2
+eval_subs       (VERB EDITOR) apply .eval_subs to verbs being compiled
2
-local           Use in-MOO text editors.
2
+local           Ship text to client for local editing.
2
-no_parens       include all parentheses in verb code.
2
+no_parens       include only necessary parentheses in verb code.
2

2
+parens        is a synonym for -no_parens
2
+noisy_insert  is a synonym for -quiet_insert
36
5
4
2
2
*forward*
2
@edit-options
36
5
4
4
2
Usage:  @add-feature  <object>
2
 @remove-feature <object>
2

2
Add or remove a feature from your list.  A feature is an object which provides additional commands you can use.  For more information, see `help features'.
36
5
4
2
2
*forward*
2
@add-feature
36
5
4
3
2
Usage:  @features [<name>] [for <player>]
2

2
List all of <player>'s features matching <name>, or all of <player>'s features if <name> is not supplied.  <player> defaults to you.  See `help features' for more information.
36
5
4
3
2
Features are objects that provide you with commands not covered by the ordinary player objects.  The advantage of using features is that you can mix and match the things you like; whereas if you like a command that's defined on a player class, you have to also get all the commands it defines, and all the commands its ancestors define.
2

2
You can list your features with the @features command, and add or remove features from your list with the @add-feature and @remove-feature commands.
36
5
4
10
2
Syntax: @rmalias <alias>[,...,<alias>] from <object>
2
        @rmalias <alias>[,...,<alias>] from <object>:<verb-name>
2
        @rmalias# <alias>[,...,<alias>] from <object>:<verb-number>
2

2
The first form is used to remove aliases from an object.  If the object is a valid player, space and commas will be assumed to be separations between unwanted aliases.  Otherwise, only commas will be assumed to be separations.
2
Note that @rmalias will not affect the object's name, only its aliases.
2

2
The second form is for use by programmers, to remove aliases from a verb they own.  All spaces and commas are assumed to be separations between unwanted aliases.
2

2
The third form, @rmalias#, is for unambiguously referring to a verb on an object that might have more than one verb with the same name. The verb-number is the 1-based index of the verb as it appears in the verb() (or @verbs) output list.
36
5
4
25
2
Syntax: @addalias <alias>[,...,<alias>] to <object>
2
        @addalias <alias>[,...,<alias>] to <object>:<verb-name>
2
        @addalias# <alias>[,...,<alias>] to <object>:<verb-number>
2

2
The first form is used to add aliases to an object's list of aliases.  You can separate multiple aliases with commas.  The aliases will be checked against the object's current aliases and all aliases not already in the object's list of aliases will be added.
2

2
Example:
2
Muchkin wants to add new aliases to Rover the Wonder Dog:
2
  @addalias Dog,Wonder Dog to Rover
2
Since Rover the Wonder Dog already has the alias "Dog" but does not have the alias "Wonder Dog", Munchkin sees:
2
  Rover the Wonder Dog(#4237) already has the alias Dog.
2
  Alias Wonder Dog added to Rover the Wonder Dog(#4237).
2

2
If the object is a player, spaces will also be assumed to be separations between aliases and each alias will be checked against the Player Name Database to make sure no one else is using it. Any already used aliases will be identified.  Certain other classes of objects (e.g., mail-recipients) also enforce rules about what aliases may be given them.
2

2
Example:
2
Munchkin wants to add his nicknames to his own list of aliases:
2
  @addalias Foobar Davey to me
2
@Addalias recognizes that Munchkin is trying to add an alias to a valid player and checks the aliases against the Player Name Database.  Unfortunately, DaveTheMan is already using the alias "Davey" so Munchkin sees:
2
  DaveTheMan(#5432) is already using the alias Davey
2
  Alias Foobar added to Munchkin(#1523).
2

2
The second form of the @addalias command is for use by programmers, to add aliases to a verb they own.  All commas and spaces are assumed to be separations between aliases.
2

2
The third form, @addalias#, is for unambiguously referring to a verb on an object in case there are more than one with the same name. The verb number is the 1-based index of the verb as it appears in the verbs() (or @verbs) output list.
36
5
4
5
2
*forward*
2
summary
2

2
Type 'help <topic>' for information on a particular topic.
2

36
5
4
4
2
Every object (including players, rooms, exits) has a name and a set of aliases. The object name is commonly used to display an object in various contexts. The object aliases are used to refer to an object when players type commands.
2
Help is available on the following commands:
2
@rename -- change the names or aliases of an object or yourself.
2
@addalias, @rmalias -- add and remove aliases.
36
5
4
7
2
Usage:    @request <player-name> for <email-address>
2

2
Example:  @request Munchkin for msneed@baum.edu
2

2
This command is available to Guest characters only.
2

2
The @request command requests a new character, registered for your email address. Please use your primary address for this, as your password will be sent to the address provided.
36
5
4
6
2
*subst*
2
A player name must be a single word, must not contain any spaces, backslashes, or quotes, nor can it begin with the characters #, *, (, or ).  Finally it cannot be one that is in use by any other player nor any of the words on the following list:
2

2
%;;lns={};for l in ($string_utils:columnize({@$player_db.stupid_names,@$player_db.reserved},6)) lns={@lns,"  "+l}; endfor return lns;
2

2
Note that these rules apply as well to your single-word aliases, since those can equally well be used to refer to you in commands that match on player names (@who, whereis, ...).  There are no restrictions on your multi-word aliases, however the commands that expect player names will not recognize them.
36
5
4
6
2
  @registerme as <email-address>
2
This verb changes your registered email_address property. It will modify the registration, and then, to validate the email address, it will assign a new password and mail the password to the given email_address.
2
If, for some reason, this is a problem for you, contact a wizard or registrar to get your email address changed.
2

2
  @registerme
2
Prints your registered email address.
36
5
4
2
2
*forward*
2
@eject
36
5
4
5
2
Options allow you to customize the behavior of various commands.  Options are grouped into separate option packages that each affects a given class of related commands.  Each has its own help topic:
2

2
  @mail-options    --- mail commands (@mail, @read, @next, @prev, @send...)
2
  @edit-options    --- editing commands (@edit and commands within the editor)
2
  @build-options   --- building commands (@create, @dig, @recycle)
36
5
4
4
2
Syntax:  @age [player]
2

2
Displays the MOO age of the player if the player specified first connected after initial connections were recorded.
2
MOO age is computed from the moment the player first connected until the current time.
36
5
4
9
2
Syntax:  @edit <object>.<property>
2
         @edit <object>:<verb-name> [<dobj> [<prep> [<iobj>]]]
2
         @edit <object>
2

2
Enters a MOO editor, as appropriate.
2

2
Chooses the MOO Note editor for the named property, or the MOO verb editor for the named verb.  If no property or verb name is given, assumes property .text for a note object, or .description for any other object.
2

2
See 'help editors' for more detail.
36
5
4
2
2
*forward*
2
@add-feature
36
5
4
15
2
There are several commands available to allow you to communicate with your fellow MOOers.  Help is available on the following communication-related topics:
2

2
say      -- talking to the other connected players in the room
2
whisper  -- talking privately to someone in the same room
2
page     -- yelling to someone anywhere in the MOO
2
emote    -- non-verbal communication with others in the same room
2
gagging  -- screening out noise generated by certain other players
2
news     -- reading the wizards' most recent set of general announcements
2
@gripe   -- sending complaints to the wizards
2
@typo @bug @idea @suggest
2
         -- sending complaints/ideas to the owner of the current room
2
whereis  -- locating other players
2
@who     -- finding out who is currently logged in
2
mail     -- the MOO email system
2
security -- the facilities for detecting forged messages and eavesdropping.
36
5
4
7
2
Objects are the fundamental building blocks of the MOO.  Every object has a unique number, a name, an owner, a location, and various other properties.  An object can always be referred to by its number, and sometimes by its name or one of its aliases -- if you are in the same location as the object, for example, and also in some other special cases.
2

2
For help on creating an object, see 'help @create'.
2

2
For help on recycling an object, see 'help @recycle'.
2

2
For help on finding information about specific objects, see 'help @display', 'help @show', and 'help $object_utils'.
36
1
4
5
2
Every object on the MOO (players included) has a list of aliases, or names by which it can be referred.  This is useful when an object has a nice long descriptive name that you don't want to have to type every time you refer to it.
2

2
Typing `exam object' will show you its aliases.  If you are a programmer, you can type `#<object>.aliases', using an object's number, or `#Munchkin.aliases p'.  (The `p' indicates that the prefix is a player's name.)
2

2
See also `help #', `help @addalias', and `help @rmalias'.
36
1
4
2
2
*forward*
2
@check
36
5
4
3
2
Syntax:  @users
2

2
Prints out the number of users currently connected and a list of their names, in alphabetical order.
36
5
4
2
2
*forward*
2
 name
36
5
4
2
2
*forward*
2
@addalias
36
5
4
3
2
Syntax:  @mode <brief | verbose>
2

2
Sets your current mode to either brief or verbose.  In brief mode, when you enter into a room, you will not see the room's description unless you explicitly type `look'.  Verbose is the default mode.
36
1
4
2
2
*forward*
2
wizard-list
36
5
4
10
2
Players sometimes have difficulty getting their backspace key to work.  This is an outside-MOO problem:  Whatever access software you have determines how the line you type is edited before the MOO ever sees it.  If your backspace key won't work here, you will probably need to consult with some documentation or a guru at your end.
2

2
The above notwithstanding, here are a few things to try instead of backspace:
2

2
   ctrl-h            (another way of typing backspace)
2
   del               (delete character)
2
   ctrl-backspace    (another way of typing delete character)
2
   ctrl-w            (delete word left)
2
   ctrl-u            (delete entire line)
2
   ctrl-r            (redraw line)
36
5
4
8
2
The spivak pronouns were developed by mathematician Michael Spivak for use in his books.  They are the most simplistic of the gender neutral pronouns (others being "neuter" and "splat") and can be easily integrated into writing.  They should be used in a generic setting where the gender of the person referred to is unknown, such as "the reader."  They can also be used to describe a specific individual who has chosen not to identify emself with the traditional masculine (male) or feminine (female) gender.
2

2
The spivak pronouns are
2
E      - subjective
2
Em     - objective
2
Eir    - possessive (adjective)
2
Eirs   - possessive (noun)
2
Emself - reflexive
36
5
4
3
2
Usage: @owner object
2

2
Displays the specified object, its object number, and its owner (and its owner's object number).
36
1
4
5
2
Checkpointing refers to process by which the MOO makes a backup copy of itself.  Because the computer that's running the MOO has to simultaneously handle two copies of itself, this results in a period of high lag for the MOO users.  So, why do we put up with this?
2

2
Every successful checkpoint results in a database of what the MOO was like at that point in time.  All the MOOmail, mailing lists, objects, descriptions, properties, and verbs on all of the MOO are frozen in time and stored.  In the event that the MOO crashes (due to a power failure or the like), this checkpoint database can be used to restart the MOO with much of our recent work intact.  This is a very good thing.
2

2
Checkpointing is a global backup.  Do not rely on the checkpoint database to back up your own work!  Archive your code, properties, and objects offline to ensure their safety.  Each successful checkpoint overwrites the previous day's checkpoint, so it is an unreliable means of recovering lost data.  Some of these checkpoints do get backed up quarterly, but these are not available without inconveniencing the MOO populace as a whole.
36
1
5
36
5
4
1
2
gen-index
36
1
5
36
4
4
0
36
5
4
9
2
The object $help is the main help database.  For every help topic there is a corresponding property on $help, interpreted as follows:
2

2
$help.(topic) = string           - one-line help text.
2
$help.(topic) = {"*verb*",@args} - call this:verb(args,{}) to get text
2
$help.(topic) = any other list   - multi-line help text
2

2
There is also a "" property which applies in the case of `help' typed without any arguments.
2

2
See the description of $generic_help for more detail.
36
5
4
2
0
96515
0
1641541193
36
1
#61
News
16
36
1
46
0
0
4
0
1
45
4
0
21
description
36
173
-1
is_writable_by
2
173
-1
rm_message_seq
36
173
-1
undo_rmm
36
173
-1
expunge_rmm
36
173
-1
set_current_news
36
173
-1
add_current_news
36
173
-1
rm_current_news
36
173
-1
news_display_seq_full
2
173
-1
to_text
36
173
-1
check
2
173
-1
touch
2
45
-1
@addnews
2
157
1
@rmnews
2
157
5
@setnews
2
105
1
_parse
36
173
-1
init_for_core
2
173
-1
add_news
2
173
-1
rm_news
2
173
-1
@listnews
2
141
4
@clearnews
2
41
-1
4
current_news
last_news_time
current_news_going
archive_news
26
4
2
0
1
0
2
36
5
0
1084848652
36
5
4
0
36
5
4
0
36
5
4
0
36
5
0
1084848652
36
1
4
0
36
0
0
1
36
5
2
%n (%#) can't send to moderated list %t (%[#t]) directly.
36
5
4
0
36
5
0
1
36
5
4
0
36
1
4
0
36
1
0
0
36
1
0
1084848652
36
1
4
1
4
2
0
1
4
150
0
1084848652
2
Wizard (#2)
2
*News (#61)
2
Welcome to LambdaCore
2

2
Getting Started with your LambdaCore MOO
2
========================================
2

2
Thank you for choosing LambdaCore!
2

2
Initial Setup Notes
2
-------------------
2

2
The "welcome" screen, seen when a player connects.
2
  -- this is stored in $login.welcome_message
2

2
Do you want on-line character creation?
2
  -- this is stored in $login.create_enabled
2
     for more detailed information, edit $login:player_creation_enabled
2

2
Do you want to limit the number of players on the MOO at once?
2
  -- look at $login.max_connections
2
     the `connection_limit' message on $login is the message printed
2
     when this limit is reached.
2

2
Do you want a different default player class?
2
  -- set $player_class to a different value
2
     *do not* change $player
2

2
You should also set the following:
2
  $network.postmaster
2
    -- your email address, or the email address of the person who will 
2
       handle your email
2
  $network.site
2
    -- the machine your MOO is running on (e.g. "lambda.moo.mud.org")
2
  $network.port
2
    -- the port your MOO is running on (e.g. 8888)
2
  $network.MOO_Name
2
    -- the name of your MOO (e.g. "LambdaMOO")
2
  $site_db.domain
2
  -- this is set to the `domain' of your address
2
     (eg `foo.com' for `moo.foo.com')
2

2
If you compiled the server with open_network_connection() enabled (allowing the MOO to open up connections with other computers on the network), then you should set
2
  $network.active = 1
2
     This will enable @newpassword, @registerme, @password, @mailme, @netforward, and others to send mail from the MOO.
2

2
-------------------------------------------------------------------
2

2
Setting Yourself Up
2
-------------------
2

2
Set a password for yourself.
2
  -- @password <new-password>
2

2
Set a description for yourself.
2
  -- @describe me as <anything>
2

2
Set a gender for yourself.
2
  -- @gender <gender>
2

2
There are, also, a large number of messages you can set on yourself.  Setting them will enhance the virtual reality.
2

2
-------------------------------------------------------------------
2

2
About Guests
2
------------
2

2
To make a new Guest character:
2
  -- @make-guest <guestname>
2
     will make a new guest with the name you specify with `_Guest' appended
2
     and some other standard but useful aliases
2

2
This is the easiest way to make Guest characters.  The most important things to remember about Guests, if you want to make them yourself, are:
2
  -- make them owned by nonwizards, and not owned by themselves
2
  -- make sure they've got .password == 0, and that .password is nonclear
2
  -- at least one Guest must always be named `Guest'; this can be an alias
2

2
To set the default description and gender for a guest:
2
  -- set .default_description to the description the guest should start with
2
  -- set .default_gender to the gender the guest should start with
2
  -- remember to set .description and .gender too, for the guest's first use
2

2
-------------------------------------------------------------------
2

2
Adding to the Newspaper
2
-----------------------
2

2
The newspaper is a special mailing list.  To add a post to the newspaper, send mail to it (as *News or $news), and then note the number of your post (let's call it <x> and:
2
  -- @addnews <x> to *News
2
... in general, `@addnews $ to *News' will work as well.
2

2
-------------------------------------------------------------------
2

2
Quota
2
-----
2

2
By default, LambdaCore runs with byte-based quota, an in-DB quota system, limiting users by total database space as opposed to total objects.  You'll need to do two things:
2
  -- decide on the default quota:
2
     ;$byte_quota_utils.default_quota[1] = <a number of bytes>
2
  -- start the measurement task; see `help routine_tasks' for more information (Note: this help topic contains information about more than just the quota task; it should be read regardless of how quota is set).
2

2
If you prefer the quota system documented in the LambdaMOO Programmer's Manual, directly supported by the server, you can enable object-based quota:
2
  -- set $quota_utils to $object_quota_utils
2

2
It's best that you make this switch before users start, because converting existing users is an awkward (and inherently arbitrary and political) move.
2

2
-------------------------------------------------------------------
2

2
Making Programmers
2
------------------
2

2
The command to turn someone into a programmer is `@programmer'  Its syntax is `@programmer <user>'.  For example:
2
  -- @programmer Haakon
2
The `@programmer' verb will prompt you if the user isn't set up with a description and a gender.
2

2
No code to automatically grant programmer bits is included with LambdaCore.
2

2
Making Wizards
2
--------------
2

2
THINK CAREFULLY.
2

2
Be very careful before giving someone a wizard bit.  That person can do gross damage to your database, and fixable but serious damage to the machine it runs on.  That person can quite possibly open outbound network connections from your machine, and thus commit acts for which your host system will be blamed.  That person can ruin your MOO's as-yet-untarnished reputation.
2

2
Wizards have technical power, the ability to change anything within the database, to create anything within the database.  Be careful with the idea of a `Social Wizard' -- a nontechnical person holding a wizard bit is fairly likely to, at some point, accidentally do something destructive.  It's a good idea not to socialize as your wizard character, for the same reason, to make it less likely to be accidentally destructive.
2

2
That said, in general you don't turn an existing character into a wizard, you make a -new- character to be the wizard.  This is because the existing character probably owns code and objects which could be destructive if suddenly made wizardly; it's a good security measure to make a fresh player.  So, to make a fresh player:
2
  -- @make-player (see `help @make-player' for more information)
2
     this will make you a new player. for this example, #123
2

2
To make #123 a wizard:
2
  -- @programmer #123
2
     (a nonprogrammer wizard is a truly strange beast)
2
  -- ;#123.wizard = 1;
2
  -- @chparent #123 to $wiz
2
  -- ;#123.public_identity = <the player's nonwizard character's object number>
2

2
-------------------------------------------------------------------
2

2
Good luck with your new LambdaCore database!
2

2
Visit us at LambdaMOO: lambda.moo.mud.org 8888
2

2
Join the international mailing list for MOO coders: send an email message to moo-cows-request@the-b.org with the word `subscribe' as the body of your message.
2

2
Do good things.
2

2
The LambdaMOO Wizards
2
[authored February 15, 1999]
36
0
5
36
5
5
36
5
4
0
36
1
5
36
0
5
36
0
5
36
0
0
0
36
4
4
1
2
News
36
1
2
It's the current issue of the News, dated %d.
36
5
4
2
0
29103
0
1641541193
36
1
#62
The First Room
16
36
1
-1
0
0
4
1
1
2
1
3
4
0
5
disfunc
2
173
-1
enterfunc
2
173
-1
match
36
173
-1
init_for_core
2
173
-1
keep_clean
2
173
-1
0
17
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
4
0
36
4
5
36
5
5
36
5
4
0
36
4
5
36
5
5
36
5
5
36
4
4
0
36
5
2
This is all there is right now.
36
5
4
2
0
6559
0
1641541193
36
1
#63
Recycling Center
16
36
1
-1
0
0
4
0
1
5
4
0
15
_recreate
2
173
-1
_recycle
2
173
-1
_create
2
173
-1
addhist
2
173
-1
show*-history
2
45
-1
setup_toad
2
173
-1
add_orphan
36
173
-1
remove_orphan
36
173
-1
valid
2
173
-1
init_for_core
2
173
-1
reclaim_lost_souls
2
173
-1
check_quota_scam
2
173
-1
gc
36
173
-1
moveto
36
173
-1
kill_all_tasks
2
173
-1
5
orphans
announce_removal_msg
nhist
history
lost_souls
17
4
0
36
1
2

36
5
0
50
36
0
4
0
36
0
4
0
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
4
4
2
2
Recycling Center
2
Center
36
5
2
Object reuse. Call $recycler:_create() to create an object (semantics the same as create()), $recycler:_recycle() to recycle an object. Will create a new object if nothing available in its contents. Note underscores, to avoid builtin :recycle() verb called when objects are recycled. Uses $building_utils:recreate() to prepare objects.
36
5
4
2
0
13313
0
1641541193
36
1
# 64 recycled
#65
Mail Options
16
36
1
-1
0
0
4
0
1
68
4
0
20
actual
36
173
-1
parse_@mail
36
173
-1
parse_sticky parse_manymsgs
36
173
-1
parse_replyto
36
173
-1
show_manymsgs
36
173
-1
show_sticky
36
173
-1
show_@mail
36
173
-1
show_replyto
36
173
-1
show
36
173
-1
check_replyto
36
173
-1
show_netmail
2
173
-1
check_netmail
2
173
-1
show_expire
36
173
-1
parse_expire
36
173
-1
init_for_core
2
165
-1
check_news
36
173
-1
parse_news
36
173
-1
show_news
36
173
-1
parse_@unsend
2
173
-1
show_@unsend
2
173
-1
18
show_include
show_all
show_nosubject
show_expert
show_enter
type_manymsgs
type_@mail
type_replyto
type_expire
show_followup
show_resend_forw
choices_rn_order
show_no_auto_forward
show_expert_netfwd
show_no_dupcc
show_no_unsend
type_@unsend
unsend_sequences
26
4
2
2
Original message will not be included in replies
2
Original message will be included in replies
36
5
4
2
2
Replies will go to original sender only.
2
Replies will go to original sender and all previous recipients.
36
5
4
2
2
Mail editor will initially require a subject line.
2
Mail editor will not initially require a subject line.
36
5
4
2
2
Novice mail user...
2
Expert mail user...
36
5
4
2
2
Mail editor will not start with an implicit `enter' command.
2
Mail editor will start with an implicit `enter' command.
36
5
4
1
0
0
36
5
4
2
0
2
4
1
0
2
36
5
4
2
0
1
4
1
0
1
36
5
4
1
0
0
36
5
4
2
2
No special reply action for messages with non-player recipients.
2
Replies go only to first non-player recipient if any.
36
5
4
2
2
@resend puts player in Resent-By: header
2
@resend puts player in From: header (like @forward)
36
5
4
3
4
2
2
read
4
1
2
.current_message folders are sorted by last read date.
4
2
2
send
4
1
2
.current_message folders are sorted by last send date.
4
2
2
fixed
4
1
2
.current_message folders are not sorted.
36
5
4
2
2
@netforward when expiring messages
2
do not @netforward messages when expiring mail
36
5
4
2
2
@netforward confirms before emailing messages
2
@netforward doesn't confirm before emailing messages
36
5
4
2
2
i want to read mail to me also sent to lists i read
2
don't send me personal copies of mail also sent to lists i read
36
1
4
2
2
People may @unsend unread messages they send to me
2
No one may @unsend messages they sent to me
2
1
4
2
0
2
4
1
0
2
2
1
4
7
2
before
2
after
2
since
2
until
2
subject
2
body
2
last
2
1
4
20
2
include
2
all
2
followup
2
nosubject
2
expert
2
enter
2
sticky
2
@mail
2
manymsgs
2
replyto
2
netmail
2
expire
2
resend_forw
2
rn_order
2
no_auto_forward
2
expert_netfwd
2
news
2
no_dupcc
2
no_unsend
2
@unsend
36
1
2
!include!noinclude!all!sender!nosubject!expert!enter!sticky!@mail!manymsgs!replyto!netmail!expire!followup!resend_forw!rn_order!no_auto_forward!expert_netfwd!news!no_dupcc!no_unsend!@unsend!
36
1
4
2
2
noinclude
2
sender
36
1
0
25
36
5
5
36
4
4
1
2
Mail Options
36
5
2
Options for mailing
36
5
4
2
0
21303
0
1641541193
36
1
#66
Edit Options
16
36
1
-1
0
0
4
0
1
68
4
0
2
actual
36
173
-1
show
36
173
-1
4
show_quiet_insert
show_eval_subs
show_local
show_no_parens
12
4
2
2
Report line numbers on insert or append.
2
No echo on insert or append.
36
5
4
2
2
Ignore .eval_subs when compiling verbs.
2
Use .eval_subs when compiling verbs.
36
5
4
2
2
Use in-MOO text editors.
2
Ship text to client for local editing.
36
5
4
2
2
include all parentheses when fetching verbs.
2
includes only necessary parentheses when fetching verbs.
36
5
4
4
2
quiet_insert
2
eval_subs
2
local
2
no_parens
36
1
2
!quiet_insert!eval_subs!local!no_parens!parens!noisy_insert!
36
1
4
2
2
parens
2
noisy_insert
36
1
0
25
36
5
5
36
4
4
1
2
Edit Options
36
5
5
36
5
4
2
0
2904
0
1641541193
36
1
#67
Display Options
16
36
1
-1
0
0
4
0
1
68
4
0
0
3
show_blank_tnt
show_shortprep
show_thisonly
11
4
2
2
Treat `this none this' verbs like the others.
2
Blank out the args on `this none this' verbs.
36
5
4
2
2
Display prepositions in full.
2
Use short forms of prepositions.
36
5
4
2
2
./: will show ancestor properties/verbs if none on this.
2
./: will not show ancestor properties/verbs.
36
5
4
3
2
blank_tnt
2
shortprep
2
thisonly
36
1
2
!blank_tnt!shortprep!thisonly!
36
1
4
0
36
1
5
36
5
5
36
4
4
1
2
Display Options
36
5
5
36
5
4
2
0
1273
0
1641541193
36
1
#68
Generic Option Package
144
36
1
-1
0
0
4
0
1
1
4
6
1
65
1
66
1
67
1
77
1
76
1
102
12
get
36
173
-1
set
36
173
-1
parse
36
173
-1
_name
36
173
-1
add_name
36
173
-1
remove_name
36
173
-1
show
36
173
-1
actual
36
173
-1
istype
36
173
-1
islistof
36
173
-1
desc_type
36
173
-1
parsechoice
36
173
-1
4
names
_namelist
extras
namewidth
8
4
0
36
1
2
!
36
1
4
0
36
1
0
25
36
5
5
36
4
4
1
2
Generic Option Package
36
5
2
an option package in need of a description.  See `help $generic_option'...
36
5
4
2
0
17483
0
1641541193
36
1
#69
Error Generator
16
36
1
-1
0
0
4
0
1
1
4
0
20
raise
36
173
-1
E_NONE
36
173
-1
E_TYPE
36
173
-1
E_DIV
36
173
-1
E_PERM
36
173
-1
E_PROPNF
36
173
-1
E_VERBNF
36
173
-1
E_VARNF
36
173
-1
E_INVIND
36
173
-1
E_RECMOVE
36
173
-1
E_MAXREC
36
173
-1
E_RANGE
36
173
-1
E_ARGS
36
173
-1
E_NACC
36
173
-1
E_INVARG
36
173
-1
E_QUOTA
2
173
-1
accept
36
173
-1
name
36
173
-1
toerr
36
173
-1
match_error
36
173
-1
2
names
all_errors
6
4
16
2
E_NONE
2
E_TYPE
2
E_DIV
2
E_PERM
2
E_PROPNF
2
E_VERBNF
2
E_VARNF
2
E_INVIND
2
E_RECMOVE
2
E_MAXREC
2
E_RANGE
2
E_ARGS
2
E_NACC
2
E_INVARG
2
E_QUOTA
2
E_FLOAT
36
5
4
16
3
0
3
1
3
2
3
3
3
4
3
5
3
6
3
7
3
8
3
9
3
10
3
11
3
12
3
13
3
14
3
15
36
1
5
36
4
4
1
2
Error Generator
36
5
4
3
2
Object to automatically generate errors.
2

2
raise(error) actually raises the error.
36
5
4
2
0
12480
0
1641541193
36
1
#70
Site-Locks
0
2
1
46
0
0
4
0
1
45
4
0
1
init_for_core
2
173
-1
0
22
4
0
2
5
0
0
36
1
4
0
36
0
0
1
2
5
2
%n (%#) can't send to moderated list %t (%[#t]) directly.
2
5
4
0
2
5
4
0
2
5
4
1
1
2
36
1
4
0
36
1
0
2592000
36
1
0
0
36
1
4
0
36
0
5
2
5
5
2
5
4
0
36
1
5
36
0
5
36
0
5
36
0
5
2
4
4
1
2
Site-Locks
36
1
2
Notes on annoying sites.
2
5
4
2
0
1864
0
1648488120
36
1
#71
housekeeper
19
71
1
-1
0
0
4
0
1
58
4
0
24
look_self
71
173
-1
cleanup
71
173
-1
replace
71
173
-1
cleanup_list
71
29
-1
add_cleanup
71
93
-2
remove_cleanup
71
29
-1
controls
71
173
-1
continuous
71
173
-1
litterbug
71
173
-1
is_watching
71
173
-1
send_home
71
173
-1
moveit
2
173
-1
ejectit
2
173
-1
is_object_cleaned
71
173
-1
is_litter
71
173
-1
init_for_core
2
173
-1
clean_status
71
173
-1
is_cleaning
71
173
-1
time
71
173
-1
acceptable
2
173
-1
move_players_home
2
173
-1
move_em
2
173
-1
take_away_msg drop_off_msg
71
173
-1
set_moveto_task
71
173
-1
17
recycle_bins
owners
cleaning
litter
eschews
public_places
task
requestors
destination
clean
testing
player_queue
take_away_msg
drop_off_msg
move_player_task
moveto_task
cleaning_index
112
4
0
71
5
4
1
1
2
71
5
1
-1
71
5
4
0
71
5
4
0
71
5
4
0
71
5
0
0
71
5
4
0
71
5
4
0
71
5
4
0
71
1
0
0
71
5
4
0
71
1
2
%[tpsc] arrives to cart %n off to bed.
71
5
2
%[tpsc] arrives to drop off %n, who is sound asleep.
71
5
0
0
71
1
0
0
71
5
0
0
71
5
4
0
36
1
5
36
1
2
here=player.location;me=player
36
1
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
0
0
36
1
5
71
5
5
71
5
5
71
5
5
36
1
5
71
5
5
71
4
5
71
5
5
2
1
4
1
1
2
71
5
4
0
71
5
5
71
5
5
71
5
5
71
4
5
71
4
5
98
1
5
98
1
4
0
98
1
4
2
1
90
1
89
36
1
5
2
0
5
2
0
0
2147483647
2
1
0
0
71
5
5
71
5
5
36
1
5
36
1
5
36
0
5
36
1
4
1
1
71
2
1
0
-80
36
1
5
71
4
5
2
0
5
2
0
5
71
5
5
71
5
2
The housekeeper is too busy putting away all of the junk all over LambdaMoo that there isn't time to listen to pages and stuff like that so your page isn't listened to, too bad.
71
5
5
71
5
5
71
5
5
71
5
5
2
1
0
-9993
36
0
1
62
71
5
2
Impossible password to type
2
0
5
71
5
5
71
5
5
71
5
0
2147483647
2
1
4
4
0
183000
0
32307
0
1648488120
0
0
36
0
0
0
2
0
5
2
0
5
2
1
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
5
5
71
4
4
1
2
housekeeper
2
1
2
A very clean, neat, tidy person who doesn't mind lugging players and their gear all over the place.
71
5
4
2
0
32307
0
1648488120
36
1
#72
Network Utilities
16
2
1
-1
0
0
4
0
1
1
4
0
25
parse_address
2
173
-1
local_domain
2
173
-1
open
2
173
-1
close
2
173
-1
sendmail
2
29
-1
trust
2
173
-1
init_for_core
2
173
-1
raw_sendmail
2
29
-1
invalid_email_address
2
173
-1
invalid_hostname
2
173
-1
email_will_fail
2
173
-1
read
2
173
-1
is_open
36
173
-1
incoming_connection
2
173
-1
return_address_for
2
173
-1
server_started
2
173
-1
is_outgoing_connection
2
173
-1
notify
2
173
-1
suspend_if_needed
2
173
-1
error
2
173
-1
help_msg
36
173
-1
adjust_postmaster_for_password
2
173
-1
add_queued_mail
36
173
-1
send_queued_mail
2
173
-1
tcp_wait
2
173
-1
21
site
large_domains
connect_connections_to
postmaster
port
MOO_name
valid_host_regexp
maildrop
trusts
active
valid_email_regexp
invalid_userids
debugging
errors_to_address
suspicious_userids
usual_postmaster
password_postmaster
queued_mail
queued_mail_task
envelope_from
blank_envelope
25
2
yoursite
2
1
4
0
2
1
4
0
2
0
2
postmastername@yourhost
2
5
0
7777
2
5
2
YourMOO
2
5
2
^%([-_a-z0-9]+%.%)+%(gov%|edu%|com%|org%|int%|mil%|net%|%nato%|arpa%|name%|info%|[a-z][a-z]%)$
2
5
2
localhost
2
5
4
1
1
36
2
1
0
0
2
5
2
^[-a-z0-9_!.%+$'=/]*[-a-z0-9_!%+$'=]$
2
5
4
7
2

2
sysadmin
2
root
2
postmaster
2
system
2
operator
2
bin
2
5
0
0
2
5
2
moomailerrors@yourhost
2
5
4
13
2

2
sysadmin
2
root
2
postmaster
2
bin
2
SYSTEM
2
OPERATOR
2
guest
2
me
2
mailer-daemon
2
webmaster
2
sysop
2
info
2
5
2
postmastername@yourhost
2
5
2
postmastername@yourhost
2
5
4
0
36
0
0
1076002766
36
1
2
postmastername@yourhost
2
5
0
0
2
5
0
0
2
4
4
1
2
Network Utilities
2
5
4
74
2
Utilities for dealing with network connections
2
---------------
2
Creating & tracking hosts:
2

2
:open(host, port [, connect-connection-to]) => connection
2
    open a network connection (using open_network_connection).
2
    If 'connect-connection-to' is a player object, the
2
    connection will be connected to that object when it
2
    gets the first line of input.
2

2
:close(connection)
2
     closes the connection & cleans up data
2

2
------------------
2
Parsing network things:
2

2
:invalid_email_address(email)
2
     return "" or string saying why 'email' is invalid.
2
     uses .valid_email_regexp
2

2
:invalid_hostname(host)
2
     return "" or string saying why 'host' doesn't look
2
     like a valid internet host name
2

2
:local_domain(host)
2
     returns the 'important' part of a host name, e.g.
2
     golden.parc.xerox.com => parc.xerox.com
2

2
-------------------
2
Sending mail
2

2
:sendmail(to, subject, @lines)
2
     send mail to the email address 'to' with indicated subject.
2
     header fields like 'from', 'date', etc. are filled in.
2
     lines can start with additional header lines.
2

2
:raw_sendmail(to, @lines)
2
     used by :sendmail. Send mail to given user at host, just
2
     as specified, no error checking.
2

2
================================================================
2
Parameters:
2

2
.active If 0, disabled sending of mail.
2

2
.site   Where does this MOO run?
2
        (Maybe MOOnet will use it later).
2

2
.port   The network port this MOO listens on.
2

2
.large_domains 
2
        A list of sites where more than 2 levels of host name are
2
        significant, e.g., if you want 'parc.xerox.com' to be
2
        different than 'cinops.xerox.com', put "xerox.com" as an
2
        element in .large_domains.
2

2
.postmaster
2
        Email address to which problems with MOO mail should
2
        go. This should be a real email address that someone reads.
2

2
.maildrop
2
        Hostname to connect to for dropping off mail. Usually can
2
        just be "localhost".
2

2
.reply_address
2
        If a MOO character sends email, where does a reply go?
2
        Inserted in 'From:' for mail from characters without
2
        registration addresses.        
2

2
.trusts
2
        List of (non-wizard) programmers who can call
2
        :open, :sendmail, :close
2

2
                
2
5
4
2
0
32197
0
1648488120
36
1
#73
Generic BigList Resident
144
36
1
-1
0
0
4
0
1
1
4
0
7
_make
2
173
-1
_kill
2
173
-1
_get
36
173
-1
_put
36
173
-1
_genprop
36
173
-1
_ord
36
173
-1
init_for_core
2
173
-1
3
_genprop
mowner
_mgr
7
2
a
36
5
1
36
36
5
1
13
36
5
5
36
4
4
3
2
biglist
2
resident
2
gblr
36
5
4
1
2
This is the object you want to use as a parent in order to @create a place for your biglists to live.  Suitably sick souls may wish to reimplement :_genprop and :_kill to reclaim unused properties (this :_kill just throws them away and this :_genprop just relentlessly advances....  who cares).  Anyway, you'll need to look at $biglist before this will make sense.
36
5
4
2
0
5624
0
1641541193
36
1
#74
Generic Feature Object
144
36
1
-1
0
0
4
0
1
5
4
2
1
89
1
90
12
help_msg
36
173
-1
look_self
36
173
-1
using this
36
173
-1
examine_commands_ok
2
173
-1
set_feature_ok
36
173
-1
hidden_verbs
36
173
-1
set_feature_verbs
36
173
-1
initialize
36
173
-1
init_for_core
2
173
-1
feature_remove
2
173
-1
player_connected
2
173
-1
has_feature_verb
2
173
-1
4
warehouse
help_msg
feature_verbs
feature_ok
16
1
83
36
1
2
The Generic Feature Object--not to be used as a feature object.
36
5
4
1
2
Using
36
1
0
1
36
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
4
4
4
2
Generic Feature Object
2
Generic .Features_Huh Object
2
Feature Object
2
.Features_Huh Object
36
5
2
This is the Generic Feature Object.  It is not meant to be used as a feature object itself, but is handy for making new feature objects.
36
5
4
2
0
11423
0
1641541193
36
1
#75
Shapes Object Serialization Library
0
2
1
-1
0
0
4
0
1
-1
4
0
23
_log
2
172
-1
_suspend_if_necessary
2
172
-1
_controls controls
2
164
-1
_controls_verb
2
164
-1
_controls_property
2
164
-1
objects
2
172
-1
read_object
2
172
-1
write_object
2
172
-1
_parent_property_info
2
172
-1
_values
2
172
-1
values
2
172
-1
read_value
2
172
-1
write_value
2
172
-1
_write_parents
2
172
-1
_write_player
2
172
-1
read_verb
2
172
-1
write_verb
2
172
-1
read_property
2
172
-1
write_property
2
172
-1
bare_object
2
172
-1
add_value
2
172
-1
add_property_definition
2
172
-1
add_verb_definition
2
172
-1
0
0
#76
Programmer Options
16
36
1
-1
0
0
4
0
1
68
4
0
11
actual
36
173
-1
show
36
173
-1
show_verb_args
36
173
-1
check_verb_args
36
173
-1
parse_verb_args
36
173
-1
show_@prop_flags
36
173
-1
check_@prop_flags
2
173
-1
parse_@prop_flags
2
173
-1
check_verb_perms
2
173
-1
show_verb_perms
2
173
-1
parse_verb_perms
2
173
-1
8
show_eval_time
show_list_all_parens
show_list_no_numbers
show_copy_expert
type_@prop_flags
show_list_show_permissions
show_rmverb_mail_backup
show_//_comments
16
4
2
2
eval does not show ticks/seconds consumed.
2
eval shows ticks/seconds consumed.
36
5
4
2
2
@list shows only necessary parentheses by default
2
@list shows all parentheses by default
36
5
4
2
2
@list gives line numbers by default
2
@list omits line numbers by default
36
5
4
2
2
@copy prints warning message.
2
@copy omits warning message.
36
5
4
1
0
2
36
5
4
2
2
@list does not display permissions in header
2
@list displays permissions in header
36
5
4
2
2
@rmverb does not email you a backup
2
@rmverb emails you a backup before deleting the verb
36
5
4
2
2
Comments shown in editors will be MOO-style.
2
Comments shown in editors will begin with //
36
5
4
10
2
list_all_parens
2
list_no_numbers
2
eval_time
2
copy_expert
2
verb_args
2
verb_perms
2
@prop_flags
2
list_show_permissions
2
rmverb_mail_backup
2
//_comments
36
1
2
!list_all_parens!list_no_numbers!list_show_permissions!eval_time!copy_expert!list_numbers!verb_args!@prop_flags!rmverb_mail_backup!//_comments!verb_perms!
36
1
4
1
2
list_numbers
36
1
0
25
36
5
0
0
36
4
4
1
2
Programmer Options
36
5
4
1
2
Option package for $prog commands.  See `help @prog-options'.
36
5
4
2
0
10468
0
1641541193
36
1
#77
Builder Options
16
36
1
-1
0
0
4
0
1
68
4
0
5
check_create_flags
36
173
-1
show_create_flags
36
173
-1
parse_create_flags
36
173
-1
show_dig_room show_dig_exit
36
173
-1
parse_dig_room parse_dig_exit
36
173
-1
5
show_bi_create
type_dig_room
type_dig_exit
show_audit_bytes
show_audit_float
13
4
2
2
@create/@recycle re-use object numbers.
2
@create/@recycle call create()/recycle() directly.
36
5
4
1
0
1
36
5
4
1
0
1
36
5
4
2
2
@audit/@prospectus shows `<1K'
2
@audit/@prospectus shows bytes
2
1
4
2
2
@audit/@prospectus shows integer sizes (1K)
2
@audit/@prospectus shows floating-point sizes (1.0K)
2
1
4
6
2
dig_room
2
dig_exit
2
create_flags
2
bi_create
2
audit_bytes
2
audit_float
36
1
2
!dig_room!dig_exit!create_flags!bi_create!audit_bytes!audit_float!
36
1
4
0
36
1
0
25
36
5
5
36
4
4
1
2
Builder Options
36
5
4
1
2
Option package for $builder commands.  See `help @build-options'.
36
5
4
2
0
6109
0
1641541193
36
1
#78
Generic Utilities Package
144
2
1
-1
0
0
4
0
1
1
4
23
1
20
1
55
1
24
1
27
1
41
1
26
1
43
1
51
1
52
1
53
1
56
1
42
1
21
1
33
1
13
1
79
1
81
1
59
1
91
1
93
1
99
1
124
1
126
0
1
help_msg
5
4
1
2
This is the Generic Utility Object.  One presumes it should have text in it explaining the use of the utility object in question.
2
5
0
0
2
4
4
1
2
Generic Utilities Package
2
5
2
This is a placeholder parent for all the $..._utils packages, to more easily find them and manipulate them. At present this object defines no useful verbs or properties. (Filfre.)
2
5
4
2
0
835
0
1648488120
36
1
#79
Byte Quota Utilities
16
36
1
-1
0
0
4
0
1
78
4
0
35
initialize_quota
36
173
-1
init_for_core
2
173
-1
adjust_quota_for_programmer
36
173
-1
bi_create
2
173
-1
enable_create
2
173
-1
disable_create
2
173
-1
parse_create_args
36
173
-1
creation_permitted verb_addition_permitted property_addition_permitted
36
173
-1
all_characters
36
173
-1
display_quota
36
173
-1
get_quota
36
173
-1
charge_quota
36
173
-1
reimburse_quota
36
173
-1
set_quota
36
173
-1
get_size_quota
36
173
-1
display_quota_summary
36
173
-1
quota_remaining
36
173
-1
value_bytes
2
173
-1
object_bytes object_size
2
173
-1
do_summary
36
157
0
summarize_one_user
36
173
-1
recent_object_bytes
2
173
-1
measurement_task
2
173
-1
can_peek
36
173
-1
can_touch
36
173
-1
do_breakdown
2
173
-1
object_overhead_bytes
36
173
-1
property_overhead_bytes
2
173
-1
verb_overhead_bytes
2
173
-1
add_owned_object
2
173
-1
measurement_task_nofork
2
173
-1
measurement_task_body
2
173
-1
schedule_measurement_task
2
173
-1
task_perms
2
173
-1
property_exists
2
173
-1
15
default_quota
large_negative_number
max_unmeasured
unmeasured_multiplier
working
cycle_days
task_time_limit
byte_based
exempted
task_repeat
repeat_cycle
too_large
large_objects
report_recipients
measurement_task_running
20
4
4
0
20000
0
0
0
0
0
1
36
5
0
-10000
36
5
0
10
36
5
0
100
36
5
1
96
36
5
0
5
36
5
0
500
36
5
0
1
36
5
4
0
36
5
0
1
36
5
0
0
36
5
0
1000000
36
5
4
1
1
32
36
5
4
0
36
5
0
0
36
5
4
66
2
Verbs a user might want to call from a program:
2
 :bi_create -- built-in create() call, takes same args.
2

2
 :get_quota(who) -- just get the raw size_quota property
2
 :display_quota(who) -- prints to player the quota of who.  If caller_perms() controls who, include any secondary characters.  Called by @quota.
2
 :get_size_quota(who [allchars]) -- return the quota of who, if allchars flag set, add info from all secondary chars, if caller_perms() permits.
2

2
 :value_bytes(value) -- computes the size of the value.
2
 :object_bytes(object) -- computes the size of the object and caches it.
2
 :recent_object_bytes(object, days) -- computes and caches the size of object only if cached value more than days old.  Returns cached value.
2
 :do_summary(user) -- prints out the results of summarize-one-user.
2
 :summarize_one_user(user) -- summarizes and caches space usage for user.  See verb help for details.
2

2
Verbs the system calls:
2
 :"creation_permitted verb_addition_permitted property_addition_permitted"(who) -- returns true if who is permitted to build.
2
 :initialize_quota(who) -- sets quota for newly created players
2
 :adjust_quota_for_programmer(who) -- empty; might add more quota to newly @progged player.
2
 :enable_create(who) -- sets .ownership_quota to 1
2
 :disable_create(who) -- sets .ownership_quota back to -1000 to prohibit create()
2
 :charge_quota(who, object) -- subtract the size of object from who's quota.  Manipulates the #-unmeasured if what is not currently measured.  Called by $wiz_utils:set_owner.
2
 :reimburse_quota(who, object) -- add the size of object to who's quota.  Ditto.
2
 :preliminary_reimburse_quota(who, object) -- Because the set_owner is done *after* an object has been turned into $garbage, ordinary reimbursement fails.  So we use this verb in the $recycler.
2
 :set_quota(who, howmuch)
2
 :quota_remaining(who) 
2
 :display_quota_summary -- internal, called by display quota
2

2
The measurement task:
2

2
 :measurement_task() -- runs once every 24 hours measuring stuff, separated from the scheduling in case you just want to run it once.  Calls the body and then reports via moomail.
2
 :schedule_measurement_task() -- actually schedules it.  Look here to change the start time.
2
 :measurement_task_body(timeout) -- does the real work, working for no longer than timeout seconds.
2
 .task_time_limit -- integer number of seconds indicating for how long it should run each day.
2
 .working -- object indicating the player whom it is either working on now (or if not running) will pick up working on when it commences tonight.
2
 .cycle_days -- integer numbers indicating how long ago an object must have been measured before it will be remeasured.
2
 .repeat_cycle -- boolean.  0 means have a vanilla cycle (goes through all players() exactly once measuring their objects measured more than .cycle_days ago).  1 means to have a much more complex algorithm: The first cycle, it only measures stuff owned by people who have logged in within .cycle_days.  If, in .task_time_limit seconds, it measures all objects not measured in cycle_days owned by such people, it will run again measuring those objects which have not been measured in cycle_days - 1, considering people who have logged in within 4 * cycle_days, repeating until it has used up its seconds.  ("Doing some of tomorrow's work.")  Selecting .repeat_cycle = 1 is appropriate only for large MOOs.
2
 .exempted -- list of objects to never measure (useful if there are huge objects).  Suggested huge objects include $player_db and $site_db.
2
 .measurement_task -- indicates the task_id() of the most recent measurement task -- used to prevent duplicate invocation.
2
 .report_recipients -- recipients of the daily reports.  Set to {} to disable reporting entirely.
2

2
See help @measure and help @quota for the command line verbs.
2

2

2
Porter's notes:  If you are planning on porting this system to another MOO, here are the things to grab in addition to @dumping all of $quota_utils:
2

2
The following verbs have been changed on $prog:
2
@prop*erty @verb @copy (@add-alias @copy-move as well)
2

2
The following verbs have been changed on $wiz:
2
@programmer @quota
2

2
The following verbs have been changed on $wiz_utils:
2
set_programmer set_owner make_player
2

2
The following verbs have been changed on $builder:
2
@quota _create
2

2
This verb probably should have gone on $builder.
2
@measure
2

2
The followig verbs have been changed on $recycler
2
_recycle _create setup_toad
2

2
The following verb has been changed on $login:
2
create
2

2
And don't forget $object_quota_utils, which has the object based implementation.
36
5
0
0
36
4
4
1
2
Byte Quota Utilities
36
5
4
1
2
This is the Byte Quota Utilities utility package.  See `help $quota_utils' for more details.
36
5
4
2
0
44035
0
1641541193
36
1
#80
@paranoid database
16
36
1
-1
0
0
4
0
1
1
4
0
10
ensure_props_exist
36
173
-1
init_for_core
36
173
-1
add_data
36
173
-1
get_data
36
173
-1
erase_data
36
173
-1
set_kept_lines
36
173
-1
gc
36
173
-1
help_msg
2
173
-1
semiweeklyish
2
173
-1
is_paranoid
2
173
-1
1
max_lines
5
0
30
2
1
0
0
36
4
4
2
2
@paranoid database
2
paranoid
36
5
4
19
2

2
This object stores the @paranoid data from :tell.  Normally it is not necessary to access these things directly.  All verbs are controlled by a caller_perms() check.  All data is stored in the old .responsible format.
2

2
:add_data(who,data) adds one line's worth of data to the collection, trimming from the front as necessary.
2

2
:get_data(who) retrieves the entire batch of data.
2

2
:erase_data(who) sets the data to {}
2

2
:set_kept_lines(who,number) Changes the number of kept lines.  Maximum is 20.
2

2
Core verbs that call the above are this are $player:tell, @check, @paranoid, and :erase_paranoid_data.
2

2
Internal:  
2
   Properties used are
2
   tostr(player)+"lines"
2
   tostr(player)+"pdata"
2
   :ensure_props_exist(who,linesname,dataname):  creates the above
2
   :GC() --- loops over all data and verifies they're for players.
36
5
4
2
0
9154
0
1641541193
36
1
#81
Object Quota Utilities
16
36
1
-1
0
0
4
0
1
78
4
0
14
initialize_quota
36
173
-1
init_for_core
2
173
-1
adjust_quota_for_programmer
36
173
-1
bi_create
2
173
-1
creation_permitted
36
173
-1
verb_addition_permitted property_addition_permitted
36
173
-1
display_quota
36
173
-1
get_quota quota_remaining
36
173
-1
charge_quota
36
173
-1
reimburse_quota
36
173
-1
set_quota
36
173
-1
preliminary_reimburse_quota
36
173
-1
can_peek
36
173
-1
can_touch
36
173
-1
1
byte_based
6
0
0
36
5
2
This is the default package that interfaces to the $player/$prog quota manipulation verbs.
36
5
0
0
36
4
4
1
2
Object Quota Utilities
36
5
4
1
2
This is the Object Quota Utilities utility package.  See `help $object_quota_utils' for more details.
36
5
4
2
0
10488
0
1641541193
36
1
#82
Server Options
16
2
1
-1
0
0
4
0
1
1
4
0
2
help_msg
36
173
-1
init_for_core
2
173
-1
18
protect_chparent
protect_add_verb
protect_add_property
protect_recycle
permit_writable_verbs
protect_set_verb_info
queued_task_limit
help_msg
support_numeric_verbname_strings
connect_msg
protect_force_input
protect_set_property_info
fg_ticks
bg_ticks
boot_msg
protect_read
dump_interval
no_name_lookup
22
0
1
2
5
0
1
2
5
0
1
2
5
0
1
2
5
0
0
2
5
0
1
2
5
0
300
2
5
4
36
2
                Server Options <$server_options>
2
                --------------------------------
2

2
messages: 'boot_msg', 'connect_msg', 'create_msg', 'recycle_msg', 'redirect_from_msg', 'redirect_to_msg', and 'timeout_msg'.
2
A number of the messages printed to a connection by the server under various circumstances can now be customized or eliminated from within the DB.  In each case, a property on $server_options is checked at the time the message would be printed.  If the property does not exist, the standard message is printed.  If the property exists and its value is not a string, then no message is printed at all.  Otherwise, the string is printed in place of the standard message.  The following list covers all of the newly customizable messages, showing for each the name of the relevant property on $server_options, the default/standard message, and the circumstances under which the message is printed:
2
'boot_msg'              "*** Disconnected ***"
2
The function boot_player() was called on this connection.
2
'connect_msg'           "*** Connected ***"
2
The user object that just logged in on this connection existed before #0:do_login_command() was called.
2
'create_msg'            "*** Created ***"
2
The user object that just logged in on this connection did not exist before #0:do_login_command() was called.
2
'recycle_msg'           "*** Recycled ***"
2
The logged-in user of this connection has been recycled.
2
'redirect_from_msg'     "*** Redirecting connection to new port ***"
2
The logged-in user of this connection has just logged in on some other connection.
2
'redirect_to_msg'       "*** Redirecting old connection to this port ***"
2
The user who just logged in on this connection was already logged in on some other connection.
2
'timeout_msg'           "*** Timed-out waiting for login. ***"
2
This in-bound network connection was idle and un-logged-in for at least CONNECT_TIMEOUT seconds (as defined in options.h).
2

2
Note: on a 1.8rN server, changes to $server_options will not take effect until load_server_options() has been called.
2

2

2
Some properties on $server_options can change the server behavior:
2

2
'bg_seconds', 'bg_ticks', 'fg_seconds', and 'fg_ticks'.
2
If those properties exist and are numbers, the server use them instead of the constants DEFAULT_BG_SECONDS, DEFAULT_BG_TICKS, DEFAULT_FG_SECONDS and DEFAULT_FG_TICKS (respectively) defined at compile time in "options.h"; they are looked up anew every time a task begins or resumes execution. Those define ticks (basic operations)/real-time seconds any task is allowed to use without suspending. 'fg' constants/properties are used only for 'foreground' tasks (those started by either player input or the server's initiative and that have never suspended); the 'bg' constants/properties are used only for 'background' tasks (forked tasks and those of any kind that have suspended).
2

2
'max_stack_depth' This allow to change in-db the the maximum verb-call depth. Originillay the maximum verb-call depth is defined at compile time by the DEFAULT_MAX_STACK_DEPTH constant in "options.h". The maximum stack depth for any task is set at the time that task is created and cannot be changed thereafter. This implies that suspended tasks, even after being saved in and restored from the DB, are not affected by later changes to $server_options.max_stack_depth. 
2

2
'queued_task_limit' if this property exist and its value is non-negative, then it is used as the maximum of tasks a verb-owner (more exactly the user's perms the verb run with) can queue (through fork() and suspend()). This setting is overriden if the user has a 'queued_task_limit' property and if its value is non-negative. E_QUOTA is raised of either forking or suspending when the user is over quota for tasks.
2

2
'protect_...' On every call to a built-in function 'foo', if the property $server_options.protect_foo exists and is true, and the programmer is not a wizard, then the server checks for the existence of #0:bf_<fuction> and calls that. If it doesn't exist then E_PERM is raised, i.e. the built-in function is made wiz-only.
2

2
'no_name_lookup' If this property exists and is true, the server will no longer automatically handle DNS name lookups. Instead, you'll have to use the 'connection_name_lookup()' function. This has the advantage of performing name lookups in a separate thread (thus not locking the main MOO until it finishes), but it also has the disadvantage of preventing '#0:do_login_command()' from working properly. To mitigate this, you must use the 'switch_player()' function instead of returning an object number. Note that this is the default behavior of ToastCore.
2
                --------------------------------
2
5
0
0
36
1
2
*** Connected ***
2
5
0
1
2
5
0
1
2
1
0
150000
2
5
0
80000
2
5
2

2
5
0
1
2
5
0
3600
2
5
0
1
2
5
0
0
2
4
4
1
2
Server Options
2
5
5
2
5
4
2
0
9190
0
1648488120
36
1
#83
Feature Warehouse
16
36
1
-1
0
0
4
0
1
8
4
0
1
list
36
157
3
0
31
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
2
1
0
0
2
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
0
1
2
1
5
36
4
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
0
0
36
4
4
2
2
Feature Warehouse
2
warehouse
36
5
5
36
5
4
2
0
2626
0
1641541193
36
1
#84
Builder Help DB
16
36
1
-1
0
0
4
0
1
30
4
0
1
init_for_core
2
173
-1
51
builder-index
@locations
@sort-owned
@verify-owned
@add-owned
@recreate
@parents
@contents
key-representation
keys
@unlock
@lock
locking
@classes
@audit
@count
@quota
@create
creation
@dig
@recycle
building
@dump
@setprop
@set
@builder-options
@builderoptions
@buildoptions
@build-options
room-messages
@resident
exit-messages
@add-entrance
@add-exit
topology
@entrances
@exits
containers
rooms
@remove-entrance
@remove-exit
@unlock_for_open
@lock_for_open
@opacity
container-messages
thing-messages
common_quota
object-quota
@measure
audit_bytes
audit_float
57
4
2
2
*index*
2
Builder Help Topics
36
5
4
7
2
Syntax:  @locations object
2

2
Prints out the names and object numbers of all containing objects.
2

2
Example:
2
  @locations ur-Rog
2
  ur-Rog(#6349)   ur-Rog's Display Case(#6355)   Editorial Boardroom(#5747)
36
5
4
5
2
Syntax:  @sort-owned  [ object | size ]
2

2
Sorts your .owned_objects property so @audit shows up sorted.  See help @audit for more information.
2

2
@sort-owned object will sort by object number (the default).  @sort-owned size will sort by size of object as periodically recorded.
36
5
4
3
2
Syntax:  @verify-owned
2

2
Checks that all the objects in your .owned_objects property are actually owned by you, and effects repairs if needed.  See help @audit for more information.
36
5
4
3
2
Syntax:  @add-owned <object>
2

2
Adds an object to your .owned_objects property in case it managed not to get updated properly upon creation of that object.  Checks to ensure that the objects is really owned by you and otherwise belongs in your .owned_objects property.  See help @audit for more information.
36
5
4
7
2
Usage: @recreate <object> as <parent> named <name spec>
2

2
This is a combination of @create and @chparent.  It takes an existing object, completely strips it of any verbs, properties, and values for inherited properties.  This object is then reshaped into a child of the parent specified, as though @create had been called, but retaining the same object number as the original.
2

2
You may use "called" instead of "named" in this command, if you wish.
2

2
The <parent> and <name spec> arguments are as in @create.
36
5
4
8
2
Syntax:  @parents object
2

2
A quick way to find out the ancestry of an object.  Prints out the names and object numbers of all ancestors.
2

2
Example:
2
  @parents Haakon
2
  Haakon(#2)   generic wizard(#218)   generic programmer(#217)   generic 
2
  player(#6)   Root Class(#1)
36
5
4
8
2
Syntax:  @contents object
2

2
A quick way to find out the contents of an object.  Prints out the names and object numbers of all direct contents.  This can be useful when you need to refer to something by object number because something is wrong with its aliases.
2

2
Example:
2
  @contents here
2
  The Entrance Hall(#19) contains:
2
  Strasbourg Clock(#71)   mirror at about head height(#7444)
36
5
4
10
2
The representation of key expressions is very simple and makes it easy to construct new keys on the fly.
2

2
Objects are represented by their object numbers and all other kinds of key expressions are represented by lists.  These lists have as their first element a string drawn from the following set:
2
        "&&"     "||"     "!"     "?"
2
For the first two of these, the list should be three elements long; the second and third elements are the representations of the key expressions on the left- and right-hand sides of the appropriate operator.  In the third case, "!", the list should be two elements long; the second element is again a representation of the operand.  Finally, in the "?" case, the list is also two elements long but the second element must be an object number.
2

2
As an example, the key expression
2
        #45  &&  ?#46  &&  (#47  ||  !#48)
2
would be represented as follows:
2
        {"&&", {"&&", #45, {"?", #46}}, {"||", #47, {"!", #48}}}
36
1
4
24
2
LambdaMOO supports a simple but powerful notation for specifying locks on objects, encryption on notes, and other applications.  The idea is to describe a constraint that must be satisfied concerning what some object must be or contain in order to use some other object.
2

2
The constraint is given in the form of a logical expression, made up of object numbers connected with the operators 'and', 'or', and 'not' (written '&&', '||', and '!', for compatibility with the MOO programming language).  When writing such expressions, though, one usually does not use object numbers directly, but rather gives their names, as with most MOO commands.
2

2
These logical expressions (called 'key expressions') are always evaluated in the context of some particular 'candidate' object, to see if that object meets the constraint.  To do so, we consider the candidate object, along with every object it contains (and the ones those objects contain, and so on), to be 'true' and all other objects to be 'false'.
2

2
As an example, suppose the player Munchkin wanted to lock the exit leading to his home so that only he and the holder of his magic wand could use it.  Further, suppose that Munchkin was object #999 and the wand was #1001.  Munchkin would use the '@lock' command to lock the exit with the following key expression:
2
        me || magic wand
2
and the system would understand this to mean
2
        #999 || #1001
2
That is, players could only use the exit if they were (or were carrying) either #999 or #1001.
2

2
To encrypt a note so that it could only be read by Munchkin or someone carrying his book, his bell, and his candle, Munchkin would use the 'encrypt' command with the key expression
2
        me || (bell && book && candle)
2

2
Finally, to keep players from taking a large gold coffin through a particularly narrow exit, Munchkin would use this key expression:
2
        ! coffin
2
That is, the expression would be false for any object that was or was carrying the coffin.
2

2
There is one other kind of clause that can appear in a key expression:
2
        ? <object>
2
This is evaluated by testing whether the given object is unlocked for the candidate object; if so, this clause is true, and otherwise, it is false.  This allows you to have several locks all sharing some single other one; when the other one is changed, all of the locks change their behavior simultaneously.
2

2
[Note to programmers: The internal representation of key expressions, as stored in .key on every object, for example, is very simple and easy to construct on the fly.  For details, see 'help key-representation'.]
36
1
4
3
2
Syntax:  @unlock <object>
2

2
Clear any lock that might exist on the given object.  See 'help locking' for general information about locking.
36
1
4
5
2
Syntax:  @lock <object> with <key expression>
2

2
Set a lock on <object> to restrict its use.  See 'help locking' for general information about locking and 'help keys' for the syntax and semantics of key expressions.
2

2
N.B.  In the case of rooms, you are actually better off setting room.free_entry to 0 thus preventing teleportation and then @locking the various entrances.  The problem with @locking the room itself is that this can make it impossible to drop objects in the room.
36
1
4
21
2
It is frequently useful to restrict the use of some object.  For example, one might want to keep people from using a particular exit unless they're carrying a bell, a book, and a candle.  Alternatively, one might allow anyone to use the exit unless they're carrying that huge golden coffin in the corner.  LambdaMOO supports a general locking mechanism designed to make such restrictions easy to implement, usually without any programming.
2

2
Every object supports a notion of being 'locked' with respect to certain other objects.  For example, the exit above might be locked for any object that was carrying the coffin object but unlocked for all other objects.  In general, if some object 'A' is locked for another object, 'B', then 'B' is usually prevented from using 'A'.  Of course, the meaning of 'use' in this context depends upon the kind of object.
2

2
The various standard classes of objects use locking as follows:
2
  + Rooms and containers refuse to allow any object inside them if they're locked for it.
2
  + Exits refuse to transport any object that they're locked for.
2
  + Things (including notes and letters) cannot be moved to locations that they're locked for.
2

2
There are two sides to locking:
2
  + How is it specified whether one object is locked for another one?
2
  + What is the effect of an object being locked?
2
Note that these two questions are entirely independent: one could invent a brand-new way to specify locking, but the effect of an exit being locked would be unchanged.
2

2
[Note to programmers: the interface between these two sides is the verb x:is_unlocked_for(y), which is called by x to determine if it is locked for the object y.  The way in which 'is_unlocked_for' is implemented is entirely independent of the ways in which x uses its results.  Note that you can play on either side of this interface with your own objects, either defining new implementations of 'is_unlocked_for' that match your particular circumstances or having your objects interpret their being locked in new ways.]
2

2
There is a default way to specify locks on objects; the following help topics cover the relevant commands:
2

2
@lock -- setting a lock on an object
2
@unlock -- clearing the lock on an object
2
keys -- describes the language used to describe lock keys
36
1
4
8
2
Syntax:  @classes
2
         @classes <class-name> ...
2

2
The wizards have identified several useful classes of objects in the database.  The @classes command is used to see which classes exist and what their member objects are.
2

2
The first form simply lists all of the defined classes along with short descriptions of the membership of each.
2

2
The second form prints an indented listing of that subset of the object parent/child hierarchy containing the objects in the class(es) you specify.
36
1
4
27
2
Syntax:  @audit [<player>] [for <string>] [from <number>] [to <number>] 
2

2
`@audit'        prints a report of all of the objects you own.
2
`@audit player' prints the same report for another player.
2

2
The `for' string restricts the search to objects whose names begin with that string.
2
It is also possible to restrict the range of object numbers to include only those above a given number (`from') or below a given number (`to').
2

2
All forms of @audit print a report:
2

2
   #14 Gemba                          [The Pool]
2
  #144 Popgun                         [Gemba]
2
 #1479 Cockatoo                      *[The Living Room]
2
 #1673 Bottom of Swimming Pool       
2
 #2147 Cavern                        <-*west
2
 #2148 tunnel                         Bottom of Swimming ->Cavern
2

2
The first column is the object's number, the second its name. The third column shows the object's location: Gemba is in The Pool, and is carrying the Popgun (#144).
2
For exits, the third column shows source ->dest.
2
For rooms, the third column shows any entrances owned by someone else.
2
Object location, exit sources and destinations owned by another player are preceded by a *.
2

2
@audit uses a property .owned_objects on the player, for speed.  This property is updated at the time of each object creation and destruction and ownership change.  The verb @auditdb (same args as @audit) actually searches through the entire database for objects.
2

2
See also @verify-owned, @sort-owned, and @add-owned.
2

2
See also @prospectus, which gives some additional information.
36
1
4
5
2
Syntax:  @count [player]
2

2
Prints out the number of objects you or another person own.  Do not be surprised if this is one larger than you think it should be: remember that your player object is owned by you as well, even though you didn't create it in the usual way.
2

2
If byte-based quota is enabled, also prints the total usage by all objects at last measurement.
36
1
4
2
2
*pass*
2
@quota
36
1
4
16
2
Syntax:  @create <class-name> named "<names>"
2
         @create <parent-object> named "<names>"
2

2
The main command for creating objects other than rooms and exits (for them, see 'help @dig'; it's much more convenient).
2

2
The first argument specifies the 'parent' of the new object: loosely speaking, the 'kind' of object you're creating.  <class-name> is one of the four standard classes of objects: $note, $letter, $thing, or $container.  As time goes on, more 'standard classes' may be added.  If the parent you have in mind for your new object isn't one of these, you may use the parent's name (if it's in the same room as you) or else its object number (e.g., #4562).
2

2
You may use "called" instead of "named" in this command, if you wish.
2

2
An object must be fertile to be used as a parent-class.  See help @chmod for details.
2

2
The <names> are given in the same format as in the @rename command:
2
        <name-and-alias>,<alias>,...,<alias> [preferred]
2
        <name>:<alias>,...,<alias> [not preferred]
2

2
See 'help @rename' for a discussion of the difference between a name and an alias.
36
1
4
11
2
The primary means for players to extend the MOO is for them to create new objects with interesting behavior.  There are convenient commands for creating and recycling objects and for keeping track of the objects you've created.  Help is available on these commands in the following topics:
2

2
@dig -- conveniently building new rooms and exits
2
@create -- making other kinds of objects
2
@recycle -- destroying objects you no longer want
2
@quota -- determining how many more objects you can build
2
@count -- determining how many objects you already own
2
@audit -- listing all of your objects
2
@classes -- listing all of the public classes available for your use
2
@move -- moving your objects from place to place
2
@parents, @kids -- examine the inheritance hierarchy.
36
1
4
24
2
Syntax:  @dig "<new-room-name>"
2
         @dig <exit-spec> to "<new-room-name>"
2
         @dig <exit-spec> to <old-room-object-number>
2

2
This is the basic building tool.  The first form of the command creates a new room with the given name.  The new room is not connected to anywhere else; it is floating in limbo.  The @dig command tells you its object number, though, so you can use the @move command to get there easily.
2

2
The second form of the command not only creates the room, but one or two exits linking your current location to (and possibly from) the new room.  An <exit-spec> has one of the following two forms:
2
        <names>
2
        <names>|<names>
2
where the first form is used when you only want to create one exit, from your current room to the new room, and the second form when you also want an exit back, from the new room to your current room.  In any case, the <names> piece is just a list of names for the exit, separated by commas; these are the names of the commands players can type to use the exit.  It is usually a good idea to include explicitly the standard abbreviations for direction names (e.g., 'n' for 'north', 'se' for 'southeast', etc.).  DO NOT put spaces in the names of exits; they are useless in MOO.
2

2
The third form of the command is just like the second form except that no new room is created; you instead specify by object number the other room to/from which the new exits will connect.
2

2
NOTE: You must own the room at one end or the other of the exits you create.  If you own both, everything is hunky-dorey.  If you own only one end, then after creating the exits you should write down their object numbers.  You must then get the owner of the other room to use @add-exit and @add-entrance to link your new exits to their room.
2

2
Examples:
2
    @dig "The Conservatory"
2
creates a new room named "The Conservatory" and prints out its object number.
2
    @dig north,n to "The North Pole"
2
creates a new room and also an exit linking the player's current location to the new room; players would say either 'north' or 'n' to get from here to the new room.  No way to get back from that room is created.
2
    @dig west,w|east,e,out to "The Department of Auto-Musicology"
2
creates a new room and two exits, one taking players from here to the new room (via the commands 'west' or 'w') and one taking them from the new room to here (via 'east', 'e', or 'out').
2
    @dig up,u to #7164
2
creates an exit leading from the player's current room to #7164, which must be an existing room.
36
5
4
3
2
Syntax:  @recycle <object-name-or-number>
2

2
Destroys the indicated object utterly and irretrievably.  Naturally, you may only do this to objects that you own.
36
5
4
6
2
There are a number of commands available to players for building new parts of the MOO.  Help on them is available under the following topics:
2

2
creation -- making, unmaking, and listing your rooms, exits, and other objects
2
topology -- making and listing the connections between rooms and exits
2
descriptions -- setting the names and descriptive texts for new objects
2
locking -- controlling use of and access to your objects
36
1
4
7
2
Syntax:  @dump <object> [with [id=#<id>] [noprops] [noverbs] [create]]
2

2
This spills out all the properties and verbs on an object, calling suspend at appropriate intervals.
2
   id=#<id> -- specifies an idnumber to use in place of the object's actual id (for porting to another MOO)
2
   noprops  -- don't show properties.
2
   noverbs  -- don't show verbs.
2
   create   -- indicates that a @create command should be generated and all of the verbs be introduced with @verb rather than @args; the default assumption is that the object already exists and you're just doing this to have a look at it.
2
1
4
4
2
Syntax:  @set <object>.<prop-name> to <value>
2

2
Changes the value of the specified object's property to the given value.
2
You must have permission to modify the property, either because you own the property or if it is writable.
36
5
4
3
2
*forward*
2
@setprop
2
@set is a valid abbreviation for @setprop.
36
5
4
2
2
*forward*
2
@build-options
36
5
4
2
2
*forward*
2
@build-options
36
5
4
2
2
*forward*
2
@build-options
36
5
4
41
2
Syntax:  @build-option
2
         @build-option <option>
2

2
Synonyms:  @buildoption, @builder-option @builderoption
2

2
The first form displays all of your builder options
2
The second displays just that one option, which may be one of the flags listed below.  The builder options control various annoying details of your building commands (e.g., @create, ...)
2

2
The remaining forms of this command are for setting your programmer options:
2

2
         @build-option create_flags [is] <flags>
2
         @build-option create_flags=<flags>
2
         @build-option -create_flags
2
                      (equivalent to create_flags="")
2

2
where flags is some substring of "rwf".  This option determines the read/write/fertility permissions of an object freshly created with @create or @recreate (see `help @create' and `help @recreate' and `help @chmod').  E.g., to make every object you create henceforth readable by default, do
2

2
         @build-option create_flags=r
2

2
For controlling the behavior of @dig, we have
2

2
         @build-option  dig_room=<room>
2
         @build-option  dig_room [is] <room>
2
         @build-option -dig_room
2
                      (equivalent to dig_room=$room)
2
         @build-option  dig_exit=<exit>
2
         @build-option  dig_exit [is] <exit>
2
         @build-option -dig_exit
2
                      (equivalent to dig_exit=$exit)
2

2
The following respectively set and reset the specified flag option
2

2
         @build-option +<option>
2
         @build-option -<option>
2
         @build-option !<option>           (equivalent to -<option>)
2

2
Currently the only builder flag option available is
2
 -bi_create     @create/@recycle re-use object numbers.
2
 +bi_create     @create/@recycle call create()/recycle() directly 
2

2
we prefer that you not use +bi_create, since this drives up the object numbers.
36
5
4
13
2
*subst*
2
A few different messages can be set on a room object (see 'help messages' for instructions on doing so); they are printed to various audiences when a player or other object is ejected from the room.  (See 'help @eject'.)  The standard pronoun substitutions are made on each message before it is printed; see 'help pronouns' for details.
2

2
The default message is given in brackets after each name below:
2

2
@ejection  [%[$room.ejection_msg]]
2
  Printed to the player doing the ejecting.
2

2
@victim_ejection  [%[$room.victim_ejection_msg]]
2
  Printed to the object being ejected.
2

2
@oejection  [%[$room.oejection_msg]]
2
  Printed to others in the room from which the object is being ejected.
36
5
4
13
2
Syntax: @resident player
2
        @resident !player
2
        @resident
2

2
Adds or removes a player from the residents list of a room.  The residents list controls who is allowed to use @sethome in that room.  This defaults to just the owner of the room; by manipulating the residents list you may allow additional players to use that room as their home.
2

2
@resident player adds that player to the list.  
2
@resident !player removes that player from the list.
2
@resident with no arguments simply displays the current list (which may be "none", indicating no additional people besides the owner may use that room as their home).
2

2
See also help @sethome.
2

2
Hints for programmers: The verb $room:accept_for_abode is called by @sethome.  By overriding this verb you can give different criteria to @sethome.  It should return 1 for allowed and 0 for denied.
36
5
4
22
2
*subst*
2
Several kinds of messages can be set on an exit object (see 'help messages' for instructions on doing so); they are printed to various audiences at certain times whenever an attempt is made to go through the exit.  The ones whose names begin with 'o' are always shown prefixed with the name of the player making the attempt and a single space character.  The standard pronoun substitutions (with respect to the player) are made on each message before it is printed; see 'help pronouns' for details.
2

2
The default message is given in brackets after each name below:
2

2
@leave  [%[$exit.leave_msg]]
2
  Printed to the player just before they successfully use the exit.
2

2
@oleave  [%[$exit.oleave_msg||"has left."]]
2
  Printed to others in the source room when a player successfully uses the exit.
2

2
@arrive  [%[$exit.arrive_msg]]
2
  Printed to the player just after they successfully use the exit.
2

2
@oarrive  [%[$exit.oarrive_msg||"has arrived."]]
2
  Printed to others in the destination room when a player successfully uses the exit.
2

2
@nogo  [%[$exit.nogo_msg||"You can't go that way."]]
2
  Printed to the player when they fail in using the exit.
2

2
@onogo  [%[$exit.onogo_msg]]
2
  Printed to others when a player fails in using the exit.
36
1
4
3
2
Syntax:  @add-entrance <exit-object-number>
2

2
Add the exit with the given object number as a recognized entrance to the current room (that is, one whose use is not considered teleportation).  Usually, @dig does this for you, but it doesn't if you don't own the room in question.  Instead, it tells you the object number of the new exit and you have to find the owner of the room and get them to use the @add-entrance command to link it up.
36
1
4
3
2
Syntax:  @add-exit <exit-object-number>
2

2
Add the exit with the given object number as a conventional exit from the current room (that is, an exit that can be invoked simply by typing its name, like 'east').  Usually, @dig does this for you, but it doesn't if you don't own the room in question.  Instead, it tells you the object number of the new exit and you have to find the owner of the room and get them to use the @add-exit command to link it up.
36
1
4
10
2
The topology of the MOO universe is determined by the rooms that exist and the exits that connect them.  Several commands are available for creating and discovering the topology of the MOO.  Help on them is available under the following topics:
2

2
@dig -- creating new rooms and exits
2
@add-exit -- adding other players' exits from your rooms
2
@add-entrance -- adding other player's entrances to your rooms
2
@remove-exit -- removing exits from your room
2
@remove-entrance -- removing entrances from your room
2
@exits -- listing all of the conventional exits from your rooms
2
@entrances -- listing all of the conventional entrances to your rooms
2
@resident -- listing or changing the residents of your rooms
36
1
4
3
2
Syntax:  @entrances
2

2
Prints a list of all recognized entrances to the current room (but only if you own the room).  A recognized entrance is one whose use is not considered to be teleportation.
36
5
4
3
2
Syntax:  @exits
2

2
Prints a list of all conventional exits from the current room (but only if you own the room).  A conventional exit is one that can be used simply by typing its name, like 'east'.
36
5
4
15
2
Containers are objects that allow you to store other objects inside them.  The following help topics cover verbs that can be used with containers:
2

2
put -- putting an object into a container
2
remove -- taking an object out of a container
2

2
Containers may be open or closed, using the verbs 'open container' and 'close container'.  Containers have a separate lock to determine if a player may open them.  See the following help topics:
2

2
@lock_for_open -- setting the lock for opening a container
2
@unlock_for_open -- clearing the lock
2

2
You can make a container by creating a child of the standard container, $container (see 'help @create').
2

2
Containers have a large number of messages which get printed when players act upon them.  See 'help container-messages' for more information.
2

2
Containers have opacity.  See 'help @opacity' for more information.
36
1
4
1
2
Rooms may be made by builders, using the DIG verb. By default, all rooms are instances of _the_ room, $room, or #3, which you can examine to see how it works. If you require a room to have a more specific behaviour, you can make a subclass of room.
36
1
4
3
2
Syntax:  @remove-entrance <entrance>
2

2
Remove the specified entrance from the current entrances list of the room.  Entrance may be either the name or object number of an entrance to this room.
36
5
4
3
2
Syntax:  @remove-exit <exit>
2

2
Remove the specified exit from the current exits list of the room.  Exit may be either the name or object number of an exit from this room.
36
5
4
6
2
Syntax:
2
  @unlock_for_open <container>
2

2
Clears the lock which restricts who may open <container>.  See 'help locking' for general information about locking. 
2

2
See 'help containers' for information on containers.
36
5
4
6
2
Syntax:
2
  @lock_for_open <container> with <key expression>
2

2
Set the lock on <container> which restricts who can open it.  See 'help locking' for general information about locking and 'help keys' for the syntax and semantics of key expressions.
2

2
See 'help containers' for information on containers.
36
5
4
9
2
Syntax:
2
  @opacity <container> is <integer>
2

2
The opacity can take on one of three values:
2
   0:  The container is transparent and you can always see into it.
2
   1:  The container is opaque, and you cannot see into it when closed
2
   2:  The container is a black hole, and you can never see into it whether closed or open.  
2

2
The default @opacity is 1.
36
5
4
49
2
*subst*
2
Several kinds of messages can be set on a container object; they are printed to various audiences at certain times whenever an attempt is made to use the container.  The ones whose names begin with 'o' are always shown prefixed with the name of the player making the attempt and a single space character.  The standard pronoun substitutions (with respect to the player) are made on each message before it is printed; see 'help pronouns' for details.
2

2
The default message is given in brackets after each name below:
2

2
@empty[%[$container.empty_msg]]
2
  Printed in place of the contents list when the container is empty.
2

2
@open  [%[$container.open_msg]]
2
  Printed to the player who successfully opens the container.
2

2
@oopen  [%[$container.oopen_msg]]
2
  Printed to others in the same room if the player successfully opens the container.
2

2
@open_fail  [%[$container.open_fail_msg]]
2
  Printed to the player who cannot open the container.
2

2
@oopen_fail  [%[$container.oopen_fail_msg]]
2
  Printed to others in the room when a player fails to open a container.
2

2
@close  [%[$container.close_msg]]
2
  Printed to the player who closes a container.
2

2
@oclose  [%[$container.oclose_msg]]
2
  Printed to others in the room when a player closes a container.
2

2
@put  [%[$container.put_msg]]
2
  Printed to a player when an object is successfully placed in a container.
2

2
@oput  [%[$container.oput_msg]]
2
  Printed to others in the room when a player successfully places an object in a container.
2

2
@put_fail  [%[$container.put_fail_msg]]
2
  Printed when a player fails to put an object in a container.
2

2
@oput_fail  [%[$container.oput_fail_msg]]
2
  Printed to others in the room when a player fails to place an object in a container.
2

2
@remove  [%[$container.remove_msg]]
2
  Printed when a player succeeds in removing an object from a container.
2

2
@oremove  [%[$container.oremove_msg]]
2
  Printed to others in the room when a player succeeds in removing an object from a container.
2

2
@remove_fail  [%[$container.remove_fail_msg]]
2
  Printed when a player fails to remove an object from a container.
2

2
@oremove_fail  [%[$container.oremove_fail_msg]]
2
  Printed to others in the room when a player fails to remove an object from a container.
36
5
4
28
2
*subst*
2
Several kinds of messages can be set on 'things', objects that have $thing as an ancestor (see 'help messages' for instructions on doing so).  They are printed to various audiences under various circumstances when an attempt is made to 'take' or 'drop' a thing.  The ones whose names begin with 'o' are always shown prefixed with the name of the player making the attempt and a single space character.  The standard pronoun substitutions (with respect to the player) are made on each message before it is printed; see 'help pronouns' for details.
2

2
The default message is given in brackets after each name below:
2

2
@take_failed  [%[$thing.take_failed_msg]]
2
  Printed to a player who fails to take the object.
2

2
@otake_failed [%[$thing.otake_failed_msg]]
2
  Printed to others in the same room if a player fails to take the object.
2

2
@take_succeeded  [%[$thing.take_succeeded_msg]]
2
  Printed to a player who succeeds in taking the object.
2

2
@otake_succeeded  [%[$thing.otake_succeeded_msg]]
2
  Printed to others in the same room if a player succeeds in taking the object.
2

2
@drop_failed  [%[$thing.drop_failed_msg]]
2
  Printed to a player who fails to drop the object.
2

2
@odrop_failed [%[$thing.odrop_failed_msg]]
2
  Printed to others in the same room if a player fails to drop the object.
2

2
@drop_succeeded  [%[$thing.drop_succeeded_msg]]
2
  Printed to a player who succeeds in dropping the object.
2

2
@odrop_succeeded  [%[$thing.odrop_succeeded_msg]]
2
  Printed to others in the room if a player succeeds in dropping the object.
36
1
4
7
2
Syntax:  @quota
2

2
Each player has a limit as to how many objects that player may create, called their 'quota'.  Every object they create lowers the quota by one and every object they recycle increases it by one.  If the quota goes to zero, then that player may not create any more objects (unless, of course, they recycle some first).
2

2
The @quota command prints out your current quota.
2

2
The quota mechanism is intended to solve a long-standing problem in many MUDs: database bloat.  The problem is that a large number of people build a large number of dull objects and areas that are subsequently never used or visited.  The database becomes quite large and difficult to manage without getting substantially more interesting.  With the quota system, we can make it possible for players to experiment and learn while simultaneously keeping random building to acceptable levels.
2
1
4
4
2
*forward*
2
common_quota
2

2
To get a larger quota, talk to a wizard.  They will take a look at what you've done with the objects you've built so far and make a determination about whether or not it would be a net gain for the MOO community if you were to build some more things.  If so, they will increase your quota; if not, they will try to explain some ways in which you could build things that were more useful, entertaining, or otherwise interesting to other players.  Wizards may be more impressed by objects which are interactive and employ a fair number of verbs.
36
5
4
18
2
Syntax:
2
  @measure object <object name>
2
  @measure summary [player]
2
  @measure new [player]
2
  @measure breakdown <object name>
2
  @measure recent [number of days] [player]
2

2
When the MOO is under byte-quota, objects in the MOO are measured approximately once a week, and the usage tally as reported by @quota is updated.  You may wish to measure an object specially, however, without waiting for the automatic measurement to take place, or if the MOO is under object-quota.  @measure has some subcommands to handle this.
2

2
@measure object will measure an individual object right now, update the usage of that object in your usage as reported by @quota, and update the date of that object's measurement.
2

2
@measure summary will go through your or another player's objects and produce the summary information that is printed by @quota.  Normally this will be just the same as @quota prints out, but occasionally the addition/subtraction done to keep @quota in sync will get out of date, and @measure summary will be needed.
2

2
@measure new will go through all your or another player's objects, measuring exactly those which have never been measured before (that is, are too newly @created to have any measurement data).  This is necessary as any player is only permitted to own 10 unmeasured objects, or object creation will not be permitted.
2

2
@measure breakdown will give you full information on where an object's size is coming from.  It will offer to moomail you the result.  Caution: don't forget to delete this message, as it is large and takes up a lot of space!
2

2
@measure recent will let you re-measure objects of yours or another player's which have not been measured in the specified number of days (the default is the ordinary cycle of the measurement task).
36
5
4
7
2
Usage:  @build-option [+|-|!]audit_bytes
2
Lets you see the actual bytes of small objects in @audit and @prospectus.  Ignored if `audit_float' is turned on.
2

2
  -audit_bytes     @audit/@prospectus shows `<1K'
2
  +audit_bytes     @audit/@prospectus shows bytes.
2

2
Default: -audit_bytes
2
1
4
7
2
Usage: @build-option [+|-|!]audit_float
2
Lets you see object sizes in @audit and @prospectus as floating point numbers to one decimal place.
2

2
  -audit_float     @audit/@prospectus shows integer sizes (1K)
2
  +audit_float     @audit/@prospectus shows floating-point sizes (1.2K)
2

2
Default: -audit_float
2
1
5
36
5
4
1
2
builder-index
36
1
0
0
36
4
4
2
2
Builder Help DB
2
BHD
36
5
2
This help database contains topics about the generic builder and building commands.
36
5
4
2
0
46326
0
1641541193
36
1
#85
Mail Commands Help Db
16
36
1
-1
0
0
4
0
1
30
4
0
0
39
mail-index
@mailoptions
@mail-options
mail-forwarding
@forward
@subscribe
@rn
@unsubscribe
@skip
zombie-messages
message-sequences
@unrmmail
@reply
@renumber
@prev
@next
@answer
@rmmail
@read
@send
mail
@mail
@peek
@subscribed
@netforward
@keep-mail
@keepmail
@resend
@qsend
@qreply
@quickreply
@quicksend
@nn
@mail-all-new-mail
@read-all-new-mail
@refile
@copymail
@add-notify
@unsend
45
4
2
2
*index*
2
Mail System Help Topics
36
5
4
2
2
*forward*
2
@mail-options
36
1
4
103
2
Syntax:  @mail-option
2
         @mail-option <option>
2

2
Synonym:  @mailoption
2

2
The first form displays all of your mail options
2
The second displays just that one option, which may be either `@mail', `replyto', or one of the flags listed below.  The mail options control various annoying details of your mail reading and mail editing commands.
2

2
The remaining forms of this command are for setting your mail options:
2

2
         @mail-option +<flag>
2
         @mail-option -<flag>
2
         @mail-option !<flag>           (equivalent to -<flag>)
2

2
These respectively set and reset the specified flag
2

2
 -include          @replys start out with a blank message body
2
 +include          @replys start with original message included
2
 -all              @replys go to sender only
2
 +all              @replys go to sender and all original recipients
2
 -followup         @replys go as directed by `all' flag
2
 +followup         @replys go to first nonplayer recipient if any
2
                    (if there are no non-player recipients, use `all' flag).
2
 -nosubject        @send forces you to provide a Subject: line
2
 +nosubject        allow entering the mail editor without giving a subject line
2
 -expert           novice mail user (various annoying messages will be printed)
2
 +expert           expert mail user (suppress printing of annoying messages)
2
 -enter            start each mail editing session in the usual command mode.
2
 +enter            start each mail editing session with an implicit `enter'
2
                    command
2
 -sticky           each mail command applies by default to one's own collection
2
 +sticky           each mail command applies by default to the same message 
2
                    collection that the previous successful command did
2
 -netmail          mail to you accumulates in your MOO mailbox
2
 +netmail          mail to you is actually forwarded to your registered email
2
                    address, if you have one.
2
 -resend_forw      @resend puts player in Resent-By: header
2
 +resend_forw      @resend puts player in From: header (like @forward)
2
 -no_auto_forward  @netforward when expiring messages
2
 +no_auto_forward  do not @netforward messages when expiring mail
2
 -expert_netfwd    @netforward confirms before emailing messages
2
 +expert_netfwd    @netforward doesn't confirm before emailing messages
2
 -no_dupcc         send a personal copy even if already subscribed to a 
2
                    mailing list on the to: line
2
 +no_dupcc         don't send personal copies of mail also sent to lists
2
                    you are subscribed to
2
 -no_unsend        People may @unsend unread messages they send to you
2
 +no_unsend        No one may @unsend messages they sent to you
2

2
For "sticky", `mail command' is one of @mail, @read, @prev, @next, @answer.
2
All flags default to the `-' settings.  
2

2
Next, we have
2

2
         @mail-option  manymsgs [is] <number>
2
         @mail-option  manymsgs=<number>
2
         @mail-option -manymsgs
2

2
The first two forms specify that if you give a @mail or @read command asking for <number> or more messages, you will first be given a yes-or-no prompt to continue, the idea being that you many not actually have wanted to see that many messages.  The third form turns off this behavior.
2

2
         @mail-option  @mail [is] <message-sequence>
2

2
The "@mail" option determines what message-sequence the @mail command uses by 
2
default.  Initially, this is "last:15", but other reasonable choices include
2
"new" and "1-last"
2

2
         @mail-option  replyto [is] <recipient> [<recipient>...]
2
         @mail-option -replyto
2

2
The first form specifies that a Reply-To: field is to be placed in all messages constructed by @send or @answer.  Note this can still be changed before sending via the mail room's reply-to command.  
2
The second form resets this option so that no Reply-to: is initially inserted.
2

2
        @mail-option rn_order=<order>
2

2
controls the order in which folders listed by @rn and @subscribed will appear.  <order> can be one of
2

2
 read    folders are sorted by last read date. (default)
2
 send    folders are sorted by last send date.
2
 fixed   folders are not sorted
2

2
To control expiration of messages (see `help @keep-mail') we have
2

2
        @mail-option expire [is] <time-interval>
2
        @mail-option expire=<time-interval>
2

2
<time-interval> can either be a number of seconds or something with units in it, e.g.,
2

2
        @mail-option expire 13 days
2
        @mail-option expire 1 year 39 days
2

2
A negative number or
2

2
        @mail-option +expire
2

2
disables message expiration entirely
2

2
        @mail-option -expire
2

2
sets your message expiration time to the current default.
2

2
        @mail-option @unsend=<message sequence>
2

2
sets the default message sequence that the @unsend command will operate upon.  The default is "last:1".
36
5
4
30
2
There are 3 personal properties that you can use to customize how your mail is composed and forwarded
2

2
.mail_forward 
2
 -- list of objects that will receive any mail that gets sent to you.
2
    Objects on this list should either be players or descendants of 
2
    $mail_recipient.
2
    If this list is nonempty, you will not receive any mail yourself unless
2
    you are on it.  E.g., if Rog is #4292 and ur-Rog is #6349
2

2
  #6349.mail_forward={}            -- usual case; ur-Rog gets his own mail.
2
  #6349.mail_forward={#4292}       -- Rog gets ur-Rog's mail instead.
2
  #6349.mail_forward={#6349,#4292} -- ur-Rog gets mail and Rog gets a copy.
2
  #6349.mail_forward={#-1}         -- ur-Rog's mail disappears without a trace.
2

2
.mail_notify
2
 -- list of objects to be notified whenever mail is sent to you.
2
    This list may include anything that has a :notify_mail() verb.
2
    Notification will take place regardless of whether or how your mail
2
    is forwarded.  
2

2
Thus, in the previous example
2

2
  #4292.mail_notify={#6349} --- means that ur-Rog will be told
2
                                whenever Rog is sent new mail.
2

2
.mail_options
2
 -- this controls lots of miscellaneous things.  Use the @mail-option command
2
    to view and set these options (see `help @mail-option')
2

2
See `help mail-resolve' for more detail on how mail forwarding and mail notification work.  See `help MR-subscribing' for information on how to change .mail_forward and .mail_notify on $mail_recipient children, where they are !c properties.
36
5
4
18
2
Syntax:  @forward <msg> [on *<collection>] to <recipient> [<recipient>...]
2
Syntax:  @resend  <msg> [on *<collection>] to <recipient> [<recipient>...]
2

2
Both of these commands take the indicated message in your (or some other) message collection, and sends it on to the indicated recipients in some form.
2

2
@forward sends an entirely new message whose body is the original message (both headers and body).
2
@resend sends the original message, but with a header containing the lines
2

2
  From:  original-sender
2
  To:    original-recipients...
2
  Resent-By: you
2
  Resent-To: new-recipients...
2

2
If you prefer to have yourself in the From: line of messages you @resend, set the mail option `resend_forw (see `help @mail-options').  In this case, the message will instead have a header containing the lines
2

2
  From:  you
2
  To:    new-recipients...
2
  Original-From:  original-sender
36
5
4
22
2
Syntax:  @subscribe *<collection> [with|without notification] [before|after *<collection>]
2
         @subscribe
2
         @subscribe-quick
2

2
The second and third form of the command gives a list of all mail collections that are readable by you. The third form omits the mail collection description.
2

2
The first form of this command sets up a current message and a last-read-time for the given mail collection so that when you next log in or issue the @rn command, you will be informed about new mail that has appeared there.  Note that this happens automatically whenever you @read messages on a given collection, so if this much is all you care about, you don't need to use this command; just do, e.g.,
2
         @read last on *<collection>
2

2
Specifying "with notification" causes you to be added to the immediate-notification list (.mail_notify) for that collection, i.e., whenever new mail arrives there, you will be notified immediately.  Specifying "without notification" causes you to be removed from the collection's .mail_notify.
2

2
Specifying "before *<other-collection>" causes <collection> to be placed immediately before *<collection> in your @rn listing (which see) and likewise for the "after" clause.  By default, new collections are placed at the end of your list.  The before/after specification is only useful if you have @mail-option rn_order=fixed set (see `help @mail-options').
2

2
@subscribing to a collection for which you already have a current-message/last-read-time has no effect other from possibly changing that collection's .mail_notify and/or reordering your collections for @rn.
2

2
You can only @subscribe to collections that are readable by you.
2

2
Note that this is entirely different from the Mail Room `subscribe' command
2
which actually adds you to the .mail_forward list for a given collection/
2
mailing-list, so that mail sent to the list actually shows up in your own
2
mail collection.
2
We're probably going to phase out the Mail Room `subscribe' command...
36
5
4
5
2
Syntax:  @rn
2

2
For each collection of mail messages that you read other from your own, a last-read-time is kept.  This command tells you which collections (out of all those you have ever read) have recently had messages added to them, i.e., more recently than when you last did a @read, @prev, @next, or @skip on that collection.
2

2
Etymologists' note:  If you thought @rn had anything to do with the popular UNIX newsreading program `rn', it's just your imagination.
36
5
4
2
2
*forward*
2
@skip
36
5
4
8
2
Syntax:  @skip [<collection>...]
2
         @unsubscribe [<collection>...]
2

2
For each collection of mail messages that you read other from your own, a current message and a last-read-time is kept.  Normally, if you neglect to actually @read any messages on a collection other from your own, @rn (or :check_mail_lists) will continue to remind you that they are there.
2

2
The @skip command indicates that you're not interested in reading the rest of the messages that currently exist in that given collection.  
2

2
The @unsubscribe command flushes the current-message/last-read-time information completely, indicating that you are not only uninterested in the rest of the messages on that collection, but also likewise uninterested in anything else that may appear on that collection later on.  @unsubscribe also removes you from the collection's .mail_notify list.
36
5
4
2
2
*forward*
2
@unrmmail
36
5
4
55
2
Certain mail commands, including @mail, @read, and @rmmail, allow a <message-sequence> argument that indicates to which messages in one's collection the command is to apply.  Any combination of the following may appear as a <message-sequence> argument to any of the various mail commands (@mail, @read, @answer, @rmm).
2

2
  17        message number 17 if there is one (and likewise for other integers)
2
  17..23    all messages numbered between 17 and 23 (inclusive), if any.
2
  cur       the current message
2
  prev      the message before
2
  next      the message after
2
  prev17    the 17 messages prior to the current message
2
  next17    the 17 messages after the current message
2
  first     the first message if any
2
  last      the final message if any (`$' is a synonym for `last')
2
  new       unread messages if any
2

2
You may use as many of these at once as sanity permits, e.g.,
2

2
  @mail cur 1..5 last
2

2
which will display the header for your current message, your messages in the range 1..5, and your last message.  Though some of these ranges may overlap, the header for any given message is only shown once in any event.
2

2
In addition, there are other message-sequence arguments that act as filters on whatever precedes them. 
2

2
 before:<date>               messages strictly before the given date
2
 after:<date>                messages strictly after the given date
2
 since:<date>                messages on or after the given date
2
 until:<date>                messages on or before the given date
2
 from:<player>[|<player...]  messages from the given player(s)
2
 to:<recip>[|<recip>...]     messages to the given recipient(s)
2
 %from:<string>              messages with <string> in the From: line
2
 %to:<string>                messages with <string> in the To: line
2
 subject:<string>            messages with <string> in the subject
2
 body:<string>               messages with <string> in the body (SLOW!!!)
2
 first:<number>              the first <number> messages
2
 last:<number>               the last <number> messages
2
 kept:                       messages marked as kept (see `help @keep-mail')
2
 unkept:                     messages not marked as kept
2

2
<date>  is either a weekday, "today", "yesterday", or
2
        a dd-Month, dd-Month-yy or dd-Month-yyyy date
2
<recip> is either <player> or *<$mail_recipient kid>
2

2
Examples:
2

2
  @read from:G7|Gemba              read all messages from G7 or Gemba
2
  @rmm to:yduJ|*Core               remove messages that are to yduJ or to *Core
2
  @mail since:1-Jan before:1-Feb   show messages dated in January
2
  @mail since:Tues                 show messages dated on or after Tuesday
2
  @rmm subject:manners             remove msgs with `manners' in the subject:
2
  @mail subject:"stupid idiots"    (search string contains a space => need "'s)
2
  @rmm to:yduJ to:*Core            remove messages that are to yduJ and *Core
2
  @mail from:Haakon last:5         show the last 5 messages from Haakon
2
  @mail %from:guest                show mail from players with "guest" in
2
                                   their names
2
  @mail last:10 body:fribble       show those of the last 10 messages having
2
                                   `fribble' in the body (one should always try
2
                                   to narrow body searches in this way).
36
1
4
13
2
Syntax:  @unrmmail [list|expunge] [on *<collection>]
2

2
When you do @rmmail on a particular message collection, the messages removed don't go away immediately, but are rather saved elsewhere.  These "zombie" messages can be brought back or examined using the @UNrmmail command.
2

2
Without `list' or `expunge', @unrmm restores the zombie messages, thus undoing the effect of the most recent @rmmail command.  Only the most recent @rmmail can be undone in this way; messages deleted by any previous @rmmail commands on this same collection are lost and gone forever.
2

2
The `list' option merely lists the headers of the zombie messages without actually restoring them.
2

2
The `expunge' option banishes the zombie messages forever.
2

2
Note that the message numbers used by zombie messages are held in reserve against the possibility that you might @unrmm them some day; with such messages around, new messages received will be given higher numbers than you might have expected.  @renumber does an implicit @unrmm expunge.
2

2
`@unrmmail' and `@unrmmail expunge' on collections other than your own are only allowed when you have write access.  Likewise, `@unrmmail list' on other collections is only possible when they are readable by you.
36
5
4
2
2
*forward*
2
@answer
36
5
4
5
2
Syntax:  @renumber [<collection>]
2

2
Renumbers the messages in your collection to go from 1 to however many you have at the moment.  The optional argument allows you to renumber the messages stored in some other collection (@renumber, like @rmmail, requires write access).
2

2
Note that if you have zombie messages from a previous @rmmail command (see `help zombie-messages'), these will be expunged.
36
5
4
3
2
Syntax:  @prev [<number>] [on <collection>]
2

2
Print the 'previous' message in a given email collection (defaults to your own).  The mail system's notion of your 'current message' for that collection is decremented.  Thus, e.g., one can review all of one's previous messages one-by-one simply by typing '@prev' repeatedly.  If <number> is supplied, print (and decrement current message by) that many messages.
36
5
4
3
2
Syntax:  @next [<number>] [on <collection>]
2

2
Print the `next' message in a given email collection (defaults to your own).  The mail system's notion of your 'current message' for that collection is incremented.  Thus, e.g., one can read all of one's new messages one-by-one simply by typing '@next' repeatedly.  If <number> is supplied, prints and advances that many messages.
36
1
4
17
2
Syntax:  @answer [<message-number>] [sender] [all] [include] [noinclude] [followup]
2

2
Synonym: @reply
2

2
Prepares for you to compose a MOO email message to the players who either received or composed the indicated message from your collection.  The usual editor is invoked (see `help editors' for details).  The subject line for the new message will be initialized from that of the indicated message.  If you leave off the message number, the reply will be to your current message, if that exists.  In fact you may give a general message-sequence (see `help message-sequences') argument here, provided that it indicates only a single message (e.g., `@answer last:1')
2

2
If there is a Reply-to: field in the message you are @answer'ing, its contents will be used to initialize the To: line of your reply.  Otherwise, a To: line is determined depending on whether you specified `sender', `all', or `followup' in the command line (or your .mail_options).
2
  `sender'   replies to sender only
2
  `all'      replies to sender and all original recipients
2
  `followup' replies to first original recipient that is a non-player
2
             (no effect if there are no non-player recipients).
2

2
`include' includes the text of the original message in your reply, `noinclude' does not.  
2

2
`sender', `all', `followup', `include', and `noinclude' can all be abbreviated (e.g., `@answer i').
2

2
Defaults are `sender' and `noinclude', but you can change this by setting your .mail-options (see `help mail-options').  
36
5
4
12
2
Syntax:  @rmmail [<message-sequence>] [from *<recipient>]
2

2
Deletes the indicated messages from your MOO email collection.
2
By default, your current message is deleted.
2
See `help message-sequence' for the full list of possible arguments.
2
You get the message numbers for use here by typing the '@mail' command.
2

2
There is no confirmation for this action, so be careful.  While it is true that @unrmmail will be able to bring back the messages deleted by the last @rmm, any messages deleted before then are really gone, i.e., irrecoverable.  See `help @unrmmail' for more information.
2

2
This command may be used on other mail recipients (children of $mail_recipient), but only ones to which you have write access (you either have to own it or be on good terms with whoever does...).
2

2
You can try to delete messages that you accidentally sent to a person with the command @unsend (see `help @unsend').  Note there are restrictions on the operation, so it often will not work.
36
5
4
14
2
Syntax:  @read <message-number>
2
         @read
2
         @peek ...
2

2
Prints the contents of the indiciated messages from your MOO email collection.  You get the message numbers for use here by typing the '@mail' command, which prints a table of contents for your entire MOO email collection.  If no arguments are given to @read, then the 'current message' in your collection is printed.  In any case, the 'current message' after @read finishes is the last one printed.
2

2
The most general form of the @read command is
2

2
         @read <message-sequence> [on *<collection>]  
2

2
where <message-sequence> is as described in `help message-sequences'.
2
As with the @mail command you may @read messages on any publically readable collection (child of $mail_recipient).
2

2
The @peek command is a variant of @read that works no differently except that it refrains from setting your `current message'.  This is useful, for example, if you want to see some particular message on a collection without losing track of where you are in it.
36
5
4
10
2
Syntax:  @send <recipient> [<recipient> ...]  [subj[ect]="<subject>"]
2

2
Prepares for you to compose a MOO email message to the recipients named on the command line.  A recipient can be specified by giving a player name or object-id, or a '*' followed by the name or object-id of some non-player mail recipient (e.g., a mailing list or a mail folder) -- a list of such non-player recipients is available from within the mailroom with the 'showlists' command.
2

2
The usual editor is invoked.   
2
You will be prompted for a subject line if you did not specify one in the @send command (see `help mail_options' for how to avoid this).
2
Use `say' (") to insert lines in the body of your message.  
2
See `help editors' for details.
2

2
Giving this command without arguments resumes editing the previous unsent draft message if one exists.
36
5
4
35
2
The MOO email system allows you to send and receive messages to and from other players.  It provides commands to view and manage your own collection of saved messages and, in addition, to browse through other collections that may be available (e.g.,archives of public mailing lists).  Help is available on the following commands:
2

2
@mail     -- seeing a table of contents for a collection of email messages
2
@read     -- reading individual messages 
2
@next     -- reading the 'next'     message
2
@prev     -- reading the 'previous' message
2

2
@send     -- composing and sending a message to other players
2
@answer   -- replying to one of the messages in a collection
2
@forward  -- resending one of the messages in a collection somewhere else
2

2
@rmmail   -- discarding some subset of a collection
2
@unrmmail -- undoing the most recent @rmm on a collection
2
@unsend   -- try to remove a message you accidentally sent
2
@renumber -- renumbering the messages in a collection
2
@keep-mail - marking messages in a collection as exempt from expiration
2

2
@mail-option -- describes and sets various customization flags
2

2
help mail-forwarding
2
 -- describes mail forwarding
2
help message-sequences
2
 -- describes message-sequences arguments to @mail, @read, @rmm, and @answer.
2

2
For viewing collections other from your own, the following commands are useful:
2

2
@rn          -- list those collections that have new messages on them
2
@subscribe   -- indicate that you want @rn to report on a given collection
2
                  and add yourself to its .mail_notify list
2
@skip        -- ignore any remaining new messages in a given collection
2
@unsubscribe -- ignore a given collection entirely from now on
2
                  and remove yourself from its .mail_notify list
2
@unsubscribed-- show the mailing lists that you aren't subscribed to.
2
@subscribed  -- like @rn, but shows all lists that you are subscribed to
2
                even if they have no new activity
36
5
4
16
2
Syntax:  @mail
2
         @mail new            (to see recent messages)
2
         @mail 1-$            (to see *all* messages)
2

2
Shows a table of contents for your MOO email message collection.  You are notified when you connect to the MOO if there are any such messages.  A little arrow indicates the mail system's notion of your 'current message'.  
2
The first form lists all of your messages or the last 15 if you have more than that many; the second form lists only those messages after your `current message'.  The third form shows your entire collection.
2

2
If you have a large number of mail messages, you can give arguments so that @mail only lists the messages you're interested in.  You can also list messages residing on mail recipients which are public or for which you have read access.
2
The general format is
2

2
         @mail <message-sequence> [on *<recipient>]
2

2
<recipient> must name some child of $mail_recipient (e.g., a mailing list);
2
<message-sequence> can be a sequence of message numbers; you can also scan the recipient for articles that fit a given description, as specified in `help message-sequences'.
2

2
Note that if you view mail on some other recipient and have "sticky" in your .mail_options (see `help mail-options'), all further mail commands (e.g., @read, @next, @rmm,...) will apply to that recipient.  In this case use `@mail on me' to go back to looking at your own mail.
36
1
4
2
2
*forward*
2
@read
36
5
4
3
2
Syntax: @subscribed
2

2
Like @rn, but shows you ALL mailing lists to which you are subscribed, even those which have no new messages.
36
5
4
16
2
Syntax:  @netforward <message-number>
2
         @netforward 
2
         @netforward <message-sequence> on *collection
2

2
Forwards the contents of the indiciated messages from your MOO email collection to your registered email address.  You get the message numbers for use here by typing the '@mail' command, which prints a table of contents for your entire MOO email collection.  If no arguments are given to @netforward, then the 'current message' in your collection is sent.  In any case, the 'current message' after @netforward finishes is not affected.
2

2
The most general form of the @netforward command is
2

2
         @netforward <message-sequence> [on *<collection>]
2

2
where <message-sequence> is as described in `help message-sequences'.
2
As with the @mail command you may @netforward messages on any publically readable collection (child of $mail_recipient).
2

2
Before messages are sent, you are asked to confirm the email unless you have set your `expert_netfwd' mail option on.  See `help @mail-options' for details.
2

2
If you do not have a valid registered email address, you will not be able to use this command and must first @registerme or get a wizard to register your address. `help @registerme' for details.
36
5
4
25
2
Syntax:  @keep-mail [<message-sequence>]
2
         @keep-mail none
2

2
Synonym: @keepmail
2

2
As a space-saving measure, there is a task that runs periodically and from all player collections removes those messages that are
2
  (1) marked as read (i.e., dated before the last-read-date), 
2
  (2) older than a certain expire time, and
2
  (3) not specifically marked as "kept".
2

2
"kept" messages will show up in your @mail listing with an `=' to the right of the message number.
2

2
The first form of the @keep-mail command marks the indicated messages as kept.  The message-sequence argument is as with other mail commands (see `help message-sequences').  @keep-mail without any arguments marks your current message as kept.
2

2
The second form of the command is used to remove all such marks from your mail collection.
2

2
    @mail kept:
2

2
will produce a list of all messages marked as kept (see `help message-sequences').
2

2
You can use @mail-option expire (see `help @mail-option') to change your expire time.
2

2
You can use the @netforward command (see `help @netforward') to send mail to your email address for local archival.
2

2
[...At the time of this writing, player mail is taking up a large fraction of LambdaMOO's database.  It would be appreciated if you not @keep any more mail than you have to...]
36
5
4
2
2
*forward*
2
@keep-mail
36
5
4
2
2
*forward*
2
@forward
36
5
4
2
2
*forward*
2
@quicksend
36
5
4
2
2
*forward*
2
@quickreply
36
5
4
6
2
Syntax:   @quickreply  <msg> [on *<recipient>] [<flags>...]
2
          @quickreply  <msg> [<flags>...] [on *<recipient>] 
2

2
Synonym:  @qreply
2

2
The @quickreply command allows you to do a short reply to a mail message without heading for the mail room.  As with @reply, the subject line on the reply message is taken from the original.  <flags> are as with @reply, except that `include' is not recognized --- if you're going to include the original message, you *have* to trim it down, and that requires the editor.
36
5
4
6
2
Syntax:   @quicksend <player> [subj="<text>"] <one-line-message>...
2
          @quicksend <player> [subj="<text>"]
2

2
Synonym:  @qsend
2

2
The @quicksend command allows you to send a short mail message without heading for the mail room.  With the second form of the command you will be prompted for the body of the message (and a subject line unless your `nosubject' mailoption is set (see `help @mail-option') or you already gave a subject line).
36
5
4
15
2
Alternative mail reading commands.
2

2
Syntax:  @nn
2

2
This command finds a folder containing an unread message, displays the first such, and updates your last-read-time for that folder.  Your personal mail and all @subscribed folders are checked.
2

2
Syntax:  @mail-all-new-mail
2

2
Displays headers of all unread messages on all of your folders (i.e., your personal folder and all @subscribed folders).
2

2
Syntax:  @read-all-new-mail
2

2
Displays all unread messages on all of your folders (i.e., your personal folder and all @subscribed folders).  This command ends with a prompt, "Did you get all of that? [Enter `yes' or `no']."  Answering "yes" causes all of your last-read times to be updated.  You will probably want to check for <<<n lines flushed>>> indications before you answer this question.
2

2
@read-all-new-mail (with a "yes" answer at the end) is equivalent to doing a large number of @nn's.
36
5
4
2
2
*forward*
2
@nn
36
5
4
2
2
*forward*
2
@nn
36
5
4
6
2
Syntax:  @refile <message-seq> [on mail-recipient] to mail-recipient
2
         @copymail <message-seq> [on mail-recipient] to mail-recipient
2

2
Moves a message sequence directly from one mail recipient (defaulting as per the sticky @mail-option) to another, without adding headers or reordering.
2

2
NOTE:  The recipient of @refiled messages may well have its mail out of order.  This can confuse a variety of features of the mail system, which expects its messages to always be in chronological order.  Care should be exercised with @refile/@copymail.
36
5
4
2
2
*forward*
2
@refile
36
5
4
6
2
Usage:  @add-notify me to player
2
    Sends mail to player saying that I want to be added to their mail notification property.
2
Usage:  @add-notify player to me
2
    Makes sure that player wants to be notified, if so, adds them to my .mail_notify property.
2

2
In order for one person to be notified that another person has new mail, both the mail recipient and the notification recipient should agree that this is an OK transfer of information.  This verb facilitates that transaction.
36
5
4
17
2
The @unsend command was created by ballot on LambdaMOO, *B:Unsend (#77081).
2

2
Syntax: @unsend [message-sequence] from <user>
2

2
A message cannot be unsent to a player if e has read the message, it has been forwarded to eir e-mail address, or e has set an option to prevent messages being unsent to em.  A message cannot be unsent to a group of players unless it can be unsent to each player in the group.
2

2
The unsender may not view a list of unread messages on a player.  E may only select the message(s) to be unsent by filters such as "subject:<subject>" or "since:today".
2

2
In order to protect privacy, if any of the restrictions above, such as one of the users having already read the message, are not met, the error message will be quite generic and not tell you exactly what went wrong, but simply that messages could not be unsent.
2

2
The following mail options are available:
2

2
@mail-option +no_unsend      No one may @unsend messages they sent to you
2
@mail-option -no_unsend      People may @unsend unread messages they send to you
2
@mail-option @unsend=<message sequence>
2

2
sets the default message sequence that the @unsend command will operate upon.  The default is "last:1".
36
5
5
36
5
4
1
2
mail-index
36
1
0
0
36
4
4
1
2
Mail Commands Help Db
36
5
2
This help database contains topics relating to the general use of the mail system.
36
5
4
2
0
42114
0
1641541193
36
1
#86
ToastStunt Help Database
16
36
1
-1
0
0
4
0
1
30
4
0
0
113
binary_hmac
string_hmac
decode_base64
encode_base64
exec
exp
generate_json
getenv
mapdelete
mapkeys
mapvalues
parse_json
random_bytes
read_http
salt
strtr
value_hmac
crypt
argon2
task_local
set_task_local
respond_to
isa
switch_player
stunt
sqlite_open
sqlite_close
sqlite_handles
sqlite_info
sqlite_query
sqlite_execute
sqlite_last_insert_row_id
sqlite
pcre_replace
frandom
memory_usage
ftime
locate_by_name
usage
explode
clear_ancestor_cache
locations
spellcheck
threads
thread_info
waif_stats
fio
fileio
file_open
file_close
file_name
file_openmode
file_readline
file_readlines
file_writeline
file_read
file_write
file_tell
file_seek
file_eof
file_rename
file_remove
file_mkdir
file_rmdir
file_list
file_type
file_mode
file_chmod
file_stat
toaststunt-index
occupants
sort
yin
slice
set_thread_mode
recreate
toaststunt
chr
recycled_objects
next_recycled_object
all_members
pcre_match
sqlite_limit
curl
connection_name_lookup
connection_info
argon2_verify
maphaskey
reseed_random
finished_tasks
owned_objects
ancestors
descendants
panic
thread_pool
is_member()
listen()
move()
open_network_connection()
reverse
sqlite_interrupt
binary_hash()
descendents()
file_count_lines
file_grep
file_handles
notify()
queue_info()
queued_tasks()
random()
string_hash()
task_stack()
value_hash()
119
4
8
2
Syntax:  string_hmac (STR text, STR key [, STR algo [, binary]])
2
         binary_hmac (STR bin-string, STR key [, STR algo [, binary]])
2

2
Returns a string encoding the result of applying the HMAC-SHA256 cryptographically secure HMAC function to the contents of the string text or the binary string bin-string with the specified secret key. If algo is provided, it specifies the hashing algorithm to use. Currently, only "SHA1" and "SHA256" are supported. If binary is provided and true, the result is in MOO binary string format; by default the result is a hexidecimal string.
2

2
All cryptographically secure HMACs have the property that, if string_hmac(x, a) == string_hmac(y, b) then, almost certainly, equal(x, y) and furthermore, equal(a, b)
2

2
 This can be useful, for example, in applications that need to verify both the integrity of the message (the text) and the authenticity of the sender (as demonstrated by the possession of the secret key).
36
5
4
2
2
*forward*
2
binary_hmac
36
5
4
6
2
Syntax:  decode_base64 (STR base64 [, safe])
2

2
Returns the binary string representation of the supplied Base64 encoded string argument. Raises E_INVARG if base64 is not a properly-formed Base64 string. If safe is provide and is true, a URL-safe version of Base64 is used (see RFC4648).
2

2
decode_base64("AAEC")       =>   "~00~01~02"
2
decode_base64("AAE", 1)     =>   "~00~01"
36
5
4
6
2
Syntax:  encode_base64 (STR binary [, safe])
2

2
Returns the Base64 encoded string representation of the supplied binary string argument. Raises E_INVARG if binary is not a properly-formed binary string. If safe is provide and is true, a URL-safe version of Base64 is used (see RFC4648).
2

2
encode_base64("~00~01~02")     =>   "AAEC"
2
encode_base64("~00~01", 1)     =>   "AAE"
36
5
4
27
2
Syntax: exec (LIST command[, STR input][, LIST environment variables])
2

2
Asynchronously executes the specified external executable, optionally sending input. Returns the process return code, output and error. If the programmer is not a wizard, then E_PERM is raised.
2

2
The first argument must be a list of strings, or E_INVARG is raised. The first string is the path to the executable and is required. The rest are command line arguments passed to the executable.
2

2
The path to the executable may not start with a slash (/) or dot-dot (..), and it may not contain slash-dot (/.) or dot-slash (./), or E_INVARG is raised. If the specified executable does not exist or is not a regular file, E_INVARG is raised.
2

2
If the string input is present, it is written to standard input of the executing process.
2

2
Additionally, you can provide a list of environment variables to set in the shell.
2

2
When the process exits, it returns a list of the form:
2

2
{code, output, error}
2

2
code is the integer process exit status or return code. output and error are strings of data that were written to the standard output and error of the process.
2

2
The specified command is executed asynchronously. The function suspends the current task and allows other tasks to run until the command finishes. Tasks suspended this way can be killed with kill_task().
2

2
The strings, input, output and error are all MOO binary strings.
2

2
All external executables must reside in the executables directory.
2

2
exec({"cat", "-?"})                                      {1, "", "cat: illegal option -- ?~0Ausage: cat [-benstuv] [file ...]~0A"}
2
exec({"cat"}, "foo")                                     {0, "foo", ""}
2
exec({"echo", "one", "two"})                             {0, "one two~0A", ""}
36
5
4
3
2
Syntax: exp (FLOAT x)
2

2
Returns E (Eulers number) raised to the power of x. 
36
5
4
59
2
Syntax: generate_json (ANY value [, STR mode])
2

2
Returns the JSON representation of the MOO value.
2

2
MOO supports a richer set of values than JSON allows. The optional mode specifies how this function handles the conversion of MOO values into their JSON representation.
2

2
The common subset mode, specified by the literal mode string "common-subset", is the default conversion mode. In this mode, only the common subset of types (strings and numbers) are translated with fidelity between MOO types and JSON types. All other types are treated as alternative representations of the string type. This mode is useful for integration with non-MOO applications.
2

2
The embedded types mode, specified by the literal mode string "embedded-types", adds type information. Specifically, values other than strings and numbers, which carry implicit type information, are converted into strings with type information appended. The converted string consists of the string representation of the value (as if tostr() were applied) followed by the pipe (|) character and the type. This mode is useful for serializing/deserializing objects and collections of MOO values.
2

2
generate_json([])                                           =>   "{}"
2
generate_json(["foo" -> "bar"])                             =>   "{\"foo\":\"bar\"}"
2
generate_json(["foo" -> "bar"], "common-subset")            =>   "{\"foo\":\"bar\"}"
2
generate_json(["foo" -> "bar"], "embedded-types")           =>   "{\"foo\":\"bar\"}"
2
generate_json(["foo" -> 1.1])                               =>   "{\"foo\":1.1}"
2
generate_json(["foo" -> 1.1], "common-subset")              =>   "{\"foo\":1.1}"
2
generate_json(["foo" -> 1.1], "embedded-types")             =>   "{\"foo\":1.1}"
2
generate_json(["foo" -> #1])                                =>   "{\"foo\":\"#1\"}"
2
generate_json(["foo" -> #1], "common-subset")               =>   "{\"foo\":\"#1\"}"
2
generate_json(["foo" -> #1], "embedded-types")              =>   "{\"foo\":\"#1|obj\"}"
2
generate_json(["foo" -> E_PERM])                            =>   "{\"foo\":\"E_PERM\"}"
2
generate_json(["foo" -> E_PERM], "common-subset")           =>   "{\"foo\":\"E_PERM\"}"
2
generate_json(["foo" -> E_PERM], "embedded-types")          =>   "{\"foo\":\"E_PERM|err\"}"
2

2
JSON keys must be strings, so regardless of the mode, the key will be converted to a string value.
2

2
generate_json([1 -> 2])                                     =>   "{\"1\":2}"
2
generate_json([1 -> 2], "common-subset")                    =>   "{\"1\":2}"
2
generate_json([1 -> 2], "embedded-types")                   =>   "{\"1|int\":2}"
2
generate_json([#1 -> 2], "embedded-types")                  =>   "{\"#1|obj\":2}"
2

2
tion: value parse_json (str json [, str mode])
2

2
Returns the MOO value representation of the JSON string. If the specified string is not valid JSON, E_INVARG is raised.
2

2
The optional mode specifies how this function handles conversion of MOO values into their JSON representation. The options are the same as for generate_json().
2

2
parse_json("{}")                                            =>   []
2
parse_json("{\"foo\":\"bar\"}")                             =>   ["foo" -> "bar"]
2
parse_json("{\"foo\":\"bar\"}", "common-subset")            =>   ["foo" -> "bar"]
2
parse_json("{\"foo\":\"bar\"}", "embedded-types")           =>   ["foo" -> "bar"]
2
parse_json("{\"foo\":1.1}")                                 =>   ["foo" -> 1.1]
2
parse_json("{\"foo\":1.1}", "common-subset")                =>   ["foo" -> 1.1]
2
parse_json("{\"foo\":1.1}", "embedded-types")               =>   ["foo" -> 1.1]
2
parse_json("{\"foo\":\"#1\"}")                              =>   ["foo" -> "#1"]
2
parse_json("{\"foo\":\"#1\"}", "common-subset")             =>   ["foo" -> "#1"]
2
parse_json("{\"foo\":\"#1|obj\"}", "embedded-types")        =>   ["foo" -> #1]
2
parse_json("{\"foo\":\"E_PERM\"}")                          =>   ["foo" -> "E_PERM"]
2
parse_json("{\"foo\":\"E_PERM\"}", "common-subset")         =>   ["foo" -> "E_PERM"]
2
parse_json("{\"foo\":\"E_PERM|err\"}", "embedded-types")    =>   ["foo" -> E_PERM]
2

2
In embedded types mode, key values can be converted to MOO types by appending type information. The full set of supported types are obj, str, err, float and int.
2

2
parse_json("{\"1\":2}")                                     =>   ["1" -> 2]
2
parse_json("{\"1\":2}", "common-subset")                    =>   ["1" -> 2]
2
parse_json("{\"1|int\":2}", "embedded-types")               =>   [1 -> 2]
2
parse_json("{\"#1|obj\":2}", "embedded-types")              =>   [#1 -> 2]
2

2
JSON defines types that MOO (currently) does not support, such as boolean true and false, and null. These values are always converted to the strings "true", "false" and "null". 
36
5
4
6
2
Syntax: getenv (STR name)
2

2
Returns the value of the named environment variable. If no such environment variable exists, 0 is returned. If the programmer is not a wizard, then E_PERM is raised.
2

2
getenv("HOME")       =>  "/home/foobar"
2
getenv("XYZZY")      =>   0
36
5
4
6
2
Syntax: mapdelete (MAP map, ANY key)
2

2
Returns a copy of map with the value corresponding to key removed. If key is not a valid key, then E_RANGE is raised.
2

2
x = ["foo" -> 1, "bar" -> 2, "baz" -> 3];
2
mapdelete(x, "bar")       =>  ["baz" -> 3, "foo" -> 1]
36
5
4
6
2
Syntax: mapkeys (MAP map)
2

2
Returns the keys of the elements of map.
2

2
x = ["foo" -> 1, "bar" -> 2, "baz" -> 3];
2
mapkeys(x)    =>  {"bar", "baz", "foo"}
36
5
4
13
2
Syntax: mapvalues (MAP <map> [, ... STR <key>])
2

2
Returns the values of the elements of map.
2

2
If you only want the values of specific keys in the map, you can specify them as optional arguments. See examples below.
2

2
Examples:  
2
x = ["foo" -> 1, "bar" -> 2, "baz" -> 3];
2

2
;mapvalues(x)
2
=>  {2, 3, 1}
2
;mapvalues(x, "foo", "baz")
2
=> {1, 3}
36
5
4
28
2
Syntax: parse_json (STR json [, STR mode])
2

2
Returns the MOO value representation of the JSON string. If the specified string is not valid JSON, E_INVARG is raised.
2

2
The optional mode specifies how this function handles conversion of MOO values into their JSON representation. The options are the same as for generate_json().
2

2
parse_json("{}")                                            =>   []
2
parse_json("{\"foo\":\"bar\"}")                             =>   ["foo" -> "bar"]
2
parse_json("{\"foo\":\"bar\"}", "common-subset")            =>   ["foo" -> "bar"]
2
parse_json("{\"foo\":\"bar\"}", "embedded-types")           =>   ["foo" -> "bar"]
2
parse_json("{\"foo\":1.1}")                                 =>   ["foo" -> 1.1]
2
parse_json("{\"foo\":1.1}", "common-subset")                =>   ["foo" -> 1.1]
2
parse_json("{\"foo\":1.1}", "embedded-types")               =>   ["foo" -> 1.1]
2
parse_json("{\"foo\":\"#1\"}")                              =>   ["foo" -> "#1"]
2
parse_json("{\"foo\":\"#1\"}", "common-subset")             =>   ["foo" -> "#1"]
2
parse_json("{\"foo\":\"#1|obj\"}", "embedded-types")        =>   ["foo" -> #1]
2
parse_json("{\"foo\":\"E_PERM\"}")                          =>   ["foo" -> "E_PERM"]
2
parse_json("{\"foo\":\"E_PERM\"}", "common-subset")         =>   ["foo" -> "E_PERM"]
2
parse_json("{\"foo\":\"E_PERM|err\"}", "embedded-types")    =>   ["foo" -> E_PERM]
2

2
In embedded types mode, key values can be converted to MOO types by appending type information. The full set of supported types are obj, str, err, float and int.
2

2
parse_json("{\"1\":2}")                                     =>   ["1" -> 2]
2
parse_json("{\"1\":2}", "common-subset")                    =>   ["1" -> 2]
2
parse_json("{\"1|int\":2}", "embedded-types")               =>   [1 -> 2]
2
parse_json("{\"#1|obj\":2}", "embedded-types")              =>   [#1 -> 2]
2

2
JSON defines types that MOO (currently) does not support, such as boolean true and false, and null. These values are always converted to the strings "true", "false" and "null". 
36
5
4
3
2
Syntax: random_bytes (INT count)
2

2
Returns a binary string composed of between one and 10000 random bytes. count specifies the number of bytes and must be a positive integer; otherwise, E_INVARG is raised. 
36
5
4
32
2
Syntax: read_http (request-or-response [, OBJ conn])
2

2
Reads lines from the connection conn (or, if not provided, from the player that typed the command that initiated the current task) and attempts to parse the lines as if they are an HTTP request or response. request-or-response must be either the string "request" or "response". It dictates the type of parsing that will be done.
2

2
Just like read(), if conn is provided, then the programmer must either be a wizard or the owner of conn; if conn is not provided, then read_http() may only be called by a wizard and only in the task that was last spawned by a command from the connection in question. Otherwise, E_PERM is raised. Likewise, if conn is not currently connected and has no pending lines of input, or if the connection is closed while a task is waiting for input but before any lines of input are received, then read_http() raises E_INVARG.
2

2
If parsing fails because the request or response is syntactically incorrect, read_http() will return a map with the single key "error" and a list of values describing the reason for the error. If parsing succeeds, read_http() will return a map with an appropriate subset of the following keys, with values parsed from the HTTP request or response: "method", "uri", "headers", "body", "status" and "upgrade".
2

2
    Fine point: read_http() assumes the input strings are binary strings. When called interactively, as in the example below, the programmer must insert the literal line terminators or parsing will fail. 
2

2
The following example interactively reads an HTTP request from the players connection.
2

2
read_http("request", player)
2
GET /path HTTP/1.1~0D~0A
2
Host: example.com~0D~0A
2
~0D~0A
2

2
In this example, the string ~0D~0A ends the request. The call returns the following (the request has no body):
2

2
["headers" -> ["Host" -> "example.com"], "method" -> "GET", "uri" -> "/path"]
2

2
The following example interactively reads an HTTP response from the players connection.
2

2
read_http("response", player)
2
HTTP/1.1 200 Ok~0D~0A
2
Content-Length: 10~0D~0A
2
~0D~0A
2
1234567890
2

2
The call returns the following:
2

2
["body" -> "1234567890", "headers" -> ["Content-Length" -> "10"], "status" -> 200]
36
5
4
13
2
Syntax: salt (STR format, STR input)
2

2
Generate a crypt() compatible salt string for the specified salt format using the specified binary random input. The specific set of formats supported depends on the libraries used to build the server, but will always include the standard salt format, indicated by the format string "" (the empty string), and the BCrypt salt format, indicated by the format string "$2a$NN$" (where "NN" is the work factor). Other possible formats include MD5 ("$1$"), SHA256 ("$5$") and SHA512 ("$6$"). Both the SHA256 and SHA512 formats support optional rounds.
2

2
salt("", ".M")                                           =>    "iB"
2
salt("$1$", "~183~1E~C6/~D1")                            =>    "$1$MAX54zGo"
2
salt("$5$", "x~F2~1Fv~ADj~92Y~9E~D4l~C3")                =>    "$5$s7z5qpeOGaZb"
2
salt("$5$rounds=2000$", "G~7E~A7~F5Q5~B7~0Aa~80T")       =>    "$5$rounds=2000$5trdp5JBreEM"
2
salt("$6$", "U7~EC!~E8~85~AB~CD~B5+~E1?")                =>    "$6$JR1vVUSVfqQhf2yD"
2
salt("$6$rounds=5000$", "~ED'~B0~BD~B9~DB^,\\~BD~E7")    =>    "$6$rounds=5000$hT0gxavqSl0L"
2
salt("$2a$08$", "|~99~86~DEq~94_~F3-~1A~D2#~8C~B5sx")    =>    "$2a$08$dHkE1lESV9KrErGhhJTxc."
2

2
Note: To ensure proper security, the random input must be from a sufficiently random source. 
36
5
4
12
2
Syntax: strtr (STR source, STR str1, STR str2 [, case-matters])
2

2
Transforms the string source by replacing the characters specified by str1 with the corresponding characters specified by str2. All other characters are not transformed. If str2 has fewer characters than str1 the unmatched characters are simply removed from source. By default the transformation is done on both upper and lower case characters no matter the case. If case-matters is provided and true, then case is treated as significant.
2

2
strtr("foobar", "o", "i")           =>    "fiibar"
2
strtr("foobar", "ob", "bo")         =>    "fbboar"
2
strtr("foobar", "", "")             =>    "foobar"
2
strtr("foobar", "foba", "")         =>    "r"
2
strtr("5xX", "135x", "0aBB", 0)     =>    "BbB"
2
strtr("5xX", "135x", "0aBB", 1)     =>    "BBX"
2
strtr("xXxX", "xXxX", "1234", 0)    =>    "4444"
2
strtr("xXxX", "xXxX", "1234", 1)    =>    "3434"
36
5
4
3
2
Syntax: value_hmac (value, STR key [, STR algo [, binary]])
2

2
Returns the same string as string_hmac(toliteral(value), key, ...); see the description of string_hmac() for details. 
36
5
4
15
2
Syntax: crypt (STR text [, STR salt])
2

2
Encrypts (hashes) the given text using the standard UNIX encryption method. If provided, salt should be a string at least two characters long, and it may dictate a specific algorithm to use. By default, crypt uses the original, now insecure, DES algorithm. Stunt specifically includes the BCrypt algorithm (identified by salts that start with "$2a$"), and may include MD5, SHA256, and SHA512 algorithms depending on the libraries used to build the server. The salt used is returned as the first part of the resulting encrypted string.
2

2
Aside from the possibly-random input in the salt, the encryption algorithms are entirely deterministic. In particular, you can test whether or not a given string is the same as the one used to produce a given piece of encrypted text; simply extract the salt from the front of the encrypted text and pass the candidate string and the salt to crypt(). If the result is identical to the given encrypted text, then youve got a match.
2

2
crypt("foobar", "iB")                               =>    "iBhNpg2tYbVjw"
2
crypt("foobar", "$1$MAX54zGo")                      =>    "$1$MAX54zGo$UKU7XRUEEiKlB.qScC1SX0"
2
crypt("foobar", "$5$s7z5qpeOGaZb")                  =>    "$5$s7z5qpeOGaZb$xkxjnDdRGlPaP7Z ... .pgk/pXcdLpeVCYh0uL9"
2
crypt("foobar", "$5$rounds=2000$5trdp5JBreEM")      =>    "$5$rounds=2000$5trdp5JBreEM$Imi ... ckZPoh7APC0Mo6nPeCZ3"
2
crypt("foobar", "$6$JR1vVUSVfqQhf2yD")              =>    "$6$JR1vVUSVfqQhf2yD$/4vyLFcuPTz ... qI0w8m8az076yMTdl0h."
2
crypt("foobar", "$6$rounds=5000$hT0gxavqSl0L")      =>    "$6$rounds=5000$hT0gxavqSl0L$9/Y ... zpCATppeiBaDxqIbAN7/"
2
crypt("foobar", "$2a$08$dHkE1lESV9KrErGhhJTxc.")    =>    "$2a$08$dHkE1lESV9KrErGhhJTxc.QnrW/bHp8mmBl5vxGVUcsbjo3gcKlf6"
2

2
Note: The specific set of supported algorithms depends on the libraries used to build the server. Only the BCrypt algorithm, which is distributed with the server source code, is guaranteed to exist. BCrypt is currently mature and well tested, and is recommended for new development.
36
5
4
9
2
Syntax:   argon2 (STR <password>, STR <salt> [, <iterations> 3] [, <memory usage in KB> 4096] [, <CPU threads> 1]) => STR
2

2
The function `argon2()' hashes a password using the Argon2id password hashing algorithm. It is parametrized by three optional arguments:
2

2
 * Time: This is the number of times the hash will get run. This defines the amount of computation required and, as a result, how long the function will take to complete.
2
 * Memory: This is how much RAM is reserved for hashing.
2
 * Parallelism: This is the number of CPU threads that will run in parallel.
2

2
The salt for the password should, at minimum, be 16 bytes for password hashing. It is recommended to use the random_bytes() function.
36
5
4
3
2
Syntax: task_local ()
2

2
Returns the value associated with the current task. The value is set with the `set_task_local` function.
36
5
4
6
2
Syntax: set_task_local(ANY value)
2

2
Sets a value that gets associated with the current running task. This value persists across verb calls and gets reset when the task is killed, making it suitable for securely passing sensitive intermediate data between verbs. The value can then later be retrieved using the `task_local` function.
2

2
set_task_local("arbitrary data")
2
set_task_local({"list", "of", "arbitrary", "data"})
36
5
4
3
2
Syntax: respond_to(OBJ object, STR verb)
2

2
Returns true if <verb> is callable on <object>, taking into account inheritance, wildcards (star verbs), etc. Otherwise, returns false.  If the caller is permitted to read the object (because the object's `r' flag is true, or the caller is the owner or a wizard) the true value is a list containing the object number of the object that defines the verb and the full verb name(s).  Otherwise, the numeric value `1' is returned.
36
5
4
11
2
Syntax:  isa(OBJ <object>, OBJ <parent>)
2
         isa(OBJ <object>, LIST <parent list> [, INT <return_parent>])
2

2
Returns true if <object> is a descendant of <parent>, otherwise false.
2

2
If a third argument is present and true, the return value will be the first parent that object1 descends from in the <parent list>.
2

2
isa(#2, $wiz)                           => 1
2
isa(#2, {$thing, $wiz, $container})     => 1
2
isa(#2, {$thing, $wiz, $container}, 1)  => #57 (generic wizard)
2
isa(#2, {$thing, $room, $container}, 1) => #-1 <$nothing>
36
5
4
5
2
Syntax: switch_player(OBJ <object1>, OBJ <object2> [, INT <silent>])
2

2
Silently switches the player associated with this connection from <object1> to <object2>. <object1> must be connected and <object2> must be a player. This can be used in do_login_command() verbs that read or suspend (which prevents the normal player selection mechanism from working.
2

2
If <silent> is true, no connection messages will be printed.
36
5
4
74
2
LambdaMOO-Stunt adds the following built-in functions:
2

2
binary_hmac
2
string_hmac
2
value_hmac       - Cryptographically secure HMAC functions.
2
decode_base64
2
encode_base64    - Encode and decode binary Base64 strings.
2
exec             - Execute shell scripts and applications.
2
exp              - Return Eulers number (E) to the power of <x>.
2
generate_json    - Return the JSON representation of the MOO value.
2
parse_json       - Return the MOO value representation of a JSON string.
2
getenv           - Return the value of the named environment variable.
2
mapdelete        - Delete a key from a map.
2
mapkeys          - List the keys in a map.
2
mapvalues        - List the values in a map.
2
random_bytes     - Return a binary string of <x> bytes.
2
read_http        - Parse lines from a network connection as HTTP requests.
2
salt             - Generate a cryptographically secure salt string.
2
strtr            - Replace characters in a string.
2
crypt            - Encrypt a string using a variety of algorithms.
2
task_local       - Return values associated with the current task.
2
set_task_local   - Set values associated with the current task.
2
respond_to       - Check if a verb is callable on an object.
2
isa              - Check if an object is a descendant of another object.
2
switch_player    - Silently switch a connection to another player.
2

2

2
Additionally, the ToastStunt fork adds these:
2

2
argon2                  - Argon2id secure hashing.
2
argon2_verify           - Compares password to hash
2
sqlite                  - See HELP SQLITE for a complete list.
2
pcre_match              - Match a string using Perl Compatible Regular Expressions.
2
pcre_replace            - Replace text in a string using Perl Compatible Regular Expressions.
2
frandom                 - Random floats.
2
distance                - Calculate the distance between an arbitrary number of points.
2
relative_heading        - Calculate a relative bearing between two points.
2
memory_usage            - Total memory used, resident set size, shared pages, text, data + stack
2
ftime                   - Precise time, including an argument for monotonic timing.
2
locate_by_name          - Quickly locate objects by their name and aliases.
2
usage                   - Returns a list of system information from the operating system.
2
explode                 - Return a list of substrings of a string separated by a break.
2
occupants               - Return a list of objects of parent parent, optionally with a player flag check.
2
spellcheck              - Check the spelling of a word using Aspell.
2
locations               - Recursive location reporting function.
2
clear_ancestor_cache    - Manually clears the ancestor cache.
2
simplex_noise           - Generate Simplex Noise.
2
threads                 - Display a list of active threads.
2
thread_info             - Display specific information about a running thread.
2
new_waif                - Create a new waif.
2
waif_stats              - Display a count of instantiated waifs by class.
2
sort                    - Sorts a list by itself or another list of keys. Also support natural ordering and reverse.
2
yin                     - Yield if needed. Suspend a task when running out of ticks or seconds.
2
slice                   - Makes a new list of the index-th elements of the original list.
2
reverse                 - Reverse a list.
2
recreate                - Create valid objects from invalid objects.
2
set_thread_mode         - Enable or disable threading of functions for the current verb.
2
chr                     - Translate integers into ASCII characters.
2
recycled_objects        - Return a list of all invalid objects in the database.
2
next_recycled_object    - Return the first available invalid object.
2
all_members             - Return the indices of all instances of an element in a list.
2
owned_objects           - Return a list of all objects owned by the specified player.
2
sqlite_limit            - Specify limits on various SQLite constructs.
2
curl                    - Return websites as strings.
2
connection_name_lookup  - Perform a DNS name lookup in another thread.
2
thread_pool             - Manipulate the server thread pool. (Caution advised.)
2
connection_info         - Return network information about a specific connection.
2
maphaskey               - Return true if a map contains the key specified.
2
ancestors               - Return all ancestors of an object
2
finished_tasks          - When enabled, track execution time
2
listen                  - Updated listen() with ipv6 & tls
2
open_network_connection - Updated to support ipv6 & tls
2
reseed_random           - Provide a new seed to the pseudo random number generator.
2
FileIO                  - See HELP fileio for details
36
5
4
18
2
Syntax:	  sqlite_open(STR <path to database>, [INT options]) => INT
2

2
The function `sqlite_open' will attempt to open the database at <path> for use with SQLite.
2

2
The second argument is a bitmask of options. Options are:
2

2
	SQLITE_PARSE_OBJECTS [4]:    Determines whether strings beginning with a pound symbol (#) are interpreted as MOO object numbers or not.
2
                                     The default is true, which means that any queries that would return a string (such as "#123") will be returned as objects.
2
	SQLITE_PARSE_TYPES [2]:      If unset, no parsing of rows takes place and only strings are returned.
2
	SQLITE_SANITIZE_STRINGS [8]: If set, newlines (\n) are converted into tabs (\t) to avoid corrupting the MOO database. Default is unset.
2

2
NOTE: If the MOO doesn't support bitmasking, you can still specify options. You'll just have to manipulate the int yourself. e.g. if you want to parse objects and types, arg[2] would be a 6. If you only want to parse types, arg[2] would be 2.
2

2
If successful, the function will return the numeric handle for the open database.
2

2
If unsuccessful, the function will return a helpful error message.
2

2
If the database is already open, a traceback will be thrown that contains the already open database handle.
36
5
4
7
2
Syntax:	  sqlite_close(INT <database handle) => INT
2

2
This function will close an open database.
2

2
If successful, return 1;
2

2
If unsuccessful, returns E_INVARG.
36
5
4
3
2
Syntax:	  sqlite_handles() => LIST
2

2
Returns a list of open SQLite database handles.
36
5
4
9
2
Syntax:	  sqlite_info(INT <database handle>) => MAP
2

2
This function returns a map of information about the database at <handle>
2

2
The information returned is:
2
	Database Path
2
	Type parsing enabled?
2
	Object parsing enabled?
2
	String sanitation enabled?
36
5
4
11
2
Syntax:	  sqlite_query(INT <database handle>, STR <database query>[, INT <show columns>]) => [LIST or STR]
2

2
This function will attempt to execute the query given in <query> on the database referred to by <handle>.
2

2
On success, this function will return a list identifying the returned rows. If the query didn't return rows but was successful, an empty list is returned.
2

2
If the query fails, a string will be returned identifying the SQLite error message.
2

2
If <show columns> is true, the return list will include the name of the column before its results.
2

2
WARNING: sqlite_query does NOT use prepared statements and should NOT be used on queries that contain user input.
36
5
4
12
2
Syntax:	  sqlite_execute(INT <database handle>, STR <SQL prepared statement query>, LIST <values>) => [LIST or STR]
2

2
This function will attempt to create and execute the prepared statement query given in <query> on the database referred to by <handle> with the values <values>.
2

2
On success, this function will return a list identifying the returned rows. If the query didn't return rows but was successful, an empty list is returned.
2

2
If the query fails, a string will be returned identifying the SQLite error message.
2

2
sqlite_execute uses prepared statements, so it's the preferred function to use for security and performance reasons.
2

2
Example:
2
sqlite_execute(0, "INSERT INTO users VALUES (?, ?, ?);", {#7, "lisdude", "Albori Sninvel"})
36
5
4
3
2
Syntax:	  sqlite_last_insert_row_id(INT <database handle>)
2

2
This function identifies the row ID of the last insert command executed on the database.
36
5
4
10
2
SQLite allows you to store information in locally hosted SQLite databases. The following functions (see HELP <function name> for detailed information) are available:
2

2
sqlite_open         Opens an SQLite database.
2
sqlite_close        Closes an SQLite database.
2
sqlite_handles      Returns a list of open SQLite database handles.
2
sqlite_info         Returns information about an open SQLite database.
2
sqlite_query        Runs a raw SQL query on the database.
2
sqlite_execute      Executes an SQL prepared statement on the database.
2
sqlite_limit        Set limits on various SQL constructs.
2
sqlite_interrupt    Abort a database operation.
36
5
4
22
2
Syntax:   pcre_replace (STR <subject>, STR <pattern>) => STR
2

2
The function `pcre_replace()' replaces <subject> with replacements found in <pattern> using the Perl Compatible Regular Expressions library.
2

2
The pattern string has a specific format that must be followed, which should be familiar if you have used the likes of Vim, Perl, or sed. The string is composed of four elements, each separated by a delimiter (typically a slash (/) or an exclaimation mark (!)), that tell PCRE how to parse your replacement. We'll break the string down and mention relevant options below:
2

2
1. Type of search to perform. In MOO, only 's' is valid. This parameter is kept for the sake of consistency.
2
2. The text you want to search for a replacement.
2
3. The regular expression you want to use for your replacement text.
2
4. Optional modifiers:
2
    g: Global. This will replace all occurances in your string rather than stopping at the first.
2
    i: Case-insensitive. Uppercase, lowercase, it doesn't matter. All will be replaced.
2
    
2
Examples:
2

2
Replace one word with another:
2
pcre_replace("I like banana pie. Do you like banana pie?", "s/banana/apple/g")
2
=> "I like apple pie. Do you like apple pie?"
2

2
If you find yourself wanting to replace a string that contains slashes, it can be useful to change your delimiter to an exclaimation mark:
2
pcre_replace("Unix, wow! /bin/bash is a thing.", "s!/bin/bash!/bin/fish!g")
2
=> "Unix, wow! /bin/fish is a thing."
36
5
4
3
2
Syntax:  frandom (FLOAT <mod1> [, FLOAT <mod2>)   => FLOAT
2

2
If only one argument is given, a floating point number is chosen randomly from the range `[1.0..<mod1>]` and returned. If two arguments are given, a floating point number is randomly chosen from the range `[<mod1>..<mod2>]`. 
36
5
4
5
2
Syntax:  memory_usage ()   => LIST
2

2
Return statistics concerning the server's consumption of system memory. The result is a list in the following format:
2

2
{total memory used, resident set size, shared pages, text, data + stack}
36
5
4
7
2
Syntax:  ftime ([INT monotonic])   => FLOAT
2

2
Returns the current time represented as the number of seconds and nanoseconds that have elapsed since midnight on 1 January 1970, Greenwich Mean Time.
2

2
If the <monotonic> argument is supplied and set to 1, the time returned will be monotonic. This means that will you will always get how much time has elapsed from an arbitrary, fixed point in the past that is unaffected by clock skew or other changes in the wall-clock. This is useful for benchmarking how long an operation takes, as it's unaffected by the actual system time.
2

2
The general rule of thumb is that you should use ftime() with no arguments for telling time and ftime() with the monotonic clock argument for measuring the passage of time.
36
5
4
3
2
Syntax:  locate_by_name (STR <object name>)   => LIST
2

2
This function searches every object in the database for those containing <object name> in their .name property.
36
5
4
5
2
Syntax:  usage ()   => LIST
2

2
Return statistics concerning the server the MOO is running on. The result is a list in the following format:
2

2
{load averages}, user time, system time, page reclaims, page faults, block input ops, block output ops, voluntary context switches, involuntary context switches, signals received
36
5
4
3
2
Syntax:  explode(<subject> [, <break>])   => LIST
2

2
Returns a list of substrings of <subject> that are separated by <break>. <break> defaults to a space.
36
5
4
3
2
Syntax:  clear_ancestor_cache()   => none
2

2
The ancestor cache contains a quick lookup of all of an object's ancestors which aids in expediant property lookups. This is an experimental feature and, as such, you may find that something has gone wrong. If that's that case, this function will completely clear the cache and it will be rebuilt as-needed.
36
5
4
10
2
Syntax:  locations(OBJ <object>)   => LIST
2

2
Recursively build a list of an object's location, its location's location, and so forth until finally hitting $nothing.
2

2
Example:
2
locations(me)
2
=> {#20381, #443, #104735}
2

2
$string_utils:title_list(locations(me))
2
=> "\"Butterknife Ballet\" Control Room FelElk, the one-person celestial birther \"Butterknife Ballet\", and Uncharted Space: Empty Space"
36
5
4
3
2
Syntax:  spellcheck(STR <word>)   => INT or LIST
2

2
This function checks the English spelling of <word>. If the spelling is correct, the function will return a 1. If the spelling is incorrect, a LIST of suggestions for correct spellings will be returned instead. If the spelling is incorrect and no suggestions can be found, an empty LIST is returned.
36
5
4
3
2
Syntax:  threads()   => LIST
2

2
When one or more MOO processes are suspended and working in a separate thread, this function will return a LIST of handlers to those threads. These handlers can then be passed to `thread_info' for more information.
36
5
4
6
2
Syntax:  thread_info(INT <thread handler>)   => LIST
2

2
If a MOO task is running in another thread, its thread handler will give you information about that thread. The information returned in a LIST will be:
2

2
  English Name: This is the name the programmer of the builtin function has given to the task being executed.
2
  Active: 1 or 0 depending upon whether or not the MOO task has been killed. Not all threads cleanup immediately after the MOO task dies.
36
5
4
3
2
Syntax:  waif_stats()   => MAP
2

2
Returns a MAP of statistics about instantiated waifs. Each waif class will be a key in the MAP and its value will be the number of waifs of that class currently instantiated. Additionally, there is a `total' key that will return the total number of instantiated waifs, and a `pending_recycle' key that will return the number of waifs that have been destroyed and are awaiting the call of their :recycle verb.
36
5
4
2
2
*forward*
2
fileio
36
5
4
43
2
General-purpose functions:
2

2
FHANDLE file_open(STR pathname, STR mode)
2
void file_close(FHANDLE fh)
2
STR file_name(FHANDLE fh)
2
STR file_openmode(FHANDLE fh)
2
STR file_readline(FHANDLE fh)
2
LIST file_readlines(FHANDLE fh, INT start, INT end)
2
void file_writeline(FHANDLE fh, STR line)
2
STR file_read(FHANDLE fh, INT bytes)
2
INT file_write(FHANDLE fh, STR data)
2
INT file_tell(FHANDLE fh)
2
void file_seek(FHANDLE fh, INT loc, STR whence)
2
INT file_eof(FHANDLE fh)
2
void file_rename(STR oldpath, STR newpath)
2
void file_remove(STR pathname)
2
void file_mkdir(STR pathname)
2
void file_rmdir(STR pathname)
2
LIST file_list(STR pathname, [ANY detailed])
2
STR file_type(STR pathname)
2
STR file_mode(STR filename)
2
void file_chmod(STR filename, STR mode)
2
LIST file_handles()
2
LIST file_grep(FHANDLER fh, STR search [,?match_all=0])
2

2
Attribute functions:
2

2
INT file_size(STR pathname)
2
STR file_mode(STR pathname)
2
INT file_last_access(STR pathname)
2
INT file_last_modify(STR pathname)
2
INT file_last_change(STR pathname)
2
INT file_size(FHANDLE fh)
2
STR file_mode(FHANDLE fh)
2
INT file_last_access(FHANDLE fh)
2
INT file_last_modify(FHANDLE fh)
2
INT file_last_change(FHANDLE fh)
2
INT file_count_lines(FHANDLE fh)
2

2
void file_stat(STR pathname)
2
void file_stat(FHANDLE fh)
2

2

36
5
4
47
2
 Function: FHANDLE file_open(STR pathname, STR mode)
2

2
  Raises: E_INVARG if mode is not a valid mode, E_QUOTA if too many files are open.
2
  This opens a file specified by pathname and returns an FHANDLE for it.
2
  It ensures pathname is legal.  Mode is a string of characters indicating what mode the file is opened in. 
2
  The mode string is four characters.
2

2
  The first character must be (r)ead, (w)rite, or (a)ppend.  The second must be '+' or '-'.  This modifies the previous argument.
2

2
  o  r- opens the file for reading and fails if the file does not exist.
2

2
  o  r+ opens the file for reading and writing and fails if the file
2
     does not exist.
2

2
  o  w- opens the file for writing, truncating if it exists and creating
2
     if not.
2

2
  o  w+ opens the file for reading and writing, truncating if it exists
2
     and creating if not.
2

2
  o  a- opens a file for writing, creates it if it does not exist and
2
     positions the stream at the end of the file.
2

2
  o  a+ opens the file for reading and writing, creates it if does not
2
     exist and positions the stream at the end of the file.
2

2
     The third character is either (t)ext or (b)inary.  In text mode,
2
     data is written as-is from the MOO and data read in by the MOO is
2
     stripped of unprintable characters.  In binary mode, data is
2
     written filtered through the binary-string->raw-bytes conversion
2
     and data is read filtered through the raw-bytes->binary-string
2
     conversion.  For example, in text mode writing " 1B" means three
2
     bytes are written: ' ' Similarly, in text mode reading " 1B" means
2
     the characters ' ' '1' 'B' were present in the file.  In binary
2
     mode reading " 1B" means an ASCII ESC was in the file.  In text
2
     mode, reading an ESC from a file results in the ESC getting
2
     stripped.
2

2
  It is not recommended that files containing unprintable ASCII  data be
2
  read in text mode, for obvious reasons.
2

2
  The final character is either 'n' or 'f'.  If this character is 'f',
2
  whenever data is written to the file, the MOO will force it to finish
2
  writing to the physical disk before returning.  If it is 'n' then
2
  this won't happen.
2

2
  This is implemented using fopen().
36
5
4
5
2
 Function: void file_close(FHANDLE fh)
2

2
  Closes the file associated with fh.
2

2
  This is implemented using fclose().
36
5
4
5
2
Function: STR file_name(FHANDLE fh)
2

2
  Returns the pathname originally associated with fh by file_open().
2
  This is not necessarily the file's current name if it was renamed or
2
  unlinked after the fh was opened.
36
5
4
3
2
Function: STR file_openmode(FHANDLE fh)
2

2
  Returns the mode the file associated with fh was opened in.
36
5
4
7
2
Function: STR file_readline(FHANDLE fh)
2

2
  Reads the next line in the file and returns it (without the newline).
2

2
  Not recommended for use on files in binary mode.
2

2
  This is implemented using fgetc().
36
5
4
9
2
  Function: LIST file_readlines(FHANDLE fh, INT start, INT end)
2

2
  Rewinds the file and then reads the specified lines from the file,
2
  returning them as a list of strings.  After this operation, the stream
2
  is positioned right after the last line read.
2

2
  Not recommended for use on files in binary mode.
2

2
  This is implemented using fgetc().
36
5
4
7
2
  Function: void file_writeline(FHANDLE fh, STR line)
2

2
  Writes the specified line to the file (adding a newline).
2

2
  Not recommended for use on files in binary mode.
2

2
  This is implemented using fputs()
36
5
4
8
2
Function: STR file_read(FHANDLE fh, INT bytes)
2

2
  Reads up to the specified number of bytes from the file and returns
2
  them.
2

2
  Not recommended for use on files in text mode.
2

2
  This is implemented using fread().
36
5
4
8
2
Function: INT file_write(FHANDLE fh, STR data)
2

2
  Writes the specified data to the file.  Returns number of bytes
2
  written.
2

2
  Not recommended for use on files in text mode.
2

2
  This is implemented using fwrite().
36
5
4
5
2
Function: INT file_tell(FHANDLE fh)
2

2
  Returns position in file.
2

2
  This is implemented using ftell().
36
5
4
12
2
Function: void file_seek(FHANDLE fh, INT loc, STR whence)
2

2
  Seeks to a particular location in a file.  whence is one of the
2
  strings:
2

2
  o  "SEEK_SET" - seek to location relative to beginning
2

2
  o  "SEEK_CUR" - seek to location relative to current
2

2
  o  "SEEK_END" - seek to location relative to end
2

2
  This is implemented using fseek().
36
5
4
5
2
Function: INT file_eof(FHANDLE fh)
2

2
  Returns true if and only if fh's stream is positioned at EOF.
2

2
  This is implemented using feof().
36
5
4
5
2
Function: void file_rename(STR oldpath, STR newpath)
2

2
  Attempts to rename the oldpath to newpath.
2

2
  This is implemented using rename().
36
5
4
5
2
Function: void file_remove(STR pathname)
2

2
  Attempts to remove the given file.
2

2
  This is implemented using remove().
36
5
4
5
2
Function: void file_mkdir(STR pathname)
2

2
  Attempts to create the given directory.
2

2
  This is implemented using mkdir().
36
5
4
5
2
Function: void file_rmdir(STR pathname)
2

2
  Attempts to remove the given directory.
2

2
  This is implemented using rmdir().
36
5
4
13
2
Function: LIST file_list(STR pathname, [ANY detailed])
2

2
  Attempts to list the contents of the given directory.  Returns a list
2
  of files in the directory.  If the detailed argument is provided and
2
  true, then the list contains detailed entries, otherwise it contains a
2
  simple list of names.
2

2
  detailed entry:
2
    {STR filename, STR file type, STR file mode, INT file size}
2
  normal entry:
2
    STR filename
2

2
  This is implemented using scandir().
36
5
4
6
2
Function: STR file_type(STR pathname)
2

2
  Returns the type of the given pathname, one of "reg", "dir", "dev",
2
  "fifo", or "socket".
2

2
  This is implemented using stat().
36
5
4
5
2
 Function: STR file_mode(STR filename)
2

2
  Returns octal mode for a file (e.g. "644").
2

2
  This is implemented using stat().
36
5
4
6
2
Function: void file_chmod(STR filename, STR mode)
2

2
  Attempts to set mode of a file using mode as an octal string of
2
  exactly three characters.
2

2
  This is implemented using chmod().
36
5
4
16
2
 Function: void file_stat(STR pathname)
2
  Function: void file_stat(FHANDLE fh)
2

2
  Returns the result of stat() (or fstat()) on the given file.
2
  Specifically a list as follows:
2

2
  {file size in bytes, file type, file access mode, owner, group,
2
       last access, last modify, and last change}
2

2
  owner and group are always the empty string.
2

2
  It is recommended that the specific information functions file_size,
2
  file_type, file_mode, file_last_access, file_last_modify, and
2
  file_last_change be used instead.  In most cases only one of these
2
  elements is desired and in those cases there's no reason to make and
2
  free a list.
36
5
4
2
2
*index*
2
Stunt / ToastStunt Functions
36
5
4
7
2
Syntax:  occupants(LIST <objects> [, OBJ | LIST <parent>, INT <player flag set?>])   => LIST
2

2
Iterates through the list of <objects> and returns those matching a specific set of criteria:
2

2
1. If only <objects> is specified, the occupants function will return a list of objects with the player flag set.
2
2. If the <parent> argument is specified, a list of <objects> descending from <parent> will be returned. If <parent> is a list, <object> must descend from at least one object in the list.
2
3. If both <parent> and <player flag set> are specified, occupants will check both that an object is descended from <parent> and also has the player flag set.
36
5
4
21
2
Syntax:  sort(LIST <list> [, LIST <keys>, INT <natural sort order?>, INT <reverse>])   => LIST
2

2
Sorts <list> either by <keys> or using the list itself. When sorting <list> by itself, you can use an empty list ({}) for <keys> to specify additional optional arguments.
2

2
If <natural sort order> is true, strings containing multi-digit numbers will consider those numbers to be a single character. So, for instance, this means that 'x2' would come before 'x11' when sorted naturally because 2 is less than 11. This argument defaults to 0.
2

2
If <reverse> is true, the sort order is reversed. This argument defaults to 0.
2

2
Examples:
2

2
Sort a list by itself:
2
>;sort({"a57", "a5", "a7", "a1", "a2", "a11"})
2
=> {"a1", "a11", "a2", "a5", "a57", "a7"}
2

2
Sort a list by itself with natural sort order:
2
>;sort({"a57", "a5", "a7", "a1", "a2", "a11"}, {}, 1)
2
=> {"a1", "a2", "a5", "a7", "a11", "a57"}
2

2
Sort a list of strings by a list of numeric keys:
2
>;sort({"foo", "bar", "baz"}, {123, 5, 8000})
2
=> {"bar", "foo", "baz"}
36
5
4
7
2
Syntax:  yin([INT <time>, INT <minimum ticks>, INT <minimum seconds>] )   => INT
2

2
Suspend the current task if it's running out of ticks or seconds. This is meant to provide similar functionality to the LambdaCore-based suspend_if_needed verb or manually specifying something like: ticks_left() < 2000 && suspend(0)
2

2
Time: How long to suspend the task. Default: 0
2
Minimum ticks: The minimum number of ticks the task has left before suspending.
2
Minimum seconds: The minimum number of seconds the task has left before suspending.
36
5
4
13
2
Syntax:  slice(LIST <alist> [, INT | LIST | STR <index>, ANY <default map value>])   => LIST
2

2
Return the <index>-th elements of <alist>. By default, index will be 1. If index is a list of integers, the returned list will have those elements from <alist>. This is the built-in equivalent of LambdaCore's $list_utils:slice verb.
2

2
If <alist> is a list of maps, index can be a string indicating a key to return from each map in <alist>.
2

2
If <default map value> is specified, any maps not containing the key <index> will have <default map value> returned in their place. This is useful in situations where you need to maintain consistency with a list index and can't have gaps in your return list.
2

2
Examples:
2
 >slice({{"z", 1}, {"y", 2}, {"x",5}}, 2) => {1, 2, 5}.
2
 >slice({{"z", 1, 3}, {"y", 2, 4}}, {2, 1}) => {{1, "z"}, {2, "y"}}
2
 >;slice({["a" -> 1, "b" -> 2], ["a" -> 5, "b" -> 6]}, "a") => {1, 5}
2
 >;slice({["a" -> 1, "b" -> 2], ["a" -> 5, "b" -> 6], ["b" -> 8]}, "a", 0) => {1, 5, 0}
36
5
4
9
2
Syntax:  set_thread_mode([INT <mode>])
2

2
With no arguments specified, set_thread_mode will return the current thread mode for the verb. A value of 1 indicates that threading is enabled for functions that support it. A value of 0 indicates that threading is disabled and all functions will execute in the main MOO thread, as functions have done in default LambdaMOO since version 1.
2

2
If you specify an argument, you can control the thread mode of the current verb. A <mode> of 1 will enable threading and a <mode> of 0 will disable it. You can invoke this function multiple times if you want to disable threading for a single function call and enable it for the rest.
2

2
When should you disable threading? In general, threading should be disabled in verbs where it would be undesirable to suspend(). Each threaded function will immediately suspend the verb while the thread carries out its work. This can have a negative effect when you want to use these functions in verbs that cannot or should not suspend, like $sysobj:do_command or $sysobj:do_login_command.
2

2
Note that the threading mode affects the current verb only and does NOT affect verbs called from within that verb.
36
5
4
5
2
Syntax:  recreate(OBJ <old>, OBJ <parent> [, OBJ <owner>])  => OBJ
2

2
Recreate invalid object <old> (one that has previously been recycle()ed) as <parent>, optionally owned by <owner>. This has the effect of filling in holes created by recycle() that would normally require renumbering and resetting the maximum object.
2

2
The normal rules apply to parent and owner. You either have to own <parent>, <parent> must be fertile, or you have to be a wizard. Similarly, to change <owner>, you should be a wizard. Otherwise it's superfluous.
36
5
4
2
2
*forward*
2
stunt
36
5
4
4
2
Syntax:  chr(INT <arg>, ...)  => STR
2

2
This function translates integers into ASCII characters. Each argument must be an integer between 0 and 255.
2
If the programmer is not a wizard, and integers less than 32 are provided, E_INVARG is raised. This prevents control characters or newlines from being written to the database file by non-trusted individuals.
36
5
4
3
2
Syntax:  recycled_objects()  => LIST
2

2
Return a list of all invalid objects in the database. An invalid object is one that has been destroyed with the recycle() function.
36
5
4
3
2
Syntax:  next_recycled_object(OBJ <start>)  => OBJ | INT
2

2
Return the lowest invalid object. If <start> is specified, no object lower than <start> will be considered. If there are no invalid objects, this function will return 0.
36
5
4
6
2
Syntax:  all_members(ANY <value>, LIST <alist>)  => LIST
2

2
Returns the indices of every instance of <value> in <alist>.
2

2
Example:
2
;all_members("a", {"a", "b", "a", "c", "a", "d"}) => {1, 3, 5}
36
5
4
17
2
Syntax:	  pcre_match (STR <subject>, STR <pattern> [, <case matters> 0] [, <repeat until no matches> 1]	=> LIST
2

2
The function `pcre_match()' searches <subject> for <pattern> using the Perl Compatible Regular Expressions library. The return value is a list of maps containing each match. Each returned map will have a key which corresponds to either a named capture group or the number of the capture group being matched. The full match is always found in the key "0". The value of each key will be another map containing the keys 'match' and 'position'. Match corresponds to the text that was matched and position will return the indices of the substring within <subject>.
2

2
If <repeat until no matches> is 1, the expression will continue to be evaluated until no further matches can be found or it exhausts the iteration limit. This defaults to 1.
2

2
Additionally, wizards can control how many iterations of the loop are possible by adding a property to $server_options. $server_options.pcre_match_max_iterations is the maximum number of loops allowed before giving up and allowing other tasks to proceed. CAUTION: It's recommended to keep this value fairly low. The default value is 1000. The minimum value is 100.
2

2
Examples:
2

2
Extract dates from a string:
2
pcre_match("09/12/1999 other random text 01/21/1952", "([0-9]{2})/([0-9]{2})/([0-9]{4})")
2
=> {["0" -> ["match" -> "09/12/1999", "position" -> {1, 10}], "1" -> ["match" -> "09", "position" -> {1, 2}], "2" -> ["match" -> "12", "position" -> {4, 5}], "3" -> ["match" -> "1999", "position" -> {7, 10}]], ["0" -> ["match" -> "01/21/1952", "position" -> {30, 39}], "1" -> ["match" -> "01", "position" -> {30, 31}], "2" -> ["match" -> "21", "position" -> {33, 34}], "3" -> ["match" -> "1952", "position" -> {36, 39}]]}
2

2
Explode a string (albeit a contrived example):
2
;;ret = {}; for x in (pcre_match("This is a string of words, with punctuation, that should be exploded. By space. --zippy--", "[a-zA-Z]+", 0, 1)) ret = {@ret, x["0"]["match"]}; endfor return ret;
2
=> {"This", "is", "a", "string", "of", "words", "with", "punctuation", "that", "should", "be", "exploded", "By", "space", "zippy"}
36
5
4
47
2
Syntax:	  sqlite_limit(INT <database handle>, STR <category> INT <new value>) => INT
2

2
This function allows you to specify various construct limitations on a per-database basis.
2

2
If <new value> is a negative number, the limit is unchanged. Each limit category has a hardcoded upper bound. Attempts to increase a limit above its hard upper bound are silently truncated to the hard upper bound.
2

2
Regardless of whether or not the limit was changed, the sqlite_limit() function returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.
2

2
As of this writing, the following limits exist:
2

2
LIMIT_LENGTH
2
    The maximum size of any string or BLOB or table row, in bytes.
2

2
LIMIT_SQL_LENGTH
2
    The maximum length of an SQL statement, in bytes.
2

2
LIMIT_COLUMN
2
    The maximum number of columns in a table definition or in the result set of a SELECT or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.
2

2
LIMIT_EXPR_DEPTH
2
    The maximum depth of the parse tree on any expression.
2

2
LIMIT_COMPOUND_SELECT
2
    The maximum number of terms in a compound SELECT statement.
2

2
LIMIT_VDBE_OP
2
    The maximum number of instructions in a virtual machine program used to implement an SQL statement. If sqlite3_prepare_v2() or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.
2

2
LIMIT_FUNCTION_ARG
2
    The maximum number of arguments on a function.
2

2
LIMIT_ATTACHED
2
    The maximum number of attached databases.
2

2
LIMIT_LIKE_PATTERN_LENGTH
2
    The maximum length of the pattern argument to the LIKE or GLOB operators.
2

2
LIMIT_VARIABLE_NUMBER
2
    The maximum index number of any parameter in an SQL statement.
2

2
LIMIT_TRIGGER_DEPTH
2
    The maximum depth of recursion for triggers.
2

2
LIMIT_WORKER_THREADS
2
    The maximum number of auxiliary worker threads that a single prepared statement may start.
2

2
For an up-to-date list of limits, see the SQLite documentation here: https://www.sqlite.org/c3ref/c_limit_attached.html
36
5
4
5
2
Syntax:	  curl(STR <url> [, INT <include_headers>]) => STR
2

2
The curl builtin will download a webpage and return it as a string. If <include_headers> is true, the HTTP headers will be included in the return string.
2

2
It's worth noting that the data you get back will be binary encoded. In particular, you will find that line breaks appear as ~0A. You can easily convert a page into a list by passing the return string into the decode_binary() function.
36
5
4
9
2
Syntax:  connection_name_lookup (OBJ <connection> [, INT record_result])   => STR
2

2
This function performs a DNS name lookup on connection's IP address. If a hostname can't be resolved, the function simply returns the numeric IP address. Otherwise, it will return the resolved hostname.
2

2
If record_result is true, the resolved hostname will be saved with the connection and will overwrite it's existing 'connection_name()'. This means that you can call 'connection_name_lookup()' a single time when a connection is created and then continue to use 'connection_name()' as you always have in the past.
2

2
This function is primarily intended for use when the 'NO_NAME_LOOKUP' server option is set. Barring temporarily failures in your nameserver, very little will be gained by calling this when the server is performing DNS name lookups for you.
2

2
NOTE: This function runs in a separate thread. While this is good for performance (long lookups won't lock your MOO like traditional pre-2.6.0 name lookups), it also means it will require slightly more work to create an entirely in-database DNS lookup solution. Because it explicitly suspends, you won't be able to use it in 'do_login_command()' without also using the 'switch_player()' function. For an example of how this can work, see '#0:do_login_command()' in ToastCore.
36
5
4
20
2
Syntax:  connection_info (OBJ <connection>)   => LIST
2

2
Returns a MAP of network connection information for <connection>. At the time of writing, the following information is returned:
2

2
destination_address: The hostname of the connection. For incoming connections, this is the hostname of the connected user.
2
                     For outbound connections, this is the hostname of the outbound connection's destination.
2

2
destination_ip:      The unresolved numeric IP address of the connection.
2

2
destination_port:    For incoming connections, this is the local port used to make the connection.
2
                     For outbound connections, this is the port the connection was made to.
2

2
source_address:      This is the hostname of the interface an incoming connection was made on. For outbound connections, this value is meaningless.
2

2
source_ip:           The unresolved numeric IP address of the interface a connection was made on. For outbound connections, this value is meaningless.
2

2
source_port:         The local port a connection connected to. For outbound connections, this value is meaningless.
2

2
protocol:            Describes the protocol used to make the connection. At the time of writing, this could be IPv4 or IPv6.
2
		       
36
5
4
3
2
Syntax:   argon2_verify (STR <hash>, STR <password>)  => INT
2

2
Compares <password> to the previously hashed <hash>. Returns 1 if the two match or 0 if they don't.
36
5
4
3
2
Syntax: maphaskey (MAP <map>, STR <key>)   => INT
2

2
Returns 1 if <key> exists in <map>. When not dealing with hundreds of keys, this function is faster (and easier to read) than something like: !(x in mapkeys(map))
36
5
4
3
2
Syntax: reseed_random()
2

2
Provide a new seed to the pseudo random number generator.
36
5
4
20
2
Syntax:  finished_tasks ()   => LIST
2

2
When enabled (via SAVE_FINISHED_TASKS in options.h), the server will keep track of the execution time of every task that passes through the interpreter. This data is then made available to the database in two ways.
2

2
The first is the finished_tasks() function. This function will return a list of maps of the last several finished tasks (configurable via $server_options.finished_tasks_limit) with the following information:
2

2

2
Foreground:    True if this was a foreground task.
2
Fullverb:      The full name of the verb being executed.
2
Object:        The object the verb is defined on.
2
Player:        The result of the 'player' variable.
2
Programmer:    The player whose permissions the verb is running as.
2
Receiver:      The object that received the verb invocation. In the case of primitives, this is the primitive's object handler.
2
Suspended:     True if the task suspended instead of finishing.
2
This:          The result of the 'this' variable.
2
Time:          The total time the task took inside the interpreter.
2
Verb:          The verb name used to invoke the task.
2

2

2
The second is via the $handle_lagging_task verb. When the execution threshold defined in $server_options.task_lag_threshold is exceeded, the server will write an entry to the log file and call the $handle_lagging_task verb with the call stack of the task as well as the execution time.
36
5
4
3
2
Syntax:  owned_objects(OBJ owner)  => LIST
2

2
Returns a list of all objects in the database owned by <owner>. Ownership is defined by the value of .owner on the object.
36
5
4
3
2
Syntax:  ancestors(OBJ <object> [, INT <full>])   => LIST
2

2
Return a list of all ancestors of <object> in order ascending up the inheritance hiearchy. If <full> is true, <object> will be included in the list.
36
5
4
3
2
Syntax:  descendants(OBJ <object> [, INT <full>])   => LIST
2

2
Return a list of all nested children of <object>. If <full> is true, <object> will be included in the list.
36
5
4
3
2
Syntax:  panic([STR <message>])
2

2
Unceremoniously shut down the server, mimicking the behavior of a fatal error. The database will NOT be dumped to the file specified when starting the server. A new file will be created with the name of your database appended with .PANIC.
36
5
4
21
2
Syntax:  thread_pool(STR <function>, STR <pool> [, INT <value>])
2

2
This function allows you to control any thread pools that the server created at startup. It should be used with care, as it has the potential to create disasterous consequences if used incorrectly.
2

2
The <function> parameter is the function you wish to perform on the thread pool. The functions available are:
2

2
   INIT: Control initialization of a thread pool.
2

2
   
2
The <pool> parameter controls which thread pool you wish to apply the designated function to. At the time of writing, the server creates the following thread pool:
2

2
   MAIN: The main thread pool where threaded built-in function work takes place.
2

2

2
Finally, <value> is the value you want to pass to the <function> of <pool>. The following functions accept the following values:
2

2
   INIT: The number of threads to spawn. NOTE: When executing this function, the existing <pool> will be destroyed and a new one created in its place.
2

2

2
Examples:
2
;thread_pool("INIT", "MAIN", 1)     => Replace the existing main thread pool with a new pool consisting of a single thread.
36
5
4
10
2
Syntax:  is_member (ANY value, LIST list, INT case-sensitive)   => INT
2

2
Returns the index of <value> if there is an element of <list> that is completely indistinguishable from <value>. This is much the same operation as "<value> in <list>" except that, unlike `in', the `is_member()' function does not treat upper- and lower-case characters in strings as equal. This treatment of strings can be controlled with the <case-sensitive> argument; setting <case-sensitive> to false will effectively disable this behavior.
2

2
Raises E_ARGS if two values are given or if more than three arguments are given. Raises E_TYPE if the second argument is not a list. Otherwise returns the index of <value> in <list>, or 0 if it's not in there.
2

2
  is_member(3, {3, 10, 11})                  => 1
2
  is_member("a", {"A", "B", "C"})            => 0
2
  is_member("XyZ", {"XYZ", "xyz", "XyZ"})    => 3
2
  is_member("def", {"ABC", "DEF", "GHI"}, 0) => 2
36
5
4
18
2
Syntax:  listen (OBJ <object>, INT <port> [, MAP <options>])   => value
2

2
Create a new point at which the server will listen for network connections, just as it does normally. <Object> is the object whose verbs `do_login_command', `do_command', `do_out_of_band_command', `user_connected', `user_created', `user_reconnected', `user_disconnected', and `user_client_disconnected' will be called at appropriate points as these verbs are called on #0 for normal connections. (See the chapter in the LambdaMOO Programmer's Manual on server assumptions about the database for the complete story on when these functions are called.) <Port> is a TCP port number on which to listen. The listen() function will return <port> unless <port> is zero, in which case the return value is a port number assigned by the operating system.
2

2
An optional third argument allows you to set various miscellaneous options for the listening point. These are:
2

2
  print-messages: If true, the various database-configurable messages (also detailed in the chapter on server assumptions) will be printed on connections received at the new listening port.
2
  ipv6:           Use the IPv6 protocol rather than IPv4.
2
  tls:            Only accept valid secure TLS connections.
2
  certificate:    The full path to a TLS certificate. NOTE: Requires the TLS option also be specified and true. This option is only necessary if the certificate differs from the one specified in options.h.
2
  key:            The full path to a TLS private key. NOTE: Requires the TLS option also be specified and true. This option is only necessary if the key differs from the one specified in options.h.
2

2
listen() raises E_PERM if the programmer is not a wizard, E_INVARG if <object> is invalid or there is already a listening point described by <point>, and E_QUOTA if some network-configuration-specific error occurred.
2

2

2
Example:
2
>;listen(#0, 1234, ["ipv6" -> 1, "tls" -> 1, "certificate" -> "/etc/certs/something.pem", "key" -> "/etc/certs/privkey.pem", "print-messages" -> 1]
2
Listen for IPv6 connections on port 1234 and print messages as appropriate. These connections must be TLS and will use the private key and certificate found in /etc/certs.
36
5
4
25
2
Syntax:  move (OBJ <what>, OBJ <where>[, INT <position>])   => none
2

2
Changes <what>'s location to be <where>.  This is a complex process because a number of permissions checks and notifications must be performed. The actual movement takes place as described in the following paragraphs.
2

2
<what> should be a valid object and <where> should be either a valid object or `#-1' (denoting a location of 'nowhere'); otherwise E_INVARG is raised.  The programmer must be either the owner of <what> or a wizard; otherwise, E_PERM is raised.
2

2
If <where> is a valid object and isn't the same as <what>'s location, then the verb-call
2

2
    <where>:accept(<what>)
2

2
is performed before any movement takes place.  If the verb returns a false value and the programmer is not a wizard, then <where> is considered to have refused entrance to <what>; `move()' raises E_NACC.  If <where> does not define an `accept' verb, then it is treated as if it defined one that always returned false.
2

2
If moving <what> into <where> would create a loop in the containment hierarchy (i.e., <what> would contain itself, even indirectly), then E_RECMOVE is raised instead.
2

2
The `location' property of <what> is changed to be <where>, and the `contents' properties of the old and new locations are modified appropriately.  If <position> is specified, the object will be inserted into the `contents' property of the new location at <position>.
2

2
If <where> differs from <what>'s current location, two additional verb calls take place.  Let <old-where> be the location of <what> before it was moved.  If <old-where> is a valid object, then the verb-call
2

2
    <old-where>:exitfunc(<what>)
2

2
is performed and its result is ignored; it is not an error if <old-where> does not define a verb named `exitfunc'.  Finally, if <where> and <what> are still valid objects, and <where> is still the location of <what>, then the verb-call
2

2
    <where>:enterfunc(<what>)
2

2
is performed and its result is ignored; again, it is not an error if <where> does not define a verb named `enterfunc'.
36
5
4
21
2
Syntax:  open_network_connection (STR <host>, INT <port> [, MAP <options>])   => obj
2

2
Establishes a network connection to the place specified by the arguments and more-or-less pretends that a new, normal player connection has been established from there.  The new connection, as usual, will not be logged in initially and will have a negative object number associated with it for use with `read()', `notify()', and `boot_player()'.  This object number is the value returned by this function.
2

2
If the programmer is not a wizard or if the `OUTBOUND_NETWORK' compilation option was not used in building the server, then `E_PERM' is raised.
2

2
<Host> refers to a string naming a host (possibly a numeric IP address) and <port> is an integer referring to a TCP port number.  If a connection cannot be made because the host does not exist, the port does not exist, the host is not reachable or refused the connection, `E_INVARG' is raised.  If the connection cannot be made for other reasons, including resource limitations, then `E_QUOTA' is raised.
2

2
Optionally, you can specify a map with any or all of the following options:
2

2
  listener: An object whose listening verbs will be called at appropriate points. (See HELP LISTEN() for more details.)
2
  tls:      If true, establish a secure TLS connection.
2
  ipv6:     If true, utilize the IPv6 protocol rather than the IPv4 protocol.
2

2
The outbound connection process involves certain steps that can take quite a long time, during which the server is not doing anything else, including responding to user commands and executing MOO tasks.  See the chapter on server assumptions about the database for details about how the server limits the amount of time it will wait for these steps to successfully complete.
2

2
It is worth mentioning one tricky point concerning the use of this function.  Since the server treats the new connection pretty much like any normal player connection, it will naturally try to parse any input from that connection as commands in the usual way.  To prevent this treatment, you should use `set_connection_option()' to set the `hold-input' option true on the connection.
2

2
Example:
2
>;open_network_connection("2607:5300:60:4be0::", 1234, ["ipv6" -> 1, "listener" -> #6, "tls" -> 1])
2
Open a new connection to the IPv6 address 2607:5300:60:4be0:: on port 1234 using TLS. Relevant verbs will be called on #6.
36
5
4
7
2
Syntax:  reverse(LIST <alist>) => LIST
2

2
Return a reversed list.
2

2
Examples:
2

2
;reverse({1,2,3,4}) => {4,3,2,1}
36
5
4
7
2
Syntax:	  sqlite_interrupt(INT <database handle>)
2

2
This function causes any pending database operation to abort at its earliest opportunity. If the operation is nearly finished when sqlite_interrupt is called, it might not have an opportunity to be interrupted and could continue to completion.
2

2
This can be useful when you execute a long-running query and want to abort it.
2

2
NOTE: As of this writing (server version 2.7.0) the @kill command WILL NOT abort operations taking place in a helper thread. If you want to interrupt an SQLite query, you must use sqlite_interrupt and NOT the @kill command.
36
5
4
19
2
Function: str string_hash (str string, [, algo])
2
Function: str binary_hash (str bin-string, [, algo])
2

2
string_hash -- Returns a 64-character hexadecimal string.
2
binary_hash -- Returns a 64-character hexadecimal string.
2

2
Returns a 64-character hexadecimal string encoding the result of applying the SHA256 cryptographically secure hash function to the contents of the string text or the binary string bin-string. If algo is provided, it specifies the hashing algorithm to use. "MD5", "SHA1" and "SHA256" are all supported.
2

2
Note that the MD5 hash algorithm is broken from a cryptographic standpoint, as is SHA1. Both are included for interoperability with existing applications (both are still popular).
2

2
All supported hash functions have the property that, if
2

2
string_hash(x) == string_hash(y)
2

2
then, almost certainly,
2

2
equal(x, y)
2

2
This can be useful, for example, in certain networking applications: after sending a large piece of text across a connection, also send the result of applying string_hash() to the text; if the destination site also applies string_hash() to the text and gets the same result, you can be quite confident that the large text has arrived unchanged.
36
5
4
2
2
*forward*
2
descendants
36
5
4
6
2
Function: INT file_count_lines (FHANDLER fh)
2

2
Count the lines in a file.
2

2

2

36
5
4
31
2
Function: LIST file_grep(FHANDLER fh, STR search [,?match_all = 0])
2

2
Search for a string in a file.
2

2
Assume we have a file `test.txt` with the contents:
2

2
asdf asdf 11
2
11
2
112
2

2
And we have an open file handler from running:
2

2
;file_open("test.txt", "r-tn")
2

2
If we were to execute a file grep:
2

2
;file_grep(1, "11")
2

2
We would get the first result:
2

2
{{"asdf asdf 11", 1}}
2

2
The resulting LIST is of the form {{STR match, INT line-number}}
2

2
If you pass in the optional third argument
2

2
;file_grep(1, "11", 1)
2

2
we will receive all the matching results:
2

2
{{"asdf asdf 11", 1}, {"11", 2}, {"112", 3}}
36
5
4
4
2
Function: LIST file_handles()
2

2
Return a list of open files.
2

36
5
4
12
2
Function: INT notify (OBJ conn, STR string [, INT no-flush [, INT suppress-newline]])
2

2
Enqueues <string> for output (on a line by itself) on the connection <conn>. If the programmer is not <conn> or a wizard, then E_PERM is raised. If <conn> is not a currently-active connection, then this function does nothing. Output is normally written to connections only between tasks, not during execution.
2

2
The server will not queue an arbitrary amount of output for a connection; the `MAX_QUEUED_OUTPUT' compilation option (in `options.h') controls the limit. When an attempt is made to enqueue output that would take the server over its limit, it first tries to write as much output as possible to the connection without having to wait for the other end. If that doesn't result in the new output being able to fit in the queue, the server starts throwing away the oldest lines in the queue until the new output will fit. The server remembers how many lines of output it has `flushed' in this way and, when next it can succeed in writing anything to the connection, it first writes a line like `>> Network buffer overflow; X lines of output to you have been lost <<' where <X> is the number of of flushed lines.
2

2
If <no-flush> is provided and true, then `notify()' never flushes any output from the queue; instead it immediately returns false. `Notify()' otherwise always returns true.
2

2
If no-flush is provided and true, then `notify()` never flushes any output from the queue; instead it immediately returns false. `Notify()` otherwise always returns true.
2

2

2

36
5
4
6
2
Function: LIST queue_info([obj user])
2
         MAP queue_info([obj user])
2

2
Returns the number of forked tasks that <user> has at the moment.  Since it doesn't say which tasks, security is not a significant issue.  If no argument is given, then gives a list of all users with task queues in the server.  (Essentially all connected players + all open connections + all users with tasks running in the background.)
2

2
If the caller is a wizard a map of debug information about task queues will be returned.
36
5
4
14
2
Syntax:  queued_tasks ([INT <show runtime> [, INT count-only])   => LIST
2

2
Returns information on each of the background tasks (i.e., forked, suspended, or reading)  owned by the programmer (or, if the programmer is a wizard, all queued tasks). The returned value is a list of lists, each of which encodes certain information about a particular queued task in the following format:
2

2
    {<task-id>, <start-time>, <ticks>, <clock-id>,
2
     <programmer>, <verb-loc>, <verb-name>, <line>, <this>, <task-size>}
2

2
where <task-id> is a numeric identifier for this queued task, <start-time> is the time after which this task will begin execution (in `time()' format), <ticks> is the number of ticks this task will have when it starts (always 20,000 now, though this is changeable. This makes this value obsolete and no longer interesting), <clock-id> is a number whose value is no longer interesting, <programmer> is the permissions with which this task will begin execution (and also the player who "owns" this task), <verb-loc> is the object on which the verb that forked this task was defined at the time, <verb-name> is that name of that verb, <line> is the number of the first line of the code in that verb that this task will execute, and <this> is the value of the variable `this' in that verb. For reading tasks, <start-time> is `-1'.  <task-size> is in bytes, and is the size of memory in use by the task for local variables, stack frames, etc.
2

2
If <show runtime> is true, all variables present in the task are presented in a map with the variable name as the key and its value as the value.     
2

2
If `count-only` is true, then only the number of tasks is returned. This is significantly more performant than length(queued_tasks()). 
2

2
The <ticks> and <clock-id> fields are now obsolete and are retained only for backward-compatibility reasons.  They may disappear in a future version of the server.
36
5
4
11
2
Function: int random ([INT mod [,INT range]])
2

2
random -- Return a random integer 
2

2
mod must be a positive integer; otherwise, E_INVARG is raised. If mod is not provided, it defaults to the largest MOO integer, which will depend on if you are running 32 or 64bit.
2

2
if range is provided then an integer in the range of mod to range (inclusive) is returned.
2

2
random(10)                  => integer between 1-10
2
random()                    => integer between 1 and maximum integer supported
2
random(1, 5000)             => integer between 1 and 5000
36
5
4
2
2
*forward*
2
binary_hash()
36
5
4
7
2
Function: task_stack (INT task-id [, INT include-line-numbers [, INT include-variables])  => LIST
2

2
Returns information like that returned by the `callers()' function, but for the suspended task with the given <task-id>; the <include-line-numbers> argument has the same meaning as in `callers()'. Raises E_INVARG if <task-id> does not specify an existing suspended task and E_PERM if the programmer is neither a wizard nor the owner of the specified task.
2

2
If include-line-numbers is passed and true, line numbers will be included.
2

2
If include-variables is passed and true, variables will be included with each frame of the provided task.
36
5
4
5
2
Function: str value_hash(value, [,STR algo])
2

2
Returns the same string as string_hash(toliteral(value)). 
2

2
See the description of string_hash() for details.
36
5
5
36
5
4
1
2
toaststunt-index
36
1
0
0
36
4
4
1
2
ToastStunt Help Database
36
5
2
A help database of the standard form in need of a description. See `help $generic_help'...
36
5
4
2
0
103117
0
1641541193
36
1
#87
password verifier
16
2
1
-1
0
0
4
0
1
5
4
0
13
help_msg
36
173
-1
reject_password
2
173
-1
trivial_check
36
173
-1
check_length
36
173
-1
check_name
36
173
-1
check_email
2
173
-1
check_hosts
2
173
-1
check_dictionary
36
173
-1
check_for_funky_characters
36
173
-1
check_against_moo
36
173
-1
_is_funky_case
36
173
-1
check_obscure_combinations
36
173
-1
init_for_core
2
173
-1
9
minimum_password_length
check_against_name
check_against_email
check_against_hosts
check_against_dictionary
require_funky_characters
help_msg
check_against_moo
check_obscure_stuff
21
0
0
2
1
0
0
2
1
0
0
2
1
0
0
2
1
0
0
2
1
0
0
2
1
4
8
2
Password Verifier
2
==================
2

2
To check for the validity of a password, use
2
  :reject_password( password [, for-whom? ] )
2
... If it returns a true value, that value will contain the string representing the reason why the password was rejected.  If it returns a false value, the password is OK.
2

2
The toggle switches for this checking are:
36
1
0
0
2
1
0
0
2
1
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
0
0
2
4
4
4
2
password verifier
2
password
2
verifier
2
pwd
2
5
2
The password verifier verifies passwords.
2
5
4
2
0
15188
0
1648488120
36
1
#88
Frand's player class
144
36
1
-1
0
0
4
0
1
40
4
2
1
31
1
4
77
@rooms
36
13
-1
@go
36
29
-1
lookup_room
36
173
-1
teleport
2
173
-1
teleport_messages
36
173
-1
@move
36
93
-2
index_room
36
173
-1
@addr*oom
36
29
-1
@rmr*oom
36
29
-1
@join
36
29
-1
@find
36
29
-1
find_verb
36
173
-1
@ways
36
29
-1
findexits
36
173
-1
checkexits
36
173
-1
self_port_msg player_port_msg thing_port_msg join_msg
36
173
-1
oself_port_msg self_arrive_msg oplayer_port_msg player_arrive_msg victim_port_msg othing_port_msg thing_arrive_msg object_port_msg
36
173
-1
msg_sub
36
173
-1
obvious_exits
36
173
-1
tell_ways
36
173
-1
tell_obj
36
173
-1
parse_out_object
36
173
-1
enlist
36
173
-1
@spellm*essages @spellp*roperties
2
89
-2
@at
36
93
-2
at_players
36
173
-1
do_at_all
36
173
-1
do_at
36
173
-1
print_at_items
36
173
-1
at_item
36
173
-1
internal_at
36
173
-1
confunc
2
173
-1
disfunc
2
173
-1
@addword
2
89
-2
@spell @cspell
2
89
-2
@rmword
2
89
-2
find_property
36
173
-1
find_verbs_on
36
173
-1
find_properties_on
36
173
-1
property_inherited_from
36
173
-1
@ref*use
36
89
-2
@unref*use @allow
36
89
-2
@refusals
36
73
-2
@refusal-r*eporting
36
89
-2
parse_refuse_arguments
36
173
-1
time_word_to_seconds
36
173
-1
parse_time_length
36
173
-1
parse_time
36
173
-1
clear_refusals
36
173
-1
set_default_refusal_time
36
173
-1
refusable_actions
36
173
-1
translate_refusal_synonym
36
173
-1
default_refusals_text_filter
36
173
-1
refusals_text
36
173
-1
player_to_refusal_origin
2
173
-1
refusal_origin_to_name
36
173
-1
check_refusal_actions
36
173
-1
add_refusal
36
173
-1
remove_refusal
36
173
-1
remove_expired_refusals
36
173
-1
refuses_action
36
173
-1
refuses_action_*
36
173
-1
report_refusal
36
173
-1
wh*isper
36
157
1
receive_page
36
173
-1
page_echo_msg
36
173
-1
moveto acceptable
36
173
-1
receive_message
36
173
-1
whisper_refused_msg page_refused_msg mail_refused_msg
36
173
-1
last_huh
2
173
-1
ping_features
2
173
-1
set_owned_objects
2
173
-1
init_for_core
2
173
-1
find_help
36
173
-1
@spurn
36
25
-1
@spurned
36
9
-1
set_spurned_objects
36
173
-1
26
at_room_width
at_number
join_msg
object_port_msg
victim_port_msg
thing_arrive_msg
othing_port_msg
thing_port_msg
player_arrive_msg
oplayer_port_msg
player_port_msg
self_arrive_msg
oself_port_msg
self_port_msg
rooms
refused_origins
refused_extra
default_refusal_time
report_refusal
refused_actions
refused_until
page_refused
page_refused_msg
whisper_refused_msg
mail_refused_msg
spurned_objects
90
0
30
36
5
0
0
36
5
2
You join %n.
36
5
2
teleports you.
36
5
2
teleports you.
36
5
2
%T teleports %n in.
36
5
2
%T teleports %n out.
36
5
2
You teleport %n.
36
5
2
%T teleports %n in.
36
5
2
%T teleports %n out.
36
5
2
You teleport %n.
36
5
2
%<teleports> in.
36
5
2
%<teleports> out.
36
5
2

36
5
4
0
36
1
4
0
36
1
4
0
36
1
0
604800
36
1
0
0
36
1
4
0
36
1
4
0
36
1
0
0
36
1
2
%N refuses your page.
36
5
2
%N refuses your whisper.
36
5
2
%N refuses your mail.
36
5
4
0
36
1
5
36
5
5
36
4
5
36
5
5
36
5
5
36
5
4
0
36
5
5
36
5
5
36
5
5
36
4
5
36
4
5
98
1
5
98
1
5
98
1
4
2
1
90
1
89
36
1
5
2
0
5
2
0
5
2
1
1
92
36
5
5
36
5
5
36
1
5
36
1
5
36
0
5
36
1
5
2
1
5
36
1
5
36
4
5
2
0
5
2
0
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
2
1
5
36
0
1
62
36
5
5
2
0
5
36
5
5
36
5
5
36
5
5
2
1
4
4
0
50000
0
0
0
0
0
1
36
0
5
2
0
5
2
0
5
2
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
4
4
2
2
Frand's player class
2
player class
2
1
2
You see a player who should type '@describe me as ...'.
36
5
4
2
0
94403
0
1641541193
36
1
#89
Stage-Talk Feature
144
36
1
-1
0
0
4
0
1
74
4
0
5
stage `* -*
36
93
-2
stage [*
36
93
-2
stage ]*
36
93
-2
~*
36
93
-2
stage <*
36
93
-2
0
16
5
36
1
4
1
2
This feature contains various verbs used in stage talk, which allows players to describe their actions in terms of stage directions instead of prose.
36
5
4
5
2
`
2
[
2
]
2
-
2
<
36
1
5
36
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
4
4
1
2
Stage-Talk Feature
36
5
4
1
2
This feature contains various verbs used in stage talk, which allows players to describe their actions in terms of stage directions instead of prose.
36
5
4
2
0
6159
0
1641541193
36
1
#90
Pasting Feature
144
36
1
-1
0
0
4
0
1
74
4
0
3
@paste
36
85
-2
|*
36
93
-2
@pasteto @paste-to
36
29
-1
0
16
5
36
1
2
The Pasting Feature is mostly useful to people with fancy clients (such as Emacs) or who connect using a windowing system that allows them to copy text they've already seen.  It's intended to give people a way to quote verbatim text at other people in the room.
36
5
4
3
2
@paste
2
|
2
@paste-to
36
1
5
36
1
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
5
5
36
4
4
1
2
Pasting Feature
36
5
2
Verbs useful to people using a windowing system to paste text at people.
36
5
4
2
0
5854
0
1641541193
36
1
#91
Vector and Matrix Utils
16
36
1
-1
0
0
4
0
1
78
4
0
28
vector_add vector_sub vector_mul vector_div
36
173
-1
matrix_add matrix_sub
36
173
-1
transpose
36
173
-1
determinant
36
173
-1
inverse
36
173
-1
identity
36
173
-1
null
36
173
-1
is_square
36
173
-1
is_null
36
173
-1
is_identity
36
173
-1
cross_prod outer_prod vector_prod
36
173
-1
norm length
36
173
-1
submatrix
36
173
-1
dot_prod inner_prod scalar_prod
36
173
-1
dimension*s
36
173
-1
order
36
173
-1
scalar_vector_add scalar_vector_sub scalar_vector_mul scalar_vector_div
36
173
-1
subtended_angle
36
173
-1
column
36
173
-1
matrix_mul
36
173
-1
scalar_matrix_mul scalar_matrix_div
36
173
-1
is_matrix
36
173
-1
is_vector
36
173
-1
is_reflexive is_areflexive
36
173
-1
is_symmetric is_asymmetric
36
173
-1
is_transitive is_atransitive
36
173
-1
_relation_result
36
173
-1
is_partial_ordering
36
173
-1
1
note
6
2
Please contact Uther@LambdaMOO if you make changes to this object, so he can make the changes on Lambda and elsewhere.
36
5
4
62
2
Utility verbs for manipulating lists as vectors (one dimensional lists) or as matrices (two dimensional lists).
2

2
Some definitions:
2
A VECTOR is a list of INTs or a list of FLOATs. Each element in the list represents the vector's cartesian coordinate as measured from its tail to its tip. (For instance, {3, 4} represents a vector in the x-y plane with an x component of 3 and a y component of 4. {-2, 5, 10} represents a vector in 3-space with a x component of -2, a y component of 5 and a z component of 10.)
2
A MATRIX is a list of VECTORs, all of which have the same number (and type) of components.
2

2
Vector verbs:
2
:vector_add        (V1 [,V2 ...]) => VN such that VN[n] = V1[n] + V2[n]...
2
:vector_sub        (V1 [,V2 ...]) => VN such that VN[n] = V1[n] - V2[n]...
2
:scalar_vector_mul (V, S)         => VN such that VN[n] = V[n] * S...
2
:scalar_vector_div (V, S)         => VN such that VN[n] = V[n] / S...
2
:dot_prod          (V1, V2)       => NUM sum of the products of the 
2
:inner_prod                          corresponding elements of the two
2
                                     vectors.
2
:cross_prod        (V1, V2)       => VN, the vector perpendicular to both V1
2
:outer_prod                          and V2 with length equal to the area of
2
                                     the parallelogram spanned by V1 and V2.
2
:subtended_angle   (V1, V2)       => FLOAT smallest radian angle defined by
2
                                     V1 and V2.
2
:length            (V)            => FLOAT length of the vector. 
2
:norm
2

2
Matrix and Vector verbs:
2
:dimensions (M) => LIST of dimensional sizes
2
:order      (M) => NUM of dimensions
2

2
Matrix verbs:
2
:matrix_add (M1 [,M2 ...]) => MN such that MN[m][n] = M1[m][n] + M2[m][n]...
2
:matrix_sub (M1 [,M2 ...]) => MN such that MN[m][n] = M1[m][n] - M2[m][n]...
2
:matrix_mul (M1, M2)       => MN such than MN[m][n] = the dot product of the  
2
                              mth row of M1 and the nth column of M2.
2
:scalar_matrix_mul (M, S)  => MN such that MN[m][n] = M[m][n] * S...
2
:scalar_matrix_div (M, S)  => MN such that MN[m][n] = M[m][n] / S...
2
:transpose  (M1)           => M2 such that the rows in M1 are the columns in
2
                              M2 and vice versa.
2
:identity   (INT <size>)   => Identity matrix (I) of dimensions <size> by 
2
                              <size>.
2
:null       (INT <size>)   => Null matrix (O) of dimensions <size> by <size>.
2
:is_square  (M)            => 1 iff dimensions of M are equal.
2
:column     (M, INT <n>)   => LIST the nth column of M.
2

2
Square Matrix verbs:
2
:determinant (M) => NUM the determinant of the square matrix.
2
:inverse     (M) => the matrix that M multiplied by :inverse(M) yields I.
2
:is_identity (M) => 1 iff M is I.
2
:is_null     (M) => 1 iff M is O.
2

2
Relation verbs:
2
:is_reflexive   (M) => 1 if M is a reflexive relation, -1 if areflexive,
2
                       0 otherwise.
2
:is_areflexive  (M) => 1 if M is an areflexive relation, -1 if reflexive,
2
                       0 otherwise.
2
:is_symmetric   (M) => 1 if M is a symmetric relation, -1 if asymmetric,
2
                       0 otherwise.
2
:is_asymmetric  (M) => 1 if M is an asymmetric relation, -1 if symmetric,
2
                       0 otherwise.
2
:is_transitive  (M) => 1 if M is a transitive relation, -1 if atransitive,
2
                       0 otherwise.
2
:is_atransitive (M) => 1 if M is an atransitive relation, -1 if transitive,
2
                       0 otherwise.
2
:is_partial_ordering (M) => 1 if M is a reflexive, asymmetric, transitive
2
                            relation.
36
5
0
0
36
4
4
3
2
Vector and Matrix Utils
2
vector
2
matrix
36
5
2
This is a utilities package for dealing with lists as representations of vectors and matrices. Type `help $matrix_utils' for more details.
36
5
4
2
0
39396
0
1641541193
36
1
#92
Frand Help DB
16
36
1
-1
0
0
4
0
1
30
4
0
0
28
frand-index
spelling
@spell
@cspell
@spellproperties
@spellmessages
@rmword
@addword
@find
@rooms
@addroom
@rmroom
@join
@go
@move
teleport-messages
@refuse
@unrefuse
@refusal-reporting
@refusals
refusal-programming
@ways
@at
@spurn
@spurned
@submitted
@addsubmitted
@rmsubmitted
34
4
2
2
*index*
2
Frand's Player Class Help Topics
36
5
4
14
2
The MOO has a built in spelling checker.  There are several player commands which access the database, as well as some programming features available.  Additional documentation is available under individual commands.
2

2
The spelling checker is backed by the Aspell interface.  Additionally, players have a personal dictionary that can be used to augment the main dictionary.
2

2
@spell a word or phrase - Spell check a word or phrase.
2
@spell thing.prop - Spell check a property. The value must be a string or a list of strings.
2
@spell thing:verb - Spell check a verb. Only the quoted strings in the verb are checked.
2
@spellproperties object - Spell check all text properties of an object.
2
@spellmessages object - Spell check only message properties of an object.
2
@cspell word - Spell check a word, and if it is not in the dictionary, offers suggestions about what the right spelling might be. This actually works with thing.prop and thing:verb too, but it is too slow to be useful--it takes maybe 30 seconds per unknown word.
2
@addword word - Add a word to your personal dictionary.
2
@rmword word - Remove a word from your personal dictionary.
2

2
Questions and comments should be directed to waffle on LambdaMOO.
36
5
4
11
2
Syntax: @spell <any number of words>
2
           - will check the words from the command line.
2
        @spell object.property
2
           - will spellcheck the contents of a prop. Must be a string or
2
             list of strings.
2
        @spell object:verb
2
           - will check everything within quoted strings in a verb. E.g.,
2
             only the quoted part of player:tell("Spellchecking is fun.");
2
             will be examined for errors.
2

2
Refer to Help Spelling for general information about the spell checker.
36
5
4
7
2
Syntax: @cspell <any number of words>
2
        @cspell object.property
2
        @cspell object:verb
2

2
Like @spell, but attempts to guess at correct spellings for words it believes are spelled incorrectly.   This verb can be quite slow, so correcting large chunks of text may not be a good idea.
2

2
Refer to help spelling and help @spell for more information.
36
5
4
2
2
*forward*
2
@spellmessages
36
5
4
5
2
Syntax: @spellproperties <object>
2
        @spellmessages <object>
2
These commands will spellcheck all properties or messages, respectively, on an object.  The object must be owned or readable by the user.  Messages and properties will be spellchecked if they contain a string or a list of strings; others will be ignored.
2

2
Refer to help spelling for general information about the spellchecker.
36
5
4
3
2
Usage: @rmword <word or words>
2

2
Will remove all words found from your personal dictionary, stored in player property ".dict".
36
5
4
6
2
Syntax: @addword <word or words>
2
        @addword object.property
2
        @addword object:verb
2

2
Will add all words found and unknown into your personal dictionary.
2
Your dictionary is stored in a property named ".dict".
36
5
4
7
2
  @find #<object>   - locate an object by number
2
  @find <player>    - locate a player
2
  @find :<verb>     - locate a verb on an object in your vicinity
2
  @find .<property> - locate a property on objects in your vicinity.
2
  @find ?<topic>    - locate a help topic on a help database.
2

2
For example, '@find frand' shows Frand's number and location. '@find :jump' lists every object in the same room as you (including you and the room itself) which has a 'jump' verb.  For properties and verbs, output is a list of pairs of objects: each object on which the property or verb exists, and the ancestor that actually defines it.
36
5
4
7
2
When you aren't in the same room with an object, you have to refer to it by number. When teleporting, that means you usually have to give your destination as a number. To avoid this, Frand's player class provides a way for you to store a database of rooms by name. If the library is in your list of rooms, you can just '@go library' to teleport there. Or '@move book to lib' to teleport an object there.
2

2
  @rooms                     - see a list of the rooms you know by name
2
  @addr*oom <name> <number>  - remember a room by name
2
  @rmr*oom  <name>           - forget about a room's name
2

2
For example, to add the kitchen to your database of rooms, type '@addr Kitchen #24'. To remove it, type '@rmr kitchen'.
36
5
4
2
2
*forward*
2
@rooms
36
5
4
2
2
*forward*
2
@rooms
36
5
4
2
2
*forward*
2
@move
36
5
4
2
2
*forward*
2
@move
36
5
4
10
2
  @move <obj> to <location>  - teleport an object to a given location
2
  @go <location>             - teleport yourself to a given location
2
  @join <player>             - teleport yourself to a player's location
2

2
You can teleport an object (if it allows this) to any location that will accept it. For example, `@move rock to #11' will teleport the rock to the closet. `@move #123 to here' will move object #123 to your location. `@go home' will teleport you home. `@join yduj' will teleport you to yduJ's location. You can also teleport an object to #-1, which is nowhere.
2

2
See help teleport-messages for information on customizing the text that appears
2
(both to you and to others in the vicinity) when you teleport.
2
See also help @rooms for information on naming rooms for convenient movement.
2
If @move doesn't work and you own the place where the object is located, try using @eject instead.
36
5
4
16
2
Teleporting using @go, @move, or @join causes various messages to appear. The messages are defined on you as properties. Here are the messages, who sees them, and when.
2

2
 when you teleport -  yourself      a player        a thing
2

2
           you see -  self_port     player_port     thing_port
2
        others see -  oself_port    oplayer_port    othing_port
2
  destination sees -  self_arrive   player_arrive   thing_arrive
2
   teleportee sees -                victim_port     object_port
2

2
When you @join a player, your join message is printed to you.
2

2
You can set the messages with commands like '@oself_port me is "vanishes in a shimmering haze."', '@join me is "You visit %n."', and so on.
2

2
The messages to you are printed as they stand. The messages to others are printed after your name. If you set a message to "", the null string, nothing will print for that message. But if you have a non-empty message which does not include your name, then your name will be added in front of the message. You can use the usual pronoun substitutions, like '%n' to refer to the object you are teleporting. You can also use the special substitutions %<from room> and %<to room> to refer to the original and destination rooms for the teleport.
2

2
If you are leaving your name out of the messages, and relying on its being inserted automatically, you have to be careful about the substitutions you use. If Frand has an oself_port message "jumps to %<to room>.", for example, and Frand teleports to Frand's MOOhome, the message printed will be "jumps to Frand's MOOhome." My name is there, so it isn't added in. If you want to include your name as a substitution, the one to use is %t, 'this'. "%t jumps to %<to room>." will work.
36
5
4
63
2

2
The refusal facility allows you to ignore specific actions by players. You can ignore all mail that Stupid_Jerk (#34567) sends you, for
2
example, or you can ignore all whispers and pages, no matter who they are from.
2

2
There are three basic refusal commands. They are explained below.
2

2
    @refuse <action> from <player>
2
    @unrefuse <action> from <player>
2
    @refusals
2

2
The actions you can refuse are page, whisper, mail, move, join, and accept. These are explained in a table farther down.
2

2
For example, '@refuse mail from Stupid_Jerk'. Any future mail that Stupid_Jerk sends you will be dropped on the floor, and Stupid_Jerk will
2
be told that you refused to receive it. The refusal stays active for a week; after the week is over, Stupid_Jerk's mail will again get
2
through. (If you want the refusal to last a longer or shorter time, keep on reading.)
2

2
You can refuse more than one action at a time. '@refuse page whisper from Stupid_Jerk' refuses both pages and whispers.
2

2
You can also refuse actions from everybody.
2

2
    @refuse <actions>
2

2
For example, '@refuse page' refuses every page. These refusals are listed as refusals of 'everybody' when you use the @refusals command,
2
below.
2

2
See `help @unrefuse' and `help @refusal-reporting' for information on undoing refusals and finding out what you're refusing.
2

2
 - the actions
2

2
The actions everybody can refuse are page, whisper, mail, move, and join.
2
refuse other things as well, depending on your player class.
2

2
 refuse this      to prevent somebody from doing this
2
 -----------      -----------------------------------
2
    page        - tell you a message with the 'page' command
2
    whisper     - tell you a message with the 'whisper' or 'murmur' command
2
    mail        - send you a MOOmail message via @send
2
    move        - teleport you
2
    join        - enter the same room as you (only works in a some rooms)
2
    accept      - hand you an object (or teleport it to you)
2
    flames      - posts are suppressed on mail lists
2
    politics    - set yourself `apolitical' [see `help apolitical']
2
    all         - all of the above
2

2
Refusing move is a little tricky. The player will not be able to teleport you, but you will not be able to pass through any special exits
2
that the player may have programmed either. Refusing move means refusing *all* movement, including movement through programmed exits.
2
Fortunately most exits are plain exits, and you will always be able to pass through them. Only specially programmed exits by the player you
2
are refusing move from are barred to you.
2

2
Refusing join only works in special rooms that support it.
2

2
 - time limits
2

2
Refusals expire after a certain amount of time has gone by. Unless you say otherwise, they expire after a week. You can add '... for
2
<time>' to the end of a @refuse command:
2

2
    @refuse <action> from <player> for <time>
2
    @refuse <action> for <time>
2

2
For example, '@refuse join from Stupid_Jerk for 3 days'.
2

2
The <time> is always a number followed by a unit, like '10 weeks' or '45 seconds'. The possible units are second, minute, hour, day, week,
2
and month.
36
5
4
15
2
Syntax:
2
    @unrefuse <actions> from <player>
2

2
If Stupid_Jerk reforms, you can change your mind. '@unrefuse mail from Stupid_Jerk' will remove the refusal.
2

2
'@unrefuse' can also be called '@allow', for those who prefer English over clarity.
2

2
    @unrefuse <actions>
2

2
If you don't mention a player, you remove only refusals that apply to everybody. '@unrefuse page' turns off any '@refuse page' command you
2
gave before, but does not affect refusals of specific players. You will still be refusing pages from Stupid_Jerk, if you were before.
2

2
    @unrefuse everything
2

2
 If you '@unrefuse everything', all your refusals are removed. This command asks if you are sure before erasing them all.
36
5
4
26
2
[See help @refuse for a discussion of the refusal facility]
2

2
    @refusals
2
    @refusals for <player>
2

2
List the players and actions you are refusing, or the players and actions that another player is refusing. For example, you can see if
2
Stupid_Jerk is refusing your mail too: '@refusals for Stupid_Jerk'.
2

2
Normally refusal works without your awareness. You don't even notice when Stupid_Jerk attempts to send you mail. If you would rather be
2
notified when it happens (so you can thumb your nose), then do
2

2
    @refusal-reporting on
2

2
Actually, all you need to type is '@refusal-r on'. You will see a message like 'Mail from Stupid_Jerk (#34567) refused.' as soon as
2
Stupid_Jerk types 'send' in the mail editor.
2

2
Refusal reporting only works for some actions. It works for page, whisper, and mail, but not for move, join or accept. Sorry.
2

2
You will only be notified if you are connected when the refusal happens. If you are not connected when Stupid_Jerk tries to send you mail,
2
you won't know about it, no matter whether refusal reporting is on or off.
2

2
You can turn off refusal reporting with '@refusal-r off'. You can check whether it is on or off with '@refusal-r'. Here's the list:
2

2
    @refusal-reporting on     - turn on refusal reporting
2
    @refusal-reporting off    - turn off refusal reporting
2
    @refusal-reporting        - see whether it is on or off
36
5
4
2
2
*forward*
2
@refusal-reporting
36
5
4
123
2

2
  -- -- --  refusal programming
2

2
This entry explains how to program new kinds of refusal for the refusal mechanism. This information is only useful for programmers. For basic information about the refusal mechanism, read the 'refusal' entry.
2

2
 - making a new refusable action
2

2
Making a refusable action has several steps. You have to (1) override the verb that lists your refusable actions, (2) write a verb to handle any special cases in determining when an action should be refused, and (3) write the code that does the actual acceptance or refusal of the action.
2

2
You can put new refusable actions on yourself, or on a player class. If you put them on yourself, then you are the only one who can use them. If you put them on a player class, then everyone who belongs to that class can use them.
2

2
I'll walk you through the example of making a refusable action 'smirk'. If you '@refuse smirk from Munchkin' then anything Munchkin tells you with the word 'smirk' in it will be refused. Since this is useless, I'll assume that you're defining it on yourself, instead of on a player class.
2

2
(1) You have to make 'smirk' a refusable action. You do that by overriding your :refusable_actions verb. :Refusable_actions is a verb which returns the actions that you know how to refuse. It is a verb instead of a property so that players can add refusable actions at all levels of the player class hierarchy without interfering with each other.
2

2
    @verb me:refusable_actions this none this
2
    @program me:refusable_actions
2
      return {@pass(@args), "smirk"};
2
    .
2

2
'@pass (@args)' means 'include the actions that my parent knows how to refuse, because I know how to refuse them too.'
2

2
(2) The refusal mechanism provides for special cases in deciding whether an action should be refused. None of the refusals defined on Frand's Player Class actually make use of this special case, and you probably won't have to use it either. But you still have to write a verb to deal with it.
2

2
The verb should be named :refuses_action_<action>, where <action> is the action that the verb is for. In this case, it should be :refuses_action_smirk. The verb takes some arguments and returns whether the action should be refused. The details of this will someday be explained in the next section, 'fancy refusable actions', but in all simple cases the verb should simply return 1.
2

2
    @verb me:refuses_action_smirk this none this
2
    @program me:refuses_action_smirk
2
      return 1;
2
    .
2

2
(3) Finally you must implement the refusal itself. The code that performs the action should call <target>:refuses_action (player, <action>). <target> is the target of the action; it is you, because others are smirking at you. 'Player' is the current player, the one who is attempting to perform the action. <action> is the action the player is attempting, 'smirk'.
2

2
In this case, you want to change your :tell verb to check whether its message contains the word 'smirk', and whether you are refusing smirks from the player who's talking. It also has to do two other things: (1) inform the player whose smirk was refused, and (2) call this:report_refusal, which tests whether you have refusal reporting turned on, and if so, reports the refusal to you. The call is this:report_refusal (<player>, <message>).
2

2
    @verb me:tell this none this
2
    @program me:tell
2
      line = tostr (@args);
2
      if (index (line, "smirk") &&
2
          this:refuses_action (player, "smirk"))
2
        player:tell (this.name, " refuses your s m i r k.");
2
        this:report_refusal (player, "You refused a s m i r k.");
2
      else
2
        pass (@args);
2
      endif
2
    .
2

2
The messages say 's m i r k' instead of 'smirk' to prevent an infinite :tell loop.
2

2
It may help to study some examples. To see how whisper refusal works, read #3133:whisper. For page refusal, see #3133:receive_page and #3133:page_echo_msg. For mail refusal, #3133:receive_message. For move and accept refusal, #3133:moveto or #3133:accept (they are the same verb).
2

2
 - refusal data structures
2

2
Refusal information is stored in four main properties, all lists.
2

2
    .refused_origins    - who you are refusing actions from
2
    .refused_actions    - for each, what actions you're refusing
2
    .refused_until      - when the refusals expire
2
    .refused_extra      - any further information about each refused action
2

2
These properties are all readable and owned by Frand. You (or anyone) can see their values, but you can only change them by calling verbs for the purpose. The verbs are explained later on.
2

2
Your .refused_origins property remembers who you are refusing actions from. It might have the value {#47, #34567} if you are refusing actions from Frand (#47) and Stupid_Jerk (#34567). If you are refusing actions by guests, it will have entries like "xxP1Xw.nkQzft". This weird string is a code word that stands for the guest's connection site; you are refusing actions not by a certain guest character, but by any guest who may connect from that site. The verb :player_to_refusal_origin (<player>) converts a player object to a refusal origin (either the same player object or a guest's site code) suitable to be stored in .refused_origins.
2

2
Your .refused_actions property stores, for each origin in .refused_origins, a list of the actions you are refusing for that origin. Continuing the example from the last paragraph, if you are refusing page from Frand and page, whisper, and mail from Stupid_Jerk, then your .refused_actions has the value {{"page"}, {"page", "whisper", "mail"}}.
2

2
Your .refused_until stores an expiration time for each refusal origin, in the form used by time(), the number of seconds since midnight, 1 January 1970, GMT. All actions that you are refusing from a given player expire at the same time. If you are refusing Frand until 19 December 1992, and Stupid_Jerk for seven years, your .refused_until might have the value {724763397, 928384392}.
2

2
Your .refused_extra property stores any additional information needed for fancy refusals. It stores one piece of information for every action you are refusing from every player. In other words, .refused_extra contains a list of lists which are parallel to the lists in .refused_actions. None of the built-in refusals on #3133 is fancy, so for them, the extra piece of information is always 0. In the example, your .refused_extra has the value {{0}, {0, 0, 0}}. The next section explains how to use .refused_extra in fancy refusals.
2

2
Another property, .default_refusal_time, stores the duration in seconds that a refusal lasts by default. This property is readable and owned by Frand. Its value is usually 604800, seven days. You can set it via the verb :set_default_refusal_time.
2

2
 - fancy refusable actions
2

2
THIS SECTION IS NOT YET WRITTEN
2

2
 - selective refusal reporting
2

2
If you have done '@refusal-reporting on', then you see a message when you refuse somebody else's action (for some actions). This reporting is done by the verb :report_refusal.
2

2
    :report_refusal (<player>, <message>, ...)
2

2
The first argument is the player whose action is refused, and the rest are concatenated to form the message that you see.
2

2
You can override this verb if you want more selective refusal reporting. If you're refusing pages, for example, you might find that the refusal report is just as annoying as the original page--but you still don't want to turn it off. In that case, you might decide to give no more than one refusal report per minute, using code like this:
2

2
    @property me.refusal_time 0
2
    @property me.refusal_count 0
2
    @verb me:report_refusal this none this
2
    @program me:report_refusal
2
      if (time() - this.refusal_time < 60)
2
        this.refusal_count = this.refusal_count + 1;
2
      else
2
        if (this.refusal_count > 0)
2
           pass (args [1], "You've refused ", this.refusal_count+1,
2
                 " actions recently.");
2
        else
2
          pass (@args);
2
        endif
2
        this.refusal_time = time();
2
        this.refusal_count = 0;
2
      endif
2
    .
2

2
The property that remembers whether refusal reporting is turned on is .report_refusal, which may have the values 0 or 1. The property is owned by Frand, so you can't change it directly.
2

2
 - refusal synonyms
2

2
You can give a refusal more than one name by overriding the verb :translate_refusal_synonym. The verb takes one argument, a word from the command line, and it returns a list of refusal names that the word stands for. If the word is not a synonym, :translate_refusal_synonym should return the empty list, {}.
2

2
    :translate_refusal_synonym (<word>) -> <list>
2

2
If you want 'noise' to mean both page and whisper for you, then you'd write this. You need to pass(@args) to get the synonym 'all', which stands for all refusable actions. If you type '@refuse noises from Munchkin', the plural 's' is removed automatically, so you don't have to worry about that.
2

2
    @verb me:translate_refusal_synonym this none this
2
    @program me:translate_refusal_synonym
2
      return pass(@args) ||
2
             (args [1] == "noise") ? {"page", "whisper"} | {};
2
    .
2

2
 - refusing actions by classes of players
2

2
THIS SECTION IS NOT YET WRITTEN
36
5
4
1
2
'@ways', '@ways <room>' - List any obvious exits from the given room (or this room, if none is given).
36
5
4
8
2
 '@at' - Find out where everyone is.
2
 '@at <player>' - Find out where <player> is, and who else is there.
2
 '@at <obj>' - Find out who else is at the same place as <obj>.
2
 '@at <place>' - Find out who is at the place.
2
 The place can be given by number, or it can be a name from your @rooms list.
2
 '@at #-1' - Find out who is at #-1.
2
 '@at me' - Find out who is in the room with you.
2
 '@at home' - Find out who is at your home.
36
5
4
3
2
*verbdoc*
2
$frand_class
2
@spurn
2
1
4
3
2
*verbdoc*
2
$frand_class
2
@spurned
2
1
4
3
2
*verbdoc*
2
$frand_class
2
@submitted
2
1
4
2
2
*forward*
2
@submitted
2
1
4
2
2
*forward*
2
@submitted
2
1
5
36
5
4
1
2
frand-index
36
1
0
0
36
4
4
1
2
Frand Help DB
36
5
5
36
5
4
2
0
30023
0
1641541193
36
1
#93
Conversion Utils
16
36
1
-1
0
0
4
0
1
78
4
0
15
dd_to_dms dh_to_hms
36
173
-1
dms_to_dd hms_to_dh
36
173
-1
rect_to_polar
36
173
-1
polar_to_rect
36
173
-1
F_to_C degF_to_degC
36
173
-1
C_to_F degC_to_degF
36
173
-1
convert
36
173
-1
_do_convert
36
173
-1
_try_metric_prefix
36
173
-1
_format_units
36
173
-1
K_to_C degK_to_degC
36
173
-1
C_to_K degC_to_degK
36
173
-1
F_to_R degF_to_degR
36
173
-1
R_to_F degR_to_degF
36
173
-1
_do_value
36
173
-1
385
basic_units
pi
c
g
au
mole
e
abcoulomb
force
slug
mercury
hg
torr
%
percent
cg
atmosphere
atm
psi
bar
chemamu
physamu
amu
chemdalton
dalton
physdalton
dozen
bakersdozen
quire
ream
gross
hertz
cps
hz
khz
mhz
rutherford
degree
circle
turn
revolution
rpm
grade
grad
sign
arcdeg
arcmin
arcsec
karat
proof
mpg
curie
stoke
steradian
sr
sphere
ps
us
ns
ms
sec
minute
min
hour
hr
day
week
quadrant
fortnight
year
yr
month
mo
decade
century
millenium
gm
myriagram
mg
metricton
gamma
metriccarat
quintal
lb
pound
lbf
cental
stone
ounce
oz
avdram
usdram
dram
dr
grain
gr
shortton
ton
longquarter
shortquarter
longton
longhundredweight
shorthundredweight
wey
carat
scruple
pennyweight
apdram
apounce
appound
cm
mm
km
parsec
pc
nm
micron
angstrom
fermi
point
pica
caliber
barleycorn
inch
in
mil
palm
hand
span
foot
feet
ft
cubit
pace
yard
yd
fathom
rod
rd
rope
ell
skein
cable
furlong
nmile
nautmile
bolt
mile
mi
league
nautleague
lightyear
engineerschain
engineerslink
gunterchain
gunterlink
ramdenchain
ramdenlink
acre
rood
are
centare
hectare
barn
section
township
cc
liter
l
ml
registerton
cord
boardfoot
boardfeet
cordfoot
cordfeet
last
perch
stere
cfs
gallon
imperial
gal
quart
qt
magnum
pint
pt
cup
gill
fifth
firkin
barrel
petrbarrel
hogshead
hd
tun
kilderkin
noggin
floz
fldr
tablespoon
teaspoon
minim
pk
bushel
dry
bu
british
brbucket
brpeck
brbushel
brfirkin
dryquartern
liqquarten
butt
bag
brbarrel
seam
drachm
newton
pascal
nt
joule
cal
gramcalorie
calorie
btu
frigorie
kcal
kcalorie
langley
dyne
poundal
pdl
erg
horsepower
hp
poise
reyn
rhe
coul
statcoul
ampere
abampere
amp
watt
volt
v
abvolt
statvolt
ohm
abohm
mho
abmho
siemens
farad
abfarad
statfarad
pf
abhenry
henry
stathenry
mh
weber
gauss
electronvolt
ev
kev
mev
bev
faraday
gilbert
oersted
oe
cd
lumen
lux
footcandle
footlambert
lambert
phot
stilb
candle
engcandle
germancandle
carcel
hefnerunit
candlepower
baud
byte
kb
mb
gb
word
long
block
mph
knot
brknot
mach
energy
ccs
peck
arpentcan
apostilb
arpentlin
atomicmassunit
barie
barye
biot
blondel
bottommeasure
refrigeration
centesimalminute
centesimalsecond
chain
circularinch
circularmil
clusec
coomb
crith
dioptre
displacementton
dopplezentner
equivalentfootcandle
equivalentlux
equivalentphot
finger
franklin
galileo
geographicalmile
hefnercandle
homestead
hyl
imaginarycubicfoot
jeroboam
line
link
lusec
marineleague
maxwell
mgd
minersinch
nail
nit
nox
pieze
pipe
pole
quarter
quartersection
ra
rankine
rehoboam
rontgen
rydberg
sabin
shippington
sigma
skot
spat
spindle
square
sthene
tesla
thermie
timberfoot
tonne
water
xunit
k
puncheon
tnt
basic_units_template
meter
gram
second
inches
sennight
cubichectare
astronomicalunit
fluidounce
tsp
tbsp
390
4
9
2
m
2
kg
2
s
2
coul
2
candela
2
radian
2
bit
2
erlang
2
kelvin
36
1
2
3.14159265358979323846264338327950288
36
1
2
2.99792458e8 m/sec
36
1
2
9.80665 m/sec2
36
1
2
1.49599e11 m
36
1
2
6.022045e23
36
1
2
1.6020e-19 coul
36
1
2
10 coul
36
1
2
g
36
1
2
lb g sec2/ft
36
1
2
1.3157895 atm/m
36
1
2
mercury
36
1
2
mm hg
36
1
2
1|100
36
1
2
%
36
1
2
centigram
36
1
2
1.01325 bar
36
1
2
atmosphere
36
1
2
lb g/in2
36
1
2
1e6 dyne/cm2
36
1
2
1.66024e-24 g
36
1
2
1.65979e-24 g
36
1
2
chemamu
36
1
2
chemamu
36
1
2
chemamu
36
1
2
physamu
36
1
2
12
36
1
2
13
36
1
2
25
36
1
2
500
36
1
2
144
36
1
2
1/sec
36
1
2
hertz
36
1
2
hertz
36
1
2
kilohz
36
1
2
megahz
36
1
2
1e6/sec
36
1
2
1|180 pi radian
36
1
2
2 pi radian
36
1
2
2 pi radian
36
1
2
360 degrees
36
1
2
revolution/minute
36
1
2
1|400 circle
36
1
2
1|400 circle
36
1
2
1|12 circle
36
1
2
1 degree
36
1
2
1|60 arcdeg
36
1
2
1|60 arcmin
36
1
2
1|24
36
1
2
1|200
36
1
2
mile/gal
36
1
2
3.7e10/sec
36
1
2
1 cm2/sec
36
1
2
radian radian
36
1
2
steradian
36
1
2
4 pi steradian
36
1
2
picosec
36
1
2
microsec
36
1
2
nanosec
36
1
2
millisec
36
1
2
second
36
1
2
60 sec
36
1
2
minute
36
1
2
60 min
36
1
2
hour
36
1
2
24 hr
36
1
2
7 day
36
1
2
5400 minute
36
1
2
14 day
36
1
2
365.24219879 day
36
1
2
year
36
1
2
1|12 year
36
1
2
month
36
1
2
10 year
36
1
2
100 year
36
1
2
1000 year
36
1
2
gram
36
1
2
10 kg
36
1
2
milligram
36
1
2
1000 kg
36
1
2
1e-6 g
36
1
2
200 mg
36
1
2
100 kg
36
1
2
0.45359237 kg
36
1
2
lb
36
1
2
lb g
36
1
2
100 lb
36
1
2
14 lb
36
1
2
1|16 lb
36
1
2
ounce
36
1
2
1|16 oz
36
1
2
1|8 oz
36
1
2
avdram
36
1
2
dram
36
1
2
1|7000 lb
36
1
2
grain
36
1
2
2000 lb
36
1
2
shortton
36
1
2
28 lb
36
1
2
500 lb
36
1
2
2240 lb
36
1
2
112 lb
36
1
2
100 lb
36
1
2
252 lb
36
1
2
205.3 mg
36
1
2
20 grain
36
1
2
24 grain
36
1
2
60 grain
36
1
2
480 grain
36
1
2
5760 grain
36
1
2
centimeter
36
1
2
millimeter
36
1
2
kilometer
36
1
2
au radian/arcsec
36
1
2
parsec
36
1
2
nanometer
36
1
2
1e-6 meter
36
1
2
1e-8 meter
36
1
2
1e-13 cm
36
1
2
1|72.27 in
36
1
2
0.166044 inch
36
1
2
0.01 in
36
1
2
1|3 in
36
1
2
2.54 cm
36
1
2
inch
36
1
2
0.001 in
36
1
2
3 in
36
1
2
4 in
36
1
2
9 in
36
1
2
12 in
36
1
2
foot
36
1
2
foot
36
1
2
18 in
36
1
2
30 inch
36
1
2
3 ft
36
1
2
yard
36
1
2
6 ft
36
1
2
16.5 ft
36
1
2
rod
36
1
2
20 ft
36
1
2
45 in
36
1
2
360 feet
36
1
2
720 ft
36
1
2
660 ft
36
1
2
1852 m
36
1
2
nmile
36
1
2
120 feet
36
1
2
5280 feet
36
1
2
mile
36
1
2
3 mi
36
1
2
3 nmile
36
1
2
c yr
36
1
2
100 ft
36
1
2
0.01 engineerschain
36
1
2
66 ft
36
1
2
0.01 gunterchain
36
1
2
100 ft
36
1
2
0.01 ramdenchain
36
1
2
43560 ft2
36
1
2
0.25 acre
36
1
2
100 m2
36
1
2
0.01 are
36
1
2
100 are
36
1
2
1e-24 cm2
36
1
2
mi2
36
1
2
36 mi2
36
1
2
cm3
36
1
2
1000 cc
36
1
2
liter
36
1
2
milliliter
36
1
2
100 ft3
36
1
2
128 ft3
36
1
2
144 in3
36
1
2
boardfoot
36
1
2
0.125 cord
36
1
2
cordfoot
36
1
2
80 bu
36
1
2
24.75 ft3
36
1
2
m3
36
1
2
ft3/sec
36
1
2
231 in3
36
1
2
1.200949
36
1
2
gallon
36
1
2
1|4 gal
36
1
2
quart
36
1
2
2 qt
36
1
2
1|2 qt
36
1
2
pint
36
1
2
1|2 pt
36
1
2
1|4 pt
36
1
2
1|5 gal
36
1
2
72 pint
36
1
2
31.5 gal
36
1
2
42 gal
36
1
2
63 gal
36
1
2
hogshead
36
1
2
252 gal
36
1
2
18 imperial gal
36
1
2
1 imperial gill
36
1
2
1|4 gill
36
1
2
1|32 gill
36
1
2
4 fldr
36
1
2
1|3 tablespoon
36
1
2
1|480 floz
36
1
2
peck
36
1
2
8 dry gal
36
1
2
268.8025 in3/gallon
36
1
2
bushel
36
1
2
277.4193|231
36
1
2
4 dry british gal
36
1
2
2 dry british gal
36
1
2
8 dry british gal
36
1
2
1.125 brbushel
36
1
2
2.272980 l
36
1
2
0.1420613 l
36
1
2
126 gal
36
1
2
3 brbushels
36
1
2
4.5 brbushels
36
1
2
8 brbushels
36
1
2
3.551531 ml
36
1
2
kg m/sec2
36
1
2
nt/m2
36
1
2
newton
36
1
2
nt m
36
1
2
4.1868 joule
36
1
2
cal
36
1
2
cal
36
1
2
1054.35 joule
36
1
2
kilocal
36
1
2
kilocal
36
1
2
kilocal
36
1
2
cal/cm cm
36
1
2
erg/cm
36
1
2
ft lb/sec2
36
1
2
poundal
36
1
2
1e-7 joule
36
1
2
550 ft lb g/sec
36
1
2
horsepower
36
1
2
gram/cm sec
36
1
2
6.89476e-6 centipoise
36
1
2
1/poise
36
1
2
coulomb
36
1
2
3.335635e-10 coul
36
1
2
coul/sec
36
1
2
10 amp
36
1
2
ampere
36
1
2
joule/sec
36
1
2
watt/amp
36
1
2
volt
36
1
2
10 volt
36
1
2
299.7930 volt
36
1
2
volt/amp
36
1
2
10 ohm
36
1
2
1/ohm
36
1
2
10 mho
36
1
2
mho
36
1
2
coul/volt
36
1
2
10 farad
36
1
2
1.112646e-12 farad
36
1
2
picofarad
36
1
2
10 henry
36
1
2
sec2/farad
36
1
2
8.987584e11 henry
36
1
2
millihenry
36
1
2
volt sec
36
1
2
maxwell/cm2
36
1
2
e volt
36
1
2
e volt
36
1
2
1e3 ev
36
1
2
1e6 ev
36
1
2
1e9 ev
36
1
2
9.648456e4coul
36
1
2
0.7957747154 amp
36
1
2
1 gilbert / cm
36
1
2
oersted
36
1
2
candela
36
1
2
cd sr
36
1
2
lumen/m2
36
1
2
lumen/ft2
36
1
2
cd/pi ft2
36
1
2
cd/pi cm2
36
1
2
lumen/cm2
36
1
2
cd/cm2
36
1
2
cd
36
1
2
1.04 cd
36
1
2
1.05 cd
36
1
2
9.61 cd
36
1
2
.92 cd
36
1
2
12.566370 lumen
36
1
2
bit/sec
36
1
2
8 bit
36
1
2
1024 byte
36
1
2
1024 kb
36
1
2
1024 mb
36
1
2
4 byte
36
1
2
4 word
36
1
2
512 byte
36
1
2
mile/hr
36
1
2
nmile/hr
36
1
2
6080 ft/hr
36
1
2
331.45 m/sec
36
1
2
c2
36
1
2
1|36 erlang
36
1
2
2 dry gallon
36
1
2
27.52 mi
36
1
2
cd/pi m2
36
1
2
191.835 ft
36
1
2
amu
36
1
2
1e-1 nt/m2
36
1
2
1e-1 nt/m2
36
1
2
10 amp
36
1
2
cd/pi m2
36
1
2
1|40 in
36
1
2
12000 but/ton hr
36
1
2
1e-2 grade
36
1
2
1e-4 grade
36
1
2
gunterchain
36
1
2
1|4 pi in2
36
1
2
1e-6|4 pi in2
36
1
2
1e-8 mm hg m3/s
36
1
2
4 bu
36
1
2
9.06e-2 gram
36
1
2
1/m
36
1
2
35 ft3
36
1
2
100 kg
36
1
2
lumen/pi ft2
36
1
2
lumen/pi m2
36
1
2
cd/pi cm2
36
1
2
7|8 in
36
1
2
3.33564e-10 coul
36
1
2
1e-2 m/sec2
36
1
2
nmile
36
1
2
hefnerunit
36
1
2
1|4 mi2
36
1
2
gram force sec2/m
36
1
2
1.4 ft3
36
1
2
4|5 gal
36
1
2
1|12 in
36
1
2
66|100 ft
36
1
2
1e-6 mm hg m3/s
36
1
2
3nmile
36
1
2
1e-8 weber
36
1
2
megagal/day
36
1
2
1.5 ft3/min
36
1
2
1|16 yd
36
1
2
cd/m2
36
1
2
1e-3 lux
36
1
2
1e3 nt/mt2
36
1
2
4 barrel
36
1
2
rd
36
1
2
9 in
36
1
2
1|4 mi2
36
1
2
100 erg/gram
36
1
2
1.8 kelvin
36
1
2
156 floz
36
1
2
2.58e-4 curie/kg
36
1
2
1.36054e1 ev
36
1
2
1 ft2
36
1
2
40 ft3
36
1
2
microsec
36
1
2
1e-3 apostilb
36
1
2
sphere
36
1
2
14400 yd
36
1
2
100 ft2
36
1
2
1e3 nt
36
1
2
weber/m2
36
1
2
1e6 cal
36
1
2
ft3
36
1
2
1e6 gram
36
1
2
0.22491|2.54 kg/m2 sec2
36
1
2
1.00202e-13 m
36
1
2
1.38047e-16 erg/kelvin
36
1
2
84 gal
36
1
2
4.6e6 m2/sec2
36
1
4
9
4
2
2
m
0
0
4
2
2
kg
0
0
4
2
2
s
0
0
4
2
2
coul
0
0
4
2
2
candela
0
0
4
2
2
radian
0
0
4
2
2
bit
0
0
4
2
2
erlang
0
0
4
2
2
kelvin
0
0
36
1
2
m
36
1
2
1|1000 kg
36
1
2
s
36
1
2
inch
36
1
2
1 week
36
1
2
1000000 m3
36
1
2
au
2
1
2
floz
2
1
2
teaspoon
2
1
2
tablespoon
2
1
4
20
2
Utility verbs for converting from one unit of measure to another.
2

2
Unusual conversions:
2
:dd_to_dms => converts decimal (INT or FLOAT) Degrees into Degrees, Minutes,
2
              and Seconds. (Also works for decimal Hours.)
2
:dms_to_dd => converts from Degrees (or Hours), Minutes, and Seconds to
2
              decimal Degrees (or Hours).
2
:rect_to_polar => converts from cartesian (x,y) coordinates to polar.
2
:polar_to_rect => converts from polar (r, theta) coordinates to cartesian.
2
:F_to_C => converts from Fahrenheit to Celsius.
2
:C_to_F => converts from Celsius to Fahrenheit.
2
:C_to_K => converts from Celsius to Kelvin.
2
:K_to_C => converts from Kelvin to Celsius.
2
:F_to_R => converts from Fahrenheit to Rankine.
2
:R_to_F => converts from Rankine to Fahrenheit.
2

2
Standard conversions:
2
:convert => takes two string inputs and attempts to determine the 
2
            multiplicative conversion factor. See the verb help for details
2
            and input format."
36
5
0
0
36
4
4
1
2
Conversion Utils
36
5
2
This is a utilities package for converting from one unit of measurement to another. Type 'help #770' for more details.
36
5
4
2
0
45582
0
1641541193
36
1
#94
Generic Gendered Object
144
2
1
-1
0
0
4
0
1
1
4
2
1
35
1
6
2
set_gender
2
173
-1
verb_sub
2
173
-1
12
gender
pqc
pq
ppc
pp
prc
pr
poc
po
psc
ps
verb_subs
16
2
neuter
2
5
2
its
2
5
2
its
2
5
2
Its
2
5
2
its
2
5
2
Itself
2
5
2
itself
2
5
2
It
2
5
2
it
2
5
2
It
2
5
2
it
2
5
4
0
2
5
0
0
2
4
4
1
2
Generic Gendered Object
2
5
5
2
5
4
2
0
3044
0
1648488120
36
1
#95
List Editor
144
96
1
-1
0
0
4
0
1
50
4
0
15
e*dit
96
25
-1
save
96
89
-2
join* fill
96
89
-2
expl*ode
96
89
-2
value
96
173
-1
working_on
96
173
-1
init_session
96
173
-1
property_match_result
96
173
-1
property
2
165
-1
set_property
2
165
-1
explode_line
96
173
-1
explode_list
96
173
-1
is_delimiter
96
173
-1
to_value
96
173
-1
parse_invoke
96
173
-1
2
objects
properties
40
4
0
96
1
4
0
96
1
4
0
96
1
4
0
96
1
4
2
4
10
2
say
2
emote
2
lis*t
2
ins*ert
2
n*ext,p*rev
2
del*ete
2
f*ind
2
s*ubst
2
m*ove,c*opy
2
expl*ode
4
3
2
w*hat
2
abort
2
q*uit,done,pause
96
5
5
96
5
5
96
5
4
3
4
2
2
e*dit
2
<object>.<prop>
4
2
2
save
2
[<object>.<prop>]
4
2
2
expl*ode
2
[<range>]
96
5
0
0
96
1
5
96
5
5
96
5
4
6
4
2
2
properties
2

4
2
2
objects
1
-1
4
2
2
texts
0
0
4
2
2
changes
0
0
4
2
2
inserting
0
1
4
2
2
readable
0
0
96
1
2
%N heads off to edit some properties.
96
5
2
%N comes back from editing properties.
96
5
4
3
2
Partially edited list value will be here when you get back.
2
To return, give the `@pedit' command with no arguments.
2
Please come back and SAVE or ABORT if you don't intend to be working on this list value in the immediate future.  Keep Our MOO Clean!  No Littering!
96
5
5
96
5
5
96
5
5
96
5
4
0
96
0
4
0
96
1
4
0
96
0
4
0
96
0
4
0
96
1
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
4
5
96
5
0
917349705
96
5
5
96
4
5
96
5
5
96
5
5
96
4
4
1
2
List Editor
96
5
5
96
5
4
2
0
17973
0
1648488120
36
1
#96
Editor_Owner
1
96
1
-1
0
0
4
0
1
4
4
0
0
0
91
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
96
5
5
96
5
5
96
5
5
36
1
5
96
5
5
96
4
5
96
5
5
2
1
4
1
1
2
96
5
4
0
96
5
5
96
5
5
96
5
5
96
4
5
96
4
5
98
1
5
98
1
4
0
98
1
4
2
1
90
1
89
36
1
5
2
0
2

2
0
0
2147483647
2
1
0
0
96
5
5
96
5
5
36
1
5
36
1
5
36
0
5
36
1
4
5
1
48
1
49
1
50
1
95
1
96
2
1
5
36
1
5
96
4
5
2
0
5
2
0
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
2
1
0
-10000
36
0
1
-1
96
5
2
impossible password to type
2
0
5
96
5
5
96
5
5
96
5
0
2147483647
2
1
4
4
0
0
0
135523
0
1648488120
0
0
36
0
0
0
2
0
5
2
0
5
2
1
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
5
96
5
0
0
96
4
4
1
2
Editor_Owner
2
1
2
This player owns all editor-related verbs.
96
5
4
2
0
3554
0
1648488120
36
1
#97
HTTP Server
0
2
1
-1
0
0
4
0
1
5
4
0
4
handle_connection
2
173
-1
tell_key
2
173
-1
gen_key
2
173
-1
init_for_core
2
173
-1
5
guests
master_key
alpha
nonalpha
help_msg
17
4
0
2
5
2
902894a52d08e5cf3c45812a321cac36
2
5
2
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
2
5
2
 !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
2
5
4
12
2
HTTP Server
2
-----------
2

2
To use this device, all you need to do is put a .html property on your object. It will then serve a web page at http://SITE:PORT/OBJID where OBJID is the object's ID number without the # sign, SITE is your MOO's address, and PORT is your MOO's port.
2
If it starts with the line <HTML>, the server will automatically serve it up as HTML code.
2
Otherwise, you will need to use your own HTTP headers (for example, if you want to serve plain text instead of HTML).
2

2
If you want to have more functionality than this, you can make a verb :html(args), that does the same thing. The args are a list of anything after the OBJID divided by /.
2
For example, the URL http://SITE:PORT/123/foo/10 will result in a call to #123:html("foo","10"). This call should return a list of strings that is HTML, or HTTP stuff with the appropriate headers.
2

2
Additionally, your object can call http:tell_key(player). This will generate a special keyed URL for that player, so when your :html() verb is called, the built-in variable PLAYER will be set to the person who was issued the key.
2
This verb tells the player their custom key directly.
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
5
2
5
0
0
2
4
4
1
2
HTTP Server
2
5
5
2
5
4
2
0
8359
0
1648488120
36
1
#98
Core
3
98
1
15
0
0
4
0
1
58
4
0
0
0
95
5
36
1
5
36
1
5
36
1
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
36
1
5
98
5
5
98
5
5
98
5
5
36
1
5
98
5
5
98
4
5
98
5
5
2
1
5
98
5
5
98
5
5
98
5
5
98
5
5
98
4
5
98
4
5
98
1
5
98
1
5
98
1
5
36
1
5
2
0
5
2
0
5
2
1
5
98
5
5
98
5
5
36
1
5
36
1
5
36
0
5
36
1
4
17
1
98
1
99
1
100
1
101
1
102
1
103
1
104
1
105
1
106
1
107
1
108
1
109
1
110
1
113
1
116
1
121
1
123
2
1
5
36
1
5
98
4
5
2
0
5
2
0
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
2
1
5
36
0
5
98
5
5
2
0
5
98
5
5
98
5
5
98
5
5
2
1
4
4
0
50000
0
239212
0
1648488120
0
100
36
0
5
2
0
5
2
0
5
2
1
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
4
5
2
1
5
98
5
4
2
0
3637
0
1648488120
36
1
#99
ANSI Utilities
0
98
1
-1
0
0
4
0
1
78
4
0
38
length
98
173
-1
index rindex
98
173
-1
contains_codes
98
165
-1
delete
98
173
-1
update_all
98
165
-1
get_code
98
165
-1
cutoff*_suspended
98
165
-1
add_group
98
173
-1
add_code
98
173
-1
show_who_listing
98
165
-1
notify
2
165
-1
add_noansi
98
173
-1
remove_noansi
98
173
-1
tell
98
173
-1
self_diagnostic
98
165
-1
trusts
98
173
-1
cutoff_locs
98
165
-1
cleanup_noansi
98
173
-1
test_benchmark
98
173
-1
cutoff_assign
98
173
-1
setadd
98
173
-1
setremove
98
173
-1
ansi_status
98
173
-1
terminate_normal
98
173
-1
left
98
173
-1
right
98
173
-1
centre center
98
173
-1
columnize columnise
98
173
-1
space
98
173
-1
ansi_title
98
165
-1
strip_black
98
173
-1
quote_ansi
98
173
-1
update_player_codes
98
173
-1
fill_string
98
173
-1
@ansi-setup
2
37
-1
approximate_256
98
173
-1
color_selector
98
173
-1
hr_to_code
98
173
-1
69
escape
code_red
code_green
code_yellow
code_blue
code_purple
code_cyan
code_normal
code_inverse
code_underline
code_bold
code_b:black
code_b:red
code_b:green
code_b:yellow
code_b:blue
code_b:magenta
code_b:purple
code_b:cyan
code_b:white
beep
code_bright
group_colors
group_bold
code_unbold
group_misc
code_blink
code_unblink
group_blinking
code_magenta
code_unbright
groups
code_white
noansi_task
all
all_regexp
group_colors_regexp
group_bold_regexp
group_misc_regexp
group_blinking_regexp
truecolor_regexp
version
code_gray
code_grey
test_screen
extra_codes
active
random_colors
ansi_log
noansi_queue
need_wizperms
code_beep
status_message
trusted
diagnostic_tests
redirect_su_names
redirect_su_code
default_codes
code_null
code_random
group_extra
group_extra_regexp
terminate_regexp
replace_code_pointers
notify_regexp
reset_guest_props
ge_fill_string
plr_db_insert
xterm_256_regexp
74
2

98
0
2
e[31m
98
1
2
e[32m
98
1
2
e[33m
98
1
2
e[34m
98
1
2
e[35m
98
1
2
e[36m
98
1
2
e[0m
98
1
2
e[7m
98
1
2
e[4m
98
1
2
e[1m
98
1
2
e[40m
98
1
2
e[41m
98
1
2
e[42m
98
1
2
e[43m
98
1
2
e[44m
98
1
2
e[45m
98
1
2
e[45m
98
1
2
e[46m
98
1
2
e[47m
98
1
2

98
0
2
e[1m
98
1
4
10
2
red
2
green
2
yellow
2
blue
2
purple
2
cyan
2
gray
2
grey
2
magenta
2
white
98
1
4
4
2
bold
2
unbold
2
bright
2
unbright
98
1
2
e[22m
98
1
4
2
2
underline
2
inverse
98
1
2
e[5m
98
1
2
e[25m
98
1
4
2
2
blink
2
unblink
98
1
2
e[35m
98
1
2
e[22m
98
1
4
5
2
bold
2
colors
2
misc
2
blinking
2
extra
98
1
2
e[37m
98
1
0
828515096
98
1
4
22
2
random
2
normal
2
null
2
bold
2
unbold
2
bright
2
unbright
2
red
2
green
2
yellow
2
blue
2
purple
2
cyan
2
gray
2
grey
2
magenta
2
white
2
underline
2
inverse
2
blink
2
unblink
2
beep
98
1
2
%[%(b:%)?%(random%|normal%|null%|bold%|unbold%|bright%|unbright%|red%|green%|yellow%|blue%|purple%|cyan%|gray%|grey%|magenta%|white%|underline%|inverse%|blink%|unblink%|beep%|:%([01][0-9][0-9]%|2[0-4][0-9]%|25[0-5]%)%|:random%|%([0-9]+%):%([0-9]+%):%([0-9]+%)%)%]
98
1
2
%[%(red%|green%|yellow%|blue%|purple%|cyan%|gray%|grey%|magenta%|white%)%]
98
1
2
%[%(bold%|unbold%|bright%|unbright%)%]
98
1
2
%[%(underline%|inverse%)%]
98
1
2
%[%(blink%|unblink%)%]
98
1
2
%([0-9]+%):%([0-9]+%):%([0-9]+%)
98
1
2
2.6
98
1
2
e[1;30m
98
1
2
e[1;30m
98
1
4
37
2
Colors        [red]red[normal]          Bold Colors   [bold][red]red[normal]
2
              [green]green[normal]                      [bold][green]green[normal]
2
              [blue]blue[normal]                       [bold][blue]blue[normal]
2
              [yellow]yellow[normal]                     [bold][yellow]yellow[normal]
2
              [cyan]cyan[normal]                       [bold][cyan]cyan[normal]
2
              [purple]purple[normal]                     [bold][purple]purple[normal]
2
              [gray]gray[normal]                       [bold][gray]gray[normal]
2
              [white]white[normal]                      [bold][white]white[normal]
2

2
Backgrounds   [b:red][gray]red[normal]          True Color    [128:0:0]maroon[normal]
2
              [b:green][gray]green[normal]                      [153:255:180]light green[normal]
2
              [b:blue][gray]blue[normal]                       [153:204:255]light blue[normal]
2
              [b:yellow][gray]yellow[normal]                     [255:255:153]funky banana[normal]
2
              [b:cyan][gray]cyan[normal]                       [0:102:102]dark cyan[normal]
2
              [b:purple][gray]purple[normal]                     [255:204:242]light purple[normal]
2
              [b:white][gray]white[normal]                      [170:121:65]brown[normal]
2

2
256 Color     [:130]Orange[normal]
2
              [:125]Pink[normal]
2
              [:055]Violet[normal]
2
	      [:102]Silver[normal]
2
	      [:178]Bold Tan[normal]
2
	      [:118]Bold Lime[normal]
2
	      
2
Blinking   - [blink]This text should be blinking.  [unblink]This shouldn't.[normal]
2

2
Bold       - [bold][cyan]This text should be bold.  [unbold][cyan]This shouldn't.[normal]
2

2
Inverse    - [inverse]This should be inverse, and [red]t[green]h[yellow]i[blue]s[normal][inverse] should be inverse and in color.[normal]
2

2
Underline  - [underline]This should be underlined.[normal]
2

2
Random     - [random]All [random]of [random]these [random]words [random]should [random]be [random]written [random]in [random]a [random]different [random]color.[normal]
2

2
Random 256 - [:random]All [:random]of [:random]these [:random]words [:random]should [:random]be [:random]written [:random]in [:random]a [:random]different [:random]color.[normal]
2

2
Beep       - [beep]You should hear a beep.
98
1
4
3
2
random
2
normal
2
null
98
1
0
1
98
1
4
8
2
red
2
green
2
yellow
2
blue
2
purple
2
cyan
2
gray
2
white
98
1
4
19
4
4
2
2.6
0
1637293016
2
[bold][yellow]l[normal][yellow]i[green]s[bold]d[red]u[normal][red]d[purple]e[normal]
4
3
2
Fixed an issue in $ansi_pc:notify where it would terminate_normal even if the task was in the noansi queue, resulting in lines with visible ANSI tags gaining a [normal[null]] tag at the end.
2
Made @dump add the task to the noansi queue, allowing ANSI tags to be visible.
2
Added a call to 'remove_noansi' to @list to cleanup the noansi queue property.
4
4
2
2.5
0
1550344231
2
[bold][yellow]l[normal][yellow]i[green]s[bold]d[red]u[normal][red]d[purple]e[normal]
4
2
2
Added support for xterm 256 colors. Tags are in the mildly awkward form: [:number] or [b::number] for backgrounds. e.g. [:200[null]]
2
Also merged True Color into the notify_regexp and removed background codes. Backgrounds are now a modifier to each color class.
4
4
2
2.4
0
1540863892
2
[bold][yellow]l[normal][yellow]i[green]s[bold]d[red]u[normal][red]d[purple]e[normal]
4
1
2
Added support for true color (24-bit) terminals. Tags are in the form: [red:green:blue] or [b:red:green:blue] for backgrounds
4
4
2
2.3
0
1112950415
2
[bold][yellow]l[normal][yellow]i[green]s[bold]d[red]u[normal][red]d[purple]e[normal]
4
2
2
Added Remco de Groot's 2.2 change to the ANSI log and added support for background colors. Tags for background colors take the form: [b:color]
2
Also updated @ansi-setup to recognize and use FileIO if it's available.
4
4
2
2.2
0
820519200
2
Remco de Groot
4
1
2
Fixed a bug in the setup script where it referenced $player rather than player.
4
4
2
2.1
0
820519200
2
[cyan]D[gray]ark_[unbold][cyan]O[gray]wl[normal]
4
3
2
Updated all the documentation. Fixed up $ansi_pc:@ansi-setup. Fixed up $ansi_utils:notify to be a *much* faster. Changed the format of $ansi_utils.ansi_log and made $ansi_help:ansi_log do the formatting itself. Added $ansi_utils:tell, $ansi_pc:title, $ansi_utils:ansi_title, help ansi-cutoff, $ansi_pc:confunc, $ansi_utils:quote_ansi, $ansi_utils.status_message, $ansi_pc:@ansi-status, help @ansi-status, $ansi_utils:trusts, $ansi_utils.trusted, $ansi_utils:setadd, $ansi_utils:setremove, $ansi_utils:terminate_normal, $ansi_utils:self_diagnostic, and a benchmark test. Fixed a bug in $ansi_utils:replace_group where it was ignoring @ansi-o escape. Removed $ansi_utils:maybe_restart_noansi and replaced it with the less server intensive :cleanup_noansi. Moved the main part of $ansi_utils:cutoff into an internal verb, :cutoff_locs, and made a :cutoff_assign verb that also uses it. Removed $ansi_utils:replace_group and :reset_string and moved it to :notify. Got rid of $ansi_utils.su_<whatever> and moved them to regular verbs on $ansi_utils. Fixed up $ansi_pc:linesplit to use $ansi_utils:cutoff_locs. Renamed $ansi_utils:update_regexp to update_all and made it update all the caches. Moved @ansi-setup to $ansi_utils.
2
NOTE: $ansi_utils:notify doesn't terminate all strings with a [[null]normal] code anymore, you will have to run the string through $ansi_utils:terminate_normal before calling it.
2
The home of the ANSI system is now NestMOO, instead of EnigMOO.
4
4
2
2.0
0
817840800
2
[red]D[gray]ark_[unbold][red]O[gray]wl[normal]
2
Updated all the documentation, removed $ansi_utils.test_title, added $ansi_pc:set_aliases, added $ansi_pc:@more to fix the one on $player, fixed up @ansi-setup a lot. I'm fairly confident that the ANSI system is now safe and secure.
4
4
2
1.6
0
817840800
2
[blue]D[gray]ark_[unbold][blue]O[gray]wl[normal]
2
Made $ansi_utils:notify, moved all the replacing stuff there, and hacked $ansi_pc:notify to call it instead of notify(). Moved the .noansi_queue, :add_noansi, and :remove_noansi from $ansi_pc to $ansi_utils. I also updated 'help ansi-bugs' now that I tracked down a couple of them.
4
4
2
1.5
0
815248800
2
[green]Grant[normal]
2
Fixed some security problems that allowed players to get a copy of the escape character and use it for malicious purposes. To do that, I got rid of $ansi_pc:replace_ansi and put the code straight in :notify, which is able to pass() now. Also made an @ansi-setup verb for convenient porting, along with some core verb code on $ansi_utils. Fixed randoms to substitute faster by adding .random_colors. Added $ansi_utils:show_who_listing and changed @who to use it.
4
4
2
1.4
0
815248800
2
[green]Grant[normal]
2
In Dark_Owl's absence, I fixed up a lot of code to make it take less ticks, due to the recent lag problems on EnigMOO, which we suspect were called by color codes (most noticeably s). Average :notify call with colors takes around 200 less ticks. Also updated much of the documentation, since I know DO doesn't like to do it ;) Copied the part of $player:set_name that checked whether people had color codes in their name or not to the ANSI PC.
4
4
2
1.3
0
812570400
2
[green]D[gray]ark_[unbold][green]O[gray]wl[normal]
2
Fixed up 'help ansi-programming' a little more. Fixed $string_utils:columnize, for some reason it worked fine here but got screwed up on ForestMOO. Added 'help ansi-porting'.
4
4
2
1.2
0
812570400
2
[purple]D[gray]ark_[unbold][purple]O[gray]wl[normal]
2
$ansi_utils:replace_group now uses substitute(). Added 'help ansi-programming' and 'help ansi-bugs'. Added @ansi-test and 'help @ansi-test'. Cleaned up a lot of other stuff. Added $ansi_utils.active.
4
4
2
1.1
0
812570400
2
[green]D[gray]ark_[unbold][green]O[gray]wl[normal]
2
Fixed up $ansi_pc:notify a little but unfortunately now it requires wizperms and overrides the ones on it's ancestors. Fixed the line wrapping. Added this log, along with $ansi_utils.version. Hacked $ansi_utils:replace_group and $ansi_utils:cutoff to use regexps.
4
4
2
1.0
0
809978400
2
[cyan]D[gray]ark_[unbold][cyan]O[gray]wl[normal]
2
$emu disappears and is replaced with $ansi_utils. $ansi_pc, $ansi_help, $ansi_options, are created and everything on $player is moved to $ansi_pc. @ansi is replaced by @ansi-o.
4
4
2
0.9
0
807300000
2
[white]D[gray]ark_[unbold][white]O[gray]wl[normal]
2
EnigMOO opens resulting in a lot of bug fixes and more core hacks.
4
4
2
0.6
0
799351200
2
[cyan]D[gray]ark_[unbold][cyan]O[gray]wl[normal]
2
Fixed up @ansi some more, fixed a lot more core stuff including $generic_editor, and made it possible to ignore ANSI codes.
4
4
2
0.4
0
788983200
2
[yellow]D[gray]ark_[unbold][yellow]O[gray]wl[normal]
2
Fixed up @ansi a little and hacked some core stuff, mostly on $string_utils to fix columnizing. $emu:replace is hacked to use strsub() as opposed to going through letter by letter, ick.
4
4
2
0.2
0
781034400
2
[purple]D[gray]ark_[unbold][purple]O[gray]wl[normal]
2
Added an .ansi_on property on $player and a primitive @ansi command to turn it on and off.
4
4
2
0.1
0
778442400
2
[white]D[gray]ark_[unbold][white]O[gray]wl[normal]
2
First version, added $emu and hacked $player:notify to call it.
98
1
4
1
0
414639345
98
1
4
4
4
2
2
ansi_pc
2
@more
4
2
2
ansi_pc
2
notify
4
2
2
ansi_utils
2
notify
4
2
2
ansi_utils
2
@ansi-setup
98
1
2
b
98
1
2

98
1
4
0
98
1
4
1
2
benchmark
98
1
4
5
2
left
2
right
2
center centre
2
columnize columnise
2
space
98
1
4
7
2
"...redirects verbs to $ansi_utils...";
2
if (verb == "redirect_ansi")
2
elseif (valid(au = $ansi_utils))
2
  return au:(verb)(@args);
2
else
2
  return this:(verb + "(noansi)")(@args);
2
endif
98
1
4
4
2
white
2
unbold
2
unblink
2
null
98
1
2

98
1
2

98
1
4
1
2
beep
98
1
2
%[%(beep%)%]
98
1
2
%[%(b:%)?%(random%|normal%|bold%|bright%|unbright%|red%|green%|yellow%|blue%|purple%|cyan%|gray%|grey%|magenta%|underline%|inverse%|blink%|:%([01][0-9][0-9]%|2[0-4][0-9]%|25[0-5]%)%|:random%|%([0-9]+%):%([0-9]+%):%([0-9]+%)%)%]
98
5
4
0
98
1
2
%[%(b:%)?%(random%|normal%|bold%|unbold%|bright%|unbright%|red%|green%|yellow%|blue%|purple%|cyan%|gray%|grey%|magenta%|white%|underline%|inverse%|blink%|unblink%|beep%|:%([01][0-9][0-9]%|2[0-4][0-9]%|25[0-5]%)%|:random%|%([0-9]+%):%([0-9]+%):%([0-9]+%)%)%]
98
5
4
2
2
ansi_options
2
replace_codes
98
1
4
5
2
if (valid(au = $ansi_utils) && au.active)
2
  return au:(verb)(@args);
2
else
2
  return this:(verb + "(noansi)")(@args);
2
endif
98
1
4
3
2
typeof(args[1]) == NUM && typeof(args[2]) == STR && (args[2] = $ansi_utils:delete(args[2]));
2
typeof(args[1]) == STR && (args[1] = $ansi_utils:delete(args[1]));
2
return pass(@args);
98
1
2
:%([01][0-9][0-9]%|2[0-4][0-9]%|25[0-5]%)%|:random
98
5
4
1
2
A utility package for controlling ANSI sequences from within the MOO.  See 'help ansi-intro' for more info.
98
5
0
0
98
4
4
2
2
ANSI Utilities
2
au
98
5
2
{A utility for controlling ANSI sequences from within the MOO.  See 'help ansi-intro' for more info.}
98
5
4
2
0
77241
0
1648488120
36
1
#100
ANSI PC
0
98
1
-1
0
0
4
0
1
6
4
1
1
40
18
ansi_option
98
173
-1
@ansi-o*ptions
98
89
-2
set_ansi_option
98
173
-1
notify
2
165
-1
linesplit
98
173
-1
@ansi-t*est
98
9
-1
set_name
98
173
-1
say
98
85
-2
@who who
98
85
-2
at_item
98
173
-1
@more
2
25
-1
set_aliases
98
173
-1
title
98
165
-1
confunc
98
173
-1
@ansi-s*tatus
98
89
-2
@ansi-title
98
89
-2
set_ansi_title
98
173
-1
emote
98
85
-2
3
ansi_options
ansi_title
replace_codes
54
4
0
98
1
4
0
98
1
4
0
98
1
5
36
1
5
2
0
5
2
0
5
2
1
1
101
98
5
5
98
5
5
36
1
5
36
1
5
36
0
5
36
1
5
2
1
5
36
1
5
98
4
5
2
0
5
2
0
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
2
1
5
36
0
5
98
5
5
2
0
5
98
5
5
98
5
5
98
5
5
2
1
5
36
0
5
2
0
5
2
0
5
2
1
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
5
98
5
0
0
98
4
4
2
2
ANSI PC
2
apc
2
1
2
A player with the ability to see things in [red]c[bold][yellow]o[green]l[blue]o[purple]r[normal].
98
5
4
2
0
29845
0
1648488120
36
1
#101
ANSI Help
16
98
1
-1
0
0
4
0
1
30
4
0
1
ansi_log
98
173
-1
15
ansi-index
ansi-options
ansi-codes
ansi-multimooing
ansi-intro
@ansi-test
ansi-bugs
ansi-programming
ansi-porting
@ansi-setup
ansi-log
ANSI
@ansi-status
@ansi-title
ansi-corehacks
21
4
2
2
*index*
2
ANSI Help Topics
98
1
4
76
2
You can customize the way the ANSI Player Class works with the @ansi-options
2
command.  The format of this command is:
2

2
@ansi-option                         shows the ansi options
2
@ansi-option <option> [is] <value>   sets <option> to <value>
2
@ansi-option <option>=<value>        sets <option> to <value>
2
@ansi-option +<option>               sets <option>
2
@ansi-option -<option>               resets <option> (equiv. to <option>=0)
2
@ansi-option !<option>               resets <option> (equiv. to <option>=0)
2
@ansi-option <option>                displays value of <option>
2

2
The ansi options available at this time are:
2

2
 [bold][green]colors[normal]        This option specifies whether the MOO will display
2
               color sequences (such as [[null]blue] and [[null]red]).
2

2
 [bold][green]backgrounds[normal]   This option specifies whether the MOO will display
2
               background color sequences (such as [[null]b:blue] and [[null]b:red]).
2
	       Normal color, 256 color, and True Color all support background tags.
2
	       e.g. [[null]b:red]  [[null]b::200]  [[null]b:123:23:123]
2
	       
2
 [bold][green]blinking[normal]      This option specifies whether the MOO will allow things to
2
               blink on and off.  Most people find this annoying so they
2
               keep this off most of the time.
2

2
 [bold][green]bold[normal]          This option specifies whether the MOO will allow bright
2
               colors.  This probably isn't very useful unless you happen to
2
               have a hangover (maybe from a MOO bash, right Chapman ;) and
2
               the bright colors are hurting your eyes or something.
2
               (Or unless you're using a stupid windoze client that
2
                bolds as cyan.. gimme the name of a good freeware one
2
                and I'll be happy.. -Grant)
2

2
 [bold][green]misc[normal]          This option specifies whether the MOO should display all the
2
               ANSI codes not covered by the ones above.  This should usually
2
               be on if any of the above ones are on and will probably cause
2
               some very strange effects if it's not.
2

2
 [bold][green]extra[normal]         This option specifies whether the MOO will send certain
2
               non-printable characters.  So far, this option only includes
2
               beeps.  NOTE: these will probably work even if your terminal
2
               is not ANSI compatable.
2

2
 [bold][green]all[normal]           This turns on all of the above options.  Equivalent to
2
               '@ansi-options -none' except that it automatically does an
2
               '@ansi-options -ignore'.
2

2
 [bold][green]none[normal]          This turns off all of the above options.  Equivalent to
2
               @ansi-options -all
2

2
 [bold][green]escape[normal]        This option specifies what character the MOO will send for
2
               an escape character.  The default is an ASCII character 27
2
               but it can be set to another string in case control characters
2
               won't get through to your terminal (like say if you are
2
               multimooing from another MOO or something, see 'help
2
               ansi-multimooing' for more information on that.)
2

2
 [bold][green]ignore[normal]        This option overrides all the other options and tells the
2
               MOO to completely ignore any ANSI codes.  This means that you
2
               will see the actual codes (like [[null]blue] or [[null]normal]) instead
2
               of having them either translated or stripped out like normal.
2
               This will probably screw up the line wrapping, text centering
2
               and a bunch of other things and will probably be very spammy
2
               but it's useful for checking the value of properties and
2
               other things.
2

2
 [bold][green]no_connect_status[normal] This option specifies whether the ANSI status message
2
               will be displayed when you log on.
2

2
 [bold][green]truecolor[normal]    This option enables 24-bit True Color support. Your client
2
              must offer support for it. 
2
              Color sequences are in the form [[red]red[normal]:[green]green[normal]:[blue]blue[normal]]
2

2
 [bold][green]256[normal]          This option enables Xterm 256 color support. Your client must
2
              support it.
2
              Color sequences are in the form [:number]. e.g. [:200[null]]
98
1
4
46
2
The ANSI Player Class works by either translating codes into the ANSI sequences for them, or by stripping them out before sending the rest of the text to the player. An ANSI code is made up of the name of the code with a pair of brackets ([]'s) around it. Note to put codes into the documentation, they had to be put with a [[null]null] in between the letters, so something like [[[null]null]green] had to be written (and to make that.. sigh)
2

2
These codes can be used in almost anything. MOOmail, messages, names, descriptions, and pages are all good places to put codes. ANSI codes are *not* allowed in player's names though because of all the problems this might cause. You can, however, use the new @ansi-title verb to put codes in your name.
2

2
The codes are separated into 6 main groups:
2

2
 [bold][yellow]colors[normal]         Codes that change the text to another color.  These include:
2
                [[null]red], [[null]green], [[null]yellow], [[null]blue], [[null]purple], [[null]cyan],
2
                [[null]gray], and [[null]white].  You can also use [[null]magenta] instead
2
                of [[null]purple] and [[null]grey] instead of [[null]gray] but this isn't
2
                recommended.  NOTE: [[null]gray] implies a [[null]bold] so if you have:
2
                [[null]gray]This is gray.  [[null]red]This is red.[[null]normal]
2
                The 'This is red.' will be bright red, you must put an
2
                [[null]unbold] in front of it if you want it to be dark red.
2
                In addition, if your client supports 24-bit True Color and you've enabled the 'truecolor'
2
                option, you can create tags from any arbitrary combination of red, green, and blue values.
2
                e.g. [[null]255:255:153] to create the funky banana color.
2
                These can be turned off with '@ansi-options -colors' and '@ansi-options -truecolor'
2
 
2
 [bold][yellow]backgrounds[normal]    Codes that change the background of text to another color.
2
                The same color codes that can be used for normal colors also apply to background.
2
                To use backgrounds, simply add "b:" before your color name. For example:
2
                [[null]b:red] or [b:255:255:153[null]]
2
                Backgrounds can be turned off with '@ansi-options -backgrounds'
2

2
 [bold][yellow]bold[normal]           Codes that make the text bright or not bright.  These include:
2
                [[null]bold] and [[null]unbold].  You can also use [[null]bright] and
2
                [[null]unbright] but, again, this is not recommended.  These can be
2
                turned off with '@ansi-options -bold'.  This can be used to make
2
                bright colors by putting a [[null]bold] in front of the color.
2
                (for example, in: [[null]green]A[[null]bold]B[[null]red]C[[null]unbold]D[[null]normal]
2
                the A would be dark green, the B would be bright green, the C
2
                would be bright red, and the D would be dark red)
2

2
[bold][yellow]blinking[normal]       Codes that turn on and off the blinking.  These include:
2
                [[null]blink] and [[null]unblink].  They can be turned off with
2
                '@ansi-options -blinking'.
2

2
 [bold][yellow]misc.[normal]          All the codes not covered by the ones above.  These include:
2
                [[null]underline] and [[null]inverse].  NOTE: [[null]underline]
2
                does not actually underline text on most computers.  These can
2
                be turned off with '@ansi-options -misc'.
2

2
[bold][yellow]extra[normal]          Codes that are not really ANSI and may work even if your
2
                terminal is not ANSI compatable .  These include:
2
                [[null]beep].  It can be turned off with '@ansi-options -extra'.
98
1
4
3
2
For those of you that are multimooing from another MOO (probably using Sunwiz's excellent MultiMOO PC) and your escape characters are getting stripped out, you can tell the MOO to send a certain string instead of an ASCII character 27 by typing:  '@ansi-options escape <string>'. You will then have to set your terminal program to translate <string> into an escape character. I would suggest setting <string> to '~' or some other character that is very rarely used.  You probably shouldn't tell anyone what character you are using though, because then they can clear your screen, reposition your cursor, and some other annoying things. To tell the MOO to start sending character 27's for the escape characters again, type '@ansi-options -escape'. 
2

2
Other MOOs that have the ANSI PC or other color capability have their own method of transmitting colors, so you should probably set '@ansi-options +ignore' on all the MOOs except the one you are actually telnetting too, this is because inter-MOO connecting can't send escape characters, only ASCII text.
98
1
4
8
2
This ANSI system was written and designed by Don Schwarz <darkowl@mcs.net> aka Dark_Owl.  It is composed of an ANSI Player Class ($ansi_pc), an ANSI utility package ($ansi_utils), an ANSI help database ($ansi_help), and an ANSI option database ($ansi_options).
2
It converts ANSI 'codes', which are composed of a word surrounded by brackets ([]'s), into ANSI sequences which are recognized by most terminal programs and are used to display text in certain colors, underlined, inverse, and to make text blink.  Not all terminal programs support ANSI though so this will not work for everyone.
2

2
You can put these ANSI codes in your descriptions, messages, mails, programs, and virtually anything else that is eventually sent through $player:notify().  See 'help ansi-codes' for a list of valid ANSI codes.
2

2
The ANSI PC is controlled with the @ansi-options command, see 'help @ansi-options' for more information on it.
2

2
To see a list of other ANSI help topics, see 'help ansi-index'.
98
1
4
3
2
*verbdoc*
2
$ansi_pc
2
@ansi-test
98
1
4
5
2
[bold][red]KNOWN BUGS:[normal]
2
  [bold][blue]1)[normal] Some terminal programs seem to act strangely with lines that start with a [[null]bold] code.  I'm pretty sure this isn't a MOO problem so I can't do anything about it.  I'd recommend always putting [[null]bold] codes *after* color codes, or if you're using TinyFugue, try typing "/set emulation raw".
2
  [bold][blue]2)[normal] You can still write in black with [[null]gray][[null]unbold].  Not a major problem, but it bugs me.
2
  [bold][blue]3)[normal] Some terminal programs seem to beep not only when they get a character 7, but also on every escape character they receive on the same line.
2
  [bold][blue]4)[normal] There's no way to set random replacements with @ansi-title.
98
1
4
52
2
There are a few verbs and properties that programmers might need to know about when programming things that interface with the ANSI system.  Some of the more useful ones include:
2

2
  $ansi_pc:ansi_option (STR option) - returns player's setting for <option>
2
  $ansi_pc:set_ansi_option (LIST    - sets player's options
2
                        options)
2
  $ansi_utils:add_noansi ()         - any text sent from the current task
2
                                      will not be translated by the ANSI PC.
2
  $ansi_utils:remove_noansi ()      - undoes a call to :add_noansi, this
2
                                      is not usually necessary because it
2
                                      gets removed from the queue when the
2
                                      task ends anyway.
2
  $ansi_utils.noansi_queue          - list of tasks that are currently
2
                                      being ignored.
2
  $ansi_utils:contains_codes (STR text) returns true if <text> contains
2
                                      any ANSI codes.
2
  $ansi_utils:delete (STR text)     - returns <text> with all the ANSI
2
                                      codes stripped.
2
  $ansi_utils:length (STR text)     - returns the length of <text> not
2
                                      including the ANSI codes.
2
  $ansi_utils:index/rindex (STR     - same as the builtins index() and
2
       text, STR text2[, NUM case]    rindex() but ignore ANSI codes.
2
  $ansi_utils:cutoff (STR text, NUM - same as text[start..end] for strings
2
       start, NUM end)                but ignores ANSI codes.
2
  $ansi_utils:cutoff_assign (STR    - same as text[start..end] = replacement
2
       text, NUM start, NUM end, STR
2
       replacement)
2
  $ansi_utils:notify (OBJ plr, STR  - Same as raw notify() but replaces
2
                   line)              ANSI.
2
  $ansi_utils:self_diagnostic ()    - Runs a diagnostic on the ANSI stuff.
2
  $ansi_utils:trusts (OBJ player)   - Is <player> trusted by the ANSI stuff?
2
  $ansi_utils:cutoff_locs (STR text - Returns a list of the real starting and
2
       NUM start, NUM end)            and ending locations.
2
  $ansi_utils:setadd (LIST l, ANY   - Same as setadd() but doesn't add it if
2
       element)                       element is already in the list (ignoring
2
                                      ANSI codes)
2
  $ansi_utils:setremove (LIST l,    - Same as setremove() but doesn't add it
2
       ANY element)                   if element is already in the list
2
                                      (ignoring ANSI codes)
2
  $ansi_utils:terminate_normal (STR - Returns text with a [[null]normal] code
2
       text)                          at the end.
2
  $ansi_utils:ansi_title (OBJ plr)  - Returns <plr>'s name with ANSI codes.
2
  $ansi_utils:quote_ansi (STR text) - Puts [[null]null] codes in the middle of
2
                                      all the other codes so they don't show.
2
  $ansi_utils:update_player_codes   - Should be run whenever <player>'s
2
          (OBJ player)                options are changed.
2

2
Trusted Users only:
2
  $ansi_utils:update_all ()         - Updates all the caches and regexps
2
  $ansi_utils:add_group (STR group) - adds <group> to the list of groups
2
  $ansi_utils:add_code (STR code,   - adds <code> to the codes in group
2
       STR group, ANY sequence)       <group> and set's it's ANSI sequence
2
                                      to <sequence>.
98
1
4
21
2
If you are starting a new MOO and wish to have ANSI on it, the easiest
2
  way is to use the ANSICore.  The ANSICore is a copy of the December
2
  25, 1995 LambdaCore in which everything has been fixed to work
2
  correctly with the ANSI.  The escape and beep characters are already
2
  present in the database so no set up or installation is necessary.
2
  The latest ANSICore is available via anonymous FTP from
2
  ftp.mcs.net in the directory /mcsnet.users/darkowl/ANSI, in a
2
  file named ANSICore.db.gz. (Sorry, due to file quotas I was unable to
2
  include the uncompressed version, but it is still available from
2
  darkowl.pr.mcs.net in the directory /pub/ANSI)
2
  NOTE: While the ANSI system is activated in the core, all players
2
    start out with the ANSI defaulting to off, so you will have to type
2
    '@ansi-options +all' before you can see any color.
2

2
To install the ANSI system on an already existing MOO, you will need the
2
  installation script.  This file should be uploaded into the MOO as a
2
  non-wizard (usually the second character of the wizard installing the
2
  ANSI) and will port the objects and give you instructions on how to
2
  start up the automatic setup program.  The latest installation script
2
  is available via anonymous FTP from ftp.mcs.net in the directory
2
  /mcsnet.users/darkowl/ANSI, in a file named ANSI.moo.
98
1
4
3
2
*verbdoc*
2
$ansi_utils
2
@ansi-setup
98
1
4
2
2
*subst*
2
%;this:ansi_log()
98
1
4
2
2
*forward*
2
ansi-intro
98
1
4
3
2
*verbdoc*
2
$ansi_pc
2
@ansi-status
98
1
4
3
2
*verbdoc*
2
$ansi_pc
2
@ansi-title
98
1
4
47
2
                    +-------------+                                    O F
2
                    | ANSI System |#                                 S u o
2
                    |    v2.4     |#                           N E C e t r
2
                    +_____________+#                           e n o t l e
2
                      ##############                           s i r u a s
2
        object:verb                   change?                  t g e p w t
2
 +-+---------------------------+--------------------------------------------+
2
 |1| $string_utils:left        | Redirect to $ansi_utils      |X|_|X|X|_|_|_|
2
 |1|              :right       | Redirect to $ansi_utils      |X|_|X|X|_|_|_|
2
 |1|              :center      | Redirect to $ansi_utils      |X|_|X|X|_|_|_|
2
 |1|              :columnize   | Redirect to $ansi_utils      |X|_|X|X|_|_|_|
2
 |1|              :space       | Redirect to $ansi_utils      |X|_|X|X|_|_|_|
2
 |1| $guest:do_reset           | Clearing props on $ansi_pc   |X|_|X|X|_|_|_|
2
 |1| $prog:@list               | Ignoring ANSI                |X|_|X|X|_|_|_|
2
 |2| $login:notify             | Stripping out ANSI           |X|_|X|X|_|_|_|
2
 |2|       :"@who who"         | $ansi_utils:show_who_listing |X|_|X|X|_|_|_|
2
 |2| $m_a:display_seq_headers  | Formatting                   |X|_|X|X|_|_|_|
2
 |2| $bmr:display_seq_headers  | Formatting                   |X|_|X|X|_|_|_|
2
 |2| $generic_editor:list_line | ignore ANSI                  |X|_|X|X|_|_|_|
2
 |2|              :fill_string | Redirect to $ansi_utils      |X|_|X|X|_|_|_|
2
 |2| $player_db:insert         | Stripping out ANSI           |X|_|X|X|_|_|_|
2
 |2| $prog:@dump               | Ignoring ANSI                |*|_|X|_|_|_|_|
2
 |2| $bu:object_audit_string   | Formatting                   |X|_|X|_|_|_|_|
2
 |2|    :do_audit_item         | Formatting                   |X|_|X|_|_|_|_|
2
 |3| $mail_agent:name          | Terminate normal             |X|_|X|_|_|_|_|
2
 |4| $string_utils:from_value  | Terminate normal             |X|_|_|_|_|_|_|
2
 |4|              :print       | Terminate normal             |X|_|_|_|_|_|_|
2
 |4| $player:tell_contents     | Formatting                   |X|_|X|_|_|_|_|
2
 |4| $cu:find_verbs_containing | Stripping out ANSI           |X|_|_|_|_|_|_|
2
 |4| $player:send_self_netmail | Stripping out ANSI           |X|_|_|_|_|_|_|
2
 | |  or $mail_recipient_class |                              |#|#|#|#|#|#|#|
2
 | |                           |                              |_|_|_|_|_|_|_|
2
 |===================--- Popular but Non-Core verbs ---=====================|
2
 |4| MCC FO:xm                 | Terminate normal             |_|_|_|_|_|_|_|
2
 |5|       :organize_columns   | Formatting                   |_|X|_|_|_|_|_|
2
 |5|       :get_name           | Colors in people's names     |_|_|_|_|_|_|_|
2
 | |                           |                              |_|_|_|_|_|_|_|
2
 +-+---------------------------+--------------------------------------------+
2
 
2
      +------------------+       +----------------------------------------+
2
      | X - done         |#      | 1 - Required for MOO operation         |#
2
      | # - N/A          |#      | 2 - Necessary for things to work right |#
2
      | * - extra stuff  |#      | 3 - Possible security hazard           |#
2
      | _ - not done     |#      | 4 - Fixes mild annoyance               |#
2
      +__________________+#      | 5 - Makes something look better        |#
2
        ###################      +________________________________________+#
2
                                   #########################################
98
1
5
98
5
4
1
2
ansi-index
36
1
0
0
98
4
4
2
2
ANSI Help
2
ah
98
5
2
A help database of the standard form in need of a description. See `help $generic_help'...
98
5
4
2
0
26826
0
1648488120
36
1
#102
ANSI Options
16
98
1
-1
0
0
4
0
1
68
4
0
3
actual
98
173
-1
show_escape
98
173
-1
parse_escape
98
173
-1
14
show_colors
show_backgrounds
show_blinking
show_bold
show_misc
show_all
show_none
type_escape
show_ignore
show_no_connect_status
show_extra
show_truecolor
show_approximate_256
show_256
22
4
2
2
Strip out standard 16 color sequences.
2
Translate standard 16 color sequences.
98
1
4
2
2
Strip out background color sequences.
2
Translate background color sequences.
98
5
4
2
2
Do not show blinking sequences.
2
Show blinking sequences.
98
1
4
2
2
Do not show bright colors.
2
Send bright colors.
98
1
4
2
2
Do not send all the other ANSI sequences.
2
Send all the other ANSI sequences.
98
1
4
2
2
Do not send any ANSI sequences.
2
Send all ANSI sequences.
98
1
4
2
2
Send all ANSI sequences.
2
Do not send any ANSI sequences.
98
1
4
1
0
2
98
1
4
2
2
See 'help ansi-options' for more information.
2
Overriding other options and ignoring all ANSI codes.
98
1
4
2
2
Don't show any status messages upon connecting.
2
Show status messages about ANSI upon connecting.
98
1
4
2
2
Do not send extra non-ANSI codes (such as beep).
2
Send extra non-ANSI codes (such as beep).
98
1
4
2
2
Strip out 24-bit True Color sequences.
2
Translate 24-bit True Color sequences.
98
1
4
2
2
24-bit color sequences are not approximated to 8-bit sequences for older clients.
2
24-bit color sequences are approximated to 8-bit sequences for older clients.
98
5
4
2
2
Strip out Xterm 256 color sequences.
2
Translate Xterm 256 color sequences.
98
5
4
11
2
colors
2
blinking
2
bold
2
misc
2
escape
2
ignore
2
no_connect_status
2
extra
2
backgrounds
2
truecolor
2
256
36
1
2
!colors!blinking!bold!misc!escape!ignore!no_connect_status!extra!backgrounds!truecolor!all!none!256!
36
1
4
2
2
all
2
none
36
1
0
25
98
5
0
0
98
4
4
2
2
ANSI Options
2
ao
98
5
2
An option package for controlling and customizing the ANSI PC.
98
5
4
2
0
5739
0
1648488120
36
1
#103
generic message dispatch object
0
98
1
-1
0
0
4
0
1
1
4
1
1
104
3
parse_send_args
98
173
-1
parse_receive_args
98
173
-1
set_messages_in set_messages_out
98
173
-1
2
messages_in
messages_out
6
4
0
98
1
4
0
98
1
0
0
98
4
4
2
2
generic message dispatch object
2
dispatch
98
5
5
98
5
4
2
0
5312
0
1648488120
36
1
#104
generic MCP package
0
98
1
-1
0
0
4
0
1
103
4
5
1
105
1
106
1
113
1
121
1
123
9
set_version_range
98
165
-1
dispatch
2
173
-1
match_request
98
173
-1
initialize_connection
98
173
-1
message_name_to_verbname
98
173
-1
finalize_connection
98
173
-1
add_cord_type
98
173
-1
remove_cord_type
98
173
-1
send_*
98
173
-1
2
version_range
cord_types
8
4
2
2
1.0
2
1.0
98
1
4
0
98
1
5
98
1
4
0
98
1
0
0
98
4
4
2
2
generic MCP package
2
package
98
5
5
98
5
4
2
0
7185
0
1648488120
36
1
#105
mcp-negotiate
0
98
1
-1
0
0
4
0
1
104
4
0
3
do_negotiation
98
173
-1
handle_can
98
173
-1
handle_end
98
173
-1
0
8
4
2
2
1.0
2
2.0
98
1
5
98
1
4
2
4
2
2
can
4
3
2
package
2
min-version
2
max-version
4
2
2
end
4
0
98
1
4
2
4
2
2
can
4
3
2
package
2
min-version
2
max-version
4
2
2
end
4
0
98
1
0
0
98
4
4
2
2
mcp-negotiate
2
negotiate
98
5
5
98
5
4
2
0
3348
0
1648488120
36
1
#106
mcp-cord
0
98
1
-1
0
0
4
0
1
104
4
0
9
next_id
98
173
-1
cord_send
2
173
-1
cord_closed
2
173
-1
handle_
98
173
-1
handle_closed
98
173
-1
find_type
98
173
-1
send_open
98
173
-1
finalize_connection
2
173
-1
type_name
98
173
-1
3
next_id
cords
registry_ids
11
0
1
98
1
4
0
98
1
4
0
98
5
5
98
1
4
0
98
1
4
3
4
2
2
open
4
2
2
_id
2
_type
4
2
2

4
2
2
_id
2
_message
4
2
2
closed
4
1
2
_id
98
1
4
3
4
2
2
open
4
2
2
_id
2
_type
4
2
2

4
2
2
_id
2
_message
4
2
2
closed
4
1
2
_id
98
1
0
0
98
4
4
2
2
mcp-cord
2
cord
98
5
5
98
5
4
2
0
7708
0
1648488120
36
1
#107
MCP 2.1 parser
0
98
1
-1
0
0
4
0
1
1
4
0
6
parse_mcp_alist
98
173
-1
parse_mcp
98
173
-1
parse_mcp_continuation
98
173
-1
parse
98
173
-1
unparse
98
173
-1
next_datakey
98
173
-1
2
next_datakey
unquoted_string
6
0
10155
98
1
2
^[]a-zA-Z0-9-%~`!@#$^&()=+{}[|';?/><.,]+$
2
1
0
0
98
4
4
2
2
MCP 2.1 parser
2
parser
98
5
5
98
5
4
2
0
6944
0
1648488120
36
1
#108
generic MCP 2.1 session
0
98
1
-1
0
0
4
0
1
122
4
0
22
set_connection
98
165
-1
multiline_begin
98
173
-1
multiline_finish
98
173
-1
multiline_add_value
98
173
-1
do_out_of_band_command
2
173
-1
finish
98
173
-1
initialize_connection
98
173
-1
set_packages set_authentication_key set_phase
98
173
-1
add_package
98
173
-1
handles_package
98
173
-1
register_handlers
98
173
-1
dispatch
2
173
-1
send
2
173
-1
find_handler
98
173
-1
connection
98
173
-1
package_name
98
173
-1
message_fullname
98
173
-1
strip_prefix
98
173
-1
end_negotiation
98
173
-1
_add_package_waiter
98
173
-1
_signal_package_waiter
98
173
-1
wait_for_package
98
173
-1
7
connection
pending_multilines
packages
authentication_key
phase
package_waiters
message_handlers
7
1
-1
98
1
4
0
98
0
4
0
98
1
3
0
98
0
0
0
98
1
4
0
98
0
4
2
4
0
4
0
98
1
#109
MCP package registry
0
98
1
-1
0
0
4
0
1
1
4
0
7
add_package
98
173
-1
remove_package
98
173
-1
match_package
98
173
-1
package_name
98
173
-1
packages
98
173
-1
init_for_module init_for_core
98
173
-1
@add-package @remove-package
2
153
1
2
package_names
packages
6
4
5
2
mcp-negotiate
2
mcp-cord
2
dns-org-mud-moo-simpleedit
2
dns-com-vmoo-client
2
dns-com-awns-status
98
1
4
5
1
105
1
106
1
113
1
121
1
123
98
1
0
0
98
4
4
2
2
MCP package registry
2
registry
98
5
5
98
5
4
2
0
6696
0
1648488120
36
1
#110
MCP 2.1
0
98
1
-1
0
0
4
0
1
1
4
0
15
create_session
98
173
-1
destroy_session
98
173
-1
initialize_connection
2
173
-1
finalize_connection
2
173
-1
parse_version
2
173
-1
compare_version_range
2
173
-1
compare_version
2
173
-1
unparse_version
2
173
-1
session_for
2
173
-1
user_created user_connected user_reconnected
2
173
-1
user_disconnected user_client_disconnected
2
173
-1
do_out_of_band_command
2
173
-1
package_name match_package packges
98
173
-1
handles_package wait_for_package
98
173
-1
include_for_core
2
173
-1
11
parser
session
version
package
negotiate
registry
cord
simpleedit
client
status
dispatch
15
1
107
98
5
1
108
98
1
4
2
0
2
0
1
98
5
1
104
2
1
1
105
2
1
1
109
98
5
1
106
98
1
1
113
98
5
1
121
98
5
1
123
98
5
1
103
98
5
0
0
98
4
4
2
2
MCP 2.1
2
mcp
98
5
5
98
5
4
2
0
11136
0
1648488120
36
1
#111
Object Prototype
0
2
1
-1
0
0
4
0
1
120
4
0
1
tell notify
2
173
-1
0
0
# 112 recycled
#113
dns-org-mud-moo-simpleedit
0
98
1
-1
0
0
4
0
1
104
4
0
7
send_content
2
173
-1
handle_set
2
173
-1
edit_set_program
2
173
-1
edit_sendmail
2
173
-1
edit_set_note_value
2
173
-1
verbcode_external_to_internal
98
173
-1
verbcode_internal_to_external
98
173
-1
3
foo
v_filter_in
v_filter_out
11
0
1
98
5
4
2
1
113
2
verbcode_external_to_internal
98
5
4
2
1
113
2
verbcode_internal_to_external
98
5
4
2
2
1.0
2
1.0
98
1
5
98
1
4
1
4
2
2
set
4
3
2
reference
2
type
2
content
98
1
4
1
4
2
2
content
4
4
2
reference
2
name
2
type
2
content
98
1
0
0
98
4
4
1
2
dns-org-mud-moo-simpleedit
98
5
4
61
2
A very simple local editing protocol.
2

2
S->C #$#dns-org-mud-moo-simpleedit-content (reference, name, type, content*)
2

2
Reference is the tag used when sending back to the server.
2
User may be allowed to edit it (i.e., save this same text into a
2
different property), with possibility of disastrous results.
2

2
Name is a human-readable name for the info, suitable for window title,
2
buffer name, etc.
2

2
Type is one of the following (for version 1.0):
2
 * string
2
 * string-list
2
 * moo-code
2

2
Content is the content interpreted according to the type
2
info given.  It's multiline (hence the *).
2

2
clients that don't provide special support for moo-code editing can
2
treat moo-code identically to string-list.
2

2
C->S #$#dns-org-mud-moo-simpleedit-set (reference, content*, type)
2

2
reference, content, and type are as above.  This is the message sent by the client to set when the user 'saves' the value.  Note this does not necessarily save the value.  Errors such as lack of permission to set the given reference or moo-code compliation errors may prevent it.  It is expected that the server will tell the user this (in the in-band text stream).  
2

2
Clients will probably want to provide a way to just send without closing the window, buffer, etc for this reason.
2

2

2
JHCore implementation notes
2

2
JHCore currently understands several different kinds of (local) editing sessions:
2
handled by $verb_editor:
2
   * verb editing
2
handled by $note_editor:
2
   * list of strings editing for notes and properties
2
handled by both $note_editor and $list_editor(?):
2
   * value editing for properties
2
handled by $mail_editor:
2
   * sending a mail message
2

2
@edit uses a semi-complicated system to determine (a) what the user is trying to edit and (b) how to edit it.   
2

2
So it looks like the critical things to modify are $generic_editor:invoke_local_editor, $note_editor:local_editing_info, $verb_editor:local_editing_info, and $mail_editor:local_editing_info.  
2

2
The current return path for locally edited stuff (in the core) appears to be:
2
  @program
2
  @set-note-text
2
  @set-note-value
2
  @@sendmail
2

2
.v_filter_in / .v_filter_out are hooks called when receiving/sending verb code.  JHCore supports a '// comment' syntax in verbs and conversion is made from '// blah' to '"blah";' by using the verbs :verbcode_external_to_internal / :verbcode_internal_to_external.
2

2
.v_filter_in / .v_filter_out are both 2 element lists containing an object id and a verb.  the JHCore configuration is:
2

2
    this.v_filter_in = { this, "verbcode_external_to_internal" }
2
    this.v_filter_out = { this, "verbcode_internal_to_external" }
2

2
Non JHCore installations might choose to set .v_filter_in / .v_filter_out to false (0, "" or {}) which leaves code lines unfiltered.
2

2

98
5
4
2
0
16249
0
1648488120
36
1
#114
Integer Prototype
0
2
1
-1
0
0
4
0
1
120
4
0
1
*
2
173
-1
0
0
#115
List Prototype
0
2
1
-1
0
0
4
0
1
120
4
0
5
add remove
2
173
-1
delete_index
2
173
-1
insert append
2
173
-1
merge
2
173
-1
*
2
173
-1
0
0
#116
MCP Help Database
16
98
1
-1
0
0
4
0
1
30
4
0
0
13
mcp
mcp-authentication
mcp-display-url
mcp-edit
mcp-ftp
mcp-goals
mcp-gopher
mcp-requests
mcp-semantics
mcp-spec
mcp-syntax
mcp-x-audio
mcp-index
19
4
11
2
MCP
2
1==
2

2
Rewritten from `help mcp-spec' June 7, 1994 by Jay Carlson.  Comments solicited; send mail to the `@proj usability client MCP' mailing list, moo-cows, or private email to j@io.com.
2

2
The MOO Client Protocol is a standard for transmitting structured "requests" between MUD clients and servers.  The original specification is available as `help mcp-spec', but the skeleton of a rewrite is here:
2

2
mcp-goals -- History and goals of the MCP protocol
2
mcp-syntax -- Syntactic description of MCP requests
2
mcp-semantics -- Semantics of MCP requests
2
mcp-requests -- Documented request types
98
5
4
15
2
MCP authentication
2
1=================
2

2
When an MCP client connects to an MCP server, it may set an `authentication key' for the duration of the connection.  The key is simply a string (in the format described in `help mcp-syntax') that must be sent by the server with every MCP request for the request to be authenticated.  The authentication key is a secret shared by the client and the MCP subsystem of the server.
2

2
The syntax for setting the authentication key is:
2

2
  #$#authentication-key <auth-key>
2
 
2

2
Clients may accept, reject, or query the user about MCP requests that are either missing an authentication key or have the incorrect key.
2

2
Typically, clients will generate a random number or string on connection and use it as their key.
2

2
Proposal: eliminate reference to client and server, and make the authentication scheme symmetric.
98
5
4
22
2
MCP display-url request
2
1======================
2

2
This is a simplification of the display-url request specification used by AstroVR.  It is intended to represent baseline functionality that most clients can implement.
2

2
display-url presents a document specified by a URL to the user.
2

2
Keywords
2
2=======
2

2
url:
2
3===
2

2
Required.  Must be an absolute URL, starting with a name scheme (such as "http:").
2

2
Example
2
2======
2

2
Present the JHM home page:
2

2
  #$#display-url 12345678 url: "http://jhm.ccs.neu.edu:7043/"
2
 
98
5
4
47
2
MCP edit* requests
2
1=================
2

2
A multi-line request for the client to invoke a local editor on the attached text, and later send the edited text to the server.
2

2
Keywords
2
2=======
2

2
type:
2
3====
2

2
Optional.  Suggested values include program, text, string, value and mail.  The client may be able to use this information to provide a specialized editing mode.
2

2
name:
2
3====
2

2
Optional.  A human-readable descriptive name for what's being edited.
2

2
In existing Emacs clients, this is used for the buffer name.  In tkmoo, name: is used as the window and icon title for the workspace editing the text.
2

2
upload:
2
3======
2

2
Required.  Specifies a line to prefix the edited text with before sending to the server.  When the text is sent to the server, it is followed by a line of a single period.
2

2
Notes
2
2====
2

2
Typically the upload: value will be a command that starts reading input from the player, like @paste or @qsend; the MOO will use $command_utils:read_lines() to consume the uploaded lines.
2

2
Proposal: Every known use of #$#edit requires "." as its final line sent back to the server.  Worse, it's not defined that dot-quoting should be performed on the uploaded text, which $command_utils:read_lines() expects.  We should either explicitly state these things, or we should use multi-line MCP requests to send the text back to the server.
2

2
Examples
2
2=======
2

2
A request to provide an editing session for a property:
2

2
  #$#edit* 12345678 type: text name: Dave.test upload: "@set-note-text #75.test"
2
  @@@This is a test.
2
  @@@
2
  #$#END
2

2
A request to provide an editing session for a verb:
2

2
  #$#edit* 12345678 type: program name: Dave:test upload: "@program #75:test none none none"
2
  @@@player:tell("This is a test.");
2
  #$#END
98
5
4
42
2
MCP ftp request
2
1==============
2

2
I don't understand the semantics of the ftp request fully.  AstroVR uses this protocol to move remote files into users' directories.
2

2
This specification does not specify whether anonymous ftp or authenticated ftp is used.
2

2
Keywords
2
2=======
2

2
host:
2
3====
2

2
Required.  Name of the FTP host containing the document.
2

2
directory:
2
3=========
2

2
Required.  The directory containing the document.
2

2
file:
2
3====
2

2
Required.  The filename of the document.
2

2
type:
2
3====
2

2
Required.  File type of the document.  Possible values are "ascii", "binary", "fits", "plaintext", "postscript", "compressed", and "tar".
2

2
destination:
2
3===========
2

2
Required.  Directory on the local machine the document is to be placed in.
2

2
Example
2
2======
2

2
Upload a file from an anonymous ftp site:
2

2
  #$#ftp 12345678 host: ipac.caltech.edu directory: /pub/deposit file: mud.el.Z type: "compressed ascii" destination: clients/mud.el.Z
2
 
98
5
4
12
2
MCP goals
2
1========
2

2
Most MUD clients and servers communicate by an informal protocol: lines of printable ASCII characters separated by newlines.  This is closely related to the TELNET protocol, which will in fact interoperate with MUD servers.  But TELNET clients don't provide user interface support for even the simplest of MUD tasks.  Specialized MUD clients provided these tools.
2

2
Once people started to use clients, several realized that intelligence and user interface closer to the user could be exploited by the MUD.  
2

2
In particular, the LambdaCore editor system allows an option to ship whole documents (to a mud.el variant) to be edited locally, then returned.  The $gopher system can direct clients to fetch Gopher text directly (presenting a better UI and avoiding funneling texts through the MOO).
2

2
Such "requests" are out of band; that is, they can occur at any point in the interaction between client and server.  In particular, client requests may occur while a MOO is using the read() primitive.  The MOO server has a compile-time option to process lines starting with a given prefix as if they were truly out of band.
2

2
MCP is a simple protocol for transmitting structured messages between client and server.  It traffics in "requests", which have types, properties, and optional multi-line extensions.  Standard requests exist for local editing, URL display and gopher access.
98
5
4
39
2
MCP gopher request
2
1=================
2

2
The original MOO $gopher system used a private protocol.  This is a rendering of it into MCP.  It has become deprecated in favor of display-url.
2

2
Keywords
2
2=======
2

2
host:
2
3====
2

2
Required.  Name of the gopher host to connect to.
2

2
port:
2
3====
2

2
Optional.  Port number to connect to on gopher host; defaults to 70.
2

2
path:
2
3====
2

2
Optional.  Pathname to send to the gopher host.  Defaults to the empty string.
2

2
description:
2
3===========
2

2
Required.  Description string; first character is the gopher type character, rest of characters are the human-readable name of the object.
2

2
Proposal: separate type from description.
2

2
Example
2
2======
2

2
A request to retrive Gustavus Adolphus College's root menu:
2

2
  #$#gopher 12345678 host: gopher.gac.edu description: "1Gustavus Adolphus College"
2
 
2

2
Note that port and path default to 70 and "" respectively.
98
5
4
9
2
MCP requests
2
1===========
2

2
There are several standard MCP request types.  If clients provide functionality similar to those described below, they should implement the MCP request as documented.
2

2
mcp-edit -- Perform local editing on a text
2
mcp-gopher -- Display a gopher text to the user
2
mcp-ftp -- Use ftp to download a file to the user's machine
2
mcp-display-url -- Display a URL to the user
98
5
4
19
2
MCP request semantics
2
1====================
2

2
An MCP request is of the general form:
2

2
  #$#<request-name>[*][ <auth-key>][ <keyword>: <value>]...
2
 
2

2
<request-name> identifies the `type' of the request.  The type of the request can be thought of as a function that processes the structures in the rest of the line.
2

2
<auth-key> is an optional authentication key.  See `help mcp-authentication'.
2

2
The set of <keyword>: <value> pairs are a function mapping <keyword>s onto <value>s.  <keyword>s are names of arguments to the request; <value>s are the corresponding values of arguments.
2

2
Duplicate <keyword>s are not allowed.  Arbitrary order of <keyword>: <value> pairs is allowed.
2

2
Specific <keyword>s may be optional for a given request type, with default <value>s assumed.
2

2
<keyword>s may be unrecognized by a request type.  A suggested strategy for request handlers is to ignore any <keyword>s they don't understand.
98
5
4
131
2
MOO CLIENT REQUEST PROTOCOL
2
===========================
2

2
Erik Ostrom, Dave Van Buren, Pavel Curtis, David Nichols, Jay Carlson
2

2
22 Feb 1993
2

2
Conversion to `help help-format' 21 May 1994 by Jay Carlson.
2

2
(Any first-person pronouns refer to Erik.)
2

2
AUTHENTICATION
2
--------------
2

2
An authentication key is generated and uploaded by the client to the server at login.  Proposed method:
2

2
  #$#authentication-key <key>
2
 
2

2
This requires that the server be compiled with OUT_OF_BAND_PREFIX set to "#$#".  (It's actually possible to do it as a verb on $player, but many MOOs have a programmer command "#" which does something very different.)  The authentication key may not contain spaces, double-quotes, colons, or backslashes.
2

2
GENERAL RULES
2
-------------
2

2
String sent by server:
2

2
  #$#<request-name><*-if-data-follows> [<auth-key>] <keyword>: <value> ...
2
 
2

2
An identifying tag #$# is placed at the beginning of the request line.
2

2
  o  <request-name> is the type of request, e.g. "edit" or "ftp".
2
  o  <request-name> cannot contain spaces, double-quotes, backslashes, or asterisks.
2
  o  <*-if-data-follows> is either "*" if this request is followed by additional lines of data, or the empty string.
2
  o  <keyword> is the name of an argument to the request.  Keywords cannot contain spaces, double-quotes, colons, or backslashes.
2
  o  <value> is the value of the corresponding argument.  A <value> can contain any printing ASCII character (including space), but must be quoted in the standard MOO style (with double quotes, using backslash to escape quotes and backslashes) if it either contains spaces or is the empty string.  Arbitrary order of keyword: value pairs is allowed.
2

2
Keyword: value pairs may be optional.  We haven't discussed what clients should do with unrecognized keywords; my plan is for the client simply to ignore them and work with the keywords it recognizes.
2

2
REQUEST DEFINITIONS
2
-------------------
2

2
edit
2
====
2

2
type: <program|text|string|value|mail|...>
2

2
Type of information.  Clients may or may not be able to use a special editing mode depending on type.
2

2
name: <name>
2

2
User-friendly indication of what's in this.  Good for buffer name.
2

2
upload: <command>
2

2
Command to use to begin upload of this text.
2

2
ftp
2
===
2

2
host: <name>
2

2
Name of the host that has the document.
2

2
directory: <dir>
2

2
Name of the directory that the document is in.
2

2
file: <name>
2

2
Name of the file within the directory.
2

2
type: <type>
2

2
Type of document.  Current types include ($ftp.recognized_types):
2

2
      {"ascii", "binary", "fits", "plaintext", "postscript",
2
       "compressed", "tar"}
2

2
destination: <dir>
2

2
Place to store the document locally.  I don't fully understand this.
2

2
gopher
2
======
2

2
(Larry has a local-gopher protocol--this is my attempt to render it into the New Protocol.)
2

2
host: <name>
2

2
Name of the host to connect to.
2

2
port: <number>
2

2
Port to connect to.  Default is 70.
2

2
path: <string>
2

2
String to send to the gopher server.  Default is the empty string.
2

2
description:
2

2
Description string.  First character is the type character, rest of characters are human-readable name of object.  This seems unnecessarily arcane to me--why not separate these?
2

2
EXAMPLES
2
--------
2

2
A request to provide an editing session for a property.  The request is followed by lines of data, prepended with a special tag (@@@, unless someone has strong feelings about changing it), and marked at the end with another tag (#$#END, again subject to change).  The advantage of this over dot-quoting is that it should be fairly easy for the client to figure out if there's been some breakage on the server end and the transmission has terminated early.  (A line that doesn't start with @@@ and isn't #$#END should set off warning bells.)
2

2
  #$#edit* 12345678 type: text name: Dave.test upload: "@set-note-text #75.test"
2
  @@@This is a test.
2
  @@@
2
  #$#END
2

2
A request to provide an editing session for a verb.
2

2
  #$#edit* 12345678 type: program name: Dave:test upload: "@program #75:test none none none"
2
  @@@player:tell("This is a test.");
2
  #$#END
2

2
A request to upload a file from an anonymous ftp site.  The request line contains all the data necessary.
2

2
  #$#ftp 12345678 host: ipac.caltech.edu directory: /pub/deposit file: mud.el.Z type: "compressed ascii" destination: clients/mud.el.Z
2
 
2

2
A request to retrieve a document from a gopher server.
2

2
  #$#gopher 12345678 host: gopher.gac.edu description: "1Gustavus Adolphus College"
2
 
2

2
In this case, we take advantage of default values for the port: and path: arguments ("70" and "", respectively).
98
5
4
34
2
MCP request syntax
2
1=================
2

2
Input and output to and from client and server is presumed to be divided into records (called `lines' hereafter).
2

2
An MCP request is of the general form:
2

2
  #$#<request-name>[*][ <auth-key>][ <keyword>: <value>]...
2
 
2

2
"#$#" must be the first three characters in the line.
2

2
<request-name> is a string of one or more printable ASCII characters.  It may not contain spaces, double-quotes, backslashes or asterisks.
2

2
Proposal: require <request-name> to start with a letter.  This reserves a substantial part of the namespace for private out-of-band protocols, or other protocol extensions.
2

2
<auth-key> is a string of one or more printable ASCII characters.  It may not contain spaces, double-quotes, colons or backslashes.
2

2
<keyword> is a string of one or more printable ASCII characters.  It may not contain spaces, double-quotes, colons, or backslashes.
2

2
<value> is 
2

2
  o  a string of one or more printable ASCII characters not containing spaces, double-quotes or backslashes 
2
  o  OR is a string of zero or more printable ASCII characters, enclosed in double-quotes, with double-quotes and backslashes inside the string `quoted' by preceding them with a backslash.
2

2
Note that the empty string must be quoted.  Also, the ASCII TAB character is not allowed in <value>s, at all.
2

2
Proposal: disallow unquoted <value>s with colons in them.  This is not strictly necessary, but it could detect some bugs in MCP request generators.
2

2
If the asterisk after <request-name> is present, this line starts a `multi-line request'.  Zero or more lines of data associated with the request follow, prepended with "@@@".  These lines are terminated with a single line of the form "#$#END".
2

2
Note that the 1.7.7 LambdaMOO server cannot properly handle multi-line requests sent by a client if OUT_OF_BAND_PREFIX is defined as "#$#".
2

2
Proposal: multi-line requests, in their current form, should be deprecated in favor of some other construct providing this functionality.
98
5
4
30
2
MCP x-audio request
2
1==================
2

2
This is a description of the interim protocol tkmoo uses to provide a single channel of multicast audio.  New requests change the channel.
2

2
Keywords
2
2=======
2

2
my-name
2
3======
2

2
Optional.  Name to identify the user inside a multicast conference.  Defaults to username.
2

2
key
2
3==
2

2
Optional.  Encryption key for the channel.  Defaults to "", which is no key.
2

2
address
2
3======
2

2
Required.  Multicast address 
2

2
ttl
2

2

2
port
2

2
title
2

98
5
4
2
2
*index*
2
MCP help topics
98
5
5
98
5
4
1
2
mcp-index
36
1
0
0
98
4
4
1
2
MCP Help Database
98
5
5
98
5
4
2
0
23287
0
1648488120
36
1
#117
Map Prototype
0
2
1
-1
0
0
4
0
1
120
4
0
4
keys values delete
2
173
-1
merge
2
173
-1
generate_json json
2
173
-1
*
2
173
-1
1
frob_key_name
1
2
__prototype__
2
5
#118
Generic Waif
0
2
1
-1
0
0
4
0
1
1
4
0
2
:initialize
2
173
-1
new
2
173
-1
2
:wizard
help_msg
6
0
0
2
0
4
50
2
A waif is a kind of datatype in the MOO programming language, akin to integers, floating point numbers, strings, lists, objects and errors.
2

2
Waifs are like objects in that they have inherited properties and verbs.  They are unlike objects in that they do not have object numbers, and do not ordinarily have a name, aliases, a location, or a description -- although they could.
2

2
For those who program in C, it may be helpful to think of a waif as being like the 'struct' datatype:  A waif is a collection of named values.  (A list is a collection of ordered values.)
2

2
Every waif inherits its properties and verbs from its 'class', which is an actual object that is a descendant of $waif.  Only properties and verbs whose names begin with a colon are inherited by the instantiated waif.  To create a waif, you invoke the verb <class>:new(), which returns the newly-minted waif as it's value.
2

2
A logical time to consider using waifs is in lieu of storing data as a list of lists.  Let's consider an example.  Suppose I want to create a bot that serves drinks and canapes, and for reasons of my own I want to specify what drinks are available rather than let some lout order a glass of diesel fuel at my tea party.  So I am going to create a list of drinks, the kind of container the drink comes in, and the number of sips in each, such that a cup of tea might have more sips (and thus take longer to drink) than a glass of sherry.
2

2
If I were to implement my drink list as a list of lists, I might do
2

2
  @prop bot.drink_options {{"tea", "cup", 10}, {"sherry", "glass", 4}, {"milk", "glass", 15}}
2

2
You can see that a glass of milk has more in it than a glass of sherry.  BUT, if you were looking at this code for the first time, you might not know that the third number in that list refers to quantity.  For longer sublists, it can get very confusing, indeed.
2

2
To implement this using waifs, you would first make an object, a kid of $waif, that you would use as a drink specification:
2

2
  @create $waif named "drink specification","dspec"
2

2
You would then own an object with the generic waif as its parent.  Next you would add properties to this object that the waifs are to inherit:
2

2
  @prop dspec.:drink_name "" rc
2
  @prop dspec.:drink_container "" rc
2
  @prop dspec.:sips_per_container 0 rc
2

2
Notice that each property name begins with a colon.  Property names that don't begin with a colon are not inherited by the waifs (.name, for example).
2

2
Since your drink specification is a kid of $waif, it inherits the verb :new that can be used to create a waif.  Here is how we would make a few:
2

2
  @prop bot.drink_options {} rc
2
  @prop bot.drink_spec <dspec> rc
2

2
  @verb bot:add_drink tnt rxd
2

2
  @program bot:add_drink
2
  "Adds a drink specification to this bot's .drink_options property.";
2
  "Maybe put in some code only to let the owner do this, but that is not germaine to this example.";
2
  {drink_name, drink_container, sips_per_container} = args;
2
  new_spec = this.drink_spec:new();
2
  new_spec.drink_name = drink_name;
2
  new_spec.drink_container = drink_container;
2
  new_spec.sips_per_container = sips_per_container;
2
  this.drink_options = {@this.drink_options, new_spec};
2
  "A robust version of this verb would check for proper data types in the args, maybe look for duplicates first, etc.";
2
  .
2

2
Later on you might want to specify a color for each drink, so that if it comes in a dribble glass, you can say what color the stain on your poor victim's tie is.  You would add the property (.:color -- remember the colon) to the drink spec object, and voila, it would exist on all the waifs.  You would need to set the individual values, of course, but you wouldn't have to do gymnastics on sublists in lists, which can be a delicate operation indeed.
2

2
Further information about waifs is available at http://www.ben.com/MOO/waif.html and http://www.ben.com/MOO/waif-progman.html
2
5
0
0
2
4
4
1
2
Generic Waif
2
5
5
2
5
4
2
0
6412
0
1648488120
36
1
#119
String Prototype
0
2
1
-1
0
0
4
0
1
120
4
0
1
*
2
173
-1
0
0
#120
Generic Base Primitive
0
2
1
-1
0
0
4
0
1
-1
4
5
1
117
1
119
1
115
1
114
1
111
2
length
2
173
-1
*
2
173
-1
0
0
#121
dns-com-vmoo-client
0
98
1
-1
0
0
4
0
1
104
4
0
7
handle_info
98
173
-1
handle_screensize
98
173
-1
init_for_core
98
173
-1
send_disconnect
98
173
-1
get_client_info
98
173
-1
adjust_linelen
2
173
-1
prune_client_info
98
173
-1
2
client_info
client_stats
10
4
2
4
3
0
1641541157
1
2
4
3
2
RMOO (Emacs)
2
1.3b
2
0
4
3
0
1550351436
1
98
4
3
2
wxpymoo
2
0.2
2
0.2
98
0
4
0
98
5
5
98
1
5
98
1
4
2
4
2
2
screensize
4
2
2
cols
2
rows
4
2
2
info
4
3
2
name
2
text-version
2
internal-version
98
1
4
1
4
2
2
disconnect
4
1
2
reason
98
1
0
0
98
4
4
1
2
dns-com-vmoo-client
98
5
5
98
5
4
2
0
6665
0
1648488120
36
1
#122
Generic Anonymous Object
0
2
1
-1
0
0
4
0
1
-1
4
3
1
108
1
125
1
127
1
new
2
173
-1
0
0
#123
dns-com-awns-status
0
98
1
-1
0
0
4
0
1
104
4
0
1
status
98
173
-1
0
8
4
2
2
1.0
2
1.0
98
1
5
98
1
5
98
1
4
1
4
2
2

4
1
2
text
98
1
0
0
98
4
4
1
2
dns-com-awns-status
98
5
5
98
5
4
2
0
1394
0
1648488120
36
1
#124
Generic Editor Utilities
0
2
1
-1
0
0
4
0
1
78
4
0
36
editor
2
173
-1
parse_range
2
172
-1
get_opt*ion
2
173
-1
options
2
172
-1
log_last_edit
2
172
-1
get_last_edit
2
172
-1
refresh_last_edits
2
172
-1
save
2
172
-1
session_for
2
172
-1
is_editing
2
172
-1
program_verb
2
173
-1
cmd_insert
2
173
-1
cmd_load
2
173
-1
cmd_save
2
173
-1
cmd_pass
2
173
-1
cmd_reload
2
173
-1
cmd_changeline
2
173
-1
cmd_grep
2
173
-1
cmd_quit
2
173
-1
cmd_delete
2
173
-1
cmd_list
2
173
-1
cmd_count
2
173
-1
cmd_help
2
173
-1
cmd_paste_letter
2
173
-1
cmd_commentify
2
173
-1
cmd_uncommentify
2
173
-1
cmd_traceback
2
173
-1
cmd_print_traceback
2
173
-1
cmd_format
2
173
-1
do_add_line
2
173
-1
set_option
2
173
-1
cmd_show_clipboard
2
173
-1
cmd_localedit
2
173
-1
cmd_replace
2
173
-1
init_for_core
2
173
-1
list_line
2
173
-1
4
default_options
last_edits
sessions
help
9
10
9
2
buffer_external_output
0
0
2
cmd_char
2
/
2
color_indicator
2

2
color_line
2

2
default_editor
0
0
2
escape_char
2
\
2
expert
0
0
2
jump_to_error
0
0
2
no_line_notifies
0
1
2
5
4
0
2
4
4
0
2
4
4
24
4
2
2
insert
2
Change the insertion point.
4
2
2
del
2
Delete a line or multiple lines using ranges.
4
2
2
pass
2
Pass a command through the editor to your character. (For example, '/pass say Hello.' would allow you to say hello while still editing text.)
4
2
2
list
2
View text written so far. To change what is shown, insert at a different line. You can use line ranges with this command. Providing 'all' as an argument will list everything.
4
2
2
abort
2
Throw away text.
4
2
2
done
2
 Same as hitting period (.).
4
2
2
help
2
This help.
4
4
2
find
2
Search text from the insertion point onward. Will place the caret on any results located.
2

2
If the insertion point is at the very end, it will search from the beginning of the text.
4
2
2
format
2
Format lines correctly so they don't go off the screen, based on your linelength preferences.
4
2
2
set
2
Change editor options; is a shortcut for the EDIT-OPTIONS command.
4
2
2
spellcheck
2
Check the text you've written for spelling errors.
4
2
2
count
2
Displays how many <lines|words|characters> are written so far.
4
2
2
import
2
Insert the text of a note or letter that's in your hand. (You can only insert notes that you can read.)
4
2
2
change
2
Replace <line-number> with <text>.
4
2
2
tb
2
Jump to the line indicated in the last traceback.
4
2
2
ptb
2
Print the last traceback.
4
2
2
verb
2
Display the verb you're currently editing.
4
2
2
compile
2
Send the editor contents to the MOO as code for the currently edited verb. Does NOT close the editor session.
4
2
2
copy
2
By default, copies the full text of the buffer to a temporary clipboard. You can optionally specify a range (e.g. COPY 2..5). You can then PASTE it in another edit session.
4
2
2
paste
2
Paste copied text.
4
2
2
clipboard
2
Review text that's currently on your clipboard.
4
2
2
comment
2
Turn a verb line into a comment.
4
2
2
uncomment
2
Turn a comment into a line of code.
4
3
2
replace
2
Run a Perl Compatible Regular Expressions replacement on the body of the text.
2
For information on how PCRE replacements work, check https://www.regular-expressions.info/perl.html
2
5
4
8
2
The inline editor is a vastly improved version of the current prompt that accepts multiple lines. It allows for insert and delete operations, text pasting or auto-formatting, as well as spell checking and other functions. 
2

2
The editor is highly customizable. To change different aspects of editing, type EDIT-OPTIONS (or simply EDIT-O). For help on the different commands available to you while editing, you can use the HELP command inside the editor. This is accessible by typing your command character, which is a forward slash (/) by default, followed by the word HELP.
2

2
Credit goes to:
2

2
        - Initially created in 2015 by Victor@Toastsoft.net.
2
        - Improved by Lisdude in 2017-2018 in numerous ways.
2
5
0
0
2
4
4
10
2
generic inline editor
2
inline editor
2
inline
2
flexible editor interface utilities
2
editor interface utilities
2
interface utilities
2
utilities
2
editor
2
interface
2
flexible
2
5
2
This is a placeholder parent for all the $..._utils packages, to more easily find them and manipulate them. At present this object defines no useful verbs or properties. (Filfre.)
2
5
4
2
0
52488
0
1648488120
36
1
#125
Generic Editing State Anon
0
2
1
-1
0
0
4
0
1
122
4
0
1
new
2
173
-1
11
text
cursor
error_line
verb
extra
ins
command
arg
verb_name
traceback
traceback_line
11
4
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
0
0
2
5
#126
Menu Utilities
0
2
1
-1
0
0
4
0
1
78
4
0
3
menu
2
173
-1
return_map_verb
36
173
-1
options_menu
2
173
-1
0
5
5
2
5
0
0
2
4
4
1
2
Menu Utilities
2
5
5
2
5
4
2
0
8055
0
1648488120
36
1
#127
Generic Editor Session
0
2
1
-1
10
0
4
0
1
122
4
0
0
3
last_modified
player
text
3
0
0
2
5
0
0
2
5
4
0
2
5
1
#128

0
98
1
-1
10
0
4
0
1
108
4
0
0
0
7
1
2
98
1
5
98
0
5
98
1
5
98
0
5
98
1
5
98
0
5
98
1
0
1937
#0:0
"...This code should only be run as a server task...";
if (callers())
return E_PERM;
endif
"...perform a threaded DNS name lookup and store the result for the duration of the connection...";
$login:connection_name_lookup(player);
if (typeof(h = $network:incoming_connection(player)) == OBJ)
"connected to an object";
$login:delete_name_lookup(player);
switch_player(player, h);
return;
elseif (h)
return 0;
endif
host = $string_utils:connection_hostname(player);
if ($login:redlisted(host))
boot_player(player);
server_log(tostr("REDLISTED: ", player, " from ", host));
return 0;
endif
"HTTP server by Krate";
try
newargs = $http:handle_connection(@args);
if (!newargs)
return 0;
endif
args = newargs;
except v (ANY)
endtry
"...checks to see if the login is spamming the server with too many commands...";
if (!$login:maybe_limit_commands())
args = $login:parse_command(@args);
retval = $login:(args[1])(@listdelete(args, 1));
if (typeof(retval) == OBJ)
$login:delete_name_lookup(player);
switch_player(player, retval);
return;
else
return retval;
endif
endif
.
#0:1
if (!callers())
$server["last_restart_time"] = time();
$network:server_started();
$login:server_started();
endif
.
#0:2
set_task_perms($no_one);
{?core_variant = "Imnotsurewhatthisshouldbeyetdontdependonthis", ?in_mcd = 0} = args;
if (in_mcd)
{vb, perms, loc} = callers()[1][2..4];
if (((vb != "make-core-database") || (!perms.wizard)) || (loc != $wiz))
raise(E_PERM);
endif
endif
core_objects = {};
proxy_original = proxy_incore = core_properties = skipped_parents = namespaces = {};
todo = {{#0, {"sysobj", "owner"}}};
"...lucky for us #0 has a self-referential property";
while ({?sfc, @todo} = todo)
{o, ?props_to_follow = {}} = sfc;
o_props = {};
for p in (props_to_follow)
v = o.(p);
"...namespaces should be maps with only object values.";
if (typeof(v) == MAP)
map_values = mapvalues(v);
for x in (map_values)
if (typeof(x) != OBJ)
continue p;
endif
endfor
namespaces = {@namespaces, {o, p, v}};
core_objects = {@core_objects, @map_values};
else
for v in ((typeof(o.(p)) == MAP) ? mapvalues(o.(p)) | {o.(p)})
if ((typeof(v) != OBJ) || (!valid(v)))
continue p;
endif
o_props = {@o_props, p};
if ((v in proxy_original) || (v in core_objects))
"...we have been here before...";
continue p;
endif
if ($object_utils:has_callable_verb(v, "proxy_for_core"))
"...proxy_for_core() returns an object to";
"...take the place of v in the final core.";
"...For * verbs, proxy_for_core will also accept {}";
proxy_original[1..0] = {v};
try
vnew = v:proxy_for_core(core_variant, in_mcd);
if ((typeof(vnew) in {OBJ, LIST}) == 0)
raise(E_TYPE, "returned non-object, non-empty list");
elseif ((vnew in proxy_original) > 1)
raise(E_RECMOVE, "proxy loop");
endif
except e (ANY)
player:notify(tostr("Error from ", v, ":proxy_for_core => ", e[2]));
player:notify(toliteral(e[4]));
vnew = #-1;
endtry
if ((vnew == v) || (typeof(vnew) == LIST))
proxy_original[1..1] = {};
else
proxy_incore[1..0] = {vnew};
if ((vnew in core_objects) || (!valid(vnew)))
continue p;
endif
v = vnew;
endif
endif
if ($object_utils:has_callable_verb(v, "include_for_core"))
"...include_for_core() returns a list of properties on v";
"...to be searched for additional core objects.";
try
v_props = v:include_for_core(core_variant);
if (typeof(v_props) != LIST)
raise(E_TYPE, "returned non-list");
endif
if (v_props)
todo = {@todo, {v, v_props}};
endif
except e (ANY)
player:notify(tostr("Error from ", v, ":include_for_core => ", e[2]));
player:notify(toliteral(e[4]));
endtry
endif
core_objects = setadd(core_objects, v);
endfor
endif
endfor
core_properties = {@core_properties, {o, o_props}};
endwhile
for o in (core_objects)
p = parent(o);
while (valid(p))
if (!(p in core_objects))
skipped_parents = setadd(skipped_parents, p);
endif
p = parent(p);
endwhile
endfor
if (verb == "core_object_info")
"... what make-core-database needs";
return {core_objects, core_properties, skipped_parents, proxy_original, proxy_incore, namespaces};
else
"... what most people care about";
return core_objects;
endif
.
#0:3
if (caller_perms().wizard)
pass(@args);
`delete_property(this, "mail_name_db") ! E_PROPNF';
`delete_verb(this, "do_command") ! E_VERBNF';
$server["core_history"] = {{$network.MOO_name, server_version(), time()}, @$server["core_history"]};
$wiz_utils.shutdown_message = "";
$server["shutdown_time"] = 0;
$server_options.dump_interval = 3600;
$wiz_utils.gripe_recipients = {player};
for v in ({"do_login_command", "server_started"})
c = {};
for i in (verb_code(this, v))
c = {@c, strsub(i, "$local.login", "$login")};
endfor
set_verb_code(#0, v, c);
endfor
endif
.
#0:4
"Copied from The System Object (#0):user_connected by Slartibartfast (#4242) Sun May 21 18:14:16 1995 PDT";
if (callers())
return;
endif
$mcp:(verb)(@args);
user = args[1];
set_task_perms(user);
try
user.location:confunc(user);
user:confunc();
except id (ANY)
user:tell("Confunc failed: ", id[2], ".");
for tb in (id[4])
user:tell("... called from ", tb[4], ":", tb[2], (tb[4] != tb[1]) ? tostr(" (this == ", tb[1], ")") | "", ", line ", tb[6]);
endfor
user:tell("(End of traceback)");
endtry
.
#0:5
if (callers())
return;
endif
if (args[1] < #0)
"not logged in user.  probably should do something clever here involving Carrot's no-spam hack.  --yduJ";
"...'forget' that we already performed a name lookup on this connection...";
$login:delete_name_lookup(args[1]);
return;
endif
$mcp:(verb)(@args);
user = args[1];
user.last_disconnect_time = time();
set_task_perms(user);
where = user.location;
`user:disfunc() ! ANY => 0';
if (user.location != where)
`where.location:disfunc(user) ! ANY => 0';
endif
`user.location:disfunc(user) ! ANY => 0';
.
#0:6
"chparent(object, new-parent) -- see help on the builtin.";
who = caller_perms();
{what, papa} = args;
if (typeof(what) != OBJ)
retval = E_TYPE;
elseif (!valid(what))
retval = E_INVARG;
elseif (typeof(papa) != OBJ)
retval = E_TYPE;
elseif ((!valid(papa)) && (papa != #-1))
retval = E_INVIND;
elseif (!$perm_utils:controls(who, what))
retval = E_PERM;
elseif ((is_player(what) && (!$object_utils:isa(papa, $player_class))) && (!who.wizard))
retval = E_PERM;
elseif ((is_player(what) && (!$object_utils:isa(what, $player_class))) && (!who.wizard))
retval = E_PERM;
elseif ((children(what) && $object_utils:isa(what, $player_class)) && (!$object_utils:isa(papa, $player_class)))
retval = E_PERM;
elseif ((is_player(what) && (what in $wiz_utils.chparent_restricted)) && (!who.wizard))
retval = E_PERM;
elseif ((((what.location == $mail_agent) && $object_utils:isa(what, $mail_recipient)) && (!$object_utils:isa(papa, $mail_recipient))) && (!who.wizard))
retval = E_PERM;
elseif ((!valid(papa)) || ($perm_utils:controls(who, papa) || papa.f))
retval = `chparent(@args) ! ANY';
else
retval = E_PERM;
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
.
#0:7
"add_verb() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_verb exists and is true and caller_perms() are not wizardly.";
who = caller_perms();
what = args[1];
info = args[2];
if (typeof(what) != OBJ)
retval = E_TYPE;
elseif (!valid(what))
retval = E_INVARG;
elseif ((!$perm_utils:controls(who, what)) && (!what.w))
"caller_perms() is not allowed to hack on the object in question";
retval = E_PERM;
elseif (!$perm_utils:controls(who, info[1]))
"caller_perms() is not permitted to add a verb with the specified owner.";
retval = E_PERM;
elseif (index(info[2], "w") && (!$server_options.permit_writable_verbs))
retval = E_INVARG;
elseif (!$quota_utils:verb_addition_permitted(who))
retval = E_QUOTA;
elseif (((what.owner != who) && (!who.wizard)) && (!$quota_utils:verb_addition_permitted(what.owner)))
retval = E_QUOTA;
elseif (!who.programmer)
retval = E_PERM;
else
"we now know that the caller's perms control the object or the object is writable, and we know that the caller's perms control the prospective verb owner (by more traditional means)";
retval = `add_verb(@args) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
.
#0:8
"add_property() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_property exists and is true and caller_perms() are not wizardly.";
who = caller_perms();
{what, propname, value, info} = args;
if (typeof(what) != OBJ)
retval = E_TYPE;
elseif (!valid(what))
retval = E_INVARG;
elseif ((!$perm_utils:controls(who, what)) && (!what.w))
retval = E_PERM;
elseif (!$perm_utils:controls(who, info[1]))
retval = E_PERM;
elseif (!$quota_utils:property_addition_permitted(who))
retval = E_QUOTA;
elseif (((what.owner != who) && (!who.wizard)) && (!$quota_utils:property_addition_permitted(what.owner)))
retval = E_QUOTA;
"elseif (!who.programmer)";
"  return E_PERM;     I wanted to do this, but $builder:@newmessage relies upon nonprogs being able to call add_property.  --Nosredna";
elseif ((propname in {"object_size", "size_quota", "queued_task_limit"}) && (!who.wizard))
retval = E_PERM;
else
"we now know that the caller's perms control the object (or the object is writable), and that the caller's perms are permitted to control the new property's owner.";
retval = `add_property(@args) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
.
#0:9
"recycle(object) -- see help on the builtin. This verb is called by the server when $server_options.protect_recycle exists and is true and caller_perms() are not wizardly.";
{what} = args;
if (!valid(what))
retval = E_INVARG;
elseif (!$perm_utils:controls(who = caller_perms(), what))
retval = E_PERM;
elseif ((p = `is_player(what) ! E_TYPE => 0') && (!who.wizard))
for p in ($wiz_utils:connected_wizards_unadvertised())
p:tell($string_utils:pronoun_sub("%N (%#) is currently trying to destroy %t (%[#t])", who, what));
endfor
retval = E_PERM;
else
if (p)
$wiz_utils:unset_player(what);
endif
$recycler:kill_all_tasks(what);
retval = `recycle(what) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
.
#0:10
if (callers())
return;
endif
$mcp:(verb)(@args);
if ($object_utils:isa(user = args[1], $guest))
"from $guest:boot";
oldloc = user.location;
move(user, $nothing);
"..force enterfunc to be called so that the newbie gets a room description.";
move(user, user.home);
user:do_reset();
if ($object_utils:isa(oldloc, $room))
oldloc:announce("In the distance you hear someone's alarm clock going off.");
if (oldloc != user.location)
oldloc:announce(user.name, " wavers and vanishes into insubstantial mist.");
else
oldloc:announce(user.name, " undergoes a wrenching personality shift.");
endif
endif
set_task_perms(user);
`user:confunc() ! ANY';
else
set_task_perms(user);
`user:reconfunc() ! ANY';
endif
.
#0:11
"set_verb_info() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_set_verb_info exists and is true and caller_perms() are not wizardly.";
{o, v, i} = args;
if (typeof(vi = `verb_info(o, v) ! ANY') == ERR)
"probably verb doesn't exist";
retval = vi;
elseif (!$perm_utils:controls(cp = caller_perms(), vi[1]))
"perms don't control the current verb owner";
retval = E_PERM;
elseif ((typeof(i) != LIST) || (typeof(no = i[1]) != OBJ))
"info is malformed";
retval = E_TYPE;
elseif ((!valid(no)) || (!is_player(no)))
"invalid new verb owner";
retval = E_INVARG;
elseif (!$perm_utils:controls(cp, no))
"perms don't control prospective verb owner";
retval = E_PERM;
elseif (index(i[2], "w") && (!`$server_options.permit_writable_verbs ! E_PROPNF, E_INVIND => 1'))
retval = E_INVARG;
else
retval = `set_verb_info(o, v, i) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
.
#0:12
m = `match(@args) ! ANY';
return ((typeof(m) == ERR) && $code_utils:dflag_on()) ? raise(m) | m;
.
#0:13
r = `rmatch(@args) ! ANY';
return ((typeof(r) == ERR) && $code_utils:dflag_on()) ? raise(r) | r;
.
#0:14
callers() && raise(E_PERM);
$login.checkpoint_in_progress = 0;
`$local.checkpoint_notification:checkpoint_finished(@args) ! ANY';
.
#0:15
"do_out_of_band_command -- a cheap and very dirty do_out_of_band verb.  Forwards to verb on player with same name if it exists, otherwise forwards to $login.  May only be called by the server in response to an out of band command, otherwise E_PERM is returned.";
if (((caller == #-1) && (caller_perms() == #-1)) && (callers() == {}))
if (valid(player) && is_player(player))
$mcp:(verb)(@args);
set_task_perms(player);
$object_utils:has_callable_verb(player, "do_out_of_band_command") && player:do_out_of_band_command(@args);
else
$login:do_out_of_band_command(@args);
endif
else
return E_PERM;
endif
.
#0:16
if (!callers())
{code, msg, value, stack, traceback} = args;
if (!$object_utils:connected(player))
"Mail the player the traceback if e isn't connected.";
$mail_agent:send_message(#0, player, {"traceback", $wiz_utils.gripe_recipients}, traceback);
endif
"now let the player do something with it if e wants...";
return `player:(verb)(@args) ! ANY';
endif
.
#0:17
callers() && raise(E_PERM);
$login.checkpoint_in_progress = 1;
`$local.checkpoint_notification:checkpoint_started(@args) ! ANY';
.
#0:18
"Copied from Jay (#3920):bf_force_input Mon Jun 16 20:55:27 1997 PDT";
"force_input(conn, line [, at-front])";
"see help on the builtin for more information. This verb is called by the server when $server_options.protect_force_input exists and is true and caller_perms() are not wizardly.";
{conn, line, ?at_front = 0} = args;
if (caller_perms() != conn)
retval = E_PERM;
elseif (conn in $login.newted)
retval = E_PERM;
else
retval = `force_input(@args) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
.
#0:19
"Let's keep bozos from partying.  --Nosredna the partypooper";
return pass(#-1);
.
#0:20
who = caller_perms();
retval = 0;
try
{what, propname, info} = args;
except (E_ARGS)
retval = E_ARGS;
endtry
try
{owner, perms, ?newname = 0} = info;
except (E_ARGS)
retval = E_ARGS;
except (E_TYPE)
retval = E_TYPE;
endtry
if (retval != 0)
elseif ((newname in {"object_size", "size_quota", "queued_task_limit"}) && (!who.wizard))
retval = E_PERM;
else
set_task_perms(who);
retval = `set_property_info(@args) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
.
#0:21
return properties(this);
.
#0:22
if (!callers())
{resource, stack, traceback} = args;
if (!$object_utils:connected(player))
"Mail the player the traceback if e isn't connected.";
$mail_agent:send_message(#0, player, {"traceback", $wiz_utils.gripe_recipients}, traceback);
endif
"now let the player do something with it if e wants...";
return `player:(verb)(@args) ! ANY';
endif
.
#0:23
set_task_perms(caller_perms());
`player.reading_input = 1 ! E_PROPNF, E_INVIND';
input = `read(@args) ! ANY';
`clear_property(player, "reading_input") ! E_PROPNF, E_INVARG';
return ((typeof(input) == ERR) && $code_utils:dflag_on()) ? raise(input) | input;
.
#0:24
{?time = 0, @ann} = args;
return $command_utils:suspend_if_needed(time, @ann);
.
#0:25
"A quick and dirty way to pluralize a word based on a number (oftentimes the result of a length() check).";
"Usage: $verb(word, amount)";
"$s(\"credit\", 2) => \"credits\"";
"$ies(\"battery\", 2) => \"batteries\";";
"$es(\"watch\", 2) => \"watches\";";
{word, value} = args;
return (value in {1, 1.0}) ? word | (((verb == "ies") ? word[1..$ - 1] | word) + verb);
.
#1:0
if ((typeof(this) != ANON) && (typeof(this.owner.owned_objects) == LIST))
this.owner.owned_objects = setadd(this.owner.owned_objects, this);
endif
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
if (is_clear_property(this, "object_size"))
"If this isn't clear, then we're being hacked.";
this.object_size = {0, 0};
endif
this.key = 0;
else
return E_PERM;
endif
.
#1:1
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
try
if ((typeof(this.owner.owned_objects) == LIST) && (!is_clear_property(this.owner, "owned_objects")))
this.owner.owned_objects = setremove(this.owner.owned_objects, this);
$recycler.lost_souls = setadd($recycler.lost_souls, this);
endif
except (ANY)
"Oy, doesn't have a .owned_objects??, or maybe .owner is $nothing";
"Should probably do something...like send mail somewhere.";
endtry
else
return E_PERM;
endif
.
#1:2
"set_name(newname) attempts to change this.name to newname";
"  => E_PERM   if you don't own this or aren't its parent, or are a player trying to do an end-run around $player_db...";
if ((!caller_perms().wizard) && (`is_player(this) ! ANY => 0' || ((caller_perms() != this.owner) && (this != caller))))
return E_PERM;
else
return (typeof(e = `this.name = args[1] ! ANY') != ERR) || e;
endif
.
#1:3
return this.name;
.
#1:4
return `this.namec ! E_PROPNF => $string_utils:capitalize(this:title())';
.
#1:5
"set_aliases(alias_list) attempts to change this.aliases to alias_list";
"  => E_PERM   if you don't own this or aren't its parent";
"  => E_TYPE   if alias_list is not a list";
"  => E_INVARG if any element of alias_list is not a string";
"  => 1        if aliases are set exactly as expected (default)";
"  => 0        if aliases were set differently than expected";
"              (children with custom :set_aliases should be aware of this)";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
elseif (typeof(aliases = args[1]) != LIST)
return E_TYPE;
else
for s in (aliases)
if (typeof(s) != STR)
return E_INVARG;
endif
endfor
this.aliases = aliases;
return 1;
endif
.
#1:6
c = this:contents();
return $string_utils:match(args[1], c, "name", c, "aliases");
.
#1:7
":match_object(string [,who])";
args[2..1] = {this};
return $string_utils:match_object(@args);
.
#1:8
"set_description(newdesc) attempts to change this.description to newdesc";
"  => E_PERM   if you don't own this or aren't its parent";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
elseif (typeof(desc = args[1]) in {LIST, STR})
this.description = desc;
return 1;
else
return E_TYPE;
endif
.
#1:9
return this.description;
.
#1:10
desc = this:description();
if (desc)
player:tell_lines(desc);
else
player:tell("You see nothing special.");
endif
.
#1:11
if (is_player(this))
notify(this, @args);
endif
.
#1:12
this:notify(tostr(@args));
.
#1:13
lines = args[1];
if (typeof(lines) == LIST)
for line in (lines)
this:tell(line);
endfor
else
this:tell(lines);
endif
.
#1:14
set_task_perms(caller_perms());
return this:acceptable(@args);
.
#1:15
set_task_perms(this.owner);
return `move(this, args[1]) ! ANY';
.
#1:16
"eject(victim) --- usable by the owner of this to remove victim from this.contents.  victim goes to its home if different from here, or $nothing or $player_start according as victim is a player.";
"eject_basic(victim) --- victim goes to $nothing or $player_start according as victim is a player; victim:moveto is not called.";
what = args[1];
nice = verb != "eject_basic";
perms = caller_perms();
if ((!perms.wizard) && (perms != this.owner))
raise(E_PERM);
elseif ((!(what in this.contents)) || what.wizard)
return 0;
endif
if ((((nice && $object_utils:has_property(what, "home")) && (typeof(where = what.home) == OBJ)) && (where != this)) && (is_player(what) ? `where:accept_for_abode(what) ! ANY' | `where:acceptable(what) ! ANY'))
else
where = is_player(what) ? $player_start | $nothing;
endif
fork (0)
if (what.location == this)
"It didn't move when we asked it to, or :moveto is broken. Force it.";
move(what, where);
endif
endfork
return nice ? `what:moveto(where) ! ANY' | `move(what, where) ! ANY';
.
#1:17
return (this.key == 0) || $lock_utils:eval_key(this.key, args[1]);
.
#1:18
set_task_perms((caller_perms() != #-1) ? caller_perms() | player);
$command_utils:do_huh(verb, args);
.
#1:19
":set_message(msg_name,new_value)";
"Does the actual dirty work of @<msg_name> object is <new_value>";
"changing the raw value of the message msg_name to be new_value.";
"Both msg_name and new_value should be strings, though their interpretation is up to the object itself.";
" => error value (use E_PROPNF if msg_name isn't recognized)";
" => string error message if something else goes wrong.";
" => 1 (true non-string) if the message is successfully set";
" => 0 (false non-error) if the message is successfully `cleared'";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return E_PERM;
else
return `this.(args[1] + "_msg") = args[2] ! ANY' && 1;
endif
.
#1:20
"do_examine(examiner)";
"the guts of examine";
"call a series of verbs and report their return values to the player";
who = args[1];
"if (caller == this || caller == who)";
if (caller == who)
"set_task_perms();";
who:notify_lines(this:examine_names(who) || {});
"this:examine_names(who);";
who:notify_lines(this:examine_owner(who) || {});
"this:examine_owner(who);";
who:notify_lines(this:examine_desc(who) || {});
"this:examine_desc(who);";
who:notify_lines(this:examine_key(who) || {});
"this:examine_key(who);";
who:notify_lines(this:examine_contents(who) || {});
who:notify_lines(this:examine_verbs(who) || {});
else
return E_PERM;
endif
.
#1:21
"examine_key(examiner)";
"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.";
"the default will only tell the key to a wizard or this object's owner.";
who = args[1];
if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))
return {tostr("Key:  ", $lock_utils:unparse_key(this.key))};
endif
.
#1:22
"examine_names(examiner)";
"Return a list of strings to be told to the player, indicating the name and aliases (and, by default, the object number) of this.";
return {tostr(this.name, " (aka ", $string_utils:english_list({tostr(this), @this.aliases}), ")")};
.
#1:23
"examine_desc(who) - return the description, probably";
"who is the player examining";
"this should probably go away";
desc = this:description();
if (desc)
if (typeof(desc) != LIST)
desc = {desc};
endif
return desc;
else
return {"(No description set.)"};
endif
.
#1:24
"examine_contents(examiner)";
"by default, calls :tell_contents.";
"Should probably go away.";
who = args[1];
if (caller == this)
try
this:tell_contents(this.contents, this.ctype);
except (ANY)
"Just ignore it. We shouldn't care about the contents unless the object wants to tell us about them via :tell_contents ($container, $room)";
endtry
endif
.
#1:25
"Return a list of strings to be told to the player.  Standard format says \"Obvious verbs:\" followed by a series of lines explaining syntax for each usable verb.";
if (caller != this)
return E_PERM;
endif
who = args[1];
name = dobjstr;
vrbs = {};
commands_ok = `this:examine_commands_ok(who) ! ANY => 0';
dull_classes = {$root_class, $room, $player, $prog, $builder};
what = this;
hidden_verbs = this:hidden_verbs(who);
while (what != $nothing)
$command_utils:suspend_if_needed(0);
if (!(what in dull_classes))
for i in [1..length(verbs(what))]
$command_utils:suspend_if_needed(0);
info = verb_info(what, i);
syntax = verb_args(what, i);
if (this:examine_verb_ok(what, i, info, syntax, commands_ok, hidden_verbs))
{dobj, prep, iobj} = syntax;
if (syntax == {"any", "any", "any"})
prep = "none";
endif
if (prep != "none")
for x in ($string_utils:explode(prep, "/"))
if (length(x) <= length(prep))
prep = x;
endif
endfor
endif
"This is the correct way to handle verbs ending in *";
vname = info[3];
while (j = index(vname, "* "))
vname = tostr(vname[1..j - 1], "<anything>", vname[j + 1..$]);
endwhile
if (vname[$] == "*")
vname = vname[1..$ - 1] + "<anything>";
endif
vname = strsub(vname, " ", "/");
rest = "";
if (prep != "none")
rest = " " + ((prep == "any") ? "<anything>" | prep);
if (iobj != "none")
rest = tostr(rest, " ", (iobj == "this") ? name | "<anything>");
endif
endif
if (dobj != "none")
rest = tostr(" ", (dobj == "this") ? name | "<anything>", rest);
endif
vrbs = setadd(vrbs, ("  " + vname) + rest);
endif
endfor
endif
what = parent(what);
endwhile
if ($code_utils:verb_or_property(this, "help_msg"))
vrbs = {@vrbs, tostr("  help ", dobjstr)};
endif
return vrbs && {"Obvious verbs:", @vrbs};
.
#1:26
":get_message(msg_name)";
"Use this to obtain a given user-customizable message's raw value, i.e., the value prior to any pronoun-substitution or incorporation of any variant elements --- the value one needs to supply to :set_message().";
"=> error (use E_PROPNF if msg_name isn't recognized)";
"=> string or list-of-strings raw value";
"=> {2, @(list of {msg_name_n,rawvalue_n} pairs to give to :set_message)}";
"=> {1, other kind of raw value}";
"=> {E_NONE, error message} ";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (((t = typeof(msg = `this.(args[1] + "_msg") ! ANY')) in {ERR, STR}) || (((t == LIST) && msg) && (typeof(msg[1]) == STR)))
return msg;
else
return {1, msg};
endif
.
#1:27
try
this.location:(verb)(@args);
except (ANY)
endtry
.
#1:28
if (caller_perms().wizard)
deletes = {};
for vnum in [1..length(verbs(this))]
$command_utils:suspend_if_needed(0);
for name in ($string_utils:explode(verb_info(this, vnum)[3]))
if (rindex(name, "(old)") == max(1, length(name) - 4))
deletes[1..0] = {vnum};
break;
elseif (rindex(name, "(core)") == max(1, length(name) - 5))
deletes[1..0] = {vnum};
set_verb_code(this, name[1..$ - 6], verb_code(this, vnum));
break;
endif
endfor
endfor
for vnum in (deletes)
delete_verb(this, vnum);
endfor
endif
.
#1:29
"Returns a list of the objects that are apparently inside this one.  Don't confuse this with .contents, which is a property kept consistent with .location by the server.  This verb should be used in `VR' situations, for instance when looking in a room, and does not necessarily have anything to do with the value of .contents (although the default implementation does).  `Non-VR' commands (like @contents) should look directly at .contents.";
return this.contents;
.
#1:30
"examine_verb_ok(loc, index, info, syntax, commands_ok, hidden_verbs)";
"loc is the object that defines the verb; index is which verb on the object; info is verb_info; syntax is verb_args; commands_ok is determined by this:commands_ok, probably, but passed in so we don't have to calculate it for each verb.";
"hidden_verbs is passed in for the same reasons.  It should be a list, each of whose entries is either a string with the full verb name to be hidden (e.g., \"d*rop th*row\") or a list of the form {verb location, full verb name, args}.";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
{loc, index, info, syntax, commands_ok, hidden_verbs} = args;
vname = info[3];
return (((((syntax[2..3] != {"none", "this"}) && (!index(vname, "("))) && (commands_ok || ("this" in syntax))) && `verb_code(loc, index) ! ANY') && (!(vname in hidden_verbs))) && (!({loc, vname, syntax} in hidden_verbs));
else
return E_PERM;
endif
.
#1:31
"return 1 if the object can hear a :tell, or cares. Useful for active objects that want to stop when nothing is listening.";
return 0;
.
#1:32
"hidden_verbs(who)";
"returns a list of verbs on this that should be hidden from examine";
"the player who's examining is passed in, so objects can hide verbs from specific players";
"verbs are returned as {location, full_verb_name, args} or just full_verb_name.  full_verb name is what shows up in verb_info(object, verb)[2], for example \"d*op th*row\".";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
hidden = {};
what = this;
while (what != $nothing)
for i in [1..length(verbs(what))]
info = verb_info(what, i);
if (!index(info[2], "r"))
hidden = setadd(hidden, {what, info[3], verb_args(what, i)});
endif
endfor
what = parent(what);
endwhile
return hidden;
else
return E_PERM;
endif
.
#1:33
"examine_owner(examiner)";
"Return a list of strings to be told to the player, indicating who owns this.";
return {tostr("Owned by ", this.owner.name, ".")};
.
#1:34
return;
.
#1:35
lines = args[1];
if (typeof(lines) == LIST)
for line in (lines)
this:tell(line);
$command_utils:suspend_if_needed(0);
endfor
else
this:tell(lines);
endif
.
#1:36
return 0;
"intended as a 'quiet' way to determine if :accept will succeed. Currently, some objects have a noisy :accept verb since it is the only thing that a builtin move() call is guaranteed to call.";
"if you want to tell, before trying, whether :accept will fail, use :acceptable instead. Normally, they'll do the same thing.";
.
#2:0
if (!valid(who = player:my_match_object(dobjstr)))
who = player;
endif
session = $mcp:session_for(who);
packages = session.packages;
player:tell("session: ", session);
player:tell("key: ", session.authentication_key);
for p in (packages)
player:tell(p[1].name, " (", p[1], ") ", p[2][1], ".", p[2][2]);
endfor
player:tell("---");
.
#2:1
for p in (connected_players())
session = $mcp:session_for(p);
if (session:handles_package($mcp:match_package("mcp-negotiate")))
player:tell(p.name);
endif
endfor
player:tell("---");
.
#3:0
if ((((cp = caller_perms()) == player) || $perm_utils:controls(cp, player)) || (caller == this))
"Need the first check because guests don't control themselves";
this:look_self(player.brief);
this:announce($string_utils:pronoun_sub("%N %<has> connected.", player));
endif
.
#3:1
if ((((cp = caller_perms()) == player) || $perm_utils:controls(cp, player)) || (caller == this))
this:announce($string_utils:pronoun_sub("%N %<has> disconnected.", player));
"need the first check since guests don't control themselves";
if (!$object_utils:isa(player, $guest))
"guest disfuncs are handled by $guest:disfunc. Don't add them here";
$housekeeper:move_players_home(player);
endif
endif
.
#3:2
try
player:tell("You say, \"", argstr, "\"");
this:announce(player.name, " ", $gender_utils:get_conj("says", player), ", \"", argstr, "\"");
except (ANY)
"Don't really need to do anything but ignore the idiot who has a bad :tell";
endtry
.
#3:3
if ((argstr != "") && (argstr[1] == ":"))
this:announce_all(player.name, argstr[2..length(argstr)]);
else
this:announce_all(player.name, " ", argstr);
endif
.
#3:4
for dude in (setremove(this:contents(), player))
try
dude:tell(@args);
except (ANY)
"Just skip the dude with the bad :tell";
continue dude;
endtry
endfor
.
#3:5
what = args[1];
if (what)
yes = $failed_match;
for e in (this.exits)
if (valid(e) && (what in {e.name, @e.aliases}))
if (yes == $failed_match)
yes = e;
elseif (yes != e)
return $ambiguous_match;
endif
endif
endfor
return yes;
else
return $nothing;
endif
.
#3:6
set_task_perms(caller_perms());
return `this.exits = setadd(this.exits, args[1]) ! E_PERM' != E_PERM;
.
#3:7
{contents, ctype} = args;
if ((!this.dark) && (contents != {}))
if (ctype == 0)
player:tell("Contents:");
for thing in (contents)
player:tell("  ", thing:title());
endfor
elseif (ctype == 1)
for thing in (contents)
if (is_player(thing))
player:tell($string_utils:pronoun_sub(tostr("%N ", $gender_utils:get_conj("is", thing), " here."), thing));
else
player:tell("You see ", thing:title(), " here.");
endif
endfor
elseif (ctype == 2)
player:tell("You see ", $string_utils:title_list(contents), " here.");
elseif (ctype == 3)
players = things = {};
for x in (contents)
if (is_player(x))
players = {@players, x};
else
things = {@things, x};
endif
endfor
if (things)
player:tell("You see ", $string_utils:title_list(things), " here.");
endif
if (players)
player:tell($string_utils:title_listc(players), (length(players) == 1) ? " " + $gender_utils:get_conj("is", players[1]) | " are", " here.");
endif
endif
endif
.
#3:8
if (!$perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))
player:tell("Sorry, only the owner of a room may list its exits.");
elseif (this.exits == {})
player:tell("This room has no conventional exits.");
else
try
for exit in (this.exits)
try
player:tell(exit.name, " (", exit, ") leads to ", valid(exit.dest) ? exit.dest.name | "???", " (", exit.dest, ") via {", $string_utils:from_list(exit.aliases, ", "), "}.");
except (ANY)
player:tell("Bad exit or missing .dest property:  ", $string_utils:nn(exit));
continue exit;
endtry
endfor
except (E_TYPE)
player:tell("Bad .exits property. This should be a list of exit objects. Please fix this.");
endtry
endif
.
#3:9
{?brief = 0} = args;
player:tell(this:title());
if (!brief)
pass();
endif
this:tell_contents(setremove(this:contents(), player), this.ctype);
.
#3:10
what = args[1];
return this:is_unlocked_for(what) && (((this:free_entry(@args) || ((what == this.blessed_object) && (task_id() == this.blessed_task))) || (what.owner == this.owner)) || ((typeof(this.residents) == LIST) && ((what in this.residents) || (what.owner in this.residents))));
.
#3:11
set_task_perms(caller_perms());
return `this.entrances = setadd(this.entrances, args[1]) ! E_PERM' != E_PERM;
.
#3:12
if (caller in {@this.entrances, this})
this.blessed_object = args[1];
this.blessed_task = task_id();
endif
.
#3:13
if (!$perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))
player:tell("Sorry, only the owner of a room may list its entrances.");
elseif (this.entrances == {})
player:tell("This room has no conventional entrances.");
else
try
for exit in (this.entrances)
try
player:tell(exit.name, " (", exit, ") comes from ", valid(exit.source) ? exit.source.name | "???", " (", exit.source, ") via {", $string_utils:from_list(exit.aliases, ", "), "}.");
except (ANY)
player:tell("Bad entrance object or missing .source property: ", $string_utils:nn(exit));
continue exit;
endtry
endfor
except (E_TYPE)
player:tell("Bad .entrances property. This should be a list of exit objects. Please fix this.");
endtry
endif
.
#3:14
if ((!args) || (!(dir = args[1])))
player:tell("You need to specify a direction.");
return E_INVARG;
elseif (valid(exit = player.location:match_exit(dir)))
exit:invoke();
if (length(args) > 1)
old_room = player.location;
"Now give objects in the room we just entered a chance to act.";
suspend(0);
if (player.location == old_room)
"player didn't move or get moved while we were suspended";
player.location:go(@listdelete(args, 1));
endif
endif
elseif (exit == $failed_match)
player:tell("You can't go that way (", dir, ").");
else
player:tell("I don't know which direction `", dir, "' you mean.");
endif
.
#3:15
if ((dobjstr == "") && (!prepstr))
this:look_self();
elseif ((prepstr != "in") && (prepstr != "on"))
if ((!dobjstr) && (prepstr == "at"))
dobjstr = iobjstr;
iobjstr = "";
else
dobjstr = dobjstr + (prepstr && ((dobjstr && " ") + prepstr));
dobjstr = dobjstr + (iobjstr && ((dobjstr && " ") + iobjstr));
endif
dobj = this:match_object(dobjstr);
if (!$command_utils:object_match_failed(dobj, dobjstr))
dobj:look_self();
endif
elseif (!iobjstr)
player:tell(verb, " ", prepstr, " what?");
else
iobj = this:match_object(iobjstr);
if (!$command_utils:object_match_failed(iobj, iobjstr))
if (dobjstr == "")
iobj:look_self();
elseif ((thing = iobj:match(dobjstr)) == $failed_match)
player:tell("I don't see any \"", dobjstr, "\" ", prepstr, " ", iobj.name, ".");
elseif (thing == $ambiguous_match)
player:tell("There are several things ", prepstr, " ", iobj.name, " one might call \"", dobjstr, "\".");
else
thing:look_self();
endif
endif
endif
.
#3:16
for dude in (this:contents())
try
dude:tell(@args);
except (ANY)
"Just ignore the dude with the stupid :tell";
continue dude;
endtry
endfor
.
#3:17
":announce_all_but(LIST objects to ignore, text)";
{ignore, @text} = args;
contents = this:contents();
for l in (ignore)
contents = setremove(contents, l);
endfor
for listener in (contents)
try
listener:tell(@text);
except (ANY)
"Ignure listener with bad :tell";
continue listener;
endtry
endfor
.
#3:18
object = args[1];
if (is_player(object) && (object.location == this))
player = object;
this:look_self(player.brief);
endif
if (object == this.blessed_object)
this.blessed_object = #-1;
endif
.
#3:19
return;
.
#3:20
exit = args[1];
if (caller != exit)
set_task_perms(caller_perms());
endif
return `this.exits = setremove(this.exits, exit) ! E_PERM' != E_PERM;
.
#3:21
exit = args[1];
if (caller != exit)
set_task_perms(caller_perms());
endif
return `this.entrances = setremove(this.entrances, exit) ! E_PERM' != E_PERM;
.
#3:22
set_task_perms(player);
if (!dobjstr)
player:tell("Usage:  @add-exit <exit-number>");
return;
endif
exit = this:match_object(dobjstr);
if ($command_utils:object_match_failed(exit, dobjstr))
return;
endif
if (!($exit in $object_utils:ancestors(exit)))
player:tell("That doesn't look like an exit object to me...");
return;
endif
try
dest = exit.dest;
except (E_PERM)
player:tell("You can't read the exit's destination to check that it's consistent!");
return;
endtry
try
source = exit.source;
except (E_PERM)
player:tell("You can't read that exit's source to check that it's consistent!");
return;
endtry
if (source == $nothing)
player:tell("That exit's source has not yet been set; set it to be this room, then run @add-exit again.");
return;
elseif (source != this)
player:tell("That exit wasn't made to be attached here; it was made as an exit from ", source.name, " (", source, ").");
return;
elseif (((typeof(dest) != OBJ) || (!valid(dest))) || (!($room in $object_utils:ancestors(dest))))
player:tell("That exit doesn't lead to a room!");
return;
endif
if (!this:add_exit(exit))
player:tell("Sorry, but you must not have permission to add exits to this room.");
else
player:tell("You have added ", exit, " as an exit that goes to ", exit.dest.name, " (", exit.dest, ") via ", $string_utils:english_list(setadd(exit.aliases, exit.name)), ".");
endif
.
#3:23
set_task_perms(player);
if (!dobjstr)
player:tell("Usage:  @add-entrance <exit-number>");
return;
endif
exit = this:match_object(dobjstr);
if ($command_utils:object_match_failed(exit, dobjstr))
return;
endif
if (!($exit in $object_utils:ancestors(exit)))
player:tell("That doesn't look like an exit object to me...");
return;
endif
try
dest = exit.dest;
except (E_PERM)
player:tell("You can't read the exit's destination to check that it's consistent!");
return;
endtry
if (dest != this)
player:tell("That exit doesn't lead here!");
return;
endif
if (!this:add_entrance(exit))
player:tell("Sorry, but you must not have permission to add entrances to this room.");
else
player:tell("You have added ", exit, " as an entrance that gets here via ", $string_utils:english_list(setadd(exit.aliases, exit.name)), ".");
endif
.
#3:24
"Make a mild attempt to keep people and objects from ending up in #-1 when people recycle a room";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
"... first try spilling them out onto the floor of enclosing room if any";
if (valid(this.location))
for x in (this.contents)
try
x:moveto(this.location);
except (ANY)
continue x;
endtry
endfor
endif
"... try sending them home...";
for x in (this.contents)
if (is_player(x))
if ((typeof(x.home) == OBJ) && valid(x.home))
try
x:moveto(x.home);
except (ANY)
continue x;
endtry
endif
if (x.location == this)
move(x, $player_start);
endif
elseif (valid(x.owner))
try
x:moveto(x.owner);
except (ANY)
continue x;
endtry
endif
endfor
pass(@args);
else
return E_PERM;
endif
.
#3:25
set_task_perms((caller_perms() == #-1) ? player | caller_perms());
exit = this:match_exit(verb);
if (valid(exit))
exit:invoke();
elseif (exit == $failed_match)
player:tell("You can't go that way.");
else
player:tell("I don't know which direction `", verb, "' you mean.");
endif
.
#3:26
set_task_perms(player);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
elseif (dobj.location != this)
is = $gender_utils:get_conj("is", dobj);
player:tell(dobj.name, "(", dobj, ") ", is, " not here.");
return;
elseif (!$perm_utils:controls(player, this))
player:tell("You are not the owner of this room.");
return;
elseif (dobj.wizard)
player:tell("Sorry, you can't ", verb, " a wizard.");
dobj:tell(player.name, " tried to ", verb, " you.");
return;
endif
iobj = this;
player:tell(this:ejection_msg());
this:((verb == "@eject") ? "eject" | "eject_basic")(dobj);
if (verb != "@eject!!")
dobj:tell(this:victim_ejection_msg());
endif
this:announce_all_but({player, dobj}, this:oejection_msg());
.
#3:27
return $gender_utils:pronoun_sub(this.(verb));
.
#3:28
who = args[1];
return this:basic_accept_for_abode(who) && this:acceptable(who);
.
#3:29
if (!$perm_utils:controls(player, this))
player:tell("You must own this room to manipulate the legal residents list.  Try contacting ", this.owner.name, ".");
else
if (typeof(this.residents) != LIST)
this.residents = {this.residents};
endif
if (!dobjstr)
"First, remove !valid objects from this room...";
for x in (this.residents)
if ((typeof(x) != OBJ) || (!$recycler:valid(x)))
player:tell("Warning: removing ", x, ", an invalid object, from the residents list.");
this.residents = setremove(this.residents, x);
endif
endfor
player:tell("Allowable residents in this room:  ", $string_utils:english_list($list_utils:map_prop(this.residents, "name"), "no one"), ".");
return;
elseif (dobjstr[1] == "!")
notflag = 1;
dobjstr = dobjstr[2..$];
else
notflag = 0;
endif
result = $string_utils:match_player_or_object(dobjstr);
if (!result)
return;
else
"a one element list was returned to us if it won.";
result = result[1];
if (notflag)
if (!(result in this.residents))
player:tell(result.name, " doesn't appear to be in the residents list of ", this.name, ".");
else
this.residents = setremove(this.residents, result);
player:tell(result.name, " removed from the residents list of ", this.name, ".");
endif
else
if (result in this.residents)
is = $gender_utils:get_conj("is", result);
player:tell(result.name, " ", is, " already an allowed resident of ", this.name, ".");
else
this.residents = {@this.residents, result};
player:tell(result.name, " added to the residents list of ", this.name, ".");
endif
endif
endif
endif
.
#3:30
target = {@this:contents(), @this:exits()};
return $string_utils:match(args[1], target, "name", target, "aliases");
.
#3:31
set_task_perms(player);
if (!dobjstr)
player:tell("Usage:  @remove-exit <exit>");
return;
endif
exit = this:match_object(dobjstr);
if (!(exit in this.exits))
if ($command_utils:object_match_failed(exit, dobjstr))
return;
endif
player:tell("Couldn't find \"", dobjstr, "\" in the exits list of ", this.name, ".");
return;
elseif (!this:remove_exit(exit))
player:tell("Sorry, but you do not have permission to remove exits from this room.");
else
name = valid(exit) ? exit.name | "<recycled>";
player:tell("Exit ", exit, " (", name, ") removed from exit list of ", this.name, " (", this, ").");
endif
.
#3:32
set_task_perms(player);
if (!dobjstr)
player:tell("Usage:  @remove-entrance <entrance>");
return;
endif
entrance = $string_utils:match(dobjstr, this.entrances, "name", this.entrances, "aliases");
if (!valid(entrance))
"Try again to parse it.  Maybe they gave object number.  Don't complain if it's invalid though; maybe it's been recycled in some nefarious way.";
entrance = this:match_object(dobjstr);
endif
if (!(entrance in this.entrances))
player:tell("Couldn't find \"", dobjstr, "\" in the entrances list of ", this.name, ".");
return;
elseif (!this:remove_entrance(entrance))
player:tell("Sorry, but you do not have permission to remove entrances from this room.");
else
name = valid(entrance) ? entrance.name | "<recycled>";
player:tell("Entrance ", entrance, " (", name, ") removed from entrance list of ", this.name, " (", this, ").");
endif
.
#3:33
if ((caller in {this, this.owner}) || $perm_utils:controls(caller_perms(), this))
return pass(@args);
else
return E_PERM;
endif
.
#3:34
return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(msg, args[1]) | "";
.
#3:35
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return this.(verb);
else
return E_PERM;
endif
.
#3:36
exits = {};
for exit in (`(verb == "obvious_exits") ? this.exits | this.entrances ! ANY => {}')
if (`$code_utils:verb_or_property(exit, "obvious") ! ANY')
exits = setadd(exits, exit);
endif
endfor
return exits;
.
#3:37
":here_huh(verb,args)  -- room-specific :huh processing.  This should return 1 if it finds something interesting to do and 0 otherwise; see $command_utils:do_huh.";
"For the generic room, we check for the case of the caller specifying an exit for which a corresponding verb was never defined.";
set_task_perms(caller_perms());
if (args[2] || ($failed_match == (exit = this:match_exit(verb = args[1]))))
"... okay, it's not an exit.  we give up...";
return 0;
elseif (valid(exit))
exit:invoke();
else
"... ambiguous exit ...";
player:tell("I don't know which direction `", verb, "' you mean.");
endif
return 1;
.
#3:38
this:(verb[6..$])(@args);
.
#3:39
return this == args[1].location;
.
#3:40
"examine_key(examiner)";
"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.";
"the default will only tell the key to a wizard or this object's owner.";
who = args[1];
if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))
return {tostr(this:title(), " will accept only objects matching the following key:"), tostr("  ", $lock_utils:unparse_key(this.key))};
endif
.
#3:41
"examine_contents(who)";
if (caller == this)
this:tell_contents(this.contents, this.ctype);
endif
.
#3:42
return this.free_entry;
.
#3:43
if (caller_perms().wizard)
pass(@args);
if (this == $player_start)
"... If there are ever multiple rooms, then the question of";
"....which one is to be $player_start may well be an option of some sort,";
"... so this goes better here than hardcoded into some specific room:init_for_core verb.";
move(player, this);
endif
endif
.
#3:44
return this.(verb);
.
#3:45
"Copied from generic room (#3):announce by Haakon (#2) Thu Oct 24 16:15:01 1996 PDT";
for dude in (setremove(this:contents(), player))
try
dude:tell_lines(@args);
except id (ANY)
endtry
endfor
.
#3:46
who = args[1];
return valid(who) && ((this.free_home || $perm_utils:controls(who, this)) || ((typeof(residents = this.residents) == LIST) ? who in this.residents | (who == this.residents)));
.
#4:0
set_task_perms(player);
if (dobjstr == "")
dobj = player;
else
dobj = $string_utils:match_player(dobjstr);
endif
if (!valid(dobj))
player:notify("Show whose quota?");
return;
endif
$quota_utils:display_quota(dobj);
try
if (dobj in $local.informed_quota_consumers.uninformed_quota_consumers)
player:notify(tostr("Note that quota is held in escrow -- `look ", $local.informed_quota_consumers, "' for more details."));
endif
except id (ANY)
endtry
.
#4:1
set_task_perms(player);
nargs = length(args);
pos = "named" in args;
if ((pos <= 1) || (pos == nargs))
pos = "called" in args;
endif
if ((pos <= 1) || (pos == nargs))
player:notify("Usage:  @create <parent-class> named [name:]alias,...,alias");
player:notify("   or:  @create <parent-class> named name-and-alias,alias,...,alias");
player:notify("");
player:notify("where <parent-class> is one of the standard classes ($note, $letter, $thing, or $container) or an object number (e.g., #999), or the name of some object in the current room.");
player:notify("You can use \"called\" instead of \"named\", if you wish.");
return;
endif
parentstr = $string_utils:from_list(args[1..pos - 1], " ");
namestr = $string_utils:from_list(args[pos + 1..$], " ");
if (!namestr)
player:notify("You must provide a name.");
return;
endif
if (parentstr[1] == "$")
parent = $string_utils:literal_object(parentstr);
if ((parent == $failed_match) || (typeof(parent) != OBJ))
player:notify(tostr("\"", parentstr, "\" does not name an object."));
return;
endif
else
parent = player:my_match_object(parentstr);
if ($command_utils:object_match_failed(parent, parentstr))
return;
endif
endif
object = player:_create(parent);
if (typeof(object) == ERR)
player:notify(tostr(object));
return;
endif
for f in ($string_utils:char_list(player:build_option("create_flags") || ""))
object.(f) = 1;
endfor
"move() shouldn't, but could bomb. Say if player has a stupid :accept";
`move(object, player) ! ANY';
$building_utils:set_names(object, namestr);
if ((other_names = setremove(object.aliases, object.name)) != {})
aka = (" (aka " + $string_utils:english_list(other_names)) + ")";
else
aka = "";
endif
player:notify(tostr("You now have ", object.name, aka, " with object number ", object, " and parent ", parent.name, " (", parent, ")."));
.
#4:2
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if (dobj == $nothing)
player:notify(tostr("Usage:  ", verb, " <object>"));
elseif ($command_utils:object_match_failed(dobj, dobjstr))
"...bogus object...";
elseif (player == dobj)
player:notify($wiz_utils.suicide_string);
elseif (!$perm_utils:controls(player, dobj))
player:notify(tostr(E_PERM));
else
name = dobj.name;
result = player:_recycle(dobj);
if (typeof(result) == ERR)
player:notify(tostr(result));
else
player:notify(tostr(name, " (", dobj, ") recycled."));
endif
endif
.
#4:3
"@recreate <object> as <parent-class> named [name:]alias,alias,...";
"  effectively recycles and creates <object> all over again.";
set_task_perms(player);
as = prepstr in args;
named = "named" in args;
if ((named <= (as + 1)) || (named == length(args)))
named = "called" in args;
endif
if ((named <= (as + 1)) || (named == length(args)))
player:notify_lines({tostr("Usage:  ", verb, " <object> as <parent-class> named [name:]alias,...,alias"), "", "where <parent-class> is one of the standard classes ($note, $letter, $thing, or $container) or an object number (e.g., #999), or the name of some object in the current room.  The [name:]alias... specification is as in @create.", "", "You can use \"called\" instead of \"named\", if you wish."});
return;
elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr, 1))
return;
elseif (valid(dobj) && is_player(dobj))
player:notify("You really *don't* want to do that!");
return;
endif
parentstr = $string_utils:from_list(args[as + 1..named - 1], " ");
namestr = $string_utils:from_list(args[named + 1..$], " ");
if (parentstr[1] == "$")
parent = $string_utils:literal_object(parentstr);
if ((parent == $failed_match) || (typeof(parent) != OBJ))
player:notify(tostr("\"", parentstr, "\" does not name an object."));
return;
endif
else
parent = player:my_match_object(parentstr);
if ($command_utils:object_match_failed(parent, parentstr))
return;
endif
endif
if (!(e = $building_utils:recreate(dobj, parent)))
player:notify(tostr(e));
return;
endif
for f in ($string_utils:char_list(player:build_option("create_flags") || ""))
dobj.(f) = 1;
endfor
"move() shouldn't, but could, bomb. Say if player has a stupid :accept";
`move(dobj, player) ! ANY';
$building_utils:set_names(dobj, namestr);
if ((other_names = setremove(dobj.aliases, dobj.name)) != {})
aka = (" (aka " + $string_utils:english_list(other_names)) + ")";
else
aka = "";
endif
player:notify(tostr("Object number ", dobj, " is now ", dobj.name, aka, " with parent ", parent.name, " (", parent, ")."));
.
#4:4
set_task_perms(player);
nargs = length(args);
if (nargs == 1)
room = args[1];
exit_spec = "";
elseif ((nargs >= 3) && (args[2] == "to"))
exit_spec = args[1];
room = $string_utils:from_list(args[3..$], " ");
elseif (argstr && (!prepstr))
room = argstr;
exit_spec = "";
else
player:notify(tostr("Usage:  ", verb, " <new-room-name>"));
player:notify(tostr("    or  ", verb, " <exit-description> to <new-room-name-or-old-room-object-number>"));
return;
endif
if (room != tostr(other_room = toobj(room)))
room_kind = player:build_option("dig_room");
if (room_kind == 0)
room_kind = $room;
endif
other_room = player:_create(room_kind);
if (typeof(other_room) == ERR)
player:notify(tostr("Cannot create new room as a child of ", $string_utils:nn(room_kind), ": ", other_room, ".  See `help @build-options' for information on how to specify the kind of room this command tries to create."));
return;
endif
for f in ($string_utils:char_list(player:build_option("create_flags") || ""))
other_room.(f) = 1;
endfor
other_room.name = room;
other_room.aliases = {room};
move(other_room, $nothing);
player:notify(tostr(other_room.name, " (", other_room, ") created."));
elseif (nargs == 1)
player:notify("You can't dig a room that already exists!");
return;
elseif ((!valid(player.location)) || (!($room in $object_utils:ancestors(player.location))))
player:notify(tostr("You may only use the ", verb, " command from inside a room."));
return;
elseif ((!valid(other_room)) || (!($room in $object_utils:ancestors(other_room))))
player:notify(tostr(other_room, " doesn't look like a room to me..."));
return;
endif
if (exit_spec)
exit_kind = player:build_option("dig_exit");
if (exit_kind == 0)
exit_kind = $exit;
endif
exits = $string_utils:explode(exit_spec, "|");
if ((length(exits) < 1) || (length(exits) > 2))
player:notify("The exit-description must have the form");
player:notify("     [name:]alias,...,alias");
player:notify("or   [name:]alias,...,alias|[name:]alias,...,alias");
return;
endif
do_recreate = !player:build_option("bi_create");
to_ok = $building_utils:make_exit(exits[1], player.location, other_room, do_recreate, exit_kind);
if (to_ok && (length(exits) == 2))
$building_utils:make_exit(exits[2], other_room, player.location, do_recreate, exit_kind);
endif
endif
.
#4:5
"Usage:  @audit [player] [from <start>] [to <end>] [for <matching string>]";
set_task_perms(player);
dobj = $string_utils:match_player(dobjstr);
if (!dobjstr)
dobj = player;
elseif ($command_utils:player_match_result(dobj, dobjstr)[1])
return;
endif
dobjwords = $string_utils:words(dobjstr);
if (args[1..length(dobjwords)] == dobjwords)
args = args[length(dobjwords) + 1..$];
endif
if (!(parse_result = $code_utils:_parse_audit_args(@args)))
player:notify(tostr("Usage:  ", verb, " [player] [from <start>] [to <end>] [for <match>]"));
return;
endif
return $building_utils:do_audit(dobj, @parse_result);
.
#4:6
if (!dobjstr)
dobj = player;
elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
endif
set_task_perms(player);
if (typeof(dobj.owned_objects) == LIST)
count = length(dobj.owned_objects);
player:notify(tostr(dobj.name, " currently owns ", count, " object", (count == 1) ? "." | "s."));
if ($quota_utils.byte_based)
player:notify(tostr("Total bytes consumed:  ", $string_utils:group_number($quota_utils:get_size_quota(dobj)[2]), "."));
endif
else
player:notify(tostr(dobj.name, " is not enrolled in the object ownership system.  Use @countDB instead."));
endif
.
#4:7
if (!dobjstr)
dobj = player;
elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
endif
set_task_perms(player);
count = 0;
for o in [#1..max_object()]
if ($command_utils:running_out_of_time())
player:notify("Counting...");
suspend(5);
endif
if (valid(o) && (o.owner == dobj))
count = count + 1;
endif
endfor
player:notify(tostr(dobj.name, " currently owns ", count, " object", (count == 1) ? "." | "s."));
.
#4:8
"$player:owned_objects -- sorts a players .owned_objects property in ascending";
"order so it looks nice on @audit.";
if (player != this)
return E_PERM;
endif
if (typeof(player.owned_objects) == LIST)
if ((!dobjstr) || (index("object", dobjstr) == 1))
ret = $list_utils:sort_suspended(0, player.owned_objects);
elseif (index("size", dobjstr) == 1)
ret = $list_utils:reverse_suspended($list_utils:sort_suspended(0, player.owned_objects, $list_utils:slice($list_utils:map_prop(player.owned_objects, "object_size"))));
endif
if (typeof(ret) == LIST)
player.owned_objects = ret;
player:tell("Your .owned_objects list has been sorted.");
return 1;
else
player:tell("Something went wrong. .owned_objects not sorted.");
return 0;
endif
else
player:tell("You are not enrolled in .owned_objects scheme, sorry.");
endif
.
#4:9
if (player != this)
player:tell("Permission Denied");
return E_PERM;
endif
if (!valid(dobj))
player:tell("Don't understand `", dobjstr, "' as an object to add.");
elseif (dobj.owner != player)
player:tell("You don't own ", dobj.name, ".");
elseif (dobj in player.owned_objects)
player:tell(dobj.name, " is already recorded in your .owned_objects.");
else
player.owned_objects = setadd(player.owned_objects, dobj);
player:tell("Added ", dobj, " to your .owned_objects.");
endif
.
#4:10
for x in (player.owned_objects)
if ((!valid(x)) || (x.owner != player))
player.owned_objects = setremove(player.owned_objects, x);
if (valid(x))
player:tell("Removing ", x.name, "(", x, "), owned by ", valid(x.owner) ? x.owner.name | "<recycled player>", " from your .owned_objects property.");
else
player:tell("Removing invalid object ", x, " from your .owned_objects property.");
endif
endif
$command_utils:suspend_if_needed(2, tostr("Suspending @verify-owned ... ", x));
endfor
player:tell(".owned_objects property verified.");
.
#4:11
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
try
dobj.key = 0;
player:notify(tostr("Unlocked ", dobj.name, "."));
except error (ANY)
player:notify(error[2]);
endtry
.
#4:12
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
key = $lock_utils:parse_keyexp(iobjstr, player);
if (typeof(key) == STR)
player:notify("That key expression is malformed:");
player:notify(tostr("  ", key));
else
try
dobj.key = key;
player:notify(tostr("Locked ", dobj.name, " to this key:"));
player:notify(tostr("  ", $lock_utils:unparse_key(key)));
except error (ANY)
player:notify(error[2]);
endtry
endif
.
#4:13
"Usage:  @newmessage <message-name> [<message>] [on <object>]";
"Add a message property to an object (default is player), and optionally";
"set its value.  For use by non-programmers, who aren't allowed to add";
"properties generally.";
"To undo the effects of this, use @unmessage.";
set_task_perms(player);
dobjwords = $string_utils:words(dobjstr);
if (!dobjwords)
player:notify(tostr("Usage:  ", verb, " <message-name> [<message>] [on <object>]"));
return;
endif
object = valid(iobj) ? iobj | player;
name = this:_messagify(dobjwords[1]);
value = dobjstr[length(dobjwords[1]) + 2..$];
nickname = "@" + name[1..$ - 4];
e = `add_property(object, name, value, {player, "rc"}) ! ANY';
if (typeof(e) != ERR)
player:notify(tostr(nickname, " on ", object.name, " is now \"", object.(name), "\"."));
elseif (e != E_INVARG)
player:notify(tostr(e));
elseif ($object_utils:has_property(object, name))
"object already has property";
player:notify(tostr(object.name, " already has a ", nickname, " message."));
else
player:notify(tostr("Unable to add ", nickname, " message to ", object.name, ": ", e));
endif
.
#4:14
"Usage:  @unmessage <message-name> [from <object>]";
"Remove a message property from an object (default is player).";
set_task_perms(player);
if ((!dobjstr) || (length($string_utils:words(dobjstr)) > 1))
player:notify(tostr("Usage:  ", verb, " <message-name> [from <object>]"));
return;
endif
object = valid(iobj) ? iobj | player;
name = this:_messagify(dobjstr);
nickname = "@" + name[1..$ - 4];
try
delete_property(object, name);
player:notify(tostr(nickname, " message removed from ", object.name, "."));
except (E_PROPNF)
player:notify(tostr("No ", nickname, " message found on ", object.name, "."));
except error (ANY)
player:notify(error[2]);
endtry
.
#4:15
"Given any of several formats people are likely to use for a @message";
"property, return the canonical form (\"foobar_msg\").";
name = args[1];
if (name[1] == "@")
name = name[2..$];
endif
if ((length(name) < 4) || (name[$ - 3..$] != "_msg"))
name = name + "_msg";
endif
return name;
.
#4:16
"'@kids <obj>' - List the children of an object. This is handy for seeing whether anybody's actually using your carefully-wrought public objects.";
thing = player:my_match_object(dobjstr);
if (!$command_utils:object_match_failed(thing, dobjstr))
kids = children(thing);
if (kids)
player:notify(tostr(thing:title(), "(", thing, ") has ", length(kids), " kid", (length(kids) == 1) ? "" | "s", "."));
player:notify(tostr($string_utils:names_of(kids)));
else
player:notify(tostr(thing:title(), "(", thing, ") has no kids."));
endif
endif
.
#4:17
"'@contents <obj> - list the contents of an object, with object numbers.";
set_task_perms(player);
if (!dobjstr)
dobj = player.location;
else
dobj = player:my_match_object(dobjstr);
endif
if ($command_utils:object_match_failed(dobj, dobjstr))
else
contents = dobj.contents;
if (contents)
player:notify(tostr(dobj:title(), "(", dobj, ") contains:"));
player:notify(tostr($string_utils:names_of(contents)));
else
player:notify(tostr(dobj:title(), "(", dobj, ") contains nothing."));
endif
endif
.
#4:18
"'@parents <thing>' - List <thing> and its ancestors, all the way back to the Root Class (#1).";
if (player != this)
return player:notify("Permission denied: not a builder.");
elseif (!dobjstr)
player:notify(tostr("Usage:  ", verb, " <object>"));
return;
endif
set_task_perms(player);
o = player:my_match_object(dobjstr);
if (!$command_utils:object_match_failed(o, dobjstr))
player:notify($string_utils:names_of({o, @$object_utils:ancestors(o)}));
endif
.
#4:19
"@locations <thing> - List <thing> and its containers, all the way back to the outermost one.";
set_task_perms(player);
if (!dobjstr)
what = player;
elseif ((!valid(what = player:my_match_object(dobjstr))) && (!valid(what = $string_utils:match_player(dobjstr))))
$command_utils:object_match_failed(dobj, dobjstr);
return;
endif
player:notify($string_utils:names_of({what, @$object_utils:locations(what)}));
.
#4:20
{root, indent, members, printed} = args;
if (root in members)
player:tell(indent, root.name, " (", root, ")");
else
player:tell(indent, "<", root.name, " (", root, ")>");
endif
printed = setremove(printed, root);
indent = indent + "  ";
set_task_perms(caller_perms());
for c in ($list_utils:sort_suspended(2, $set_utils:intersection(children(root), printed)))
$command_utils:suspend_if_needed(10);
this:classes_2(c, indent, members, printed);
endfor
.
#4:21
set_task_perms(caller_perms());
if (this:build_option("bi_create"))
return $quota_utils:bi_create(@args);
else
return $recycler:(verb)(@args);
endif
.
#4:22
set_task_perms(caller_perms());
if (this:build_option("bi_create"))
return recycle(@args);
else
return $recycler:(verb)(@args);
endif
.
#4:23
set_task_perms(player);
if ($command_utils:object_match_failed(object = player:my_match_object(dobjstr), dobjstr))
"...bogus object...";
elseif ($command_utils:object_match_failed(parent = player:my_match_object(iobjstr), iobjstr))
"...bogus new parent...";
elseif ((this != player) && (!$object_utils:isa(player, $player)))
"...They chparented to #1 and want to chparent back to $prog.  Probably for some nefarious purpose...";
player:notify("You don't seem to already be a valid player class.  Perhaps chparenting away from the $player hierarchy was not such a good idea.  Permission denied.");
elseif (is_player(object) && (!$object_utils:isa(parent, $player)))
player:notify(tostr(object, " is a player and ", parent, " is not a player class."));
player:notify("You really *don't* want to do this.  Trust me.");
else
if ($object_utils:isa(object, $mail_recipient))
if (!$command_utils:yes_or_no("Chparenting a mailing list is usually a really bad idea.  Do you really want to do it?  (If you don't know why we're asking this question, please say 'no'.)"))
return player:tell("Aborted.");
endif
endif
try
result = player:_chparent(object, parent);
player:notify("Parent changed.");
except (E_INVARG)
if (valid(object) && valid(parent))
player:notify(tostr("Some property existing on ", parent, " is defined on ", object, " or one of its descendants."));
player:notify(tostr("Try @check-chparent ", dobjstr, " to ", iobjstr));
else
player:notify("Either that is not a valid object or not a valid parent");
endif
except (E_PERM)
player:notify("Either you don't own the object, don't own the parent, or the parent is not fertile.");
except (E_RECMOVE)
player:notify("That parent object is a descendant of the object!");
endtry
endif
.
#4:24
"Copied from generic programmer (#217):@check-chparent by ur-Rog (#6349) Sun Nov  8 22:13:53 1992 PST";
"@check-chparent object to newparent";
"checks for property name conflicts that would make @chparent bomb.";
set_task_perms(player);
if (!(dobjstr && iobjstr))
player:notify(tostr("Usage:  ", verb, " <object> to <newparent>"));
elseif ($command_utils:object_match_failed(object = player:my_match_object(dobjstr), dobjstr))
"...bogus object...";
elseif ($command_utils:object_match_failed(parent = player:my_match_object(iobjstr), iobjstr))
"...bogus new parent...";
elseif (player != this)
player:notify(tostr(E_PERM));
elseif (typeof(result = $object_utils:property_conflicts(object, parent)) == ERR)
player:notify(tostr(result));
elseif (result)
su = $string_utils;
player:notify("");
player:notify(su:left("Property", 30) + "Also Defined on");
player:notify(su:left("--------", 30) + "---------------");
for r in (result)
player:notify(su:left(tostr(parent, ".", r[1]), 30) + su:from_list(listdelete(r, 1), " "));
$command_utils:suspend_if_needed(0);
endfor
else
player:notify("No property conflicts found.");
endif
.
#4:25
"Syntax:  @set <object>.<prop-name> to <value>";
"";
"Changes the value of the specified object's property to the given value.";
"You must have permission to modify the property, either because you own the property or if it is writable.";
set_task_perms(player);
if (this != player)
return player:tell(E_PERM);
endif
l = $code_utils:parse_propref(dobjstr);
if (l)
dobj = player:my_match_object(l[1], player.location);
if ($command_utils:object_match_failed(dobj, l[1]))
return;
endif
prop = l[2];
to_i = "to" in args;
at_i = "at" in args;
i = (to_i && at_i) ? min(to_i, at_i) | (to_i || at_i);
iobjstr = argstr[$string_utils:word_start(argstr)[i][2] + 1..$];
iobjstr = $string_utils:trim(iobjstr);
if (!iobjstr)
try
val = dobj.(prop) = "";
except e (ANY)
player:tell("Unable to set ", dobj, ".", prop, ": ", e[2]);
return;
endtry
iobjstr = "\"\"";
"elseif (iobjstr[1] == \"\\\"\")";
"val = dobj.(prop) = iobjstr;";
"iobjstr = \"\\\"\" + iobjstr + \"\\\"\";";
else
val = $string_utils:to_value(iobjstr);
if (!val[1])
player:tell("Could not parse: ", iobjstr);
return;
elseif (!$object_utils:has_property(dobj, prop))
player:tell("That object does not define that property.");
return;
endif
try
val = dobj.(prop) = val[2];
except e (ANY)
player:tell("Unable to set ", dobj, ".", prop, ": ", e[2]);
return;
endtry
endif
player:tell("Property ", dobj, ".", prop, " set to ", $string_utils:print(val), ".");
else
player:tell("Property ", dobjstr, " not found.");
endif
.
#4:26
":build_option(name)";
"Returns the value of the specified builder option";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return $options["build"]:get(this.build_options, args[1]);
else
return E_PERM;
endif
.
#4:27
":set_build_option(oname,value)";
"Changes the value of the named option.";
"Returns a string error if something goes wrong.";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return tostr(E_PERM);
endif
"...this is kludgy, but it saves me from writing the same verb n times.";
"...there's got to be a better way to do this...";
verb[1..4] = "";
foo_options = verb + "s";
prop = verb[1..index(verb, "_") - 1];
"...";
if (typeof(s = $options[prop]:set(this.(foo_options), @args)) == STR)
return s;
elseif (s == this.(foo_options))
return 0;
else
this.(foo_options) = s;
return 1;
endif
.
#4:28
"@<what>-option <option> [is] <value>   sets <option> to <value>";
"@<what>-option <option>=<value>        sets <option> to <value>";
"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1";
"@<what>-option -<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option !<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option <option>      displays value of <option>";
set_task_perms(player);
what = "build";
options = what + "_options";
option_pkg = $options[what];
set_option = ("set_" + what) + "_option";
if (!args)
player:notify_lines({("Current " + what) + " options:", "", @option_pkg:show(this.(options), option_pkg.names)});
return;
elseif (typeof(presult = option_pkg:parse(args)) == STR)
player:notify(presult);
return;
else
if (length(presult) > 1)
if (typeof(sresult = this:(set_option)(@presult)) == STR)
player:notify(sresult);
return;
elseif (!sresult)
player:notify("No change.");
return;
endif
endif
player:notify_lines(option_pkg:show(this.(options), presult[1]));
endif
.
#4:29
"Syntax:";
"  @measure object <object name>";
"  @measure summary [player]";
"  @measure new [player]";
"  @measure breakdown <object name>";
"  @measure recent [number of days] [player]";
if (length(args) < 1)
player:tell_lines($code_utils:verb_documentation());
return;
endif
if (index("object", args[1]) == 1)
"Object.";
what = player.location:match_object(name = $string_utils:from_list(args[2..$], " "));
lag = $login:current_lag();
if (!valid(what))
player:tell("Sorry, I didn't understand `", name, "'");
elseif (((((($object_utils:has_property(what, "object_size") && (what.object_size[1] > $byte_quota_utils.too_large)) && (!player.wizard)) && (player != $byte_quota_utils.owner)) && (player != $hacker)) && (player != what.owner)) && (lag > 0))
player:tell($string_utils:nn(what), " when last measured was ", $string_utils:group_number(what.object_size[1]), " bytes.  To reduce lag induced by multiple players re-measuring large objects multiple times, you may not measure that object.");
elseif (((lag > 0) && (`what.object_size[2] ! ANY => 0' > (time() - 86400))) && (!$command_utils:yes_or_no(tostr("That object was measured only ", $string_utils:from_seconds(time() - what.object_size[2]), " ago.  Please don't lag the MOO by remeasuring things frequently.  Are you sure you want to remeasure it?"))))
return player:tell("Not measuring.  It was ", $string_utils:group_number(what.object_size[1]), " bytes when last measured.");
else
player:tell("Checking size of ", what.name, " (", what, ")...");
player:tell("Size of ", what.name, " (", what, ") is ", $string_utils:group_number($byte_quota_utils:object_bytes(what)), " bytes.");
endif
elseif (index("summary", args[1]) == 1)
"Summarize player.";
if (length(args) == 1)
what = player;
else
what = $string_utils:match_player(name = $string_utils:from_list(args[2..$], " "));
endif
if (!valid(what))
player:tell("Sorry, I don't know who you mean by `", name, "'");
else
$byte_quota_utils:do_summary(what);
endif
elseif (index("new", args[1]) == 1)
if (length(args) == 1)
what = player;
elseif (!valid(what = $string_utils:match_player(name = $string_utils:from_list(args[2..$], " "))))
return $command_utils:player_match_failed(what, name);
endif
player:tell("Measuring the sizes of ", what.name, "'s recently created objects...");
total = 0;
unmeasured_index = 4;
unmeasured_multiplier = 100;
nunmeasured = 0;
if (typeof(what.owned_objects) == LIST)
for x in (what.owned_objects)
if (!$object_utils:has_property(x, "object_size"))
nunmeasured = nunmeasured + 1;
elseif (!x.object_size[1])
player:tell("Measured ", $string_utils:nn(x), ":  ", size = $byte_quota_utils:object_bytes(x), " bytes.");
total = total + size;
endif
$command_utils:suspend_if_needed(5);
endfor
if (nunmeasured && (what.size_quota[unmeasured_index] < (unmeasured_multiplier * nunmeasured)))
what.size_quota[unmeasured_index] = (what.size_quota[unmeasured_index] % unmeasured_multiplier) + (nunmeasured * unmeasured_multiplier);
endif
player:tell("Total bytes used in new creations: ", total, ".", nunmeasured ? tostr(" There were a total of ", nunmeasured, " object(s) found with no .object_size property. This will prevent additional building.") | "");
else
player:tell("Sorry, ", what.name, " is not enrolled in the object measurement scheme.");
endif
elseif (index("recent", args[1]) == 1)
"@measure recent days player";
if (length(args) > 1)
days = $code_utils:toint(args[2]);
else
days = $byte_quota_utils.cycle_days;
endif
if (!days)
return player:tell("Couldn't understand `", args[2], "' as a positive integer.");
endif
if (length(args) > 2)
if (!valid(who = $string_utils:match_player(name = $string_utils:from_list(args[3..$], " "))))
return $command_utils:player_match_failed(who, name);
endif
else
who = player;
endif
if (typeof(who.owned_objects) == LIST)
player:tell("Re-measuring objects of ", $string_utils:nn(who), " which have not been measured in the past ", days, " days.");
when = time() - (days * 86400);
which = {};
for x in (who.owned_objects)
if (x.object_size[2] < when)
$byte_quota_utils:object_size(x);
which = setadd(which, x);
$command_utils:suspend_if_needed(3, "...measuring");
endif
endfor
player:tell("Done, re-measured ", length(which), " objects.", (length(which) > 0) ? "  Recommend you use @measure summary to update the display of @quota." | "");
else
player:tell("Sorry, ", who.name, " is not enrolled in the object measurement scheme.");
endif
elseif (index("breakdown", args[1]) == 1)
what = player.location:match_object(name = $string_utils:from_list(args[2..$], " "));
if (!valid(what))
player:tell("Sorry, I didn't understand `", name, "'");
elseif (!$byte_quota_utils:can_peek(player, what.owner))
return player:tell("Sorry, you don't control ", what.name, " (", what, ")");
else
if (mail = $command_utils:yes_or_no("This might be kinda long.  Want me to mail you the result?"))
player:tell("Result will be mailed.");
endif
info = $byte_quota_utils:do_breakdown(what);
if (typeof(info) == ERR)
player:tell(info);
endif
if (mail)
$mail_agent:send_message($byte_quota_utils.owner, {player}, tostr("Object breakdown of ", what.name, " (", what, ")"), info);
else
player:tell_lines_suspended(info);
endif
endif
else
player:tell("Not a sub-command of @measure: ", args[1]);
player:tell_lines($code_utils:verb_documentation());
endif
.
#4:30
if (caller_perms().wizard)
if (this == $builder)
this.build_options = {};
else
clear_property(this, "build_options");
endif
return pass(@args);
endif
.
#4:31
"@listedit|@pedit object.prop -- invokes the list editor.";
"   if you are editing a list of strings, you're better off using @notedit.";
$list_editor:invoke(dobjstr, verb);
.
#5:0
set_task_perms(callers() ? caller_perms() | player);
if (this.location == player)
player:tell("You already have that!");
elseif (this.location != player.location)
player:tell("I don't see that here.");
else
this:moveto(player);
if (this.location == player)
player:tell(this:take_succeeded_msg() || "Taken.");
if (msg = this:otake_succeeded_msg())
player.location:announce(player.name, " ", msg);
endif
else
player:tell(this:take_failed_msg() || "You can't pick that up.");
if (msg = this:otake_failed_msg())
player.location:announce(player.name, " ", msg);
endif
endif
endif
.
#5:1
set_task_perms(callers() ? caller_perms() | player);
if (this.location != player)
player:tell("You don't have that.");
elseif (!player.location:acceptable(this))
player:tell("You can't drop that here.");
else
this:moveto(player.location);
if (this.location == player.location)
player:tell_lines(this:drop_succeeded_msg() || "Dropped.");
if (msg = this:odrop_succeeded_msg())
player.location:announce(player.name, " ", msg);
endif
else
player:tell_lines(this:drop_failed_msg() || "You can't seem to drop that here.");
if (msg = this:odrop_failed_msg())
player.location:announce(player.name, " ", msg);
endif
endif
endif
.
#5:2
where = args[1];
"if (!valid(where) || this:is_unlocked_for(where))";
if (this:is_unlocked_for(where))
pass(where);
endif
.
#5:3
set_task_perms(caller_perms());
return $string_utils:pronoun_sub(this.(verb));
.
#5:4
set_task_perms(callers() ? caller_perms() | player);
if (this.location != player)
player:tell("You don't have that!");
elseif (!valid(player.location))
player:tell("I see no \"", iobjstr, "\" here.");
elseif ($command_utils:object_match_failed(who = player.location:match_object(iobjstr), iobjstr))
elseif (who.location != player.location)
player:tell("I see no \"", iobjstr, "\" here.");
elseif (who == player)
player:tell("Give it to yourself?");
else
this:moveto(who);
if (this.location == who)
player:tell("You hand ", this:title(), " to ", who:title(), ".");
who:tell(player:titlec(), " ", $gender_utils:get_conj("hands/hand", player), " you ", this:title(), ".");
else
player:tell(who:titlec(), " ", $gender_utils:get_conj("does/do", who), " not want that item.");
endif
endif
.
#5:5
"examine_key(examiner)";
"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.";
"the default will only tell the key to a wizard or this object's owner.";
who = args[1];
if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))
return {tostr(this:title(), " can only be moved to locations matching this key:"), tostr("  ", $lock_utils:unparse_key(this.key))};
endif
.
#6:0
if (caller_perms().wizard)
pass(@args);
this.home = (this in {$no_one, $hacker, $generic_editor.owner}) ? $nothing | $player_start;
if (a = $list_utils:assoc(this, {{$prog, {$help_db["prog"], $help_db["builtin_function"], $help_db["verb"], $help_db["core"], $help_db["toaststunt"]}}, {$wiz, $help_db["wiz"]}, {$mail_recipient_class, $help_db["mail"]}, {$builder, $help_db["builder"]}, {$frand_class, $help_db["frand"]}}))
this.help = a[2];
else
this.help = 0;
endif
if (this != $player)
for p in ({"last_connect_place", "all_connect_places", "features", "previous_connection", "last_connect_time"})
clear_property(this, p);
endfor
if (is_player(this))
this.first_connect_time = $maxint;
this.last_disconnect_time = $maxint;
endif
endif
endif
.
#6:1
if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))
return E_PERM;
endif
this:("@last-connection")();
$news:check();
.
#6:2
if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))
return E_PERM;
endif
this:expunge_rmm();
this:erase_paranoid_data();
this:gc_gaglist();
return;
.
#6:3
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
this.help = 0;
return pass(@args);
else
return E_PERM;
endif
.
#6:4
return !is_player(args[1]);
.
#6:5
"Extra parsing of player commands.  Called by $command_utils:do_huh.";
"This version of my_huh just handles features.";
permissions = (((caller == this) || $perm_utils:controls(caller_perms(), this)) && $command_utils:validate_feature(@args)) ? this | $no_one;
"verb - obvious                 pass - would be args";
"plist - list of prepspecs that this command matches";
"dlist and ilist - likewise for dobjspecs, iobjspecs";
verb = args[1];
if (`$server_options.support_numeric_verbname_strings ! E_PROPNF => 0' && $string_utils:is_integer(verb))
return;
endif
pass = args[2];
plist = {"any", prepstr ? $code_utils:full_prep(prepstr) | "none"};
dlist = dobjstr ? {"any"} | {"none", "any"};
ilist = iobjstr ? {"any"} | {"none", "any"};
for fobj in (this.features)
if (!$recycler:valid(fobj))
this:remove_feature(fobj);
else
fverb = 0;
try
"Ask the FO for a matching verb.";
fverb = fobj:has_feature_verb(verb, dlist, plist, ilist);
except e (E_VERBNF)
"Try to match it ourselves.";
if (`valid(loc = $object_utils:has_callable_verb(fobj, verb)[1]) ! ANY => 0')
vargs = verb_args(loc, verb);
if ((vargs[2] in plist) && ((vargs[1] in dlist) && (vargs[3] in ilist)))
fverb = verb;
endif
endif
endtry
if (fverb)
"(got rid of notify_huh - use @find to locate feature verbs)";
set_task_perms(permissions);
fobj:(fverb)(@pass);
return 1;
endif
endif
if ($command_utils:running_out_of_time())
player:tell("You have too many features.  Parsing your command runs out of ticks while checking ", fobj.name, " (", fobj, ").");
return 1;
endif
endfor
.
#6:6
":last_huh(verb,args)  final attempt to parse a command...";
set_task_perms(caller_perms());
{verb, args} = args;
if ((verb[1] == "@") && (prepstr == "is"))
"... set or show _msg property ...";
set_task_perms(player);
$last_huh:(verb)(@args);
return 1;
elseif (verb in {"give", "hand", "get", "take", "drop", "throw"})
$last_huh:(verb)(@args);
return 1;
else
return 0;
endif
.
#6:7
":my_match_object(string [,location])";
return $string_utils:match_object(@{@args, this.location}[1..2], this);
.
#6:8
c = args[1];
if (c)
longear = {};
gear = {};
width = player:linelen();
half = width / 2;
player:tell("Carrying:");
for thing in (c)
cx = tostr(" ", thing:title());
if (length(cx) > half)
longear = {@longear, cx};
else
gear = {@gear, cx};
endif
endfor
player:tell_lines($string_utils:columnize(gear, 2, width));
player:tell_lines(longear);
endif
.
#6:9
return `this.namec ! E_PROPNF => this:title()';
.
#6:10
line = args[1];
if (!(this in connected_players()))
"...drop it on the floor...";
return 0;
elseif ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
if (this.pagelen)
"...need wizard perms if this and this.owner are different, since...";
"...only this can notify() and only this.owner can read .linebuffer...";
if ((player == this) && (this.linetask[2] != task_id()))
"...player has started a new task...";
"....linetask[2] is the taskid of the most recent player task...";
if (this.linetask[2] != this.linetask[1])
this.linesleft = this.pagelen - 2;
endif
this.linetask[2] = task_id();
endif
"... digest the current line...";
if (this.linelen > 0)
lbuf = {@this.linebuffer, @this:linesplit(line, this.linelen)};
else
lbuf = {@this.linebuffer, line};
endif
"... print out what we can...";
if (this.linesleft)
howmany = min(this.linesleft, length(lbuf));
for l in (lbuf[1..howmany])
pass(l);
endfor
this.linesleft = this.linesleft - howmany;
lbuf[1..howmany] = {};
endif
if (lbuf)
"...see if we need to say ***More***";
if (this.linetask[1] != this.linetask[2])
"....linetask[1] is the taskid of the most recent player task";
"...   for which ***More*** was printed...";
this.linetask[1] = this.linetask[2];
fork (0)
if (lb = this.linebuffer)
pass(strsub(this.more_msg, "%n", tostr(length(lb))));
endif
endfork
endif
llen = length(lbuf);
if (llen > 500)
"...way too much saved text, flush some of it...";
lbuf[1..llen - 100] = {"*** buffer overflow, lines flushed ***"};
endif
endif
this.linebuffer = lbuf;
else
if (this.linelen > 0)
for l in (this:linesplit(line, this.linelen))
pass(l);
endfor
else
pass(line);
endif
endif
.
#6:11
if (($perm_utils:controls(caller_perms(), this) || (caller == this)) || (caller_perms() == this))
set_task_perms(caller_perms());
for line in ((typeof(lines = args[1]) != LIST) ? {lines} | lines)
this:notify(tostr(line));
endfor
else
return E_PERM;
endif
.
#6:12
":linesplit(line,len) => list of substrings of line";
"used by :notify to split up long lines if .linelen>0";
{line, len} = args;
cline = {};
while (length(line) > len)
cutoff = rindex(line[1..len], " ");
if (nospace = cutoff < ((4 * len) / 5))
cutoff = len + 1;
nospace = line[cutoff] != " ";
endif
cline = {@cline, line[1..cutoff - 1]};
line = (nospace ? " " | "") + line[cutoff..$];
endwhile
return {@cline, line};
.
#6:13
return abs(this.linelen);
.
#6:14
if (player != this)
"... somebody's being sneaky...";
"... Can't do set_task_perms(player) since we need to be `this'...";
"... to notify and `this.owner' to change +c properties...";
return;
elseif (!(lbuf = this.linebuffer))
this.linesleft = this.pagelen - 2;
notify(this, "*** No more ***");
elseif (index("flush", dobjstr || "x") == 1)
this.linesleft = this.pagelen - 2;
notify(this, tostr("*** Flushed ***  ", length(lbuf), " lines"));
this.linebuffer = {};
elseif ((index("rest", dobjstr || "x") == 1) || (!this.pagelen))
this.linesleft = this.pagelen - 2;
for l in (lbuf)
notify(this, l);
endfor
this.linebuffer = {};
else
howmany = min(this.pagelen - 2, llen = length(lbuf = this.linebuffer));
for l in (lbuf[1..howmany])
notify(this, l);
endfor
this.linesleft = (this.pagelen - 2) - howmany;
this.linebuffer = lbuf[howmany + 1..llen];
if (howmany < llen)
notify(this, strsub(this.more_msg, "%n", tostr(llen - howmany)));
this.linetask[1] = task_id();
endif
endif
this.linetask[2] = task_id();
.
#6:15
if (player != this)
"... someone is being sneaky...";
"... Can't do set_task_perms(player) since we need to be `this'...";
"... to notify and `this.owner' to change +c properties...";
return;
endif
linelen = player.linelen;
if (!(prepstr in {"on", "off"}))
player:notify("Usage:  @wrap on|off");
player:notify(tostr("Word wrap is currently ", (linelen > 0) ? "on" | "off", "."));
return;
endif
player.linelen = abs(linelen) * ((prepstr == "on") ? 1 | -1);
player:notify(tostr("Word wrap is now ", prepstr, "."));
.
#6:16
if (callers() ? (caller != this) && (!$perm_utils:controls(caller_perms(), this)) | (player != this))
"... somebody is being sneaky ...";
return;
endif
curlen = player.linelen;
wrap = curlen > 0;
wrapstr = wrap ? "on" | "off";
if (!dobjstr)
player:notify(tostr("Usage:  ", verb, " <number>"));
player:notify(tostr("Current line length is ", abs(curlen), ".  Word wrapping is ", wrapstr, "."));
return;
endif
newlen = toint(dobjstr);
if (newlen < 0)
player:notify("Line length can't be a negative number.");
return;
elseif (newlen == 0)
return player:notify("Linelength zero makes no sense.  You want to use '@wrap off' if you want to turn off wrapping.");
elseif (newlen < 10)
player:notify("You don't want your linelength that small.  Setting it to 10.");
newlen = 10;
elseif (newlen > 1000)
player:notify("You don't want your line length that large.  Setting it to 1000.");
newlen = 1000;
endif
this:set_linelength(newlen);
player:notify(tostr("Line length is now ", abs(player.linelen), ".  Word wrapping is ", wrapstr, "."));
if (!wrap)
player:notify("To enable word wrapping, type `@wrap on'.");
endif
.
#6:17
"@pagelength number  -- sets page buffering to that many lines (or 0 to turn off page buffering)";
if (player != this)
"... somebody is being sneaky ...";
"... Can't do set_task_perms(player) since we need to be `this'...";
"... to notify and `this.owner' to change +c properties...";
return;
elseif (!dobjstr)
notify(player, tostr("Usage:  ", verb, " <number>"));
notify(player, tostr("Current page length is ", player.pagelen, "."));
return;
elseif (0 > (newlen = toint(dobjstr)))
notify(player, "Page length can't be a negative number.");
return;
elseif (newlen == 0)
player.pagelen = 0;
notify(player, "Page buffering off.");
if (lb = this.linebuffer)
"queued text remains";
this:notify_lines(lb);
clear_property(this, "linebuffer");
endif
elseif (newlen < 5)
player.pagelen = 5;
notify(player, "Too small.  Setting it to 5.");
else
notify(player, tostr("Page length is now ", player.pagelen = newlen, "."));
endif
if (this.linebuffer)
notify(this, strsub(this.more_msg, "%n", tostr(length(this.linebuffer))));
player.linetask = {task_id(), task_id()};
player.linesleft = 0;
else
player.linetask = {0, task_id()};
player.linesleft = player.pagelen - 2;
endif
.
#6:18
if (this.gaglist || this.paranoid)
"Check the above first, default case, to save ticks.  Paranoid gaggers are cost an extra three or so ticks by this, probably a net savings.";
if (this:gag_p())
return;
endif
if (this.paranoid == 1)
$paranoid_db:add_data(this, {{@callers(1), {player, "<cmd-line>", player}}, args});
elseif (this.paranoid == 2)
z = this:whodunnit({@callers(), {player, "", player}}, {this, $no_one}, {})[3];
args = {"(", z.name, " ", z, ") ", @args};
endif
endif
pass(@args);
.
#6:19
if (player in this.gaglist)
return 1;
elseif (gag = this.gaglist)
for x in (callers())
if (((x[1] == #-1) && (x[3] == #-1)) && (x[2] != ""))
elseif ((x[1] in gag) || (x[4] in gag))
return 1;
endif
endfor
endif
return 0;
"--- old definition --";
if (player in this.gaglist)
return 1;
elseif (this.gaglist)
for x in (callers())
if (valid(x[1]))
if (x[1] in this.gaglist)
return 1;
endif
endif
endfor
endif
return 0;
.
#6:20
":set_gaglist(@newlist) => this.gaglist = newlist";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return E_PERM;
else
return this.gaglist = args;
endif
.
#6:21
set_task_perms(player);
if (player != this)
player:notify("Permission denied.");
return;
endif
if (!args)
player:notify(tostr("Usage:  ", verb, " <player or object> [<player or object>...]"));
return;
endif
victims = $string_utils:match_player_or_object(@args);
changed = 0;
for p in (victims)
if (p in player.gaglist)
player:notify(tostr("You are already gagging ", p.name, "."));
elseif (p == player)
player:notify("Gagging yourself is a bad idea.");
elseif (children(p) && (verb != "@gag!"))
player:tell("If you really want to gag all descendents of ", $string_utils:nn(p), ", use `@gag! ", p, "' instead.");
else
changed = 1;
player:set_gaglist(@setadd(this.gaglist, p));
endif
endfor
if (changed)
this:("@listgag")();
endif
.
#6:22
set_task_perms(valid(caller_perms()) ? caller_perms() | player);
if (!this.gaglist)
player:notify(tostr("You are ", callers() ? "no longer gagging anything." | "not gagging anything right now."));
else
player:notify(tostr("You are ", callers() ? "now" | "currently", " gagging ", $string_utils:nn(this.gaglist), "."));
endif
gl = {};
if (args)
player:notify("Searching for players who may be gagging you...");
for p in (players())
if ((typeof(`p.gaglist ! E_PERM') == LIST) && (this in p.gaglist))
gl = {@gl, p};
endif
$command_utils:suspend_if_needed(10, "...searching gaglist...");
endfor
if (gl || (!callers()))
player:notify(tostr($string_utils:nn(gl, " ", "No one"), " appear", (length(gl) <= 1) ? "s" | "", " to be gagging you."));
endif
endif
.
#6:23
if ((player != this) || ((caller != this) && (!$perm_utils:controls(caller_perms(), this))))
player:notify("Permission denied.");
elseif (dobjstr == "")
player:notify(tostr("Usage:  ", verb, " <player>  or  ", verb, " everyone"));
elseif (dobjstr == "everyone")
this.gaglist = {};
player:notify("You are no longer gagging anyone or anything.");
else
if (valid(dobj))
match = dobj;
elseif ((match = toobj(dobjstr)) > #0)
else
match = $string_utils:match(dobjstr, this.gaglist, "name", this.gaglist, "aliases");
endif
if (match == $failed_match)
player:notify(tostr("You don't seem to be gagging anything named ", dobjstr, "."));
elseif (match == $ambiguous_match)
player:notify(tostr("I don't know which \"", dobjstr, "\" you mean."));
else
this.gaglist = setremove(this.gaglist, match);
player:notify(tostr(valid(match) ? match.name | match, " removed from gag list."));
endif
this:("@listgag")();
endif
.
#6:24
{record, trust, mistrust} = args;
s = {this, "???", this};
for w in (record)
if (((((!valid(s[3])) || s[3].wizard) || (s[3] in trust)) && (!(s[3] in mistrust))) || (s[1] == this))
s = w;
else
return s;
endif
endfor
return s;
.
#6:25
responsible = $paranoid_db:get_data(this);
if (length(verb) <= 6)
"@check, not @check-full";
n = 5;
trust = {this, $no_one};
"... trust no one, my friend.... no one....  --Herod";
mistrust = {};
for k in (args)
if (z = $code_utils:toint(k))
n = z;
elseif (k[1] == "!")
mistrust = listappend(mistrust, $string_utils:match_player(k[2..$]));
else
trust = listappend(trust, $string_utils:match_player(k));
endif
endfor
msg_width = player:linelen() - 60;
for q in ((n > (y = length(responsible))) ? responsible | responsible[(y - n) + 1..y])
msg = tostr(@q[2]);
if (length(msg) > msg_width)
msg = msg[1..msg_width];
endif
s = this:whodunnit(q[1], trust, mistrust);
text = valid(s[1]) ? s[1].name | "** NONE **";
this:notify(tostr($string_utils:left(tostr((length(text) > 13) ? text[1..13] | text, " (", s[1], ")"), 20), $string_utils:left(s[2], 15), $string_utils:left(tostr((length(s[3].name) > 13) ? s[3].name[1..13] | s[3].name, " (", s[3], ")"), 20), msg));
endfor
this:notify("*** finished ***");
else
"@check-full, from @traceback by APHiD";
"s_i_n's by Ho_Yan 10/18/94";
matches = {};
if (length(match = argstr) == 0)
player:notify(tostr("Usage: ", verb, " <string> --or-- ", verb, " <number>"));
return;
endif
if (!responsible)
player:notify("No text has been saved by the monitor.  (See `help @paranoid').");
else
if (typeof(x = $code_utils:toint(argstr)) == ERR)
for line in (responsible)
if (index(tostr(@line[$]), argstr))
matches = {@matches, line};
endif
endfor
else
matches = responsible[($ - min(x, $)) + 1..$];
endif
if (matches)
for match in (matches)
$command_utils:suspend_if_needed(3);
text = tostr(@match[$]);
player:notify("Traceback for:");
player:notify(text);
"Moved cool display code to $code_utils, 3/29/95, Ho_Yan";
$code_utils:display_callers(listdelete(mm = match[1], length(mm)));
endfor
player:notify("**** finished ****");
else
player:notify(tostr("No matches for \"", argstr, "\" found."));
endif
endif
endif
.
#6:26
if ((args == {}) || ((typ = args[1]) == ""))
$paranoid_db:set_kept_lines(this, 10);
this.paranoid = 1;
this:notify("Anti-spoofer on and keeping 10 lines.");
elseif (index("immediate", typ))
$paranoid_db:set_kept_lines(this, 0);
this.paranoid = 2;
this:notify("Anti-spoofer now in immediate mode.");
elseif (index("off", typ) || (typ == "0"))
this.paranoid = 0;
$paranoid_db:set_kept_lines(this, 0);
this:notify("Anti-spoofer off.");
elseif ((tostr(y = toint(typ)) != typ) || (y < 0))
this:notify(tostr("Usage: ", verb, " <lines to be kept>     to turn on your anti-spoofer."));
this:notify(tostr("       ", verb, " off                    to turn it off."));
this:notify(tostr("       ", verb, " immediate              to use immediate mode."));
else
this.paranoid = 1;
kept = $paranoid_db:set_kept_lines(this, y);
this:notify(tostr("Anti-spoofer on and keeping ", kept, " lines."));
endif
.
#6:27
buggers = 1;
found_listener = 0;
here = this.location;
for thing in (setremove(here.contents, this))
tellwhere = $object_utils:has_verb(thing, "tell");
notifywhere = $object_utils:has_verb(thing, "notify");
if (thing in connected_players())
this:notify(tostr(thing.name, " (", thing, ") is listening."));
found_listener = 1;
elseif ($object_utils:has_callable_verb(thing, "sweep_msg") && (typeof(msg = thing:sweep_msg()) == STR))
this:notify(tostr(thing.name, " (", thing, ") ", msg, "."));
found_listener = 1;
elseif (tellwhere && (((owner = verb_info(tellwhere[1], "tell")[1]) != this) && (!owner.wizard)))
this:notify(tostr(thing.name, " (", thing, ") has been taught to listen by ", owner.name, " (", owner, ")"));
found_listener = 1;
elseif (notifywhere && (((owner = verb_info(notifywhere[1], "notify")[1]) != this) && (!owner.wizard)))
this:notify(tostr(thing.name, " (", thing, ") has been taught to listen by ", owner.name, " (", owner, ")"));
found_listener = 1;
endif
endfor
buggers = {};
for v in ({"announce", "announce_all", "announce_all_but", "say", "emote", "huh", "here_huh", "huh2", "whisper", "here_explain_syntax"})
vwhere = $object_utils:has_verb(here, v);
if (vwhere && (((owner = verb_info(vwhere[1], v)[1]) != this) && (!owner.wizard)))
buggers = setadd(buggers, owner);
endif
endfor
if (buggers != {})
if ($object_utils:has_verb(here, "sweep_msg") && (typeof(msg = here:sweep_msg()) == STR))
this:notify(tostr(here.name, " (", here, ") ", msg, "."));
else
this:notify(tostr(here.name, " (", here, ") may have been bugged by ", $string_utils:english_list($list_utils:map_prop(buggers, "name")), "."));
endif
elseif (!found_listener)
this:notify("Communications look secure.");
endif
.
#6:28
this:tell(player.name, " whispers, \"", dobjstr, "\"");
player:tell("You whisper, \"", dobjstr, "\" to ", this.name, ".");
.
#6:29
nargs = length(args);
if (nargs < 1)
player:notify(tostr("Usage: ", verb, " <player> [with <message>]"));
return;
endif
who = $string_utils:match_player(args[1]);
if ($command_utils:player_match_result(who, args[1])[1])
return;
elseif (who in this.gaglist)
player:tell("You have ", who:title(), " @gagged.  If you paged ", $gender_utils:get_pronoun("o", who), ", ", $gender_utils:get_pronoun("s", who), " wouldn't be able to answer you.");
return;
endif
"for pronoun_sub's benefit...";
dobj = who;
iobj = player;
header = player:page_origin_msg();
text = "";
if (nargs > 1)
if ((args[2] == "with") && (nargs > 2))
msg_start = 3;
else
msg_start = 2;
endif
msg = $string_utils:from_list(args[msg_start..nargs], " ");
text = tostr($string_utils:pronoun_sub(($string_utils:index_delimited(header, player.name) ? "%S" | "%N") + " %<pages>, \""), msg, "\"");
endif
result = text ? who:receive_page(header, text) | who:receive_page(header);
if (result == 2)
"not connected";
player:tell((typeof(msg = who:page_absent_msg()) == STR) ? msg | $string_utils:pronoun_sub("%n is not currently logged in.", who));
else
player:tell(who:page_echo_msg());
endif
.
#6:30
"called by $player:page.  Two args, the page header and the text, all pre-processed by the page command.  Could be extended to provide haven abilities, multiline pages, etc.  Indeed, at the moment it just does :tell_lines, so we already do have multiline pages, if someone wants to take advantage of it.";
"Return codes:";
"  1:  page was received";
"  2:  player is not connected";
"  0:  page refused";
"If a specialization wants to refuse a page, it should return 0 to say it was refused.  If it uses pass(@args) it should propagate back up the return value.  It is possible that this code should interact with gagging and return 0 if the page was gagged.";
if (this:is_listening())
this:tell_lines_suspended(args);
return 1;
else
return 2;
endif
.
#6:31
"set_task_perms(this.owner)";
return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(this.(verb), this) | "";
.
#6:32
if (c = player:contents())
this:tell_contents(c);
else
player:tell("You are empty-handed.");
endif
.
#6:33
player:tell(this:titlec());
pass();
if (!(this in connected_players()))
player:tell($gender_utils:pronoun_sub("%{:He} %{!is} sleeping.", this));
elseif ((idle = idle_seconds(this)) < 60)
player:tell($gender_utils:pronoun_sub("%{:He} %{!is} awake and %{!looks} alert.", this));
else
time = $string_utils:from_seconds(idle);
player:tell($gender_utils:pronoun_sub("%{:He} %{!is} awake, but %{!has} been staring off into space for ", this), time, ".");
endif
if (c = this:contents())
this:tell_contents(c);
endif
.
#6:34
start = this.location;
if (start == this.home)
player:tell("You're already home!");
return;
elseif (typeof(this.home) != OBJ)
player:tell("You've got a weird home, pal.  I've reset it to the default one.");
this.home = $player_start;
elseif (!valid(this.home))
player:tell("Oh no!  Your home's been recycled.  Time to look around for a new one.");
this.home = $player_start;
else
player:tell("You click your heels three times.");
endif
this:moveto(this.home);
if (!valid(start))
elseif (start == this.location)
start:announce(player.name, " ", $gender_utils:get_conj("learns", player), " that you can never go home...");
else
try
start:announce(player.name, " ", $gender_utils:get_conj("goes", player), " home.");
except e (E_VERBNF)
"start did not support announce";
endtry
endif
if (this.location == this.home)
this.location:announce(player.name, " ", $gender_utils:get_conj("comes", player), " home.");
elseif (this.location == start)
player:tell("Either home doesn't want you, or you don't really want to go.");
else
player:tell("Wait a minute!  This isn't your home...");
if (valid(this.location))
this.location:announce(player.name, " ", $gender_utils:get_conj("arrives", player), ", looking quite bewildered.");
endif
endif
.
#6:35
set_task_perms(this);
here = this.location;
if (!$perm_utils:controls(player, player))
player:notify("Players who do not own themselves may not modify their home.");
elseif (!$object_utils:has_callable_verb(here, "accept_for_abode"))
player:notify("This is a pretty odd place.  You should make your home in an actual room.");
elseif (here:accept_for_abode(this))
this.home = here;
player:notify(tostr(here.name, " is your new home."));
else
player:notify(tostr("This place doesn't want to be your home.  Contact ", here.owner.name, " to be added to the residents list of this place, or choose another place as your home."));
endif
.
#6:36
player:tell("This is not a pick-up joint!");
this:tell(player.name, " tried to pick you up.");
.
#6:37
"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.";
set_task_perms((caller == this) ? this | $no_one);
dobj = this:my_match_object(dobjstr);
iobj = this:my_match_object(iobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr) || ((iobj != $nothing) && $command_utils:object_match_failed(iobj, iobjstr)))
return;
endif
if ((!$perm_utils:controls(this, dobj)) && (this != dobj))
player:tell("You may only @move your own things.");
return;
endif
old_loc = dobj.location;
if (old_loc == iobj)
player:tell(dobj.name, " is already ", valid(iobj) ? "in " + iobj.name | "nowhere", ".");
return;
endif
dobj:moveto(iobj);
if (dobj.location == iobj)
player:tell("Moved.");
if (is_player(dobj))
if (valid(old_loc))
old_loc:announce_all(dobj.name, " disappears suddenly for parts unknown.");
if (dobj != player)
dobj:tell("You have been moved by ", player.name, ".");
endif
endif
if (valid(dobj.location))
dobj.location:announce(dobj.name, " materializes out of thin air.");
endif
endif
elseif (dobj.location == old_loc)
if ($object_utils:contains(dobj, iobj))
player:tell(iobj.name, " is inside of ", dobj.name, "!");
else
player:tell($string_utils:pronoun_sub("Either %d doesn't want to go, or %i doesn't want to accept %[dpo]."));
endif
elseif (dobj == player)
player:tell("You have been deflected from your original destination.");
else
player:tell($string_utils:pronoun_sub("%D has been deflected from %[dpp] original destination."));
endif
.
#6:38
set_task_perms(player);
if (iobjstr == "here")
iobj = player.location;
elseif (iobjstr == "me")
iobj = player;
elseif ($command_utils:object_match_failed(iobj, iobjstr))
return;
endif
if (!$perm_utils:controls(player, iobj))
player:notify(tostr("You are not the owner of ", iobj.name, "."));
return;
endif
if (dobjstr == "me")
dobj = player;
else
dobj = $string_utils:literal_object(dobjstr);
if (dobj == $failed_match)
dobj = iobj:match(dobjstr);
endif
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
endif
if (dobj.location != iobj)
player:notify(tostr(dobj.name, "(", dobj, ") is not in ", iobj.name, "(", iobj, ")."));
return;
endif
if (dobj.wizard)
player:notify(tostr("Sorry, you can't ", verb, " a wizard."));
dobj:tell(player.name, " tried to ", verb, " you.");
return;
endif
iobj:((verb == "@eject") ? "eject" | "eject_basic")(dobj);
player:notify($object_utils:has_callable_verb(iobj, "ejection_msg") ? iobj:ejection_msg() | $room:ejection_msg());
if (verb != "@eject!!")
dobj:tell($object_utils:has_callable_verb(iobj, "victim_ejection_msg") ? iobj:victim_ejection_msg() | $room:victim_ejection_msg());
endif
iobj:announce_all_but({player, dobj}, $object_utils:has_callable_verb(iobj, "oejection_msg") ? iobj:oejection_msg() | $room:oejection_msg());
.
#6:39
if (!args)
them = connected_players();
else
who = $command_utils:player_match_result($string_utils:match_player(args), args);
if (length(who) <= 1)
if (!who[1])
player:notify("Where is who?");
endif
return;
elseif (who[1])
player:notify("");
endif
them = listdelete(who, 1);
endif
lmax = rmax = 0;
for p in (them)
player:notify(tostr($string_utils:left($string_utils:nn(p), 25), " ", $string_utils:nn(p.location)));
endfor
.
#6:40
if (caller != player)
return E_PERM;
endif
plyrs = args ? listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1) | connected_players();
if (!plyrs)
return;
elseif (length(plyrs) > 100)
player:tell("You have requested a listing of ", length(plyrs), " players.  Please either specify individual players you are interested in, to reduce the number of players in any single request, or else use the `@users' command instead.  The lag thanks you.");
return;
endif
$code_utils:show_who_listing(plyrs);
.
#6:41
"@wizards [all]";
if (caller != player)
return E_PERM;
endif
if (args)
$code_utils:show_who_listing($wiz_utils:all_wizards());
else
$code_utils:show_who_listing($wiz_utils:connected_wizards()) || player:notify("No wizards currently logged in.");
endif
.
#6:42
set_task_perms(callers() ? caller_perms() | player);
"...this code explicitly relies on being !d in several places...";
if ((index(verb, "?") != 1) || (length(verb) <= 1))
what = $string_utils:trimr(argstr);
elseif (argstr)
what = tostr(verb[2..$], " ", $string_utils:trimr(argstr));
else
what = verb[2..$];
endif
"...find a db that claims to know about `what'...";
dblist = $code_utils:help_db_list();
result = $code_utils:help_db_search(what, dblist);
if (!result)
"... note: all of the last-resort stuff...";
"... is now located on $help:find_topics/get_topic...";
$wiz_utils:missed_help(what, result);
player:notify(tostr("Sorry, but no help is available on `", what, "'."));
elseif (result[1] == $ambiguous_match)
$wiz_utils:missed_help(what, result);
player:notify_lines(tostr("Sorry, but the topic-name `", what, "' is ambiguous.  I don't know which of the following topics you mean:"));
for x in ($help:columnize(@$help:sort_topics(result[2])))
player:notify(tostr("   ", x));
endfor
else
{help, topic} = result;
if (topic != what)
player:notify(tostr("Showing help on `", topic, "':"));
player:notify("----");
endif
dblist = dblist[1 + (help in dblist)..$];
if (1 == (text = help:get_topic(topic, dblist)))
"...get_topic took matters into its own hands...";
elseif (text)
"...these can get long...";
for line in ((typeof(text) == LIST) ? text | {text})
if (typeof(line) != STR)
player:notify("Odd results from help -- complain to a wizard.");
else
player:notify(line);
endif
$command_utils:suspend_if_needed(0);
endfor
else
player:notify(tostr("Help DB ", help, " thinks it knows about `", what, "' but something's messed up."));
player:notify(tostr("Tell ", help.owner.wizard ? "" | tostr(help.owner.name, " (", help.owner, ") or "), "a wizard."));
endif
endif
.
#6:43
":display_option(name) => returns the value of the specified @display option";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return $options["display"]:get(this.display_options, args[1]);
else
return E_PERM;
endif
.
#6:44
":edit_option(name) => returns the value of the specified edit option";
if ((caller == this) || ($object_utils:isa(caller, $generic_editor) || $perm_utils:controls(caller_perms(), this)))
return $options["edit"]:get(this.edit_options, args[1]);
else
return E_PERM;
endif
.
#6:45
":set_edit_option(oname,value)";
":set_display_option(oname,value)";
":set_mail_option(oname,value)";
"Changes the value of the named option.";
"Returns a string error if something goes wrong.";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return tostr(E_PERM);
endif
"...this is kludgy, but it saves me from writing the same verb 3 times.";
"...there's got to be a better way to do this...";
verb[1..4] = "";
foo_options = verb + "s";
prop = verb[1..index(verb, "_") - 1];
"...";
if (typeof(s = $options[prop]:set(this.(foo_options), @args)) == STR)
return s;
elseif (s == this.(foo_options))
return 0;
else
this.(foo_options) = s;
return 1;
endif
.
#6:46
"@<what>-option <option> [is] <value>   sets <option> to <value>";
"@<what>-option <option>=<value>        sets <option> to <value>";
"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1";
"@<what>-option -<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option !<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option <option>      displays value of <option>";
set_task_perms(player);
what = {"mail", "edit", "display", "general"}[index("medg", verb[2])];
options = what + "_options";
option_pkg = $options[what];
set_option = ("set_" + what) + "_option";
if (!args)
player:notify_lines({("Current " + what) + " options:", "", @option_pkg:show(this.(options), option_pkg.names)});
return;
elseif (typeof(presult = option_pkg:parse(args)) == STR)
player:notify(presult);
return;
else
if (length(presult) > 1)
if (typeof(sresult = this:(set_option)(@presult)) == STR)
player:notify(sresult);
return;
elseif (!sresult)
player:notify("No change.");
return;
endif
endif
player:notify_lines(option_pkg:show(this.(options), presult[1]));
endif
.
#6:47
"set_name(newname) attempts to change this.name to newname";
"  => E_PERM   if you don't own this";
"  => E_INVARG if the name is already taken or prohibited for some reason";
"  => E_NACC   if the player database is not taking new names right now.";
"  => E_ARGS   if the name is too long (controlled by $login.max_player_name)";
"  => E_QUOTA  if the player is not allowed to change eir name.";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
elseif (!is_player(this))
"we don't worry about the names of player classes.";
set_task_perms(caller_perms());
return pass(@args);
elseif ($player_db.frozen)
return E_NACC;
elseif (length(name = args[1]) > $login.max_player_name)
return E_ARGS;
elseif (!($player_db:available(name, this) in {this, 1}))
return E_INVARG;
else
old = this.name;
this.name = name;
if ((name != old) && (!(old in this.aliases)))
$player_db:delete(old);
endif
$player_db:insert(name, this);
return 1;
endif
.
#6:48
"set_aliases(alias_list)";
"For changing player aliases, we check to make sure that none of the aliases match existing player names/aliases.  Aliases containing spaces are not entered in the $player_db and so are not subject to this restriction ($string_utils:match_player will not match on them, however, so they only match if used in the immediate room, e.g., with match_object() or somesuch).";
"Also we make sure that the .name is included in the .alias list.  In any situation where .name and .aliases are both being changed, do the name change first.";
"  => 1        if successful, and aliases changed from previous setting.";
"  => 0        if resulting work didn't change aliases from previous.";
"  => E_PERM   if you don't own this";
"  => E_NACC   if the player database is not taking new aliases right now.";
"  => E_TYPE   if alias_list is not a list";
"  => E_INVARG if any element of alias_list is not a string";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
elseif (!is_player(this))
"we don't worry about the names of player classes.";
return pass(@args);
elseif ($player_db.frozen)
return E_NACC;
elseif (typeof(aliases = args[1]) != LIST)
return E_TYPE;
elseif ((length(aliases = setadd(aliases, this.name)) > ($object_utils:has_property($local, "max_player_aliases") ? $local.max_player_aliases | $maxint)) && (length(aliases) >= length(this.aliases)))
return E_INVARG;
else
for a in (aliases)
if (typeof(a) != STR)
return E_INVARG;
endif
if ((!(index(a, " ") || index(a, "	"))) && (!($player_db:available(a, this) in {this, 1})))
aliases = setremove(aliases, a);
endif
endfor
old = this.aliases;
this.aliases = aliases;
for a in (old)
if (!(a in aliases))
$player_db:delete2(a, this);
endif
endfor
for a in (aliases)
if (!(index(a, " ") || index(a, "	")))
$player_db:insert(a, this);
endif
endfor
return this.aliases != old;
endif
.
#6:49
if ((player != caller) || (player != this))
return;
endif
set_task_perms(player);
bynumber = verb == "@rename#";
spec = $code_utils:parse_verbref(dobjstr);
if (spec)
if (!player.programmer)
return player:notify(tostr(E_PERM));
endif
object = this:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
vname = spec[2];
if (bynumber)
vname = $code_utils:toint(vname);
if (vname == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
endif
try
info = verb_info(object, vname);
try
result = set_verb_info(object, vname, listset(info, iobjstr, 3));
player:notify("Verb name changed.");
except e (ANY)
player:notify(e[2]);
endtry
except (E_VERBNF)
player:notify("That object does not define that verb.");
except e (ANY)
player:notify(e[2]);
endtry
endif
elseif (bynumber)
player:notify("@rename# can only be used with verbs.");
elseif (pspec = $code_utils:parse_propref(dobjstr))
if (!player.programmer)
return player:notify(tostr(E_PERM));
endif
object = this:my_match_object(pspec[1]);
if (!$command_utils:object_match_failed(object, pspec[1]))
pname = pspec[2];
try
info = property_info(object, pname);
try
result = set_property_info(object, pname, {@info, iobjstr});
player:notify("Property name changed.");
except e (ANY)
player:notify(e[2]);
endtry
except (E_PROPNF)
player:notify("That object does not define that property.");
except e (ANY)
player:notify(e[2]);
endtry
endif
else
object = this:my_match_object(dobjstr);
if (!$command_utils:object_match_failed(object, dobjstr))
old_name = object.name;
old_aliases = object.aliases;
if (e = $building_utils:set_names(object, iobjstr))
if (strcmp(object.name, old_name) == 0)
name_message = tostr("Name of ", object, " (", old_name, ") is unchanged");
else
name_message = tostr("Name of ", object, " changed to \"", object.name, "\"");
endif
aliases = $string_utils:from_value(object.aliases, 1);
if (object.aliases == old_aliases)
alias_message = tostr(".  Aliases are unchanged (", aliases, ").");
else
alias_message = tostr(", with aliases ", aliases, ".");
endif
player:notify(name_message + alias_message);
elseif (e == E_INVARG)
player:notify("That particular name change not allowed (see help @rename).");
if (object == player)
player:notify($player_db:why_bad_name(player, iobjstr));
endif
elseif (e == E_NACC)
player:notify("Oops.  You can't update that name right now; try again in a few minutes.");
elseif (e == E_ARGS)
player:notify(tostr("Sorry, name too long.  Maximum number of characters in a name:  ", $login.max_player_name));
elseif (e == 0)
player:notify("Name and aliases remain unchanged.");
else
player:notify(tostr(e));
endif
endif
endif
.
#6:50
"Syntax: @addalias <alias>[,...,<alias>] to <object>";
"        @addalias <alias>[,...,<alias>] to <object>:<verb>";
"";
"The first form is used to add aliases to an object's list of aliases.  You can separate multiple aliases with commas.  The aliases will be checked against the object's current aliases and all aliases not already in the object's list of aliases will be added.";
"";
"Example:";
"Muchkin wants to add new aliases to Rover the Wonder Dog:";
"  @addalias Dog,Wonder Dog to Rover";
"Since Rover the Wonder Dog already has the alias \"Dog\" but does not have the alias \"Wonder Dog\", Munchkin sees:";
"  Rover the Wonder Dog(#4237) already has the alias Dog.";
"  Alias Wonder Dog added to Rover the Wonder Dog(#4237).";
"";
"If the object is a player, spaces will also be assumed to be separations between aliases and each alias will be checked against the Player Name Database to make sure no one else is using it. Any already used aliases will be identified.";
"";
"Example:";
"Munchkin wants to add his nicknames to his own list of aliases:";
"  @addalias Foobar Davey to me";
"@Addalias recognizes that Munchkin is trying to add an alias to a valid player and checks the aliases against the Player Name Database.  Unfortunately, DaveTheMan is already using the alias \"Davey\" so Munchkin sees:";
"  DaveTheMan(#5432) is already using the alias Davey";
"  Alias Foobar added to Munchkin(#1523).";
"";
"The second form of the @addalias command is for use by programmers, to add aliases to a verb they own.  All commas and spaces are assumed to be separations between aliases.";
if (player != this)
return;
endif
set_task_perms(player);
bynumber = verb[$] == "#";
spec = $code_utils:parse_verbref(iobjstr);
if (spec)
if (!player.programmer)
return player:notify(tostr(E_PERM));
endif
object = player:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
vname = spec[2];
if (bynumber)
if ((vname = $code_utils:toint(vname)) == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
endif
try
info = verb_info(object, vname);
old_aliases = $string_utils:explode(info[3]);
used = {};
for alias in (new_aliases = $list_utils:remove_duplicates($string_utils:explode(strsub(dobjstr, ",", " "))))
if (alias in old_aliases)
used = {@used, alias};
new_aliases = setremove(new_aliases, alias);
endif
endfor
if (used)
player:notify(tostr(object.name, "(", object, "):", vname, " already has the alias", (length(used) > 1) ? "es" | "", " ", $string_utils:english_list(used), "."));
endif
if (new_aliases)
info = listset(info, aliases = $string_utils:from_list({@old_aliases, @new_aliases}, " "), 3);
try
result = set_verb_info(object, vname, info);
player:notify(tostr("Alias", (length(new_aliases) > 1) ? "es" | "", " ", $string_utils:english_list(new_aliases), " added to verb ", object.name, "(", object, "):", vname));
player:notify(tostr("Verbname is now ", object.name, "(", object, "):\"", aliases, "\""));
except e (ANY)
player:notify(e[2]);
endtry
endif
if ((!new_aliases) && (!used))
"Pathological case, we failed to parse dobjstr, possibly consisted only of commas, spaces, or just the empty string";
player:notify("Did not understand what aliases to add from value:  " + dobjstr);
endif
except (E_VERBNF)
player:notify("That object does not define that verb.");
except e (ANY)
player:notify(e[2]);
endtry
endif
elseif (bynumber)
player:notify(tostr(verb, " can only be used with verbs."));
else
object = player:my_match_object(iobjstr);
if (!$command_utils:object_match_failed(object, iobjstr))
old_aliases = object.aliases;
used = {};
for alias in (new_aliases = $list_utils:remove_duplicates($list_utils:map_arg($string_utils, "trim", $string_utils:explode(is_player(object) ? strsub(dobjstr, " ", ",") | dobjstr, ","))))
if (alias in old_aliases)
used = {@used, alias};
new_aliases = setremove(new_aliases, alias);
elseif (is_player(object) && valid(someone = $player_db:find_exact(alias)))
player:notify(tostr(someone.name, "(", someone, ") is already using the alias ", alias, "."));
new_aliases = setremove(new_aliases, alias);
endif
endfor
if (used)
player:notify(tostr(object.name, "(", object, ") already has the alias", (length(used) > 1) ? "es" | "", " ", $string_utils:english_list(used), "."));
endif
if (new_aliases)
if ((e = object:set_aliases(aliases = {@old_aliases, @new_aliases})) && (object.aliases == aliases))
player:notify(tostr("Alias", (length(new_aliases) > 1) ? "es" | "", " ", $string_utils:english_list(new_aliases), " added to ", object.name, "(", object, ")."));
player:notify(tostr("Aliases for ", $string_utils:nn(object), " are now ", $string_utils:from_value(aliases, 1)));
elseif (e)
player:notify("That particular name change not allowed (see help @rename or help @addalias).");
elseif (e == E_INVARG)
if ($object_utils:has_property(#0, "local"))
if ($object_utils:has_property($local, "max_player_aliases"))
max = $local.max_player_aliases;
player:notify(("You are not allowed more than " + tostr(max)) + " aliases.");
endif
else
player:notify("You are not allowed any more aliases.");
endif
elseif (e == E_NACC)
player:notify("Oops.  You can't update that object's aliases right now; try again in a few minutes.");
elseif (e == 0)
player:notify("Aliases not changed as expected!");
player:notify(tostr("Aliases for ", $string_utils:nn(object), " are now ", $string_utils:from_value(object.aliases, 1)));
else
player:notify(tostr(e));
endif
else
player:tell("No new aliases found to add.");
endif
endif
endif
.
#6:51
"Syntax: @rmalias <alias>[,...,<alias>] from <object>";
"        @rmalias <alias>[,...,<alias>] from <object>:<verb>";
"";
"The first form is used to remove aliases from an object.  If the object is a valid player, space and commas will be assumed to be separations between unwanted aliases.  Otherwise, only commas will be assumed to be separations.";
"[5/10/93 Nosredna: flushed above is_player feature";
"Note that @rmalias will not affect the object's name, only its aliases.";
"";
"The second form is for use by programmers, to remove aliases from a verb they own.  All spaces and commas are assumed to be separations between unwanted aliases.";
if (player != this)
return;
endif
set_task_perms(player);
bynumber = verb[$] == "#";
spec = $code_utils:parse_verbref(iobjstr);
if (spec)
if (!player.programmer)
player:notify(tostr(E_PERM));
endif
object = player:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
vname = spec[2];
if (bynumber)
if ((vname = $code_utils:toint(vname)) == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
endif
try
info = verb_info(object, vname);
old_aliases = $string_utils:explode(info[3]);
not_used = {};
for alias in (bad_aliases = $list_utils:remove_duplicates($string_utils:explode(strsub(dobjstr, ",", " "))))
if (!(alias in old_aliases))
not_used = {@not_used, alias};
bad_aliases = setremove(bad_aliases, alias);
else
old_aliases = setremove(old_aliases, alias);
endif
endfor
if (not_used)
player:notify(tostr(object.name, "(", object, "):", vname, " does not have the alias", (length(not_used) > 1) ? "es" | "", " ", $string_utils:english_list(not_used), "."));
endif
if (bad_aliases && old_aliases)
info = listset(info, aliases = $string_utils:from_list(old_aliases, " "), 3);
try
result = set_verb_info(object, vname, info);
player:notify(tostr("Alias", (length(bad_aliases) > 1) ? "es" | "", " ", $string_utils:english_list(bad_aliases), " removed from verb ", object.name, "(", object, "):", vname));
player:notify(tostr("Verbname is now ", object.name, "(", object, "):\"", aliases, "\""));
except e (ANY)
player:notify(e[2]);
endtry
elseif (!old_aliases)
player:notify("You have to leave a verb with at least one alias.");
else
player:notify("No aliases removed.");
endif
except (E_VERBNF)
player:notify("That object does not define that verb.");
except e (ANY)
player:notify(e[2]);
endtry
endif
elseif (bynumber)
player:notify(tostr(verb, " can only be used with verbs."));
else
object = player:my_match_object(iobjstr);
if (!$command_utils:object_match_failed(object, iobjstr))
old_aliases = object.aliases;
not_used = {};
for alias in (bad_aliases = $list_utils:remove_duplicates($list_utils:map_arg($string_utils, "trim", $string_utils:explode(dobjstr, ","))))
"removed is_player(object) ? strsub(dobjstr, \" \", \",\") | --Nosredna";
if (!(alias in old_aliases))
not_used = {@not_used, alias};
bad_aliases = setremove(bad_aliases, alias);
else
old_aliases = setremove(old_aliases, alias);
endif
endfor
if (not_used)
player:notify(tostr(object.name, "(", object, ") does not have the alias", (length(not_used) > 1) ? "es" | "", " ", $string_utils:english_list(not_used), "."));
endif
if (bad_aliases)
if (e = object:set_aliases(old_aliases))
player:notify(tostr("Alias", (length(bad_aliases) > 1) ? "es" | "", " ", $string_utils:english_list(bad_aliases), " removed from ", object.name, "(", object, ")."));
player:notify(tostr("Aliases for ", object.name, "(", object, ") are now ", $string_utils:from_value(old_aliases, 1)));
elseif (e == E_INVARG)
player:notify("That particular name change not allowed (see help @rename or help @rmalias).");
elseif (e == E_NACC)
player:notify("Oops.  You can't update that object's aliases right now; try again in a few minutes.");
elseif (e == 0)
player:notify("Aliases not changed as expected!");
player:notify(tostr("Aliases for ", $string_utils:nn(object), " are ", $string_utils:from_value(object.aliases, 1)));
else
player:notify(tostr(e));
endif
else
player:notify("Aliases unchanged.");
endif
endif
endif
.
#6:52
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
"...lose...";
elseif (e = dobj:set_description(iobjstr))
player:notify("Description set.");
else
player:notify(tostr(e));
endif
.
#6:53
set_task_perms(player);
if (dobjstr == "")
player:notify(tostr("Usage:  ", verb, " <object>"));
return;
endif
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
found_one = 0;
props = $object_utils:all_properties(dobj);
if (typeof(props) == ERR)
player:notify("You can't read the messages on that.");
return;
endif
for pname in (props)
len = length(pname);
if ((len > 4) && (pname[len - 3..len] == "_msg"))
found_one = 1;
msg = `dobj.(pname) ! ANY';
if (msg == E_PERM)
value = "isn't readable by you.";
elseif (!msg)
value = "isn't set.";
elseif (typeof(msg) == LIST)
value = "is a list.";
elseif (typeof(msg) != STR)
value = "is corrupted! **";
else
value = "is " + $string_utils:print(msg);
endif
player:notify(tostr("@", pname[1..len - 4], " ", dobjstr, " ", value));
endif
endfor
if (!found_one)
player:notify("That object doesn't have any messages to set.");
endif
.
#6:54
$note_editor:invoke(dobjstr, verb);
.
#6:55
"@last-c           reports when and from where you last connected.";
"@last-c all       adds the 10 most recent places you connected from.";
"@last-c confunc   is like `@last-c' but is silent on first login.";
opts = {"all", "confunc"};
i = 0;
if (caller != this)
return E_PERM;
elseif (args && ((length(args) > 1) || (!(i = $string_utils:find_prefix(args[1], opts)))))
this:notify(tostr("Usage:  ", verb, " [all]"));
return;
endif
opt_all = i && (opts[i] == "all");
opt_confunc = i && (opts[i] == "confunc");
if (!(prev = this.previous_connection))
this:notify("Something was broken when you logged in; tell a wizard.");
elseif (prev[1] == 0)
opt_confunc || this:notify("Your previous connection was before we started keeping track.");
elseif (prev[1] > time())
this:notify("This is your first time connected.");
else
this:notify(tostr("Last connected ", this:ctime(prev[1]), " from ", prev[2]));
if (opt_all)
this:notify("Previous connections have been from the following sites:");
for l in (this.all_connect_places)
this:notify("   " + l);
endfor
endif
endif
.
#6:56
"set_brief(value)";
"set_brief(value, anything)";
"If <anything> is given, add value to the current value; otherwise, just set the value.";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
else
if (length(args) == 1)
this.brief = args[1];
else
this.brief = this.brief + args[1];
endif
endif
.
#6:57
"@mode <mode>";
"Current modes are brief and verbose.";
"General verb for setting player `modes'.";
"Modes are coded right here in the verb.";
if (caller != this)
player:tell("You can't set someone else's modes.");
return E_PERM;
endif
modes = {"brief", "verbose"};
mode = `modes[$string_utils:find_prefix(dobjstr, modes)] ! E_TYPE, E_RANGE => 0';
if (!mode)
player:tell("Unknown mode \"", dobjstr, "\".  Known modes:");
for mode in (modes)
player:tell("  ", mode);
endfor
return 0;
elseif (mode == "brief")
this:set_brief(1);
elseif (mode == "verbose")
this:set_brief(0);
endif
player:tell($string_utils:capitalize(mode), " mode set.");
return 1;
.
#6:58
set_task_perms(player);
if (!dobjstr)
player:notify(tostr("Usage:  ", verb, " <object>"));
return E_INVARG;
endif
what = player.location:match_object(dobjstr);
if ($command_utils:object_match_failed(what, dobjstr))
return;
endif
what:do_examine(player);
.
#6:59
"Add a feature to this player's features list.  Caller must be this or have suitable permissions (this or wizardly).";
"If this is a nonprogrammer, then ask feature if it is feature_ok (that is, if it has a verb :feature_ok which returns a true value, or a property .feature_ok which is true).";
"After adding feature, call feature:feature_add(this).";
"Returns true if successful, E_INVARG if not a valid object, and E_PERM if !feature_ok or if caller doesn't have permission.";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
feature = args[1];
if ((typeof(feature) != OBJ) || (!valid(feature)))
return E_INVARG;
"Not a valid object.";
endif
if ($code_utils:verb_or_property(feature, "feature_ok", this))
"The object is willing to be a feature.";
if (typeof(this.features) == LIST)
"If list, we can simply setadd the feature.";
this.features = setadd(this.features, feature);
else
"If not, we erase the old value and create a new list.";
this.features = {feature};
endif
"Tell the feature it's just been added.";
try
feature:feature_add(this);
except (ANY)
"just ignore errors.";
endtry
return 1;
"We're done.";
else
return E_PERM;
"Feature isn't feature_ok.";
endif
else
return E_PERM;
"Caller doesn't have permission.";
endif
.
#6:60
"Remove a feature from this player's features list.  Caller must be this, or have permissions of this, a wizard, or feature.owner.";
"Returns true if successful, E_PERM if caller didn't have permission.";
feature = args[1];
if (((caller == this) || $perm_utils:controls(caller_perms(), this)) || (caller_perms() == feature.owner))
if (typeof(this.features) == LIST)
"If this is a list, we can just setremove...";
this.features = setremove(this.features, feature);
"Otherwise, we leave it alone.";
endif
"Let the feature know it's been removed.";
try
feature:feature_remove(this);
except (ANY)
"just ignore errors.";
endtry
return 1;
"We're done.";
else
return E_PERM;
"Caller didn't have permission.";
endif
.
#6:61
"Usage:";
"  @add-feature";
"  @add-feature <feature object>";
"Modified 10 Oct 94, by Michele, to check the warehouse and match.";
"Lists all features or adds an object to your features list.";
set_task_perms(player);
if (dobjstr)
if (dobj == $failed_match)
dobj = $feature.warehouse:match_object(dobjstr);
endif
if (!$command_utils:object_match_failed(dobj, dobjstr))
if (dobj in player.features)
player:tell(dobjstr, " is already one of your features.");
elseif (player:add_feature(dobj))
player:tell(dobj, " (", dobj.name, ") added as a feature.");
else
player:tell("You can't seem to add ", dobj, " (", dobj.name, ") to your features list.");
endif
endif
else
player:tell("Usage:  @add-feature <object>");
if (length($feature.warehouse.contents) < 20)
player:tell("Available features include:");
player:tell("--------------------------");
fe = {};
for c in ($feature.warehouse.contents)
fe = {(c in player.features) ? c:title() + " (*)" | c:title()};
player:tell("  " + $string_utils:english_list(fe));
endfor
player:tell("--------------------------");
player:tell("A * after the feature name means that you already have that feature.");
endif
endif
.
#6:62
"Usage:  @remove-feature <feature object>";
"Remove an object from your .features list.";
set_task_perms(player);
if (dobjstr)
features = player.features;
if (!valid(dobj))
dobj = $string_utils:match(dobjstr, features, "name", features, "aliases");
endif
if (!$command_utils:object_match_failed(dobj, dobjstr))
if (dobj in features)
player:remove_feature(dobj);
player:tell(dobj, " (", dobj.name, ") removed from your features list.");
else
player:tell(dobjstr, " is not one of your features.");
endif
endif
else
player:tell("Usage:  @remove-feature <object>");
endif
.
#6:63
"Usage:  @features [<name>] for <player>";
"List the feature objects matching <name> used by <player>.";
if (!iobjstr)
player:tell("Usage: @features [<name>] for <player>");
return;
elseif ($command_utils:player_match_failed(whose = $string_utils:match_player(iobjstr), iobjstr))
return;
endif
features = {};
for feature in (whose.features)
if (!valid(feature))
whose:remove_feature(feature);
elseif ((!dobjstr) || ((dobjstr in feature.aliases) || ((pref = $string_utils:find_prefix(dobjstr, feature.aliases)) || (pref == $ambiguous_match))))
features = listappend(features, feature);
endif
endfor
if (features)
len = max(length("Feature"), length(tostr(max_object()))) + 1;
player:tell($string_utils:left("Feature", len), "Name");
player:tell($string_utils:left("-------", len), "----");
for feature in (features)
player:tell($string_utils:left(tostr(feature), len), feature.name);
endfor
player:tell($string_utils:left("-------", len), "----");
cstr = ((tostr(length(features)) + " feature") + ((length(features) > 1) ? "s" | "")) + " found";
if (whose != this)
cstr = ((((cstr + " on ") + whose.name) + " (") + tostr(whose)) + ")";
endif
if (dobjstr)
cstr = ((cstr + " matching \"") + dobjstr) + "\"";
endif
cstr = cstr + ".";
player:tell(cstr);
elseif (dobjstr)
player:tell("No features found on ", whose.name, " (", whose, ") matching \"", dobjstr, "\".");
else
player:tell("No features found on ", whose.name, " (", whose, ").");
endif
.
#6:64
"Usage:  @features [<name>]";
"List the feature objects matching <name> used by player.";
iobjstr = player.name;
iobj = player;
this:("@features")();
.
#6:65
"Return information about the MOO's current memory usage.";
"memory_info returns in pages. You can get KB by multiplying by 4.";
"Values: total size, resident set size, shared pages, text (code), data + stack";
mem = call_function("memory_usage");
MB = 0.001;
PAGE = 4.0;
player:tell($network.moo_name, " Memory Statistics");
player:tell();
player:tell("Total Memory Usage: ", (mem[1] * PAGE) * MB, " MB");
player:tell("Resident Set Size:  ", (mem[2] * PAGE) * MB, " MB");
player:tell("Shared Pages:       ", (mem[3] * PAGE) * MB, " MB");
player:tell("Text (Code):        ", (mem[4] * PAGE) * MB, " MB");
player:tell("Data + Stack:       ", (mem[5] * PAGE) * MB, " MB");
.
#6:66
if ($object_utils:has_property($local, "server_hardware"))
hw = (" on " + $local.server_hardware) + ".";
else
hw = ".";
endif
server_version = server_version();
if (server_version[1] == "v")
server_version[1..1] = "";
endif
player:notify(tostr("The MOO is currently running version ", server_version, " of the ", $server["name"], " server code", hw));
try
{MOOname, sversion, coretime} = $server["core_history"][1];
player:notify(tostr("The database was derived from a core created on ", $time_utils:time_sub("$n $t, $Y", coretime), " at ", MOOname, " for version ", sversion, " of the server."));
except (E_RANGE)
player:notify("The database was created from scratch.");
except (ANY)
player:notify("No information is available on the database version.");
endtry
.
#6:67
player:notify(tostr($network.MOO_name, " has been up for ", $time_utils:english_time(time() - $server["last_restart_time"], $server["last_restart_time"]), "."));
.
#6:68
boot_player(player);
"-- argh, let the player decide; #3:disfunc() takes care of this --Rog";
"player:moveto(player.home)";
.
#6:69
return this == args[1];
.
#6:70
"return true if player is active.";
return typeof(`idle_seconds(this) ! ANY') != ERR;
.
#6:71
if (args[1] == #-1)
return E_INVARG;
this:notify("You are now in #-1, The Void.  Type `home' to get back.");
endif
set_task_perms(caller_perms());
pass(@args);
.
#6:72
return this.location:(verb)(@args);
"temporarily let player:announce be noisy to player";
if (verb == "announce_all_but")
if (this in args[1])
return;
endif
args = args[2..$];
endif
this:tell("(from within you) ", @args);
.
#6:73
"Return a true value if this needs linewrapping.";
"default is true if .linelen > 0";
return this.linelen > 0;
.
#6:74
"Usage:  @set-note-{string | text} {#xx | #xx.pname}";
"        ...lines of text...";
"        .";
"";
"For use by clients' local editors, to save new text for a note or object property.  See $note_editor:local_editing_info() for details.";
text = $command_utils:read_lines_escape((active = player in $note_editor.active) ? {} | {"@edit"}, {tostr("Changing ", argstr, "."), @active ? {} | {"Type `@edit' to take this into the note editor."}});
if (text && (text[1] == "@edit"))
$note_editor:invoke(argstr, verb);
who = $note_editor:loaded(player);
if (who)
$note_editor.texts[who] = text[2];
endif
return;
endif
set_task_perms(player);
text = text[2];
if ((verb == "@set-note-string") && (length(text) <= 1))
text = text ? text[1] | "";
endif
if (spec = $code_utils:parse_propref(argstr))
o = player:my_match_object(spec[1]);
p = spec[2];
if ($object_utils:has_verb(o, vb = "set_" + p) && (typeof(e = o:(vb)(text)) != ERR))
player:tell("Set ", p, " property of ", o.name, " (", o, ") via :", vb, ".");
else
original = text;
for x in [1..length(text)]
$sin(0);
value = $string_utils:to_value(text[x]);
if (value[1] != 1)
player:tell("Error:  ", value[2]);
player:tell("... assuming data is all text.");
text = original;
break;
else
text[x] = value[2];
endif
endfor
if (text != (e = `o.(p) = text ! ANY'))
player:tell("Error:  ", e);
else
player:tell("Set ", p, " property of ", o.name, " (", o, ").");
endif
endif
elseif (typeof(note = $code_utils:toobj(argstr)) == OBJ)
e = note:set_text(text);
if (typeof(e) == ERR)
player:tell("Error:  ", e);
else
player:tell("Set text of ", note.name, " (", note, ").");
endif
else
player:tell("Error:  Malformed argument to ", verb, ": ", argstr);
endif
.
#6:75
if ($perm_utils:controls(caller_perms(), this))
return this.(verb);
else
return E_PERM;
endif
.
#6:76
lines = args[1];
if (typeof(lines) != LIST)
lines = {lines};
endif
if (this.gaglist || this.paranoid)
"Check the above first, default case, to save ticks.  Paranoid gaggers are cost an extra three or so ticks by this, probably a net savings.";
if (this:gag_p())
return;
endif
if (this.paranoid == 2)
z = this:whodunnit({@callers(1), {player, "", player}}, {this, $no_one}, {})[3];
lines = {((("[start text by " + z.name) + " (") + tostr(z)) + ")]", @lines, ((("[end text by " + z.name) + " (") + tostr(z)) + ")]"};
elseif (this.paranoid == 1)
$paranoid_db:add_data(this, {{@callers(1), {player, "<cmd-line>", player}}, lines});
endif
endif
this:notify_lines(lines);
.
#6:77
"Copied from generic room (#3):@lastlog by Haakon (#2) Wed Dec 30 13:30:02 1992 PST";
if (dobjstr != "")
dobj = $string_utils:match_player(dobjstr);
if (!valid(dobj))
player:tell("Who?");
return;
endif
folks = {dobj};
else
folks = players();
endif
if (length(folks) > 100)
player:tell("You have requested a listing of ", length(folks), " players.  That is too long a list; specify individual players you are interested in.");
return;
endif
day = week = month = ever = never = {};
a_day = (24 * 60) * 60;
a_week = 7 * a_day;
a_month = 30 * a_day;
now = time();
for x in (folks)
when = x.last_connect_time;
how_long = now - when;
if ((when == 0) || (when > now))
never = {@never, x};
elseif (how_long < a_day)
day = {@day, x};
elseif (how_long < a_week)
week = {@week, x};
elseif (how_long < a_month)
month = {@month, x};
else
ever = {@ever, x};
endif
endfor
for entry in ({{day, "the last day"}, {week, "the last week"}, {month, "the last 30 days"}, {ever, "recorded history"}})
if (entry[1])
player:tell("Players who have connected within ", entry[2], ":");
for x in (entry[1])
player:tell("  ", x.name, " last connected ", ctime(x.last_connect_time), ".");
endfor
endif
endfor
if (never)
player:tell("Players who have never connected:");
player:tell("  ", $string_utils:english_list($list_utils:map_prop(never, "name")));
endif
.
#6:78
"Set linelength.  Linelength must be an integer >= 10.";
"If wrap is currently off (i.e. linelength is less than 0), maintains sign.  That is, this function *takes* an absolute value, and coerces the sign to be appropriate.";
"If you want to override the dwimming of wrap, pass in a second argument.";
"returns E_PERM if not allowed, E_INVARG if linelength is too low, otherwise the linelength.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (abs(len = args[1]) < 10)
return E_INVARG;
elseif (length(args) > 1)
this.linelen = len;
else
"DWIM here.";
this.linelen = (this.linelen > 0) ? len | (-len);
return len;
endif
.
#6:79
"Set pagelength. Must be an integer >= 5, or 0 to turn pagelength off.";
"Returns E_PERM if you shouldn't be doing this, E_INVARG if it's too low, otherwise, what it got set to.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (((len = args[1]) < 5) && (len != 0))
return E_INVARG;
else
if ((this.pagelen = len) == 0)
if (lb = this.linebuffer)
"queued text remains";
this:notify_lines(lb);
clear_property(this, "linebuffer");
endif
endif
return len;
endif
.
#6:80
"set_home(newhome) attempts to change this.home to newhome";
"E_TYPE   if newhome doesn't have a callable :accept_for_abode verb.";
"E_INVARG if newhome won't accept you as a resident.";
"E_PERM   if you don't own this and aren't its parent.";
"1        if it works.";
newhome = args[1];
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
if ($object_utils:has_callable_verb(newhome, "accept_for_abode"))
if (newhome:accept_for_abode(this))
return (typeof(e = `this.home = args[1] ! ANY') != ERR) || e;
else
return E_INVARG;
endif
else
return E_TYPE;
endif
else
return E_PERM;
endif
.
#6:81
"@registerme as <email-address> -- enter a new email address for player";
"   will change the database entry, assign a new password, and mail the new password to the player at the given email address.";
if (player != this)
return player:notify(tostr(E_PERM));
endif
who = this;
if ($object_utils:isa(this, $guest))
who:notify("Sorry, guests should use the '@request' command to request a character.");
return;
endif
connection = $string_utils:connection_hostname(who);
if (!argstr)
if ($wiz_utils:get_email_address(who))
player:tell("You are currently registered as:  ", $wiz_utils:get_email_address(who));
else
player:tell("You are not currently registered.");
endif
player:tell("Use @registerme as <address> to change this.");
return;
elseif (((prepstr != "as") || (!iobjstr)) || dobjstr)
player:tell("Usage: @registerme as <address>");
return;
endif
email = iobjstr;
if (email == $wiz_utils:get_email_address(this))
who:notify("That is your current address.  Not changed.");
return;
elseif (reason = $wiz_utils:check_reregistration(this, email, connection))
if (reason[1] == "-")
if (!$command_utils:yes_or_no(reason[2..$] + ". Automatic registration not allowed. Ask to be registered at this address anyway?"))
who:notify("Okay.");
return;
endif
else
return who:notify(tostr(reason, " Please try again."));
endif
endif
if ($network.active && (!reason))
if (!$command_utils:yes_or_no(tostr("If you continue, your password will be changed, the new password mailed to `", email, "'. Do you want to continue?")))
return who:notify("Registration terminated.");
endif
password = $wiz_utils:random_password(5);
old = $wiz_utils:get_email_address(who) || "[ unregistered ]";
who:notify(tostr("Registering you, and changing your password and mailing new one to ", email, "."));
result = $network:sendmail(email, tostr("Your ", $network.MOO_Name, " character, ", who.name), "Reply-to: " + $login.registration_address, @$generic_editor:fill_string(tostr("Your ", $network.MOO_name, " character, ", $string_utils:nn(who), " has been registered to this email address (", email, "), and a new password assigned.  The new password is `", password, "'. Please keep your password secure. You can change your password with the @password command."), 75));
if (result != 0)
who:notify(tostr("Mail sending did not work: ", reason, ". Reregistration terminated."));
return;
endif
who:notify(tostr("Mail with your new password forwarded. If you do not get it, send regular email to ", $login.registration_address, " with your character name."));
$mail_agent:send_message($new_player_log, $new_player_log, "reg " + $string_utils:nn(this), {email, tostr("formerly ", old)});
$registration_db:add(this, email, "Reregistered at " + ctime());
$wiz_utils:set_email_address(this, email);
who.password = $login:encrypt_password(password);
who.last_password_time = time();
else
who:notify("No automatic reregistration: your request will be forwarded.");
if (typeof(curreg = $registration_db:find(email)) == LIST)
additional_info = {"Current registration information for this email address:", @$registration_db:describe_registration(curreg)};
else
additional_info = {};
endif
$mail_agent:send_message(this, $registration_db.registrar, "Registration request", {((("Reregistration request from " + $string_utils:nn(who)) + " connected via ") + connection) + ":", "", (("@register " + who.name) + " ") + email, ("@new-password " + who.name) + " is ", "", "Reason this request was forwarded:", reason, @additional_info});
endif
.
#6:82
":ctime([INT time]) => STR as the function.";
"May be hacked by players and player-classes to reflect differences in time-zone.";
return ctime(@args);
.
#6:83
if ((dobjstr == "") || (dobj == player))
dobj = player;
else
dobj = $string_utils:match_player(dobjstr);
if (!valid(dobj))
$command_utils:player_match_failed(dobj, dobjstr);
return;
endif
endif
time = dobj.first_connect_time;
if (time == $maxint)
duration = time() - dobj.last_disconnect_time;
if (duration < 86400)
notice = $string_utils:from_seconds(duration);
else
notice = $time_utils:english_time((duration / 86400) * 86400);
endif
player:notify(tostr(dobj.name, " has never connected.  It was created ", notice, " ago."));
elseif (time == 0)
player:notify(tostr(dobj.name, " first connected before initial connections were being recorded."));
else
player:notify(tostr(dobj.name, " first connected on ", ctime(time)));
duration = time() - time;
if (duration < 86400)
notice = $string_utils:from_seconds(duration);
else
notice = $time_utils:english_time((duration / 86400) * 86400);
endif
player:notify(tostr($string_utils:pronoun_sub("%S %<is> ", dobj), notice, " old."));
endif
.
#6:84
"Usage: news [contents] [articles]";
"";
"Common uses:";
"news           -- display all current news, or as @mail-options decree";
"news new       -- display articles you haven't seen yet";
"news all       -- display all current news";
"news contents  -- display headers of current news";
"news <article> -- display article";
"news archive   -- display news which has been marked as archived.";
set_task_perms(player);
cur = this:get_current_message($news) || {0, 0};
arch = 0;
if (((!args) && (o = player:mail_option("news"))) && (o != "all"))
"no arguments, use the player's default";
args = {o};
elseif (args == {"all"})
args = {};
elseif (args == {"archive"})
arch = 1;
args = {};
endif
if (hdrs_only = args && (args[1] == "contents"))
"Do the mail contents list";
args[1..1] = {};
endif
if (args)
if (typeof(seq = $news:_parse(args, @cur)) == STR)
player:notify(seq);
return;
elseif (seq = $seq_utils:intersection(seq, $news.current_news))
else
player:notify((args == {"new"}) ? "No new news." | "None of those are current articles.");
return;
endif
elseif (arch && (seq = $news.archive_news))
"yduJ hates this coding style.  Just so you know.";
elseif (seq = $news.current_news)
else
player:notify("No news");
return;
endif
if (hdrs_only)
$news:display_seq_headers(seq, @cur);
else
player:set_current_message($news, @$news:news_display_seq_full(seq));
endif
.
#6:85
"Calls the verb editor on verbs, the note editor on properties, and on anything else assumes it's an object for which you want to edit the .description.";
if (!args)
((player in $note_editor.active) ? $note_editor | $verb_editor):invoke(dobjstr, verb);
elseif ($code_utils:parse_verbref(args[1]))
if (player.programmer)
$verb_editor:invoke(argstr, verb);
else
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
endif
else
$note_editor:invoke(dobjstr, verb);
endif
.
#6:86
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
else
$paranoid_db:erase_data(this);
endif
.
#6:87
"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.";
set_task_perms((caller == this) ? this | $no_one);
if ((prepstr != "to") || (!iobjstr))
player:tell("Usage: @move <object> to <location>");
return;
endif
if ((!dobjstr) || (dobjstr == "me"))
dobj = this;
else
dobj = here:match_object(dobjstr);
if (!valid(dobj))
dobj = player:my_match_object(dobjstr);
endif
endif
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
iobj = this:lookup_room(iobjstr);
if ((iobj != $nothing) && $command_utils:object_match_failed(iobj, iobjstr))
return;
endif
if (((!player.programmer) && (!$perm_utils:controls(this, dobj))) && (this != dobj))
player:tell("You may only @move your own things.");
return;
endif
this:teleport(dobj, iobj);
.
#6:88
if (($perm_utils:controls(caller_perms(), this) || (caller == this)) || (caller_perms() == this))
set_task_perms(caller_perms());
for line in ((typeof(lines = args[1]) != LIST) ? {lines} | lines)
$command_utils:suspend_if_needed(0);
this:notify(tostr(line));
endfor
else
return E_PERM;
endif
.
#6:89
set_task_perms(caller_perms());
return chparent(@args);
.
#6:90
"Prints a count and compact list of the currently-connected players, sorted into columns.";
cp = connected_players();
linelen = player:linelen() || 79;
player:tell(("There are " + tostr(length(cp))) + " players connected:");
dudes = $list_utils:map_prop(cp, "name");
dudes = $list_utils:sort_suspended($login.current_lag, dudes);
player:tell_lines($string_utils:columnize(dudes, 4, linelen));
.
#6:91
if (typeof(player.password) != STR)
if (length(args) != 1)
return player:notify(tostr("Usage:  ", verb, " <new-password>"));
else
new_password = args[1];
endif
elseif (length(args) != 2)
player:notify(tostr("Usage:  ", verb, " <old-password> <new-password>"));
return;
elseif (!argon2_verify(player.password, args[1]))
player:notify("That's not your old password.");
return;
elseif (is_clear_property(player, "password"))
player:notify("Your password has a `clear' property.  Please refer to a wizard for assistance in changing it.");
return;
elseif (player in $wiz_utils.change_password_restricted)
player:notify("You are not permitted to change your own password.");
return;
else
new_password = args[2];
endif
if (r = $password_verifier:reject_password(new_password, player))
player:notify(r);
return;
endif
player.password = $login:encrypt_password(new_password);
player.last_password_time = time();
player:notify("New password set.");
.
#6:92
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
pass(@args);
features = this.features;
for x in (features)
"Have to do this, or :feature_remove thinks you're a liar and doesn't believe.";
this.features = setremove(this.features, x);
if ($object_utils:has_verb(x, "feature_remove"))
try
x:feature_remove(this);
except (ANY)
player:tell("Failure in ", x, ":feature_remove for player ", $string_utils:nn(this));
endtry
endif
$command_utils:suspend_if_needed(0);
endfor
endif
.
#6:93
((caller == this) || $perm_utils:controls(caller_perms(), this)) || raise(E_PERM);
if (g = this.gaglist)
recycler = $recycler;
for o in (g)
if (!recycler:valid(o))
g = setremove(g, o);
endif
endfor
this.gaglist = g;
endif
.
#6:94
set_task_perms(caller_perms());
return this.email_address;
.
#6:95
set_task_perms(caller_perms());
this.email_address = args[1];
.
#6:96
if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != $sysobj))
return E_PERM;
endif
return this:confunc(@args);
.
#6:97
if ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))
return;
endif
player:tell($string_utils:nn(dobj), " is owned by ", $string_utils:nn(dobj.owner), ".");
.
#6:98
return $edit_utils:options(@args);
.
#6:99
set_task_perms(valid(caller_perms()) ? caller_perms() | player);
if (!args)
player:notify(tostr("Your gender is currently ", this.gender, "."));
player:notify($string_utils:pronoun_sub("Your pronouns:  %s,%o,%p,%q,%r,%S,%O,%P,%Q,%R"));
player:notify(tostr("Available genders:  ", $string_utils:english_list($gender_utils.genders, "", " or ")));
else
result = this:set_gender(args[1]);
quote = (result == E_NONE) ? "\"" | "";
player:notify(tostr("Gender set to ", quote, this.gender, quote, "."));
if (typeof(result) != ERR)
player:notify($string_utils:pronoun_sub("Your pronouns:  %s,%o,%p,%q,%r,%S,%O,%P,%Q,%R"));
elseif (result != E_NONE)
player:notify(tostr("Couldn't set pronouns:  ", result));
else
player:notify("Pronouns unchanged.");
endif
endif
.
#7:0
set_task_perms(caller_perms());
this:move(player);
.
#7:1
set_task_perms(caller_perms());
what = args[1];
"if ((what.location != this.source) || (!(this in this.source.exits)))";
"  player:tell(\"You can't go that way.\");";
"  return;";
"endif";
unlocked = this:is_unlocked_for(what);
if (unlocked)
this.dest:bless_for_entry(what);
endif
if (unlocked && this.dest:acceptable(what))
start = what.location;
if (msg = this:leave_msg(what))
what:tell_lines(msg);
endif
what:moveto(this.dest);
if (what.location != start)
"Don't print oleave messages if WHAT didn't actually go anywhere...";
this:announce_msg(start, what, (this:oleave_msg(what) || this:defaulting_oleave_msg(what)) || "has left.");
endif
if (what.location == this.dest)
"Don't print arrive messages if WHAT didn't really end up there...";
if (msg = this:arrive_msg(what))
what:tell_lines(msg);
endif
this:announce_msg(what.location, what, this:oarrive_msg(what) || "has arrived.");
endif
else
if (msg = this:nogo_msg(what))
what:tell_lines(msg);
else
what:tell("You can't go that way.");
endif
if (msg = this:onogo_msg(what))
this:announce_msg(what.location, what, msg);
endif
endif
.
#7:2
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
try
this.source:remove_exit(this);
this.dest:remove_entrance(this);
except id (ANY)
endtry
return pass(@args);
else
return E_PERM;
endif
.
#7:3
msg = this.(verb);
return msg ? $string_utils:pronoun_sub(msg, @args) | "";
.
#7:4
if ($perm_utils:controls(cp = caller_perms(), this) || (valid(this.source) && (this.source.owner == cp)))
return (typeof(e = `this.name = args[1] ! ANY') != ERR) || e;
else
return E_PERM;
endif
.
#7:5
if ($perm_utils:controls(cp = caller_perms(), this) || (valid(this.source) && (this.source.owner == cp)))
if (typeof(e = `this.aliases = args[1] ! ANY') == ERR)
return e;
else
return 1;
endif
else
return E_PERM;
endif
.
#7:6
"This is intended to be called only by exits, for announcing various oxxx messages.  First argument is room to announce in.  Second argument is as in $room:announce_all_but's first arg, who not to announce to.  Rest args are what to say.  If the final arg is a list, prepends all the other rest args to the first line and emits the lines separately.";
where = args[1];
whobut = args[2];
last = args[$];
if (typeof(last) == LIST)
where:announce_all_but(whobut, @args[3..$ - 1], last[1]);
for line in (last[2..$])
where:announce_all_but(whobut, line);
endfor
else
where:announce_all_but(@args[3..$]);
endif
.
#7:7
for k in ({this.name, @this.aliases})
if (k in {"east", "west", "south", "north", "northeast", "southeast", "southwest", "northwest", "out", "up", "down", "nw", "sw", "ne", "se", "in"})
return ("goes " + k) + ".";
elseif (k in {"leave", "out", "exit"})
return "leaves";
endif
endfor
if ((index(this.name, "an ") == 1) || (index(this.name, "a ") == 1))
return ("leaves for " + this.name) + ".";
else
return ("leaves for the " + this.name) + ".";
endif
.
#7:8
if ((caller in {this, this.owner}) || $perm_utils:controls(caller_perms(), this))
return pass(@args);
else
return E_PERM;
endif
.
#7:9
"examine_key(examiner)";
"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.";
"the default will only tell the key to a wizard or this object's owner.";
who = args[1];
if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))
return {tostr(this:title(), " will only transport objects matching this key:"), tostr("  ", $lock_utils:unparse_key(this.key))};
endif
.
#7:10
":announce_msg(place, what, msg)";
"  announce msg in place (except to what). Prepend with what:title if it isn't part of the string";
msg = args[3];
what = args[2];
title = what:titlec();
if (!$string_utils:index_delimited(msg, title))
msg = tostr(title, " ", msg);
endif
args[1]:announce_all_but({what}, msg);
.
#8:0
if ((this.location != player) && (this.location != player.location))
player:tell("You can't get at ", this.name, ".");
elseif (dobj == $nothing)
player:tell("What do you want to put ", prepstr, " ", this.name, "?");
elseif ($command_utils:object_match_failed(dobj, dobjstr))
elseif ((dobj.location != player) && (dobj.location != player.location))
player:tell("You don't have ", dobj.name, ".");
elseif (!this.opened)
player:tell(this.name, " is closed.");
else
set_task_perms(callers() ? caller_perms() | player);
dobj:moveto(this);
if (dobj.location == this)
player:tell(this:put_msg());
if (msg = this:oput_msg())
player.location:announce(player.name, " ", msg);
endif
else
player:tell(this:put_fail_msg());
if (msg = this:oput_fail_msg())
player.location:announce(player.name, " ", msg);
endif
endif
endif
.
#8:1
if (!(this.location in {player, player.location}))
player:tell("Sorry, you're too far away.");
elseif (!this.opened)
player:tell(this.name, " is not open.");
elseif (this.dark)
player:tell("You can't see into ", this.name, " to remove anything.");
elseif ((dobj = this:match_object(dobjstr)) == $nothing)
player:tell("What do you want to take from ", this.name, "?");
elseif ($command_utils:object_match_failed(dobj, dobjstr))
elseif (!(dobj in this:contents()))
player:tell(dobj.name, " isn't in ", this.name, ".");
else
set_task_perms(callers() ? caller_perms() | player);
dobj:moveto(player);
if (dobj.location == player)
player:tell(this:remove_msg());
if (msg = this:oremove_msg())
player.location:announce(player.name, " ", msg);
endif
else
dobj:moveto(this.location);
if (dobj.location == this.location)
player:tell(this:remove_msg());
if (msg = this:oremove_msg())
player.location:announce(player.name, " ", msg);
endif
player:tell("You can't pick up ", dobj.name, ", so it tumbles onto the floor.");
else
player:tell(this:remove_fail_msg());
if (msg = this:oremove_fail_msg())
player.location:announce(player.name, " ", msg);
endif
endif
endif
endif
.
#8:2
pass();
if (!this.dark)
this:tell_contents();
endif
.
#8:3
return !is_player(args[1]);
.
#8:4
perms = (callers() && (caller != this)) ? caller_perms() | player;
if (this.opened)
player:tell("It's already open.");
"elseif (this:is_openable_by(player))";
elseif (this:is_openable_by(perms))
this:set_opened(1);
player:tell(this:open_msg());
if (msg = this:oopen_msg())
player.location:announce(player.name, " ", msg);
endif
else
player:tell(this:open_fail_msg());
if (msg = this:oopen_fail_msg())
player.location:announce(player.name, " ", msg);
endif
endif
.
#8:5
set_task_perms(player);
key = $lock_utils:parse_keyexp(iobjstr, player);
if (typeof(key) == STR)
player:tell("That key expression is malformed:");
player:tell("  ", key);
else
try
this.open_key = key;
player:tell("Locked opening of ", this.name, " with this key:");
player:tell("  ", $lock_utils:unparse_key(key));
except error (ANY)
player:tell(error[2], ".");
endtry
endif
.
#8:6
return (this.open_key == 0) || $lock_utils:eval_key(this.open_key, args[1]);
.
#8:7
if (!this.opened)
player:tell("It's already closed.");
else
this:set_opened(0);
player:tell(this:close_msg());
if (msg = this:oclose_msg())
player.location:announce(player.name, " ", msg);
endif
endif
.
#8:8
set_task_perms(player);
try
dobj.open_key = 0;
player:tell("Unlocked ", dobj.name, " for opening.");
except error (ANY)
player:tell(error[2], ".");
endtry
.
#8:9
if (this.contents)
player:tell("Contents:");
for thing in (this:contents())
player:tell("  ", thing:title());
endfor
elseif (msg = this:empty_msg())
player:tell(msg);
endif
.
#8:10
if (!$perm_utils:controls(caller.owner, this))
return E_PERM;
else
this.opened = opened = !(!args[1]);
this.dark = this.opaque > opened;
return opened;
endif
.
#8:11
if (!$perm_utils:controls(player, this))
player:tell("Can't set opacity of something you don't own.");
elseif ((iobjstr != "0") && (!toint(iobjstr)))
player:tell("Opacity must be an integer (0, 1, 2).");
else
player:tell("Opacity changed:  Now " + {"transparent.", "opaque.", "a black hole."}[1 + this:set_opaque(toint(iobjstr))]);
endif
.
#8:12
if (!$perm_utils:controls(caller.owner, this))
return E_PERM;
elseif (typeof(number = args[1]) != INT)
return E_INVARG;
else
number = (number < 0) ? 0 | ((number > 2) ? 2 | number);
this.dark = number > this.opened;
return this.opaque = number;
endif
.
#8:13
return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(msg) | "";
.
#8:14
return this.(verb);
.
#9:0
if (!this:is_readable_by(valid(caller_perms()) ? caller_perms() | player))
player:tell("Sorry, but it seems to be written in some code that you can't read.");
else
this:look_self();
player:tell();
player:tell_lines_suspended(this:text());
player:tell();
player:tell("(You finish reading.)");
endif
.
#9:1
if (this:is_writable_by(valid(caller_perms()) ? caller_perms() | player))
this:set_text({});
player:tell("Note erased.");
else
player:tell("You can't erase this note.");
endif
.
#9:2
if (this:is_writable_by(valid(caller_perms()) ? caller_perms() | player))
this:set_text({@this.text, dobjstr});
player:tell("Line added to note.");
else
player:tell("You can't write on this note.");
endif
.
#9:3
if (!this:is_writable_by(player))
player:tell("You can't modify this note.");
elseif (!dobjstr)
player:tell("You must tell me which line to delete.");
else
line = toint(dobjstr);
if (line < 0)
line = (line + length(this.text)) + 1;
endif
if ((line <= 0) || (line > length(this.text)))
player:tell("Line out of range.");
else
this:set_text(listdelete(this.text, line));
player:tell("Line deleted.");
endif
endif
.
#9:4
set_task_perms(player);
key = $lock_utils:parse_keyexp(iobjstr, player);
if (typeof(key) == STR)
player:tell("That key expression is malformed:");
player:tell("  ", key);
else
try
this.encryption_key = key;
player:tell("Encrypted ", this.name, " with this key:");
player:tell("  ", $lock_utils:unparse_key(key));
except error (ANY)
player:tell(error[2], ".");
endtry
endif
.
#9:5
set_task_perms(player);
try
dobj.encryption_key = 0;
player:tell("Decrypted ", dobj.name, ".");
except error (ANY)
player:tell(error[2], ".");
endtry
.
#9:6
cp = caller_perms();
if ($perm_utils:controls(cp, this) || this:is_readable_by(cp))
return this.text;
else
return E_PERM;
endif
.
#9:7
key = this.encryption_key;
return (key == 0) || $lock_utils:eval_key(key, args[1]);
.
#9:8
cp = caller_perms();
newtext = args[1];
if ($perm_utils:controls(cp, this) || this:is_writable_by(cp))
if (typeof(newtext) == LIST)
this.text = newtext;
else
return E_TYPE;
endif
else
return E_PERM;
endif
.
#9:9
who = args[1];
wr = this.writers;
if ($perm_utils:controls(who, this))
return 1;
elseif (typeof(wr) == LIST)
return who in wr;
else
return wr;
endif
.
#9:10
"Usage:  mailme <note>";
"  uses $network to sends the text of this note to your REAL internet email address.";
if (!this:is_readable_by(player))
return player:tell("Sorry, but it seems to be written in some code that you can't read.");
elseif (!(email = $wiz_utils:get_email_address(player)))
return player:tell("Sorry, you don't have a registered email address.");
elseif (!$network.active)
return player:tell("Sorry, internet mail is disabled.");
elseif (!(text = this:text()))
return player:tell($string_utils:pronoun_sub("%T is empty--there wouldn't be any point to mailing it."));
endif
player:tell("Mailing ", this:title(), " to ", email, ".");
player:tell("... ", length(text), " lines ...");
suspend(0);
$network:sendmail(email, this:titlec(), "", @text);
.
#10:0
if ((caller != #0) && (caller != this))
return E_PERM;
else
clist = {};
for j in ({this, @$object_utils:ancestors(this)})
for i in [1..length(verbs(j))]
if ((verb_args(j, i) == {"any", "none", "any"}) && index((info = verb_info(j, i))[2], "x"))
vname = $string_utils:explode(info[3])[1];
star = index(vname + "*", "*");
clist = {@clist, $string_utils:uppercase(vname[1..star - 1]) + strsub(vname[star..$], "*", "")};
endif
endfor
endfor
notify(player, "I don't understand that.  Valid commands at this point are");
notify(player, "   " + $string_utils:english_list(setremove(clist, "?"), "", " or "));
return 0;
endif
.
#10:1
if ((caller != #0) && (caller != this))
return E_PERM;
else
msg = this.welcome_message;
version = server_version();
for line in ((typeof(msg) == LIST) ? msg | {msg})
if (typeof(line) == STR)
notify(player, strsub(line, "%v", version));
endif
endfor
this:check_player_db();
this:check_for_shutdown();
this:check_for_checkpoint();
this:maybe_print_lag();
return 0;
endif
.
#10:2
masked = $login.who_masks_wizards ? $wiz_utils:connected_wizards() | {};
if ((caller != #0) && (caller != this))
return E_PERM;
elseif (!args)
plyrs = connected_players();
if (length(plyrs) > 100)
this:notify(tostr("You have requested a listing of ", length(plyrs), " players.  Please restrict the number of players in any single request to a smaller number.  The lag thanks you."));
return 0;
else
$ansi_utils:show_who_listing($set_utils:difference(plyrs, masked)) || this:notify("No one logged in.");
endif
else
plyrs = listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1);
if (length(plyrs) > 100)
this:notify(tostr("You have requested a listing of ", length(plyrs), " players.  Please restrict the number of players in any single request to a smaller number.  The lag thanks you."));
return 0;
endif
$ansi_utils:show_who_listing(plyrs, $set_utils:intersection(plyrs, masked));
endif
return 0;
.
#10:3
"$login:connect(player-name [, password])";
" => 0 (for failed connections)";
" => objnum (for successful connections)";
((caller == #0) || (caller == this)) || raise(E_PERM);
"=================================================================";
"=== Check arguments, print usage notice if necessary";
try
{name, ?password = 0} = args;
name = strsub(name, " ", "_");
except (E_ARGS)
notify(player, tostr("Usage:  ", verb, " <existing-player-name> <password>"));
return 0;
endtry
try
"=================================================================";
"=== Is our candidate name invalid?";
if (!valid(candidate = orig_candidate = this:_match_player(name)))
raise(E_INVARG, tostr("`", name, "' matches no player name."));
endif
"=================================================================";
"=== Is our candidate unable to connect for generic security";
"=== reasons (ie clear password, non-player object)?";
if (`is_clear_property(candidate, "password") ! E_PROPNF' || (!$object_utils:isa(candidate, $player)))
server_log(tostr("FAILED CONNECT: ", name, " (", candidate, ") on ", connection_name(player), ($string_utils:connection_hostname(player) in candidate.all_connect_places) ? "" | "******"));
raise(E_INVARG);
endif
"=================================================================";
"=== Check password";
if (typeof(cp = candidate.password) == STR)
"=== Candidate requires a password";
if (password)
"=== Candidate requires a password, and one was provided";
if (!argon2_verify(cp, password))
"=== Candidate requires a password, and one was provided, which was wrong";
server_log(tostr("FAILED CONNECT: ", name, " (", candidate, ") on ", connection_name(player), ($string_utils:connection_hostname(player) in candidate.all_connect_places) ? "" | "******"));
raise(E_INVARG, "Invalid password.");
else
"=== Candidate requires a password, and one was provided, which was right";
endif
else
"=== Candidate requires a password, and none was provided";
set_connection_option(player, "binary", 1);
notify(player, "Password: ");
set_connection_option(player, "binary", 0);
set_connection_option(player, "client-echo", 0);
this:add_interception(player, "intercepted_password", candidate);
return 0;
endif
elseif (cp == 0)
"=== Candidate does not require a password";
else
"=== Candidate has a nonstandard password; something's wrong";
raise(E_INVARG);
endif
"=================================================================";
"=== Is the player locked out?";
if (this.no_connect_message && (!candidate.wizard))
notify(player, this.no_connect_message);
server_log(tostr("REJECTED CONNECT: ", name, " (", candidate, ") on ", connection_name(player)));
return 0;
endif
"=================================================================";
"=== Check guest connections";
if ($object_utils:isa(candidate, $guest) && (!valid(candidate = candidate:defer())))
if (candidate == #-2)
server_log(tostr("GUEST DENIED: ", connection_name(player)));
notify(player, "Sorry, guest characters are not allowed from your site at the current time.");
else
notify(player, "Sorry, all of our guest characters are in use right now.");
endif
return 0;
endif
"=================================================================";
"=== Check newts";
if (candidate in this.newted)
if (entry = $list_utils:assoc(candidate, this.temporary_newts))
if ((uptime = this:uptime_since(entry[2])) > entry[3])
"Temporary newting period is over.  Remove entry.  Oh, send mail, too.";
this.temporary_newts = setremove(this.temporary_newts, entry);
this.newted = setremove(this.newted, candidate);
fork (0)
player = this.owner;
$mail_agent:send_message(player, $newt_log, tostr("automatic @unnewt ", candidate.name, " (", candidate, ")"), {"message sent from $login:connect"});
endfork
else
notify(player, "");
notify(player, this:temp_newt_registration_string(entry[3] - uptime));
boot_player(player);
return 0;
endif
else
notify(player, "");
notify(player, this:newt_registration_string());
boot_player(player);
return 0;
endif
endif
"=================================================================";
"=== Connection limits based on lag";
if ((((!candidate.wizard) && (!(candidate in this.lag_exemptions))) && ((howmany = length(connected_players())) >= (max = this:max_connections()))) && (!$object_utils:connected(candidate)))
notify(player, $string_utils:subst(this.connection_limit_msg, {{"%n", tostr(howmany)}, {"%m", tostr(max)}, {"%l", tostr(this:current_lag())}, {"%t", candidate.last_connect_attempt ? ctime(candidate.last_connect_attempt) | "not recorded"}}));
candidate.last_connect_attempt = time();
server_log(tostr("CONNECTION LIMIT EXCEEDED: ", name, " (", candidate, ") on ", connection_name(player)));
boot_player(player);
return 0;
endif
"=================================================================";
"=== Log the player on!";
if (candidate != orig_candidate)
notify(player, tostr("Okay,... ", name, " is in use.  Logging you in as `", candidate.name, "'"));
endif
this:record_connection(candidate);
return candidate;
except (E_INVARG)
notify(player, "Either that player does not exist, or has a different password.");
return 0;
endtry
.
#10:4
if ((caller != #0) && (caller != this))
return E_PERM;
"... caller isn't :do_login_command()...";
elseif (!this:player_creation_enabled(player))
notify(player, this:registration_string());
"... we've disabled player creation ...";
elseif (length(args) != 2)
notify(player, tostr("Usage:  ", verb, " <new-player-name> <new-password>"));
elseif ($player_db.frozen)
notify(player, "Sorry, can't create any new players right now.  Try again in a few minutes.");
elseif ((!(name = args[1])) || (name == "<>"))
notify(player, "You can't have a blank name!");
if (name)
notify(player, "Also, don't use angle brackets (<>).");
endif
elseif ((name[1] == "<") && (name[$] == ">"))
notify(player, "Try that again but without the angle brackets, e.g.,");
notify(player, tostr(" ", verb, " ", name[2..$ - 1], " ", strsub(strsub(args[2], "<", ""), ">", "")));
notify(player, "This goes for other commands as well.");
elseif (index(name, " "))
notify(player, "Sorry, no spaces are allowed in player names.  Use dashes or underscores.");
"... lots of routines depend on there not being spaces in player names...";
elseif ((!$player_db:available(name)) || (this:_match_player(name) != $failed_match))
notify(player, "Sorry, that name is not available.  Please choose another.");
"... note the :_match_player call is not strictly necessary...";
"... it is merely there to handle the case that $player_db gets corrupted.";
elseif (!(password = args[2]))
notify(player, "You must set a password for your player.");
else
new = $quota_utils:bi_create($player_class, $nothing);
set_player_flag(new, 1);
new.name = name;
new.aliases = {name};
new.programmer = $player_class.programmer;
new.password = $login:encrypt_password(password);
new.last_password_time = time();
new.last_connect_time = $maxint;
"Last disconnect time is creation time, until they login.";
new.last_disconnect_time = time();
"make sure the owership quota isn't clear!";
$quota_utils:initialize_quota(new);
this:record_connection(new);
$player_db:insert(name, new);
`move(new, $player_start) ! ANY';
return new;
endif
return 0;
.
#10:5
if ((caller != #0) && (caller != this))
return E_PERM;
else
boot_player(player);
return 0;
endif
.
#10:6
if ((caller != #0) && (caller != this))
return E_PERM;
else
notify(player, tostr("The server has been up for ", $time_utils:english_time(time() - $server["last_restart_time"]), "."));
return 0;
endif
.
#10:7
if ((caller != #0) && (caller != this))
return E_PERM;
else
notify(player, tostr("The MOO is currently running version ", server_version(), " of the ", $server["name"], " server code."));
return 0;
endif
.
#10:8
":parse_command(@args) => {verb, args}";
"Given the args from #0:do_login_command,";
"  returns the actual $login verb to call and the args to use.";
"Commands available to not-logged-in users should be located on this object and given the verb_args \"any none any\"";
if ((caller != #0) && (caller != this))
return E_PERM;
endif
if (li = this:interception(player))
return {@li, @args};
endif
if (!args)
return {this.blank_command, @args};
elseif ((verb = args[1]) && (!$string_utils:is_numeric(verb)))
for i in ({this, @$object_utils:ancestors(this)})
try
if ((verb_args(i, verb) == {"any", "none", "any"}) && index(verb_info(i, verb)[2], "x"))
return args;
endif
except (ANY)
continue i;
endtry
endfor
endif
return {this.bogus_command, @args};
.
#10:9
when = $server["shutdown_time"] - time();
if (when >= 0)
line = "***************************************************************************";
notify(player, "");
notify(player, "");
notify(player, line);
notify(player, line);
notify(player, "****");
notify(player, ("****  WARNING:  The server will shut down in " + $time_utils:english_time(when - (when % 60))) + ".");
for piece in ($generic_editor:fill_string($wiz_utils.shutdown_message, 60))
notify(player, "****            " + piece);
endfor
notify(player, "****");
notify(player, line);
notify(player, line);
notify(player, "");
notify(player, "");
endif
.
#10:10
if ($player_db.frozen)
line = "***************************************************************************";
notify(player, "");
notify(player, line);
notify(player, "***");
for piece in ($generic_editor:fill_string("The character-name matcher is currently being reloaded.  This means your character name might not be recognized even though it still exists.  Don't panic.  You can either wait for the reload to finish or you can connect using your object number if you remember it (e.g., `connect #1234 yourpassword').", 65))
notify(player, "***       " + piece);
endfor
notify(player, "***");
for piece in ($generic_editor:fill_string("Repeat:  Do not panic.  In particular, please do not send mail to any wizards or the registrar asking about this.  It will finish in time.  Thank you for your patience.", 65))
notify(player, "***       " + piece);
endfor
if (this:player_creation_enabled(player))
notify(player, "***       This also means that character creation is disabled.");
endif
notify(player, "***");
notify(player, line);
notify(player, "");
endif
.
#10:11
":_match_player(name)";
"This is the matching routine used by @connect.";
"returns either a valid player corresponding to name or $failed_match.";
name = args[1];
if (valid(candidate = $string_utils:literal_object(name)) && is_player(candidate))
return candidate;
endif
".....uncomment this to trust $player_db and have `connect' recognize aliases";
if (valid(candidate = $player_db:find_exact(name)) && is_player(candidate))
return candidate;
endif
".....uncomment this if $player_db gets hosed and you want by-name login";
". for candidate in (players())";
".   if (candidate.name == name)";
".     return candidate; ";
".   endif ";
". endfor ";
".....";
return $failed_match;
.
#10:12
(caller != $ansi_utils) && set_task_perms(caller_perms());
notify(player, $ansi_utils:delete(args[1]));
.
#10:13
"keeps bad things from happening if someone brings this object into a room and talks to it.";
return 0;
.
#10:14
"Accepts a player object.  If player creation is enabled for that player object, then return true.  Otherwise, return false.";
"Default implementation checks the player's connecting host via $login:blacklisted to decide.";
if (caller_perms().wizard)
return this.create_enabled && (!this:blacklisted($string_utils:connection_hostname(args[1])));
else
return E_PERM;
endif
.
#10:15
return $string_utils:subst(this.(verb), {{"%e", this.registration_address}, {"%%", "%"}});
.
#10:16
if (caller_perms().wizard)
this.current_lag = 0;
this.lag_exemptions = {};
this.max_connections = 99999;
this.lag_samples = {0, 0, 0, 0, 0};
this.print_lag = 0;
this.last_lag_sample = 0;
this.bogus_command = "?";
this.blank_command = "welcome";
this.create_enabled = 1;
this.registration_address = "";
this.registration_string = "Character creation is disabled.";
this.newt_registration_string = "Your character is temporarily hosed.";
this.welcome_message = {"Welcome to the LambdaCore database.", "", "Type 'connect wizard' to log in.", "", "You will probably want to change this text and the output of the `help' command, which are stored in $login.welcome_message and $login.help_message, respectively."};
this.help_message = {"Sorry, but there's no help here yet.  Type `?' for a list of commands."};
this.redlist = this.blacklist = this.graylist = this.spooflist = {{}, {}};
this.temporary_redlist = this.temporary_blacklist = this.temporary_graylist = this.temporary_spooflist = {{}, {}};
this.who_masks_wizards = 0;
this.newted = this.temporary_newts = {};
this.downtimes = {};
this.current_numcommands = [];
this.max_numcommands = 20;
this.intercepted_players = this.intercepted_actions = {};
this.name_lookup_players = {};
if ("monitor" in properties(this))
delete_property(this, "monitor");
endif
if ("monitor" in verbs(this))
delete_verb(this, "monitor");
endif
if ("special_action" in verbs(this))
set_verb_code(this, "special_action", {});
endif
pass(@args);
endif
.
#10:17
.
#10:18
":blacklisted(hostname) => is hostname on the .blacklist";
":graylisted(hostname)  => is hostname on the .graylist";
":redlisted(hostname)   => is hostname on the .redlist";
sitelist = this.(this:listname(verb));
if (!caller_perms().wizard)
return E_PERM;
elseif (((hostname = args[1]) in sitelist[1]) || (hostname in sitelist[2]))
return 1;
elseif ($site_db:domain_literal(hostname))
for lit in (sitelist[1])
if ((index(hostname, lit) == 1) && ((hostname + ".")[length(lit) + 1] == "."))
return 1;
endif
endfor
else
for dom in (sitelist[2])
if (index(dom, "*"))
"...we have a wildcard; let :match_string deal with it...";
if ($string_utils:match_string(hostname, dom))
return 1;
endif
else
"...tail of hostname ...";
if ((r = rindex(hostname, dom)) && ((("." + hostname)[r] == ".") && (((r - 1) + length(dom)) == length(hostname))))
return 1;
endif
endif
endfor
endif
return this:(verb + "_temp")(hostname);
.
#10:19
"To add a temporary entry, only call the `temp' version.";
"blacklist_add_temp(Site, start time, duration)";
if (!caller_perms().wizard)
return E_PERM;
endif
{where, ?start, ?duration} = args;
lname = this:listname(verb);
which = 1 + (!$site_db:domain_literal(where));
if (index(verb, "temp"))
lname = "temporary_" + lname;
this.(lname)[which] = setadd(this.(lname)[which], {where, start, duration});
else
this.(lname)[which] = setadd(this.(lname)[which], where);
endif
return 1;
.
#10:20
"The temp version removes from the temporary property if it exists.";
if (!caller_perms().wizard)
return E_PERM;
endif
where = args[1];
lname = this:listname(verb);
which = 1 + (!$site_db:domain_literal(where));
if (index(verb, "temp"))
lname = "temporary_" + lname;
if (entry = $list_utils:assoc(where, this.(lname)[which]))
this.(lname)[which] = setremove(this.(lname)[which], entry);
return 1;
else
return E_INVARG;
endif
elseif (where in this.(lname)[which])
this.(lname)[which] = setremove(this.(lname)[which], where);
return 1;
else
return E_INVARG;
endif
.
#10:21
return {"???", "blacklist", "graylist", "redlist", "spooflist"}[1 + index("bgrs", (args[1] || "?")[1])];
.
#10:22
if (caller != #0)
return E_PERM;
elseif (!args)
$code_utils:show_who_listing(connected_players()) || this:notify("No one logged in.");
else
plyrs = listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1);
$code_utils:show_who_listing(plyrs);
endif
return 0;
.
#10:23
":record_connection(plyr) update plyr's connection information";
"to reflect impending login.";
if (!caller_perms().wizard)
return E_PERM;
else
plyr = args[1];
plyr.first_connect_time = min(time(), plyr.first_connect_time);
plyr.previous_connection = {plyr.last_connect_time, $string_utils:connection_hostname(plyr.last_connect_place)};
plyr.last_connect_time = time();
plyr.last_connect_place = connection_name(player);
chost = $string_utils:connection_hostname(player);
acp = setremove(plyr.all_connect_places, chost);
plyr.all_connect_places = {chost, @acp[1..min($, 15)]};
if (!$object_utils:isa(plyr, $guest))
$site_db:add(plyr, chost);
endif
endif
.
#10:24
if (!caller_perms().wizard)
return E_PERM;
endif
lag = (time() - this.last_lag_sample) - 15;
this.lag_samples = {lag, @this.lag_samples[1..3]};
"Now compute the current lag and store it in a property, instead of computing it in :current_lag, which is called a hundred times a second.";
thislag = max(0, (time() - this.last_lag_sample) - this.lag_sample_interval);
if (thislag > (60 * 60))
"more than an hour, probably the lag sampler stopped";
this.current_lag = 0;
else
samples = this.lag_samples;
sum = 0;
cnt = 0;
for x in (listdelete(samples, 1))
sum = sum + x;
cnt = cnt + 1;
endfor
this.current_lag = max(thislag, samples[1], samples[2], sum / cnt);
endif
fork (15)
this:sample_lag();
endfork
this.last_lag_sample = time();
.
#10:25
return this:current_lag() > this.lag_cutoff;
.
#10:26
max = this.max_connections;
if (typeof(max) == LIST)
if (this:is_lagging())
max = max[1];
else
max = max[2];
endif
endif
return max;
.
#10:27
"request_character(player, name, address)";
"return true if succeeded";
if (!caller_perms().wizard)
return E_PERM;
endif
{who, name, address} = args;
connection = $string_utils:connection_hostname(who);
if (reason = $wiz_utils:check_player_request(name, address, connection))
prefix = "";
if (reason[1] == "-")
reason = reason[2..$];
prefix = "Please";
else
prefix = "Please try again, or, to register another way,";
endif
notify(who, reason);
msg = tostr(prefix, " send mail to ", $login.registration_address, ", with the character name you want.");
for l in ($generic_editor:fill_string(msg, 70))
notify(who, l);
endfor
return 0;
endif
if (lines = $no_one:eval_d("$local.help.(\"multiple-characters\")")[2])
notify(who, "Remember, in general, only one character per person is allowed.");
notify(who, tostr("Do you already have a ", $network.moo_name, " character? [enter `yes' or `no']"));
answer = read(who);
if (answer == "yes")
notify(who, "Process terminated *without* creating a character.");
return 0;
elseif (answer != "no")
return notify(who, tostr("Please try again; when you get this question, answer `yes' or `no'. You answered `", answer, "'"));
endif
notify(who, "For future reference, do you want to see the full policy (from `help multiple-characters'?");
notify(who, "[enter `yes' or `no']");
if (read(who) == "yes")
for x in (lines)
for y in ($generic_editor:fill_string(x, 70))
notify(who, y);
endfor
endfor
endif
endif
notify(who, tostr("A character named `", name, "' will be created."));
notify(who, tostr("A random password will be generated, and e-mailed along with"));
notify(who, tostr(" an explanatory message to: ", address));
notify(who, tostr(" [Please double-check your email address and answer `no' if it is incorrect.]"));
notify(who, "Is this OK? [enter `yes' or `no']");
if (read(who) != "yes")
notify(who, "Process terminated *without* creating a character.");
return 0;
endif
if (!$network.active)
$mail_agent:send_message(this.owner, $registration_db.registrar, "Player request", {"Player request from " + connection, ":", "", (("@make-player " + name) + " ") + address});
notify(who, tostr("Request for new character ", name, " email address '", address, "' accepted."));
notify(who, tostr("Please be patient until the registrar gets around to it."));
notify(who, tostr("If you don't get email within a week, please send regular"));
notify(who, tostr("  email to: ", $login.registration_address, "."));
elseif ($player_db.frozen)
notify(who, "Sorry, can't create any new players right now.  Try again in a few minutes.");
else
new = $wiz_utils:make_player(name, address);
password = new[2];
new = new[1];
notify(who, tostr("Character ", name, " (", new, ") created."));
notify(who, tostr("Mailing password to ", address, "; you should get the mail very soon."));
notify(who, tostr("If you do not get it, please do NOT request another character."));
notify(who, tostr("Instead, send regular email to ", $login.registration_address, ","));
notify(who, tostr("with the name of the character you requested."));
$mail_agent:send_message(this.owner, $new_player_log, tostr(name, " (", new, ")"), {address, tostr(" Automatically created at request of ", valid(player) ? player.name | "unconnected player", " from ", connection, ".")});
$wiz_utils:send_new_player_mail(tostr("Someone connected from ", connection, " at ", ctime(), " requested a character on ", $network.moo_name, " for email address ", address, "."), name, address, new, password);
return 1;
endif
.
#10:28
if ((caller != #0) && (caller != this))
return E_PERM;
endif
"must be #0:do_login_command";
if (!this.request_enabled)
for line in ($generic_editor:fill_string(this:registration_string(), 70))
notify(player, line);
endfor
elseif ((length(args) != 3) || (args[2] != "for"))
notify(player, tostr("Usage:  ", verb, " <new-player-name> for <email-address>"));
elseif ($login:request_character(player, args[1], args[3]))
boot_player(player);
endif
.
#10:29
if ((caller != #0) && (caller != this))
return E_PERM;
else
msg = this.help_message;
for line in ((typeof(msg) == LIST) ? msg | {msg})
if (typeof(line) == STR)
notify(player, line);
endif
endfor
return 0;
endif
.
#10:30
if ((caller == this) || (caller_perms() == player))
if (this.print_lag)
lag = this:current_lag();
if (lag > 1)
lagstr = tostr("approximately ", lag, " seconds");
elseif (lag == 1)
lagstr = "approximately 1 second";
else
lagstr = "low";
endif
notify(player, tostr("The lag is ", lagstr, "; there ", ((l = length(connected_players())) == 1) ? "is " | "are ", l, " connected."));
endif
endif
.
#10:31
return this.current_lag;
.
#10:32
"This limits the number of commands that can be issued from the login prompt to prevent haywire login programs from lagging the MOO.";
"$login.current_numcommands has the number of commands they have issued at the prompt so far.";
"$login.max_numcommands has the maximum number of commands they may try before being booted.";
if (!caller_perms().wizard)
return E_PERM;
else
if (!(player in (keys = mapkeys(this.current_numcommands))))
this.current_numcommands[player] = 1;
else
this.current_numcommands[player] = this.current_numcommands[player] + 1;
endif
"...sweep idle connections...";
for p in (keys)
if (typeof(`idle_seconds(p) ! ANY') == ERR)
this.current_numcommands = mapdelete(this.current_numcommands, p);
endif
endfor
if (this.current_numcommands[player] > this.max_numcommands)
notify(player, "Sorry, too many commands issued without connecting.");
boot_player(player);
this.current_numcommands = mapdelete(this.current_numcommands, player);
return 1;
else
return 0;
endif
endif
.
#10:33
"Called by #0:server_started when the server restarts.";
if (caller_perms().wizard)
this.lag_samples = {0, 0, 0, 0, 0};
this.downtimes = {{time(), this.last_lag_sample}, @this.downtimes[1..min($, 100)]};
this.intercepted_players = this.intercepted_actions = {};
this.name_lookup_players = {};
this.checkpoint_in_progress = 0;
this.current_numcommands = [];
endif
.
#10:34
"uptime_since(time): How much time the MOO has been up since `time'";
since = args[1];
up = time() - since;
for x in (this.downtimes)
if (x[1] < since)
"downtime predates when we're asking about";
return up;
endif
"since the server was down between x[2] and x[1], don't count it as uptime";
up = up - (x[1] - max(x[2], since));
endfor
return up;
.
#10:35
caller_perms().wizard || $error:raise(E_PERM);
now = time();
tasks = queued_tasks();
sum = 0;
for t in (tasks)
delay = t[2] - now;
interval = (delay <= 0) ? 1 | (delay * 2);
"SUM is measured in hundredths of a player for the moment...";
(delay <= 300) && (sum = sum + (2000 / interval));
endfor
count = sum / 100;
return count;
.
#10:36
":blacklisted_temp(hostname) => is hostname on the .blacklist...";
":graylisted_temp(hostname)  => is hostname on the .graylist...";
":redlisted_temp(hostname)   => is hostname on the .redlist...";
":spooflisted_temp(hostname) => is hostname on the .spooflist...";
"";
"... and the time limit hasn't run out.";
lname = this:listname(verb);
sitelist = this.("temporary_" + lname);
if (!caller_perms().wizard)
return E_PERM;
elseif (entry = $list_utils:assoc(hostname = args[1], sitelist[1]))
return this:templist_expired(lname, @entry);
elseif (entry = $list_utils:assoc(hostname, sitelist[2]))
return this:templist_expired(lname, @entry);
elseif ($site_db:domain_literal(hostname))
for lit in (sitelist[1])
if ((index(hostname, lit[1]) == 1) && ((hostname + ".")[length(lit[1]) + 1] == "."))
return this:templist_expired(lname, @lit);
endif
endfor
else
for dom in (sitelist[2])
if (index(dom[1], "*"))
"...we have a wildcard; let :match_string deal with it...";
if ($string_utils:match_string(hostname, dom[1]))
return this:templist_expired(lname, @dom);
endif
else
"...tail of hostname ...";
if ((r = rindex(hostname, dom[1])) && ((("." + hostname)[r] == ".") && (((r - 1) + length(dom[1])) == length(hostname))))
return this:templist_expired(lname, @dom);
endif
endif
endfor
endif
return 0;
.
#10:37
"check to see if duration has expired on temporary_<colorlist>. Removes entry if so, returns true if still <colorlisted>";
":(listname, hostname, start time, duration)";
{lname, hname, start, duration} = args;
if (!caller_perms().wizard)
return E_PERM;
endif
if (this:uptime_since(start) > duration)
this:(lname + "_remove_temp")(hname);
return 0;
else
return 1;
endif
.
#10:38
return ("Your character is unavailable for another " + $time_utils:english_time(args[1])) + ".";
.
#10:39
(caller == this) || raise(E_PERM);
{who, verbname, @arguments} = args;
(who in this.intercepted_players) && raise(E_INVARG, "Player already has an interception set.");
this.intercepted_players = {@this.intercepted_players, who};
this.intercepted_actions = {@this.intercepted_actions, {verbname, @arguments}};
return 1;
.
#10:40
(caller == this) || raise(E_PERM);
{who} = args;
if (loc = who in this.intercepted_players)
this.intercepted_players = listdelete(this.intercepted_players, loc);
this.intercepted_actions = listdelete(this.intercepted_actions, loc);
return 1;
else
"raise an error?  nah.";
return 0;
endif
.
#10:41
(caller == this) || raise(E_PERM);
{who} = args;
return (loc = who in this.intercepted_players) ? this.intercepted_actions[loc] | 0;
.
#10:42
(caller == #0) || raise(E_PERM);
this:delete_interception(player);
set_connection_option(player, "client-echo", 1);
notify(player, "");
try
{candidate, ?password = ""} = args;
except (E_ARGS)
return 0;
endtry
return this:connect(tostr(candidate), password);
.
#10:43
"This is where oob handlers need to be put to handle oob commands issued prior to assigning a connection to a player object.  Right now it simply returns.";
return;
.
#10:44
if (this.checkpoint_in_progress)
line = "***************************************************************************";
notify(player, "");
notify(player, "");
notify(player, line);
notify(player, line);
notify(player, "****");
notify(player, "****  NOTICE:  The server is very slow now.");
notify(player, "****           The database is being saved to disk.");
notify(player, "****");
notify(player, line);
notify(player, line);
notify(player, "");
notify(player, "");
endif
.
#10:45
{password} = args;
salt = random_bytes(20);
return argon2(password, salt, this.argon2["iterations"], this.argon2["memory"], this.argon2["threads"]);
.
#10:46
":connection_name_lookup(connection)";
"Perform a threaded DNS lookup on 'connection' and record it to avoid multiple calls.";
if ((caller != #0) && (caller != this))
return E_PERM;
endif
{connection} = args;
if (!(connection in this.name_lookup_players))
this.name_lookup_players = setadd(this.name_lookup_players, connection);
connection_name_lookup(connection, 1);
endif
.
#10:47
":delete_name_lookup(connection)";
"Remove a connection from the list of connections that have already have name lookups performed on.";
if ((caller != #0) && (caller != this))
return E_PERM;
endif
{connection} = args;
this.name_lookup_players = setremove(this.name_lookup_players, connection);
.
#11:0
"{last_huh}  @<msg_name> <object> is [<text>]";
"If <text> is given calls <object>:set_message(<msg_name>,<text>),";
"otherwise prints the value of the specified message property";
set_task_perms(caller_perms());
nargs = length(args);
pos = "is" in args;
if (pos == 1)
player:notify(tostr("Usage:  ", verb, " <object> is <message>"));
return;
endif
dobjstr = $string_utils:from_list(args[1..pos - 1], " ");
message = $string_utils:from_list(args[pos + 1..nargs], " ");
msg_name = verb[2..$];
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
"... oh well ...";
elseif (pos == nargs)
if (E_PROPNF == (get = `dobj.(msg_name + "_msg") ! ANY'))
player:notify(tostr(dobj.name, " (", dobj, ") has no \"", msg_name, "\" message."));
elseif (typeof(get) == ERR)
player:notify(tostr(get));
elseif (!get)
player:notify("Message is not set.");
else
player:notify(tostr("The \"", msg_name, "\" message of ", dobj.name, " (", dobj, "):"));
player:notify(tostr(get));
endif
else
set = dobj:set_message(msg_name, message);
if (set)
if (typeof(set) == STR)
player:notify(set);
else
player:notify(tostr("You set the \"", msg_name, "\" message of ", dobj.name, " (", dobj, ")."));
endif
elseif (set == E_PROPNF)
player:notify(tostr(dobj.name, " (", dobj, ") has no \"", msg_name, "\" message to set."));
elseif (typeof(set) == ERR)
player:notify(tostr(set));
else
player:notify(tostr("You clear the \"", msg_name, "\" message of ", dobj.name, " (", dobj, ")."));
endif
endif
.
#11:1
"{last_huh}  give any to any";
"a give \"verb\" that works for non-$things.";
set_task_perms(caller_perms());
if (((verb == "give") && (dobjstr == "up")) && (!prepstr))
player:tell("Try this instead: @quit");
elseif (dobj == $nothing)
player:tell("What do you want to give?");
elseif (iobj == $nothing)
player:tell("To whom/what do you want to give it?");
elseif ($command_utils:object_match_failed(dobj, dobjstr) || $command_utils:object_match_failed(iobj, iobjstr))
"...lose...";
elseif (dobj.location != player)
player:tell("You don't have that!");
elseif (iobj.location != player.location)
player:tell("I don't see ", iobj.name, " here.");
else
dobj:moveto(iobj);
if (dobj.location == iobj)
player:tell("You give ", dobj:title(), " to ", iobj.name, ".");
iobj:tell(player.name, " gives you ", dobj:title(), ".");
else
player:tell("Either that doesn't want to be given away or ", iobj.name, " doesn't want it.");
endif
endif
.
#11:2
"{last_huh}  get/take any";
"a take \"verb\" that works for non-$things.";
set_task_perms(caller_perms());
if (dobj == $nothing)
player:tell(verb, " what?");
elseif ($command_utils:object_match_failed(dobj, dobjstr))
"...lose...";
elseif (dobj.location == player)
player:tell("You already have that!");
elseif (dobj.location != player.location)
player:tell("I don't see that here.");
else
dobj:moveto(player);
if (dobj.location == player)
player:tell("Taken.");
player.location:announce(player.name, " takes ", dobj.name, ".");
else
player:tell("You can't pick that up.");
endif
endif
.
#11:3
"{last_huh}  drop/throw any";
"a drop \"verb\" that works for non-$things.";
set_task_perms(caller_perms());
if (dobj == $nothing)
player:tell(verb, " what?");
elseif ($command_utils:object_match_failed(dobj, dobjstr))
"...lose...";
elseif (dobj.location != player)
player:tell("You don't have that.");
elseif (!player.location:acceptable(dobj))
player:tell("You can't drop that here.");
else
dobj:moveto(player.location);
if (dobj.location == player.location)
player:tell_lines((verb[1] == "d") ? "Dropped." | "Thrown.");
player.location:announce(player.name, (verb[1] == "d") ? " dropped " | " threw away ", dobj.name, ".");
else
player:tell_lines("You can't seem to drop that here.");
endif
endif
.
#12:0
":enter(who,islogin,time,site)";
"adds an entry to the connection log for a given guest (caller).";
if ($object_utils:isa(caller, $guest))
$guest_log.connections = {{caller, @args}, @$guest_log.connections[1..min($guest_log.max_entries, $)]};
else
return E_PERM;
endif
.
#12:1
":last([n,[guest_list]])";
"print list of the last n entries in the guest log";
" (use n=0 if you want all entries)";
" optional second arg limits listing to the specified guest(s)";
set_task_perms(caller_perms());
{?howmany = 0, ?which = 0} = args;
howmany = min(howmany || $maxint, length($guest_log.connections));
if (!caller_perms().wizard)
player:notify("Sorry.");
else
current = {};
listing = {};
last = 0;
for c in ($guest_log.connections[1..howmany])
if (which && (!(c[1] in which)))
elseif (c[2])
"...login...";
if (a = $list_utils:assoc(c[1], current))
listing[a[2]][3] = c[3];
current = setremove(current, a);
else
listing = {@listing, {c[1], c[4], c[3], $object_utils:connected(c[1]) ? -idle_seconds(c[1]) | 1}};
last = last + 1;
endif
else
"...logout...";
listing = {@listing, {c[1], c[4], 0, c[3]}};
last = last + 1;
if (i = $list_utils:iassoc(c[1], current))
current[i][2] = last;
else
current = {@current, {c[1], last}};
endif
endif
$command_utils:suspend_if_needed(2);
endfor
su = $string_utils;
player:notify(su:left(su:left(su:left("Guest", 20) + "Connected", 36) + "Idle/Disconn.", 52) + "From");
player:notify(su:left(su:left(su:left("-----", 20) + "---------", 36) + "-------------", 52) + "----");
for l in (listing)
on = l[3] ? (ct = ctime(l[3]))[1..3] + ct[9..19] | "earlier";
off = (l[4] > 0) ? (ct = ctime(l[4]))[1..3] + ct[9..19] | ("  " + $string_utils:from_seconds(-l[4]));
player:notify(su:left(su:left(su:right(tostr(strsub(l[1].name, "uest", "."), " (", l[1], ")  "), -20) + on, 36) + off, 52) + l[2]);
$command_utils:suspend_if_needed(2);
endfor
endif
.
#12:2
if (caller_perms().wizard)
pass(@args);
this.connections = {};
endif
.
#12:3
":find(guest_id,time)";
" => site name of guest logged in at that time";
" => 0 if not logged in";
" => E_NACC if this is earlier than the earliest guest recorded";
set_task_perms(caller_perms());
{who, when} = args;
if (!caller_perms().wizard)
raise(E_PERM);
else
found = (who in connected_players()) ? $string_utils:connection_hostname(who.last_connect_place) | 0;
for c in ($guest_log.connections)
if (c[3] < when)
return found;
elseif (c[1] != who)
"... different guest...";
elseif (c[2])
"...login...";
if (c[3] == when)
return found;
endif
found = 0;
else
"...logout...";
found = c[4];
endif
endfor
return E_NACC;
endif
.
#13:0
":length(tree) => number of leaves in tree.";
return args[1] ? args[1][2] | 0;
.
#13:1
":find_nth(tree,n) => nth leaf of tree.  Assumes n in [1..tree[2]]";
return this:_find_nth(caller, @args);
.
#13:2
":_find_ord(tree,n,comp) ";
" => index of rightmost leaf for which :(comp)(n,:_ord(leaf)) is false.";
"returns 0 if true for all leaves.";
return args[1] ? this:_find_ord(caller, @args) | 0;
.
#13:3
":set_nth(tree,n,value) => tree";
"modifies tree so that nth leaf == value";
if (((n = args[2]) < 1) || ((!(tree = args[1])) || (tree[2] < n)))
return E_RANGE;
else
this:_set_nth(caller, @args);
return (n != 1) ? tree | listset(tree, caller:_ord(args[3]), 3);
endif
.
#13:4
":kill(tree[,leafverb]) deletes tree and _kills all of the nodes that it uses.";
"if leafverb is given, caller:leafverb is called on all leaves in tree.";
if (tree = args[1])
lverb = {@args, ""}[2];
this:_skill(caller, (typeof(tree) == LIST) ? tree[1] | tree, lverb);
endif
"... otherwise nothing to do...";
.
#13:5
":insert_after(tree,subtree,n)";
":insert_before(tree,subtree,n)";
"  inserts subtree after (before) the nth leaf of tree,";
"  returning the resulting tree.";
subtree = args[2];
if (tree = args[1])
if (subtree)
where = args[3] - (verb == "insert_before");
if (where <= 0)
return this:_merge(caller, subtree, tree);
elseif (where >= tree[2])
return this:_merge(caller, tree, subtree);
else
s = this:_split(caller, caller:_get(tree[1])[1], where, tree);
return this:_merge(caller, this:_merge(caller, s[1], subtree), s[2]);
endif
else
return tree;
endif
else
return subtree;
endif
.
#13:6
":extract_range(tree,first,last) => {newtree,extraction}";
return this:_extract(caller, @args);
.
#13:7
":delete_range(tree,first,last[,leafkill]) => newtree";
extract = this:_extract(caller, @args);
if (die = extract[2])
this:_skill(caller, die[1], {@args, ""}[4]);
endif
return extract[1];
.
#13:8
":keep_range(tree,first,last[,leafkill]) => range";
extract = this:_extract(caller, @args);
if (die = extract[1])
this:_skill(caller, die[1], {@args, ""}[4]);
endif
return extract[2];
.
#13:9
":insert_last(tree,insert) => newtree";
"insert a new leaf to be inserted at the righthand end of the tree";
tree = args[1];
insert = args[2];
if (!tree)
return {caller:_make(0, {insert}), 1, caller:_ord(insert)};
endif
hgt = caller:_get(tree[1]);
rspine = {{tree, plen = length(kids = hgt[2])}};
for i in [1..hgt[1]]
parent = kids[plen];
kids = caller:_get(parent[1])[2];
plen = length(kids);
rspine = {{parent, plen}, @rspine};
endfor
iord = caller:_ord(insert);
for h in [1..length(rspine)]
"... tree is the plen'th (rightmost) child of parent...";
if (rspine[h][2] < this.maxfanout)
parent = rspine[h][1];
hgp = caller:_get(parent[1]);
caller:_put(parent[1], @listset(hgp, {@hgp[2], insert}, 2));
for p in (rspine[h + 1..length(rspine)])
rkid = listset(parent, parent[2] + 1, 2);
parent = p[1];
hgp = caller:_get(parent[1]);
caller:_put(parent[1], @listset(hgp, listset(hgp[2], rkid, p[2]), 2));
endfor
return listset(tree, tree[2] + 1, 2);
endif
insert = {caller:_make(h - 1, {insert}), 1, iord};
endfor
return {caller:_make(length(rspine), {tree, insert}), tree[2] + 1, tree[3]};
.
#13:10
":start(tree,first,last) => {list of leaf nodes, @handle}";
"handle is of the form {{node,next,size}...}";
if (tree = args[1])
before = max(0, args[2] - 1);
howmany = min(args[3], tree[2]) - before;
if (howmany <= 0)
return {};
else
spine = {};
for h in [1..caller:_get(tree[1])[1]]
ik = this:_listfind_nth(kids = caller:_get(tree[1])[2], before);
newh = kids[ik[1]][2] - ik[2];
if (newh < howmany)
spine = {{tree[1], ik[1] + 1, howmany - newh}, @spine};
howmany = newh;
endif
tree = kids[ik[1]];
before = ik[2];
endfor
return {caller:_get(tree[1])[2][before + 1..before + howmany], @spine};
endif
else
return {};
endif
.
#13:11
":next(@handle) => {list of more leaf nodes, @newhandle}";
if (args)
spine = listdelete(args, 1);
node = args[1][1];
n = args[1][2];
size = args[1][3];
for h in [1..caller:_get(node)[1]]
nnode = caller:_get(node)[2][n];
if (size > nnode[2])
spine = {{node, n + 1, size - nnode[2]}, @spine};
size = nnode[2];
endif
n = 1;
node = nnode[1];
endfor
test = caller:_get(node);
return {test[2][n..size], @spine};
else
return {};
endif
.
#13:12
":_find_nth(home,tree,n) => nth leaf of tree.";
"...Assumes n in [1..tree[2]]";
if (caller != this)
return E_PERM;
endif
{home, tree, n} = args;
if ((p = home:_get(tree[1]))[1])
for k in (p[2])
if (n > k[2])
n = n - k[2];
else
return this:_find_nth(home, k, n);
endif
endfor
return E_RANGE;
else
return p[2][n];
endif
.
#13:13
":_find_ord(home,tree,n,less_than) ";
" => index of rightmost leaf for which :(less_than)(n,:_ord(leaf)) is false.";
"returns 0 if true for all leaves.";
if (caller != this)
return E_PERM;
endif
{home, tree, n, less_than} = args;
if ((p = home:_get(tree[1]))[1])
sz = tree[2];
for i in [-length(p[2])..-1]
k = p[2][-i];
sz = sz - k[2];
if (!this:_call(home, less_than, n, k[3]))
return sz + this:_find_ord(home, k, n, less_than);
endif
endfor
return 0;
else
for i in [1..r = length(p[2])]
if (this:_call(home, less_than, n, home:_ord(p[2][i])))
return i - 1;
endif
endfor
return r;
endif
.
#13:14
":_set_nth(home,tree,n,value) => tree[n] = value";
"Assumes n in [1..tree[2]]";
if (caller != this)
return E_PERM;
endif
{home, tree, n, value} = args;
if ((p = home:_get(tree[1]))[1])
ik = this:_listfind_nth(p[2], n - 1);
this:_set_nth(home, p[2][ik[1]], ik[2] + 1, value);
if (!ik[2])
p[2][ik[1]][3] = home:_ord(value);
home:_put(tree[1], @p);
endif
else
p[2][n] = value;
home:_put(tree[1], @p);
endif
.
#13:15
":_skill(home,node,kill_leaf)";
"home:_kill's node and all descendants, home:(kill_leaf)'s all leaves";
if (caller != this)
return E_PERM;
endif
{home, node, kill_leaf} = args;
try
{height, subtrees} = home:_get(node) || {0, {}};
except (E_PROPNF)
return;
endtry
if (height)
for kid in (subtrees)
this:_skill(home, kid[1], kill_leaf);
endfor
elseif (kill_leaf)
for kid in (subtrees)
this:_call(home, kill_leaf, kid);
endfor
endif
home:_kill(node);
.
#13:16
":_extract(home,tree,first,last) => {newtree,extraction}";
if (caller != this)
return E_PERM;
endif
home = args[1];
if (!(tree = args[2]))
return {{}, {}};
endif
before = max(0, args[3] - 1);
end = min(tree[2], args[4]);
if ((end <= 0) || (before >= end))
return {tree, {}};
endif
height = home:_get(tree[1])[1];
if (end < tree[2])
r = this:_split(home, height, end, tree);
if (before)
l = this:_split(home, height, before, r[1]);
extract = l[2];
newtree = this:_merge(home, l[1], r[2]);
else
extract = r[1];
newtree = r[2];
endif
elseif (before)
l = this:_split(home, height, before, tree);
extract = l[2];
newtree = l[1];
else
return {{}, tree};
endif
return {this:_scrunch(home, newtree), this:_scrunch(home, extract)};
.
#13:17
"_merge(home,ltree,rtree) => newtree";
"assumes ltree and rtree to be nonempty.";
if (caller != this)
return E_PERM;
endif
{home, lnode, rnode} = args;
lh = home:_get(lnode[1])[1];
rh = home:_get(rnode[1])[1];
if (lh > rh)
return this:_rmerge(home, lnode, rnode);
endif
for h in [lh + 1..rh]
lnode[1] = home:_make(h, {lnode});
endfor
m = this:_smerge(home, rh, lnode, rnode);
return (length(m) <= 1) ? m[1] | {home:_make(rh + 1, m), m[1][2] + m[2][2], m[1][3]};
.
#13:18
"_smerge(home, height, ltree, rtree) =>{ltree[,rtree]}";
"assumes ltree and rtree are at the given height.";
"merges the trees if the combined number of children is <= maxfanout";
"otherwise returns two trees where ltree is guaranteed minfanout children and rtree is guaranteed the minimum of minfanout and however many children it started with.";
if (caller != this)
return E_PERM;
endif
{home, height, ltree, rtree} = args;
llen = length(lkids = home:_get(ltree[1])[2]);
rlen = length(rkids = home:_get(rtree[1])[2]);
if (height)
m = this:_smerge(home, height - 1, lkids[llen], rkids[1]);
mlen = length(mkids = {@listdelete(lkids, llen), @m, @listdelete(rkids, 1)});
if (mlen <= this.maxfanout)
home:_put(ltree[1], height, mkids);
home:_kill(rtree[1]);
ltree[2] = ltree[2] + rtree[2];
return {ltree};
else
S = max(llen - 1, (mlen + 1) / 2);
home:_put(ltree[1], height, mkids[1..S]);
home:_put(rtree[1], height, mkids[S + 1..$]);
xfer = -lkids[llen][2];
for k in (mkids[llen..S])
xfer = xfer + k[2];
endfor
ltree[2] = ltree[2] + xfer;
rtree[2] = rtree[2] - xfer;
rtree[3] = mkids[S + 1][3];
return {ltree, rtree};
endif
elseif ((llen * 2) >= this.maxfanout)
return {ltree, rtree};
elseif (this.maxfanout < (llen + rlen))
T = ((rlen - llen) + 1) / 2;
home:_put(ltree[1], 0, {@lkids, @rkids[1..T]});
home:_put(rtree[1], 0, rkids[T + 1..rlen]);
ltree[2] = ltree[2] + T;
rtree[2] = rtree[2] - T;
rtree[3] = home:_ord(rkids[T + 1]);
return {ltree, rtree};
else
home:_put(ltree[1], 0, {@lkids, @rkids});
home:_kill(rtree[1]);
ltree[2] = ltree[2] + rtree[2];
return {ltree};
endif
.
#13:19
"_split(home, height,lmax,ltree[,@rtrees]}) => {ltree,[mtree,]@rtrees}";
"ltree is split after the lmax'th leaf, the righthand portion grafted onto the leftmost of the rtrees, if possible.  Otherwise we create a new tree mtree, stealing from rtrees[1] if necessary.";
"Assumes 1<=lmax<ltree[2]";
if (caller != this)
return E_PERM;
endif
{home, height, lmax, ltree, @rtrees} = args;
llen = length(lkids = home:_get(ltree[1])[2]);
rlen = length(rkids = rtrees ? home:_get(rtrees[1][1])[2] | {});
if (height)
ik = this:_listfind_nth(lkids, lmax);
if (ik[2])
llast = ik[1];
m = this:_split(home, height - 1, ik[2], lkids[llast], @lkids[llast + 1..llen], @rkids);
lkids[llast] = m[1];
mkids = listdelete(m, 1);
else
llast = ik[1] - 1;
mkids = {@lkids[ik[1]..llen], @rkids};
endif
home:_put(ltree[1], height, lkids[1..llast]);
mlen = length(mkids);
if ((((mlen - rlen) * 2) >= this.maxfanout) || (!rtrees))
"...residue left over from splitting ltree can stand by itself...";
return {listset(ltree, lmax, 2), {home:_make(height, mkids[1..mlen - rlen]), ltree[2] - lmax, mkids[1][3]}, @rtrees};
elseif (mlen <= this.maxfanout)
"...residue left over from splitting ltree fits in rtrees[1]...";
home:_put(rtrees[1][1], height, mkids);
rtrees[1][2] = (ltree[2] - lmax) + rtrees[1][2];
rtrees[1][3] = mkids[1][3];
return {listset(ltree, lmax, 2), @rtrees};
else
"...need to steal from rtrees[1]...";
if (llast < llen)
msize = ltree[2] - lmax;
R = (mlen - rlen) + 1;
else
msize = 0;
R = 1;
endif
for k in (mkids[R..mlen / 2])
msize = msize + k[2];
endfor
home:_put(rtrees[1][1], height, mkids[(mlen / 2) + 1..mlen]);
rtrees[1][2] = (rtrees[1][2] + ltree[2]) - (lmax + msize);
rtrees[1][3] = mkids[(mlen / 2) + 1][3];
return {listset(ltree, lmax, 2), {home:_make(height, mkids[1..mlen / 2]), msize, mkids[1][3]}, @rtrees};
endif
else
home:_put(ltree[1], 0, lkids[1..lmax]);
if ((((llen - lmax) * 2) >= this.maxfanout) || (!rtrees))
"...residue left over from splitting ltree can stand by itself...";
return {listset(ltree, lmax, 2), {home:_make(0, lkids[lmax + 1..llen]), llen - lmax, home:_ord(lkids[lmax + 1])}, @rtrees};
elseif ((mlen = (rlen + llen) - lmax) <= this.maxfanout)
"...residue left over from splitting ltree fits in rtrees[1]...";
home:_put(rtrees[1][1], 0, {@lkids[lmax + 1..llen], @rkids});
rtrees[1][2] = mlen;
rtrees[1][3] = home:_ord(lkids[lmax + 1]);
return {listset(ltree, lmax, 2), @rtrees};
else
"...need to steal from rtrees[1]...";
home:_put(rtrees[1][1], 0, rkids[(R = ((rlen - llen) + lmax) / 2) + 1..rlen]);
rtrees[1][2] = (mlen + 1) / 2;
rtrees[1][3] = home:_ord(rkids[R + 1]);
return {listset(ltree, lmax, 2), {home:_make(0, {@lkids[lmax + 1..llen], @rkids[1..R]}), mlen / 2, home:_ord(lkids[lmax + 1])}, @rtrees};
endif
endif
.
#13:20
":_rmerge(home, tree, insertree) => newtree ";
"(newtree is tree with insertree appended to the right)";
"insertree is assumed to be of height < tree";
if (caller != this)
return E_PERM;
endif
{home, tree, insert} = args;
if (!tree)
return insert;
elseif (!insert)
return tree;
endif
iheight = home:_get(insert[1])[1];
rspine = {};
for i in [iheight + 1..home:_get(tree[1])[1]]
kids = home:_get(tree[1])[2];
tlen = length(kids);
rspine = {{tree, tlen}, @rspine};
tree = kids[tlen];
endfor
isize = insert[2];
m = this:_smerge(home, iheight, tree, insert);
for h in [1..length(rspine)]
plen = rspine[h][2];
parent = rspine[h][1];
hgp = home:_get(parent[1]);
if (((length(m) - 1) + plen) > this.maxfanout)
home:_put(parent[1], @listset(hgp, listset(hgp[2], m[1], plen), 2));
parent[2] = (parent[2] + isize) - m[2][2];
m = {parent, listset(m[2], home:_make(h + iheight, {m[2]}), 1)};
else
home:_put(parent[1], @listset(hgp, {@hgp[2][1..plen - 1], @m}, 2));
for p in (rspine[h + 1..length(rspine)])
parent[2] = parent[2] + isize;
tree = parent;
parent = p[1];
hgp = home:_get(parent[1]);
home:_put(parent[1], @listset(hgp, listset(hgp[2], tree, p[2]), 2));
endfor
return listset(parent, parent[2] + isize, 2);
endif
endfor
return {home:_make((length(rspine) + iheight) + 1, m), m[1][2] + m[2][2], m[1][3]};
.
#13:21
":_scrunch(home,tree) => newtree";
"decapitates single-child nodes from the top of the tree, returns new root.";
if (caller != this)
return E_PERM;
endif
if (tree = args[2])
home = args[1];
while ((n = home:_get(tree[1]))[1] && (length(n[2]) == 1))
home:_kill(tree[1]);
tree = n[2][1];
endwhile
endif
return tree;
.
#13:22
"_listfind_nth(nodelist,key) => {i,k} where i is the smallest i such that the sum of the first i elements of intlist is > key, and k==key - sum(first i-1 elements).";
"1 <= i <= length(intlist)+1";
{lst, key} = args;
for i in [1..length(lst)]
key = key - lst[i][2];
if (0 > key)
return {i, key + lst[i][2]};
endif
endfor
return {length(lst) + 1, key};
.
#13:23
if (caller != this)
return E_PERM;
endif
.
#13:24
return $perm_utils:controls(caller_perms(), this) ? this:(args[1])(@listdelete(args, 1)) | E_PERM;
.
#13:25
":_call(home,verb,@vargs) calls home:verb(@vargs) with $no_one's perms";
set_task_perms($no_one);
if (caller != this)
raise(E_PERM);
endif
{home, vb, @vargs} = args;
return home:(vb)(@vargs);
.
#14:0
gp = this._genprop;
ngp = "";
for i in [1..length(gp)]
if (gp[i] != "z")
ngp = (ngp + "bcdefghijklmnopqrstuvwxyz"[index("abcdefghijklmnopqrstuvwxy", gp[i])]) + gp[i + 1..length(gp)];
return " " + (this._genprop = ngp);
endif
ngp = ngp + "a";
endfor
return " " + (this._genprop = ngp + "a");
.
#14:1
":_make(...) => new node with value {...}";
if (!(caller in {this._mgr, this}))
return E_PERM;
endif
prop = this:_genprop();
`add_property(this, prop, args, {this.mowner, ""}) ! ANY';
return prop;
.
#14:2
":_kill(node) destroys the given node.";
if (!(caller in {this, this._mgr}))
return E_PERM;
endif
`delete_property(this, args[1]) ! ANY';
.
#14:3
return (caller == this._mgr) ? `this.(args[1]) ! ANY' | E_PERM;
.
#14:4
return (caller == this._mgr) ? this.(args[1]) = listdelete(args, 1) | E_PERM;
.
#14:5
return args[1][2..3];
.
#14:6
":_makemsg(ord,msg) => leafnode for msg";
"msg = $mail_agent:__convert_new(@args[2])";
msg = args[2];
if (caller != this)
return E_PERM;
elseif (h = "" in msg)
return {this:_make(@msg[h + 1..$]), args[1], @msg[1..h - 1]};
else
return {0, args[1], @msg};
endif
.
#14:7
if (caller != this._mgr)
return E_PERM;
elseif (node = args[1][1])
this:_kill(node);
endif
.
#14:8
return args[2];
.
#14:9
return args[3];
.
#14:10
return args[3..$];
.
#14:11
if ((caller == this) || this:is_readable_by(caller_perms()))
"perms check added HTC 16 Feb 1999";
return {@args[3..$], @args[1] ? {"", @this.(args[1])} | {}};
else
return E_PERM;
endif
.
#14:12
return args[1] < args[2][1];
.
#14:13
return args[1] < args[2][2];
.
#14:14
if (!this:is_writable_by(caller_perms()))
return E_PERM;
else
new = this:new_message_num();
msgtree = this.messages;
for m in (args)
msgtree = this._mgr:insert_last(msgtree, this:_makemsg(new, m[2]));
new = new + 1;
if ($command_utils:running_out_of_time())
this.messages = msgtree;
player:tell("... ", new);
suspend(0);
msgtree = this.messages;
new = this:new_message_num();
endif
endfor
this.messages = msgtree;
this.last_used_time = time();
return 1;
endif
.
#14:15
if (!this:is_writable_by(caller_perms()))
return E_PERM;
else
this.messages = this._mgr:insert_last(this.messages, msg = this:_makemsg(new = this:new_message_num(), args[1]));
this.last_msg_date = this:_message_date(@msg);
this.last_used_time = time();
return new;
endif
.
#14:16
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (typeof(seq = args[1]) != LIST)
x = this._mgr:find_nth(this.messages, seq);
return {this:_message_num(@x), this:_message_text(@x)};
else
msgs = {};
while (seq)
handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);
while (handle)
for x in (handle[1])
msgs = {@msgs, {this:_message_num(@x), this:_message_text(@x)}};
endfor
handle = this._mgr:next(@listdelete(handle, 1));
$command_utils:suspend_if_needed(0);
endwhile
seq = seq[3..$];
endwhile
return msgs;
endif
.
#14:17
":display_seq_headers(msg_seq[,cur[,last_read_date]])";
"This is the default header display routine.";
"Prints a list of headers of messages on this to player.  msg_seq is the handle returned by this:parse_message_seq(...).  cur is the player's current message.  last_read_date is the date of the last of the already-read messages.";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
getmsg = this.summary_uses_body ? "_message_text" | "_message_hdr";
{seq, ?cur = 0, ?last_old = $maxint} = args;
keep_seq = {@$seq_utils:contract(this:kept_msg_seq(), $seq_utils:complement(seq, 1, this:length_all_msgs())), $maxint};
k = 1;
mcount = 0;
width = player:linelen();
while (seq)
handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);
while (handle)
for x in (handle[1])
$command_utils:suspend_if_needed(0);
if (keep_seq[k] <= (mcount = mcount + 1))
k = k + 1;
endif
annot = (x[3] > last_old) ? "+" | ((k % 2) ? " " | "=");
line = tostr($string_utils:right(x[2], 5, (cur == x[2]) ? ">" | " "), ":", annot, " ", this:msg_summary_line(@this:(getmsg)(@x)));
player:tell(line[1..min(width, $)]);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
seq = seq[3..$];
endwhile
player:tell("-----+");
.
#14:18
":display_seq_full(msg_seq[,preamble]) => {cur}";
"This is the default message display routine.";
"Prints the indicated messages on folder to player.  msg_seq is the handle returned by folder:parse_message_seq(...).  Returns the number of the final message in the sequence (to be the new current message number).";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{seq, ?preamble = ""} = args;
cur = date = 0;
while (seq)
handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);
while (handle)
for x in (handle[1])
cur = this:_message_num(@x);
date = this:_message_date(@x);
player:display_message(preamble ? strsub(preamble, "%d", tostr(cur)) | {}, this:msg_full_text(@this:_message_text(@x)));
endfor
handle = this._mgr:next(@listdelete(handle, 1));
$command_utils:suspend_if_needed(0);
endwhile
seq = seq[3..$];
endwhile
return {cur, date};
.
#14:19
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
len = 0;
getmsg = this.summary_uses_body ? "_message_text" | "_message_hdr";
going = this.messages_going;
if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))
kept = {@going[1], $maxint};
going = going[2];
else
kept = {$maxint};
endif
k = 1;
mcount = 0;
for s in (going)
if (kept[k] <= (mcount = mcount + s[1]))
k = k + 1;
endif
len = len + s[2][2];
handle = this._mgr:start(s[2], 1, s[2][2]);
while (handle)
for x in (handle[1])
if (kept[k] <= (mcount = mcount + 1))
k = k + 1;
endif
player:tell($string_utils:right(this:_message_num(@x), 4), (k % 2) ? ":  " | ":= ", this:msg_summary_line(@this:(getmsg)(@x)));
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
if (len)
player:tell("----+");
endif
return len;
.
#14:20
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
msgtree = this.messages;
seq = {};
last = 0;
"there are two possible formats here:";
"OLD: {{n,msgs},{n,msgs},...}";
"NEW: {kept_seq, {{n,msgs},{n,msgs},...}}";
going = this.messages_going;
if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))
kept = going[1];
going = going[2];
else
kept = {};
endif
for s in (going)
msgtree = this._mgr:insert_after(msgtree, s[2], last + s[1]);
seq = {@seq, (last + s[1]) + 1, (last = (last + s[1]) + s[2][2]) + 1};
endfor
this.messages = msgtree;
this.messages_going = {};
this.messages_kept = $seq_utils:union(kept, $seq_utils:expand(this.messages_kept, seq));
this:_fix_last_msg_date();
return seq;
.
#14:21
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
len = 0;
going = this.messages_going;
if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))
going = going[2];
endif
for s in (going)
len = len + s[2][2];
this._mgr:kill(s[2], "_killmsg");
endfor
this.messages_going = {};
return len;
.
#14:22
seq = args[1];
if (!(this:ok_write(caller, caller_perms()) || (this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args)))))
return E_PERM;
endif
msgtree = this.messages;
save = nums = {};
onext = 1;
rmmed = 0;
for i in [1..length(seq) / 2]
if ($command_utils:suspend_if_needed(0))
player:tell("... rmm ", onext);
suspend(0);
endif
start = seq[(2 * i) - 1];
next = seq[2 * i];
{msgtree, zmsgs} = this._mgr:extract_range(msgtree, start - rmmed, (next - 1) - rmmed);
save = {@save, {start - onext, zmsgs}};
nums = {@nums, this:_message_num(@this._mgr:find_nth(zmsgs, 1)), this:_message_num(@this._mgr:find_nth(zmsgs, zmsgs[2])) + 1};
onext = next;
rmmed = (rmmed + next) - start;
endfor
tmg = this.messages_going;
save_kept = $seq_utils:intersection(this.messages_kept, seq);
this.messages_kept = $seq_utils:contract(this.messages_kept, seq);
this.messages_going = save_kept ? {save_kept, save} | save;
fork (0)
for s in (tmg)
this._mgr:kill(s[2], "_killmsg");
endfor
endfork
this.messages = msgtree;
this:_fix_last_msg_date();
return $seq_utils:tostr(nums);
.
#14:23
":renumber([cur]) renumbers caller.messages, doing a suspend() if necessary.";
"  => {number of messages,new cur}.";
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
{?cur = 0} = args;
this:expunge_rmm();
"... blow away @rmm'ed messages since there's no way to tell what their new numbers should be...";
if (!(msgtree = this.messages))
return {0, 0};
endif
if (cur)
cur = this._mgr:find_ord(msgtree, cur - 1, "_lt_msgnum") + 1;
endif
while (1)
"...find first out-of-sequence message...";
n = 1;
subtree = msgtree;
if (msgtree[3][1] == 1)
while ((node = this.(subtree[1]))[1])
"...subtree[3][1]==n...";
kids = node[2];
n = n + subtree[2];
i = length(kids);
while ((n = n - kids[i][2]) != kids[i][3][1])
i = i - 1;
endwhile
subtree = kids[i];
endwhile
leaves = node[2];
n = ((firstn = n) + length(leaves)) - 1;
while (n != leaves[(n - firstn) + 1][2])
n = n - 1;
endwhile
n = n + 1;
endif
"... n == first out-of-sequence ...";
"...renumber as many messages as we have time for...";
while ((n <= msgtree[2]) && (!$command_utils:running_out_of_time()))
msg = this._mgr:find_nth(msgtree, n);
msgtree = this._mgr:set_nth(msgtree, n, listset(msg, n, 2));
n = n + 1;
endwhile
this.messages = msgtree;
if (n > msgtree[2])
return {n - 1, cur};
endif
player:tell("...(renumbering to ", n - 1, ")");
suspend(0);
"...start over... may have received new mail, rmm'ed stuff, etc...";
"...so who knows what's there now?...";
if (this.messages_going)
player:tell("Renumber aborted.");
return;
endif
msgtree = this.messages;
endwhile
.
#14:24
return this:ok(caller, caller_perms()) ? this.messages ? this.messages[2] | 0 | E_PERM;
.
#14:25
return this:ok(caller, caller_perms()) ? this._mgr:find_ord(this.messages, args[1], "_lt_msgnum") | E_PERM;
.
#14:26
return this:ok(caller, caller_perms()) ? this._mgr:find_ord(this.messages, args[1], "_lt_msgdate") | E_PERM;
.
#14:27
return this:ok(caller, caller_perms()) ? (i = this._mgr:find_ord(this.messages, args[1], "_lt_msgnum")) && ((this:_message_num(@this._mgr:find_nth(this.messages, i)) == args[1]) && i) | E_PERM;
.
#14:28
if (this:ok(caller, caller_perms()))
new = (msgtree = this.messages) ? this:_message_num(@this._mgr:find_nth(msgtree, msgtree[2])) + 1 | 1;
if (rmsgs = this.messages_going)
lbrm = rmsgs[$][2];
return max(new, this:_message_num(@this._mgr:find_nth(lbrm, lbrm[2])) + 1);
else
return new;
endif
else
return E_PERM;
endif
.
#14:29
":from_msg_seq(object or list)";
" => msg_seq of messages from any of these senders";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{plist, ?mask = {1, this.messages[2] + 1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
fseq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
fromline = msg[4];
for f in ($mail_agent:parse_address_field(fromline))
if (f in plist)
fseq = $seq_utils:add(fseq, i, i);
endif
endfor
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
.
#14:30
":%from_msg_seq(string or list of strings)";
" => msg_seq of messages with one of these strings in the from line";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{nlist, ?mask = {1, this.messages[2] + 1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
fseq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
fromline = " " + msg[4];
for n in (nlist)
if (index(fromline, n))
fseq = $seq_utils:add(fseq, i, i);
endif
endfor
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg($string_utils, "print", nlist), "no one", " or "));
.
#14:31
":to_msg_seq(object or list) => msg_seq of messages to those people";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{plist, ?mask = {1, this.messages[2] + 1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
seq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
toline = msg[5];
for r in ($mail_agent:parse_address_field(toline))
if (r in plist)
seq = $seq_utils:add(seq, i, i);
endif
endfor
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return seq || ("%f %<has> no messages to " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
.
#14:32
":%to_msg_seq(string or list of strings)";
" => msg_seq of messages containing one of strings in the to line";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{nlist, ?mask = {1, this.messages[2] + 1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
seq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
toline = " " + msg[5];
for n in (nlist)
if (index(toline, n))
seq = $seq_utils:add(seq, i, i);
endif
endfor
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return seq || ("%f %<has> no messages to " + $string_utils:english_list($list_utils:map_arg($string_utils, "print", nlist), "no one", " or "));
.
#14:33
":subject_msg_seq(target) => msg_seq of messages with target in the Subject:";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{target, ?mask = {1, this.messages[2] + 1}} = args;
seq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
if (((subject = msg[6]) != " ") && index(subject, target))
seq = $seq_utils:add(seq, i, i);
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return seq || (("%f %<has> no messages with subjects containing `" + target) + "'");
.
#14:34
":body_msg_seq(target) => msg_seq of messages with target in the body";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{target, ?mask = {1, this.messages[2] + 1}} = args;
seq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
if ((msg[1] && (body = this.(msg[1]))) && index(tostr(@body), target))
seq = $seq_utils:add(seq, i, i);
"Above saves ticks. Munges the whole message into one string and indexes it. Old code follows.";
"l = length(body);";
"while (!index(body[l], target) && (l = l - 1))";
"$command_utils:suspend_if_needed(0);";
"endwhile";
"if (l)";
"seq = $seq_utils:add(seq, i, i);";
"endif";
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return seq || tostr("%f %<has> no messages containing `", target, "' in the body.");
.
#14:35
return E_VERBNF;
.
#14:36
msgtree = this.messages;
this.last_msg_date = (msgtree && this:_message_hdr(@this._mgr:find_nth(msgtree, msgtree[2]))[1]) || 0;
.
#14:37
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
{?doit = 0} = args;
msgtree = this.messages;
for n in [1..msgtree[2]]
msg = this._mgr:find_nth(msgtree, n);
msg = {@msg[1..2], @$mail_agent:__convert_new(@msg[3..$])};
if (doit)
msgtree = this._mgr:set_nth(msgtree, n, msg);
endif
if ($command_utils:running_out_of_time())
suspend(0);
if (this.messages != msgtree)
player:notify("urk.  someone played with this folder.");
return 0;
endif
endif
endfor
return 1;
.
#14:38
if (caller_perms().wizard)
this._mgr = $biglist;
this.mowner = $mail_recipient.owner;
for p in (properties(this))
$command_utils:suspend_if_needed(0);
if (p && (p[1] == " "))
delete_property(this, p);
endif
endfor
this.messages = this.messages_going = {};
this:_fix_last_msg_date();
this._genprop = "";
pass(@args);
endif
.
#14:39
if (this:ok(caller, caller_perms()))
date = args[1];
return (this.last_msg_date <= date) ? 0 | (this.messages[2] - this._mgr:find_ord(this.messages, args[1], "_lt_msgdate"));
else
return E_PERM;
endif
.
#14:40
c = callers();
if ((caller != this) && (!((((length(c) > 1) && (c[1][1] == $list_utils)) && (c[1][2] == "map_arg")) && (c[2][1] == this))))
raise(E_PERM);
endif
$command_utils:suspend_if_needed(0);
biglist = this;
propname = args[1];
if (!propname)
bestlevel = -1;
best = {};
for prop in (properties(biglist))
$command_utils:suspend_if_needed(0);
if (index(prop, " ") == 1)
val = biglist.(prop);
if (typeof(val[1]) == INT)
if (bestlevel < val[1])
bestlevel = val[1];
best = {prop};
elseif (bestlevel == val[1])
best = {@best, prop};
endif
endif
endif
endfor
if (!best)
player:notify("Can't find a root.");
raise(E_INVARG);
elseif (length(best) == 1)
propname = best[1];
else
propname = best[1];
val = biglist.(propname);
for prop in (best[2..$])
$command_utils:suspend_if_needed(0);
val[2] = {@val[2], @biglist.(prop)[2]};
endfor
biglist.(propname) = val;
"Now that the new value is safely stored, delete old values.";
for prop in (best[2..$])
$command_utils:suspend_if_needed(0);
player:notify(tostr("Removing property ", toliteral(prop), ".  Its value, ", toliteral(biglist.(prop)), ", has been merged with property ", toliteral(propname), "."));
delete_property(biglist, prop);
endfor
endif
maxlevel = biglist.(propname)[1];
player:notify(tostr("Maximum level is ", maxlevel, "."));
items = $list_utils:make(maxlevel, {});
"Arrgh.  Even after finding the root, some nodes might be detached!";
player:notify("Checking for orphans...");
for prop in (properties(biglist))
$command_utils:suspend_if_needed(0);
if (prop && (prop[1] == " "))
val = biglist.(prop);
if (((typeof(val) == LIST) && (typeof(level = val[1]) == INT)) && (level < maxlevel))
items[level + 1] = {@items[level + 1], prop};
endif
endif
endfor
for prop in (properties(biglist))
$command_utils:suspend_if_needed(0);
if (prop && (prop[1] == " "))
val = biglist.(prop);
if (((typeof(val) == LIST) && (typeof(level = val[1]) == INT)) && (level > 0))
for item in (val[2])
items[level] = setremove(items[level], item[1]);
endfor
endif
endif
endfor
player:notify(tostr("Orphans: ", toliteral(items)));
backbone_prop = propname;
level = maxlevel;
while (level)
backbone = biglist.(backbone_prop);
lastkid = backbone_prop;
for prop in (props = items[level])
backbone[2] = {@backbone[2], {lastkid = prop, 0, {0, 0}}};
endfor
player:notify(tostr("Attaching ", nn = length(props), " propert", (nn == 1) ? "y" | "ies", " to property ", toliteral(backbone_prop), "..."));
biglist.(backbone_prop) = backbone;
backbone_prop = lastkid;
level = level - 1;
endwhile
player:notify(tostr("Orphans repatriated."));
endif
toplevel = "(top level)";
context = args[2] || toplevel;
"This stuff is just paranoia in case something unexpected is in the data structure.  Normally there should be no blowouts here. --Minnie";
if (typeof(propname) != STR)
player:notify(tostr("Context=", context, " Prop Name=", toliteral(propname), " -- bad property name."));
raise(E_INVARG);
endif
val = biglist.(propname);
if (typeof(val) != LIST)
player:notify(tostr("Context=", context, " Prop Name=", toliteral(propname), " -- contents invalid."));
raise(E_INVARG);
endif
if (typeof(level = val[1]) != INT)
player:notify(tostr("Context=", context, " Prop Name=", toliteral(propname), " -- contents invalid (bad first argument)."));
raise(E_INVARG);
endif
"This is where the real work starts. --Minnie";
"First check that the properties referred to really exist.  This must be done for all levels.";
for item in (val[2])
try
biglist.(item[1]);
except (E_PROPNF)
player:notify(tostr("Item ", toliteral(item), " is invalid in property ", toliteral(propname), ".  It is being removed."));
val[2] = setremove(val[2], item);
continue item;
endtry
endfor
"Next, only for upper levels, check that the message count for inferior levels is correct, but only after recursing into those levels and making repairs.";
if (level > 0)
new = $list_utils:map_arg(this, verb, $list_utils:slice(val[2]), propname);
if (val[2] != new)
player:notify(tostr("Changing ", toliteral(val[2]), " to ", toliteral(new), "."));
val[2] = new;
endif
"Now that everything is correct, count size of inferiors.";
endif
"Bravely stuff the result back into place.";
biglist.(propname) = val;
"The result will be of the form:                               ";
"  {propname, inferior_msgcount, {first_msgnum, first_time}}  ";
if (level == 0)
"Count the messages for message count.";
"Use first message number and time for first_msgnum and first_time.";
result = {propname, length(val[2]), val[2][1][2..3]};
else
"Use message count that is sum of inferior counts.";
"Just propagate first node's first_msgnum and first_time upward literally.";
n = 0;
for subnode in (val[2])
n = n + subnode[2];
endfor
result = {propname, n, val[2][1][3]};
endif
if (context == toplevel)
if (result != biglist.messages)
biglist.messages = result;
player:notify(tostr("Property ", biglist, ".messages updated."));
endif
player:tell(biglist.messages[2], " messages repaired in ", $mail_agent:name(biglist), ".");
endif
return result;
"Last modified Thu Feb 15 23:13:44 1996 MST by Minnie (#123).";
.
#14:41
"Syntax: repair <biglist>";
"";
"This tool makes a last-resort attempt to repair broken biglists (ones whose data structures are out of alignment due to an error such as \"out of ticks\" during some update operation leaving the b-tree in an inconsistent state).  This tool comes with no warranty of any kind.  You should only use it when you have no other choice, and you should make an attempt to @dump or fully copy or otherwise checkpoint your object before attempting to repair it so that you can recover from any failures this might produce.  This operation is NOT undoable.";
if (!$perm_utils:controls(player, this))
player:tell("You do not control that.");
elseif (!$command_utils:yes_or_no("This tool can be used to repair some (but maybe not all) situations involving generic biglists that have had an error (usually \"out of ticks\") during an update operation and were left inconsistent.  Is this list really and truly broken in such a way?"))
player:tell("No action taken.  PLEASE don't use this except in extreme cases.");
elseif (!$command_utils:yes_or_no("Have you made a best effort to @dump or otherwise save the contents in case this make things worse?"))
player:tell("No action taken.  PLEASE do any saving you can before proceeding.");
elseif (!$command_utils:yes_or_no("This tool comes with no warranty of any kind.  Is this really your last resort and are you prepared to accept the consequences of utter failure?  There is no undoing the actions this takes.  Do you understand and accept the risks?"))
player:tell("No action taken.  I'm not taking any responsibility for this failing.  It's gotta be your choice.");
else
player:tell("OK!  Going ahead with repair attempts...");
this:_repair();
player:tell("All done.  If this worked, you can thank Mickey.  If not, remember the promises you made above about accepting responsibility for failure.");
endif
"Last modified Fri Feb 16 08:36:27 1996 MST by Minnie (#123).";
.
#14:42
":restore_from(OLD_MAIL_RECIPIENT, LOST_STRING)";
"This clears all biglist properties from this object, then";
"scans the properties of OLD_MAIL_RECIPIENT, which must be a descendant";
"of $big_mail_recipient, looking for those corresponding to mail messages,";
"and then rebuilds the message tree entirely from scratch.";
"";
"No attempt is made to preserve the original tree structure.";
"The live/deleted state of any given message is lost;";
"all messages, including formerly rmm-ed ones, are restored to .messages";
"";
"In the (unlikely) event that message-body properties have been lost, the";
"affected messages are given a one-line body consisting of LOST_STRING";
"";
{old, ?lost_body = "###BODY-LOST###"} = args;
if (!($perm_utils:controls(caller_perms(), this) && $perm_utils:controls(caller_perms(), old)))
raise(E_PERM);
elseif (!$object_utils:isa(old, $big_mail_recipient))
raise(E_TYPE, "First argument must be a $big_mail_recipient.");
elseif (typeof(lost_body) != STR)
raise(E_TYPE, "Second argument, if given, must be a string.");
endif
mgr = this._mgr;
"...";
"... destroy everything...";
for p in (properties(this))
delete_property(this, p);
endfor
this.messages = this.messages_going = {};
"...";
"... look at all properties...";
msgcount = lostcount = 0;
for p in (properties(old))
if (index(p, " ") == 1)
pvalue = old.(p);
"... ignore everything except level-0 nodes...";
if (pvalue[1..min(1, $)] == {0})
for msg in (pvalue[2])
if ((ticks_left() < 6000) || (seconds_left() < 2))
player:tell("...", msgcount, " copied.");
suspend(0);
endif
try
body = old.(msg[1]);
except e (E_PROPNF)
body = {lost_body};
lostcount = lostcount + 1;
endtry
msg[1] = this:_make(@body);
msgtree = mgr:insert_last(this.messages, msg);
msgcount = msgcount + 1;
n = mgr:find_ord(msgtree, this:_message_num(@msg), "_lt_msgnum");
if (n < msgcount)
{msgtree, singleton} = mgr:extract_range(msgtree, msgcount, msgcount);
msgtree = mgr:insert_after(msgtree, singleton, n);
endif
this.messages = msgtree;
endfor
endif
endif
endfor
player:tell(msgcount, " messages installed on ", this.name, "(", this, ")");
if (lostcount)
player:tell(lostcount, " messages have missing bodies (indicated by ", toliteral(lost_body), ").");
else
player:tell("No message bodies were missing.");
endif
.
#14:43
{i, body} = args;
if (!this:ok_write(caller, caller_perms()))
"... maybe someday let people edit messages they've sent?";
"... && !(this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args))) ???";
return E_PERM;
endif
{bodyprop, @rest} = this._mgr:find_nth(this.messages, i);
if (!body)
if (bodyprop)
this:_kill(bodyprop);
this._mgr:set_nth(this.messages, i, {0, @rest});
endif
elseif (bodyprop)
if (typeof(body) != LIST)
raise(E_TYPE);
endif
this.(bodyprop) = body;
else
bodyprop = this:_make(@body);
this._mgr:set_nth(this.messages, i, {bodyprop, @rest});
endif
.
#15:0
what = args[1];
return is_player(what) && (!(what in connected_players()));
.
#15:1
(caller == #0) || raise(E_PERM);
{who} = args;
"this:eject(who)";
if (!$recycler:valid(home = who.home))
clear_property(who, "home");
home = who.home;
if (!$recycler:valid(home))
home = who.home = $player_start;
endif
endif
"Modified 08-22-98 by TheCat to foil people who manually set their home to places they shouldn't.";
if ((!home:acceptable(who)) || (!home:accept_for_abode(who)))
home = $player_start;
endif
try
move(who, home);
except (ANY)
move(who, $player_start);
endtry
who.location:announce_all_but({who}, who.name, " has connected.");
.
#15:2
return $player_start:who_location_msg(@args);
.
#15:3
"Don't go anywhere.";
.
#15:4
if ($perm_utils:controls(caller_perms(), this))
if ((what = args[1]).wizard && (what.location == this))
move(what, what.home);
else
return pass(@args);
endif
endif
.
#16:0
return ((caller == this) || caller_perms().wizard) ? pass(@args) | E_PERM;
.
#16:1
":add(player,email[,comment])";
if (!caller_perms().wizard)
return E_PERM;
endif
{who, email, @comment} = args;
l = this:find_exact(email);
if (l == $failed_match)
this:insert(email, {{who, @comment}});
elseif (i = $list_utils:iassoc(who, l))
this:insert(email, listset(l, {who, @comment}, i));
else
this:insert(email, {@l, {who, @comment}});
endif
.
#16:2
if (caller_perms().wizard)
pass(@args);
this:clearall();
this.registrar = #2;
this:prune_reset();
endif
.
#16:3
"suspicious(address [,who])";
"Determine whether an address appears to be another player in disguise.";
"returns a list of similar addresses.";
"If second argument given, then if all similar addresses are held by that";
"person, let it pass---they're just switching departments at the same school";
"or something.";
"";
"at the moment,";
"  foo@bar.baz.bing.boo";
"is considered 'similar' to anything matching";
"  foo@*.bing.boo";
if (!caller_perms().wizard)
return E_PERM;
endif
{address, ?allowed = #-1} = args;
{userid, site} = $network:parse_address(address);
exact = (!site) && this:find_exact(address);
if (!site)
site = $network.site;
endif
site = $network:local_domain(site);
sitelen = length(site);
others = this:find_all_keys(userid + "@");
for other in (others)
if (other[max(1, ($ - sitelen) + 1)..$] != site)
others = setremove(others, other);
endif
endfor
if (exact)
others = listinsert(others, address);
endif
for x in (others)
allzapped = 1;
for y in (this:find_exact(x))
if ((((length(y) == 2) && ((y[2] == "zapped due to inactivity") || (y[2] == "toaded due to inactivity"))) || (y[1] == allowed)) || (($object_utils:has_property($local, "second_char_registry") && (typeof(them = $local.second_char_registry:other_chars(y[1])) == LIST)) && (allowed in them)))
"let them change to the address if it is them, or if it is a registered char of theirs.";
"Hrm. Need typeof==LIST check because returns E_INVARG for shared characters. bleah Ho_Yan 5/8/95";
else
allzapped = 0;
endif
endfor
if (allzapped)
others = setremove(others, x);
endif
endfor
return others;
.
#16:4
"suspicious_userid(userid)";
"Return yes if userid is root or postmaster or something like that.";
if ($object_utils:has_property(#0, "local") && $object_utils:has_property($local, "suspicious_userids"))
extra = $local.suspicious_userids;
else
extra = {};
endif
return ((((args[1] in {@$network.suspicious_userids, @extra}) || match(args[1], "^guest")) || match(args[1], "^help")) || index(args[1], "-owner")) || index(args[1], "owner-");
"Thinking about ruling out hyphenated names, on the grounds that they're probably mailing lists.";
.
#16:5
"Returns a list of strings describing the registration data for an email address.  Args[1] should be the result of this:find.";
set_task_perms(caller_perms());
result = {};
for x in (args[1])
name = (valid(x[1]) && is_player(x[1])) ? x[1].name | "<recycled>";
email = (valid(x[1]) && is_player(x[1])) ? $wiz_utils:get_email_address(x[1]) | "<???>";
result = {@result, tostr("  ", name, " (", x[1], ") current email: ", email, (length(x) > 1) ? (" [" + x[2]) + "]" | "")};
endfor
return result;
.
#16:6
"Carefully loop through the db and delete items associated with reaped objects.  If that results in no objects remaining for a username, delete that username.";
"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.";
if (!caller_perms().wizard)
raise(E_PERM);
endif
this.prune_task = task_id();
probe = this.prune_progress;
while (probe < this.prune_stop)
for username in (this:find_all_keys(probe))
items = this:find_exact(username);
orig = items;
for y in (items)
{who, @whys} = y;
if ((!valid(who)) || (!is_player(who)))
nuke = 1;
for why in (whys)
if (((why && (why != "zapped due to inactivity")) && (why != "toaded due to inactivity")) && (why != "Additional email address"))
nuke = 0;
endif
endfor
if (nuke)
items = setremove(items, y);
endif
endif
$command_utils:suspend_if_needed(0);
endfor
if (!items)
this:delete(username);
this.total_pruned_people = this.total_pruned_people + 1;
elseif (items != orig)
this:insert(username, items);
this.total_pruned_characters = (this.total_pruned_characters + length(orig)) - length(items);
endif
$command_utils:suspend_if_needed(0);
endfor
probe = $string_utils:incr_alpha(probe, this.alphabet);
this.prune_progress = probe;
if ($command_utils:running_out_of_time())
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endwhile
player:tell("Prune stopped at ", toliteral(this.prune_progress));
.
#16:7
player:tell("Prune is up to ", toliteral(this.prune_progress), ".");
mine = 0;
alphalen = length(this.alphabet);
if (typeof(this.prune_progress) == STR)
total = (alphalen * alphalen) * alphalen;
for x in [1..3]
mine = ((mine * alphalen) + index(this.alphabet, this.prune_progress[x])) - 1;
endfor
else
total = 256 * 256;
mine = (this.prune_progress[1] * 256) + this.prune_progress[2];
endif
percent = (100.0 * tofloat(mine)) / tofloat(total);
player:tell("We have processed ", mine, " entries out of ", total, ", or ", toint(percent), ".", toint(10.0 * percent) % 10, "%.");
player:tell("There were ", this.total_pruned_characters, " individual list entries removed, and ", this.total_pruned_people, " whole email addresses removed.");
if ($code_utils:task_valid(this.prune_task))
player:tell("Prune task is ", this.prune_task, ".  Stacktrace:");
for x in (task_stack(this.prune_task, 1))
if (valid(x[4]))
player:tell(x[4], ":", x[2], " [", x[1], "]  ", x[3].name, "  (", x[6], ")");
endif
endfor
else
player:tell("The recorded task_id is no longer valid.");
endif
.
#16:8
this:report_prune_progress();
player:tell("Resetting...");
this.prune_progress = "aaa";
this.prune_stop = "zzz";
this.total_pruned_people = 0;
this.total_pruned_characters = 0;
this.prune_task = 0;
.
#16:9
who = caller_perms();
if (((who != #-1) && (!((who == player) || (caller == this)))) || (!(who.wizard || (who in $local.registrar_pet_core.members))))
raise(E_PERM);
endif
total = 0;
player:tell("Searching...");
for k in ($registration_db:find_all_keys(""))
$command_utils:suspend_if_needed(0);
line = (k + " ") + toliteral($registration_db:find_exact(k));
if (index(line, iobjstr))
player:tell(line);
total = total + 1;
endif
endfor
player:tell("Search over.  ", total, " matches found.");
.
#17:0
":display_seq_headers(msg_seq[,cur])";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
player:tell("       WHEN    BY        WHO                 EMAIL-ADDRESS");
pass(@args);
.
#17:1
when = ctime(args[1])[5..10];
from = args[2];
by = $string_utils:left(from[1..index(from, " (") - 1], -9);
subject = args[4];
who = subject[1..(open = index(subject, " (")) - 1];
if ((close = rindex(subject, ")")) > open)
who = who[1..min(9, $)] + subject[open..close];
endif
who = $string_utils:left(who, 18);
line = args[("" in args) + 1];
email = line[1..index(line + " ", " ") - 1];
if (!index(email, "@"))
email = "??";
endif
return tostr(when, "  ", by, " ", who, "  ", email);
.
#17:2
if (caller_perms().wizard)
pass(@args);
this.mail_notify = {player};
player:set_current_message(this, 0, 0, 1);
this.moderated = {this};
else
return E_PERM;
endif
.
#17:3
"Copied from Generic Mail Recipient (#6419):is_usable_by by Rog (#4292) Tue Mar  2 10:02:32 1993 PST";
return (!this.moderated) || ((this:is_writable_by(who = args[1]) || (who in this.moderated)) || who.wizard);
.
#17:4
"Stop breaking the expire task completely with out of seconds/ticks.";
if (this:ok_write(caller, caller_perms()))
fork (0)
pass(@args);
endfork
else
return E_PERM;
endif
.
#18:0
if ($code_utils:parse_verbref(what = args[1]))
"... hey wow, I found it!...";
return {what};
else
return {};
endif
.
#18:1
"Help facility for verbs that people have bothered to document.  If the argument is a verb specification, this retrieves the code and prints any documentation lines that might be at the beginning.  Returns true if the arg can actually be interpreted as a verb specification, whether or not it is a correct one.";
set_task_perms(caller_perms());
if (!(spec = $code_utils:parse_verbref(args[1])))
return 0;
elseif ($command_utils:object_match_failed(object = $string_utils:match_object(spec[1], player.location), spec[1]))
return 1;
elseif (!(hv = $object_utils:has_verb(object, spec[2])))
return "That object does not define that verb.";
elseif (typeof(verbdoc = $code_utils:verb_documentation(object = hv[1], spec[2])) == ERR)
return tostr(verbdoc);
elseif (typeof(info = `verb_info(object, spec[2]) ! ANY') == ERR)
return tostr(info);
else
objverb = tostr(object.name, "(", object, "):", strsub(info[3], " ", "/"));
if (verbdoc)
return {tostr("Information about ", objverb), "----", @verbdoc};
else
return tostr("No information about ", objverb);
endif
endif
.
#18:2
set_task_perms(caller_perms());
if (!(spec = $code_utils:parse_verbref(args[1])))
return E_INVARG;
elseif ($command_utils:object_match_failed(object = $string_utils:match_object(spec[1], player.location), spec[1]))
return E_INVARG;
elseif (!(hv = $object_utils:has_verb(object, spec[2])))
return E_VERBNF;
elseif (typeof(vd = $code_utils:verb_documentation(hv[1], spec[2])) != LIST)
return vd;
else
return {tostr(";$code_utils:set_verb_documentation(", $code_utils:corify_object(hv[1]), ",", $string_utils:print(spec[2]), ",$command_utils:read_lines())"), @$command_utils:dump_lines(vd)};
endif
.
#19:0
if (!args)
l = {};
for p in (properties(#0))
if ((p[max(1, $ - 5)..$] == "_utils") && `#0.(p):help_msg() ! ANY')
l = {@l, "$" + p};
endif
endfor
return {@pass(@args), @l};
elseif (ts = pass(@args))
return ts;
elseif ((what = args[1])[1] != "$")
return {};
elseif (ts = pass("$generic_" + what[2..$]))
return ts;
elseif ((r = rindex(w = strsub(what[2..$], "-", "_"), "_utils")) && ((r == (length(w) - 5)) && (`valid(#0.(w)) ! ANY' && `#0.(w):help_msg() ! ANY')))
return {what};
else
return {};
endif
.
#19:1
topic = args[1];
if ((topic == (("$" + topic[2..$ - 5]) + "utils")) && (valid(#0.(w = strsub(topic[2..$], "-", "_"))) && (uhelp = #0.(w):description())))
return {tostr("General information on $", w, ":"), "----", @(typeof(uhelp) == STR) ? {uhelp} | uhelp};
else
return pass(@args);
endif
.
#19:2
if ((E_PROPNF != (text = pass(@args))) || ((args[1][1] != "$") || ((!((uprop = args[1][2..$]) in properties(#0))) || (typeof(uobj = #0.(uprop)) != OBJ))))
return text;
else
udesc = uobj.description;
return {tostr(";;$", uprop, ".description = $command_utils:read_lines()"), @$command_utils:dump_lines((typeof(udesc) == LIST) ? udesc | {udesc})};
endif
.
#20:0
"space(len,fill) returns a string of length abs(len) consisting of copies of fill.  If len is negative, fill is anchored on the right instead of the left.";
{n, ?fill = " "} = args;
if (typeof(n) == STR)
n = length(n);
endif
if (n > 1000)
"Prevent someone from crashing the moo with $string_utils:space($maxint)";
return E_INVARG;
endif
if (" " != fill)
fill = fill + fill;
fill = fill + fill;
fill = fill + fill;
elseif ((n = abs(n)) < 70)
return "                                                                      "[1..n];
else
fill = "                                                                      ";
endif
m = (n - 1) / length(fill);
while (m)
fill = fill + fill;
m = m / 2;
endwhile
return (n > 0) ? fill[1..n] | fill[($ + 1) + n..$];
.
#20:1
"$string_utils:left(string,width[,filler])";
"";
"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> followed by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.";
"";
"The <filler> is optional and defaults to \" \"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.";
{text, len, ?fill = " "} = args;
abslen = abs(len);
out = tostr(text);
if (length(out) < abslen)
return out + this:space(length(out) - abslen, fill);
else
return (len > 0) ? out | out[1..abslen];
endif
.
#20:2
"$string_utils:right(string,width[,filler])";
"";
"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then <string> is cut off at <width> from the right.";
"";
"The <filler> is optional and defaults to \" \"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.";
{text, len, ?fill = " "} = args;
abslen = abs(len);
out = tostr(text);
if ((lenout = length(out)) < abslen)
return this:space(abslen - lenout, fill) + out;
else
return (len > 0) ? out | out[($ - abslen) + 1..$];
endif
.
#20:3
"$string_utils:center(string,width[,lfiller[,rfiller]])";
"";
"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded and followed by enough filler to make it that wide.  If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.";
"";
"The <lfiller> is optional and defaults to \" \"; it controls what is used to fill the left part of the resulting string when it is too short.  The <rfiller> is optional and defaults to the value of <lfiller>; it controls what is used to fill the right part of the resulting string when it is too short.  In both cases, the filler is replicated as many times as is necessary to fill the space in question.";
{text, len, ?lfill = " ", ?rfill = lfill} = args;
out = tostr(text);
abslen = abs(len);
if (length(out) < abslen)
return (this:space((abslen - length(out)) / 2, lfill) + out) + this:space(((abslen - length(out)) + 1) / -2, rfill);
else
return (len > 0) ? out | out[1..abslen];
endif
.
#20:4
"columnize (items, n [, width]) - Turn a one-column list of items into an n-column list. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize ({1, 2, 3, 4, 5, 6, 7}, 3));'.";
{items, n, ?width = 79} = args;
height = ((length(items) + n) - 1) / n;
items = {@items, @$list_utils:make((height * n) - length(items), "")};
colwidths = {};
for col in [1..n - 1]
colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));
endfor
result = {};
for row in [1..height]
line = tostr(items[row]);
for col in [1..n - 1]
line = tostr(this:left(line, colwidths[col]), " ", items[row + (col * height)]);
endfor
result = listappend(result, line[1..min($, width)]);
endfor
return result;
.
#20:5
"$string_utils:from_list(list [, separator])";
"Return a string being the concatenation of the string representations of the elements of LIST, each pair separated by the string SEPARATOR, which defaults to the empty string.";
{thelist, ?separator = ""} = args;
if (separator == "")
return tostr(@thelist);
elseif (thelist)
result = tostr(thelist[1]);
for elt in (listdelete(thelist, 1))
result = tostr(result, separator, elt);
endfor
return result;
else
return "";
endif
.
#20:6
"Prints the argument (must be a list) as an english list, e.g. {1, 2, 3} is printed as \"1, 2, and 3\", and {1, 2} is printed as \"1 and 2\".";
"Optional arguments are treated as follows:";
"  Second argument is the string to use when the empty list is given.  The default is \"nothing\".";
"  Third argument is the string to use in place of \" and \".  A typical application might be to use \" or \" instead.";
"  Fourth argument is the string to use instead of a comma (and space).  Gary_Severn's deranged mind actually came up with an application for this.  You can ask him.";
"  Fifth argument is a string to use after the penultimate element before the \" and \".  The default is to have a comma without a space.";
{things, ?nothingstr = "nothing", ?andstr = " and ", ?commastr = ", ", ?finalcommastr = ","} = args;
nthings = length(things);
if (nthings == 0)
return nothingstr;
elseif (nthings == 1)
return tostr(things[1]);
elseif (nthings == 2)
return tostr(things[1], andstr, things[2]);
else
ret = "";
for k in [1..nthings - 1]
if (k == (nthings - 1))
commastr = finalcommastr;
endif
ret = tostr(ret, things[k], commastr);
endfor
return tostr(ret, andstr, things[nthings]);
endif
.
#20:7
"Return a string of the names and object numbers of the objects in a list.";
line = "";
for item in (args[1])
if ((typeof(item) == OBJ) && valid(item))
line = (((line + item.name) + "(") + tostr(item)) + ")   ";
endif
endfor
return $string_utils:trimr(line);
.
#20:8
":from_seconds(number of seconds) => returns a string containing the rough increment of days, or hours if less than a day, or minutes if less than an hour, or lastly in seconds.";
":from_seconds(86400) => \"a day\"";
":from_seconds(7200)  => \"two hours\"";
minute = 60;
hour = 60 * minute;
day = 24 * hour;
secs = args[1];
if (secs > day)
count = secs / day;
unit = "day";
article = "a";
elseif (secs > hour)
count = secs / hour;
unit = "hour";
article = "an";
elseif (secs > minute)
count = secs / minute;
unit = "minute";
article = "a";
else
count = secs;
unit = "second";
article = "a";
endif
if (count == 1)
time = tostr(article, " ", unit);
else
time = tostr(count, " ", unit, "s");
endif
return time;
.
#20:9
":trim (string [, space]) -- remove leading and trailing spaces";
"";
"`space' should be a character (single-character string); it defaults to \" \".  Returns a copy of string with all leading and trailing copies of that character removed.  For example, $string_utils:trim(\"***foo***\", \"*\") => \"foo\".";
{string, ?space = " "} = args;
m = match(string, tostr("[^", space, "]%(.*[^", space, "]%)?%|$"));
return string[m[1]..m[2]];
.
#20:10
":triml(string [, space]) -- remove leading spaces";
"";
"`space' should be a character (single-character string); it defaults to \" \".  Returns a copy of string with all leading copies of that character removed.  For example, $string_utils:triml(\"***foo***\", \"*\") => \"foo***\".";
{string, ?what = " "} = args;
m = match(string, tostr("[^", what, "]%|$"));
return string[m[1]..$];
.
#20:11
":trimr(string [, space]) -- remove trailing spaces";
"";
"`space' should be a character (single-character string); it defaults to \" \".  Returns a copy of string with all trailing copies of that character removed.  For example, $string_utils:trimr(\"***foo***\", \"*\") => \"***foo\".";
{string, ?what = " "} = args;
return string[1..rmatch(string, tostr("[^", what, "]%|^"))[2]];
.
#20:12
":strip_chars(string,chars) => string with chars removed";
{subject, stripped} = args;
for i in [1..length(stripped)]
subject = strsub(subject, stripped[i], "");
endfor
return subject;
.
#20:13
":strip_all_but(string,keep) => string with chars not in `keep' removed.";
"`keep' is used in match() so if it includes ], ^, or -,";
"] should be first, ^ should be other from first, and - should be last.";
string = args[1];
wanted = ("[" + args[2]) + "]+";
output = "";
while (m = match(string, wanted))
output = output + string[m[1]..m[2]];
string = string[m[2] + 1..$];
endwhile
return output;
.
#20:14
"lowercase(string) -- returns a lowercase version of the string.";
"uppercase(string) -- returns the uppercase version of the string.";
string = args[1];
from = caps = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
to = lower = "abcdefghijklmnopqrstuvwxyz";
if (verb == "uppercase")
from = lower;
to = caps;
endif
for i in [1..26]
string = strsub(string, from[i], to[i], 1);
endfor
return string;
.
#20:15
"capitalizes its argument.";
if ((string = args[1]) && (i = index("abcdefghijklmnopqrstuvwxyz", string[1], 1)))
string[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i];
endif
return string;
.
#20:16
"Matches args[1] against literal objects: #xxxxx, $variables, *mailing-lists, and username.  Returns the object if successful, $failed_match else.";
string = args[1];
if (!string)
return $nothing;
elseif ((string[1] == "#") && (E_TYPE != (object = $code_utils:toobj(string))))
return object;
elseif (string[1] == "~")
return this:match_player(string[2..$], #0);
elseif ((string[1] == "*") && (length(string) > 1))
return $mail_agent:match_recipient(string);
elseif (string[1] == "$")
string[1..1] = "";
object = #0;
while (pn = string[1..(dot = index(string, ".")) ? dot - 1 | $])
if ((!$object_utils:has_property(object, pn)) || (typeof(object = object.(pn)) != OBJ))
"Try to match a map now.";
object = $code_utils:parse_sysobj_map(args[1]);
if (object == E_PROPNF)
return $failed_match;
else
break;
endif
endif
string = string[length(pn) + 2..$];
endwhile
if ((object == #0) || (typeof(object) == ERR))
return $failed_match;
else
return object;
endif
else
return $failed_match;
endif
.
#20:17
"$string_utils:match(string [, obj-list, prop-name]*)";
"Each obj-list should be a list of objects or a single object, which is treated as if it were a list of that object.  Each prop-name should be string naming a property on every object in the corresponding obj-list.  The value of that property in each case should be either a string or a list of strings.";
"The argument string is matched against all of the strings in the property values.";
"If it exactly matches exactly one of them, the object containing that property is returned.  If it exactly matches more than one of them, $ambiguous_match is returned.";
"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of some property string.  Again, if exactly one match is found, the object with that property is returned, and if there is more than one match, $ambiguous_match is returned.";
"Finally, if there are no exact or partial matches, then $failed_match is returned.";
subject = args[1];
if (subject == "")
return $nothing;
endif
no_exact_match = no_partial_match = 1;
for i in [1..length(args) / 2]
prop_name = args[(2 * i) + 1];
for object in ((typeof(olist = args[2 * i]) == LIST) ? olist | {olist})
if (valid(object))
if (typeof(str_list = `object.(prop_name) ! E_PERM, E_PROPNF => {}') != LIST)
str_list = {str_list};
endif
if (subject in str_list)
if (no_exact_match)
no_exact_match = object;
elseif (no_exact_match != object)
return $ambiguous_match;
endif
else
for string in (str_list)
if (index(string, subject) != 1)
elseif (no_partial_match)
no_partial_match = object;
elseif (no_partial_match != object)
no_partial_match = $ambiguous_match;
endif
endfor
endif
endif
endfor
endfor
return no_exact_match && (no_partial_match && $failed_match);
.
#20:18
"* wildcard matching. Returns a list of what the *s actually matched. Won't cath every match, if there are several ways to parse it.";
"Example: $string_utils:match_string(\"Jack waves to Jill\",\"* waves to *\") returns {\"Jack\", \"Jill\"}";
"Optional arguments: numbers are interpreted as case-sensitivity, strings as alternative wildcards.";
{what, targ, @rest} = args;
wild = "*";
case = ret = {};
what = what + "&^%$";
targ = targ + "&^%$";
for y in (rest)
if (typeof(y) == STR)
wild = y;
elseif (typeof(y) == INT)
case = {y};
endif
endfor
while (targ != "")
if (z = index(targ, wild))
part = targ[1..z - 1];
else
z = length(targ);
part = targ;
endif
n = (part == "") ? 1 | index(what, part, @case);
if (n)
ret = listappend(ret, what[1..n - 1]);
what = what[(z + n) - 1..$];
targ = targ[z + 1..$];
else
return 0;
endif
endwhile
if (ret == {})
return what == "";
elseif (ret == {""})
return 1;
elseif (ret[1] == "")
return ret[2..$];
else
return 0;
endif
.
#20:19
":match_object(string,location[,someone])";
"Returns the object matching the given string for someone, on the assumption that s/he is in the given location.  `someone' defaults to player.";
"This first tries :literal_object(string), \"me\"=>someone,\"here\"=>location, then player:match(string) and finally location:match(string) if location is valid.";
"This is the default algorithm for use by room :match_object() and player :my_match_object() verbs.  Player verbs that are calling this directly should probably be calling :my_match_object instead.";
{string, here, ?who = player} = args;
if ($failed_match != (object = this:literal_object(string)))
return object;
elseif (string == "me")
return who;
elseif (string == "here")
return here;
elseif ((valid(pobject = who:match(string)) && (string in {@pobject.aliases, pobject.name})) || (!valid(here)))
"...exact match in player or room is bogus...";
return pobject;
elseif ((valid(hobject = here:match(string)) && (string in {@hobject.aliases, hobject.name})) || (pobject == $failed_match))
"...exact match in room or match in player failed completely...";
return hobject;
else
return pobject;
endif
.
#20:20
"match_player(name,name,...)      => {obj,obj,...}";
"match_player(name[,meobj])       => obj";
"match_player({name,...}[,meobj]) => {obj,...}";
"objs returned are either players, $failed_match, $ambiguous_match, or $nothing in the case of an empty string.";
"meobj (what to return for instances of `me') defaults to player; if given and isn't actually a player, `me' => $failed_match";
retstr = 0;
me = player;
if ((length(args) < 2) || (typeof(me = args[2]) == OBJ))
me = (valid(me) && is_player(me)) ? me | $failed_match;
if (typeof(args[1]) == STR)
strings = {args[1]};
retstr = 1;
"return a string, not a list";
else
strings = args[1];
endif
else
strings = args;
me = player;
endif
found = {};
for astr in (strings)
if (!astr)
aobj = $nothing;
elseif (astr == "me")
aobj = me;
elseif (valid(aobj = $string_utils:literal_object(astr)) && is_player(aobj))
"astr is a valid literal object number of some player, so we are done.";
else
aobj = $player_db:find(astr);
endif
found = {@found, aobj};
endfor
return retstr ? found[1] | found;
.
#20:21
"Accepts any number of strings, attempts to match those strings first against objects in the room, and if no objects by those names exist, matches against player names (and \"#xxxx\" style strings regardless of location).  Returns a list of valid objects so found.";
"Unlike $string_utils:match_player, does not include in the list the failed and ambiguous matches; instead has built-in error messages for such objects.  This should probably be improved.  Volunteers?";
if (!args)
return;
endif
unknowns = {};
objs = {};
"We have to do something icky here.  Parallel walk the victims and args lists.  When it's a valid object, then it's a player.  If it's an invalid object, try to get an object match from the room.  If *that* fails, complain.";
for i in [1..length(args)]
if (valid(o = player.location:match_object(args[i])))
objs = {@objs, o};
else
unknowns = {@unknowns, args[i]};
endif
endfor
victims = $string_utils:match_player(unknowns);
for i in [1..length(victims)]
if (!valid(victims[i]))
player:tell("Could not find ", unknowns[i], " as either an object or a player.");
else
objs = {@objs, victims[i]};
endif
endfor
return objs;
.
#20:22
"find_prefix(prefix, string-list) => list index of something starting with prefix, or 0 or $ambiguous_match.";
{subject, choices} = args;
answer = 0;
for i in [1..length(choices)]
if (index(choices[i], subject) == 1)
if (answer == 0)
answer = i;
else
answer = $ambiguous_match;
endif
endif
endfor
return answer;
.
#20:23
"index_delimited(string,target[,case_matters]) is just like the corresponding call to the builtin index() but instead only matches on occurences of target delimited by word boundaries (i.e., not preceded or followed by an alphanumeric)";
args[2] = ("%(%W%|^%)" + $string_utils:regexp_quote(args[2])) + "%(%W%|$%)";
return (m = match(@args)) ? m[3][1][2] + 1 | 0;
.
#20:24
"Usage:  is_numeric(string)";
"        is_integer(string)";
"Is string numeric (composed of one or more digits possibly preceded by a minus sign)? This won't catch floating points.";
"Return true or false";
return match(args[1], "^ *[-+]?[0-9]+ *$");
digits = "1234567890";
if (!(string = args[1]))
return 0;
endif
if (string[1] == "-")
string = string[2..length(string)];
endif
for i in [1..length(string)]
if (!index(digits, string[i]))
return 0;
endif
endfor
return 1;
.
#20:25
":short_ordinal(1) => \"1st\",:short_ordinal(2) => \"2nd\",etc...";
string = tostr(n = args[1]);
n = abs(n) % 100;
if (((n / 10) != 1) && ((n % 10) in {1, 2, 3}))
return string + {"st", "nd", "rd"}[n % 10];
else
return string + "th";
endif
.
#20:26
"$string_utils:group_number(INT n [, sep_char])";
"$string_utils:group_number(FLOAT n, [INT precision [, scientific [, sep_char]]])";
"";
"Converts N to a string, inserting commas (or copies of SEP_CHAR, if given) every three digits, counting from the right.  For example, $string_utils:group_number(1234567890) returns the string \"1,234,567,890\".";
"For floats, the arguements precision (defaulting to 4 in this verb) and scientific are the same as given in floatstr().";
if (typeof(args[1]) == INT)
{n, ?comma = ","} = args;
result = "";
sign = (n < 0) ? "-" | "";
n = tostr(abs(n));
elseif (typeof(args[1]) == FLOAT)
{n, ?prec = 4, ?scien = 0, ?comma = ","} = args;
sign = (n < 0.0) ? "-" | "";
n = floatstr(abs(n), prec, scien);
i = index(n, ".");
result = n[i..$];
n = n[1..i - 1];
else
return E_INVARG;
endif
while ((len = length(n)) > 3)
result = (comma + n[len - 2..len]) + result;
n = n[1..len - 3];
endwhile
return (sign + n) + result;
"Code contributed by SunRay";
.
#20:27
"$string_utils:english_number(n) -- convert the integer N into English";
"";
"Produces a string containing the English phrase naming the given integer.  For example, $string_utils:english_number(-1234) returns the string `negative one thousand two hundred thirty-four'.";
numb = toint(args[1]);
if (numb == 0)
return "zero";
endif
labels = {"", " thousand", " million", " billion"};
numstr = "";
mod = abs(numb);
for n in [1..4]
div = mod % 1000;
if (div)
hun = div / 100;
ten = div % 100;
outstr = this:english_tens(ten) + labels[n];
if (hun)
outstr = ((this:english_ones(hun) + " hundred") + (ten ? " " | "")) + outstr;
endif
if (numstr)
numstr = (outstr + " ") + numstr;
else
numstr = outstr;
endif
endif
mod = mod / 1000;
endfor
return ((numb < 0) ? "negative " | "") + numstr;
.
#20:28
"$string_utils:english_ordinal(n) -- convert the integer N into an english ordinal (1 => \"first\", etc...)";
numb = toint(args[1]);
if (numb == 0)
return "zeroth";
elseif (numb % 100)
hundreds = (abs(numb) > 100) ? this:english_number((numb / 100) * 100) + " " | ((numb < 0) ? "negative " | "");
numb = abs(numb) % 100;
specials = {1, 2, 3, 5, 8, 9, 12, 20, 30, 40, 50, 60, 70, 80, 90};
ordinals = {"first", "second", "third", "fifth", "eighth", "ninth", "twelfth", "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth", "seventieth", "eightieth", "ninetieth"};
if (i = numb in specials)
return hundreds + ordinals[i];
elseif ((numb > 20) && (i = (numb % 10) in specials))
return ((hundreds + this:english_tens((numb / 10) * 10)) + "-") + ordinals[i];
else
return (hundreds + this:english_number(numb)) + "th";
endif
else
return this:english_number(numb) + "th";
endif
.
#20:29
numb = args[1];
ones = {"", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
return ones[numb + 1];
.
#20:30
numb = args[1];
teens = {"ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"};
others = {"twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
if (numb < 10)
return this:english_ones(numb);
elseif (numb < 20)
return teens[numb - 9];
else
return (others[(numb / 10) - 1] + ((numb % 10) ? "-" | "")) + this:english_ones(numb % 10);
endif
.
#20:31
"subst(string,{{redex1,repl1},{redex2,repl2},{redex3,repl3}...}[,case])";
"  => returns string with all instances of the strings redex<n> replaced respectively by the strings repl<n>.  If the optional argument `case' is given and nonzero, the search for instances of redex<n> is case sensitive.";
"  Substitutions are done in parallel, i.e., instances of redex<n> that appear in any of the replacement strings are ignored.  In the event that two redexes overlap, whichever is leftmost in `string' takes precedence.  For two redexes beginning at the same position, the longer one takes precedence.";
"";
"subst(\"hoahooaho\",{{\"ho\",\"XhooX\"},{\"hoo\",\"mama\"}}) => \"XhooXamamaaXhooX\"";
"subst(\"Cc: banana\",{{\"a\",\"b\"},{\"b\",\"c\"},{\"c\",\"a\"}},1) => \"Ca: cbnbnb\"";
{ostr, subs, ?case = 0} = args;
if (typeof(ostr) != STR)
return ostr;
endif
len = length(ostr);
" - - - find the first instance of each substitution - -";
indices = {};
substs = {};
for s in (subs)
if (i = index(ostr, s[1], case))
fi = $list_utils:find_insert(indices, i = i - len) - 1;
while (fi && ((indices[fi] == i) && (length(substs[fi][1]) < length(s[1]))))
"...give preference to longer redexes...";
fi = fi - 1;
endwhile
indices = listappend(indices, i, fi);
substs = listappend(substs, s, fi);
endif
endfor
"- - - - - perform substitutions - ";
nstr = "";
while (substs)
ind = len + indices[1];
sub = substs[1];
indices = listdelete(indices, 1);
substs = listdelete(substs, 1);
if (ind > 0)
nstr = (nstr + ostr[1..ind - 1]) + sub[2];
ostr = ostr[ind + length(sub[1])..len];
len = length(ostr);
endif
if (next = index(ostr, sub[1], case))
fi = $list_utils:find_insert(indices, next = next - len) - 1;
while (fi && ((indices[fi] == next) && (length(substs[fi][1]) < length(sub[1]))))
"...give preference to longer redexes...";
fi = fi - 1;
endwhile
indices = listappend(indices, next, fi);
substs = listappend(substs, sub, fi);
endif
endwhile
return nstr + ostr;
.
#20:32
"subst(string,{{redex1,repl1},{redex2,repl2},{redex3,repl3}...}[,case])";
"Just like :substitute() but it uses index_delimited() instead of index()";
{ostr, subs, ?case = 0} = args;
if (typeof(ostr) != STR)
return ostr;
endif
len = length(ostr);
" - - - find the first instance of each substitution - -";
indices = {};
substs = {};
for s in (subs)
if (i = this:index_delimited(ostr, s[1], case))
fi = $list_utils:find_insert(indices, i = i - len) - 1;
while (fi && ((indices[fi] == i) && (length(substs[fi][1]) < length(s[1]))))
"...give preference to longer redexes...";
fi = fi - 1;
endwhile
indices = listappend(indices, i, fi);
substs = listappend(substs, s, fi);
endif
endfor
"- - - - - perform substitutions - ";
nstr = "";
while (substs)
ind = len + indices[1];
sub = substs[1];
indices = listdelete(indices, 1);
substs = listdelete(substs, 1);
if (ind > 0)
nstr = (nstr + ostr[1..ind - 1]) + sub[2];
ostr = ostr[ind + length(sub[1])..len];
len = length(ostr);
endif
if (next = this:index_delimited(ostr, sub[1], case))
fi = $list_utils:find_insert(indices, next = next - len) - 1;
while (fi && ((indices[fi] == next) && (length(substs[fi][1]) < length(sub[1]))))
"...give preference to longer redexes...";
fi = fi - 1;
endwhile
indices = listappend(indices, next, fi);
substs = listappend(substs, sub, fi);
endif
endwhile
return nstr + ostr;
.
#20:33
"cap_property(what,prop[,ucase]) returns what.(prop) but capitalized if either ucase is true or the prop name specified is capitalized.";
"If prop is blank, returns what:title().";
"If prop is bogus or otherwise irretrievable, returns the error.";
"If capitalization is indicated, we return what.(prop+\"c\") if that exists, else we capitalize what.(prop) in the usual fashion.  There is a special exception for is_player(what)&&prop==\"name\" where we just return what.name if no .namec is provided --- ie., a player's .name is never capitalized in the usual fashion.";
"If args[1] is a list, calls itself on each element of the list and returns $string_utils:english_list(those results).";
{what, prop, ?ucase = 0} = args;
set_task_perms(caller_perms());
if (typeof(what) == LIST)
result = {};
for who in (what)
result = {@result, this:_cap_property(who, prop, ucase)};
endfor
return $string_utils:english_list(result);
endif
ucase = (prop && (strcmp(prop, "a") < 0)) || ucase;
if (!prop)
return valid(what) ? ucase ? what:titlec() | what:title() | ((ucase ? "N" | "n") + "othing");
elseif ((!ucase) || (typeof(s = `what.(prop + "c") ! ANY') == ERR))
if (prop == "name")
s = valid(what) ? what.name | "nothing";
ucase = ucase && (!is_player(what));
else
s = `$object_utils:has_property(what, prop) ? what.(prop) | $player.(prop) ! ANY';
endif
if (ucase && (s && ((typeof(s) == STR) && (((z = index(this.alphabet, s[1], 1)) < 27) && (z > 0)))))
s[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[z];
endif
endif
return (typeof(s) == ERR) ? s | tostr(s);
.
#20:34
"Pronoun (and other things) substitution. See 'help pronouns' for details.";
"syntax:  $string_utils:pronoun_sub(text[,who[,thing[,location[,dobj[,iobj]]]]])";
"%s,%o,%p,%q,%r    => <who>'s pronouns.  <who> defaults to player.";
"%n,%d,%i,%t,%l,%% => <who>, dobj, iobj, <thing>, location and %";
"<thing> defaults to caller; <location> defaults to who.location";
"%S,%O,%P,%Q,%R, %N,%D,%I,%T,%L have corresponding capitalized substitutions.";
" %[#n], %[#d], ...  =>  <who>, dobj, etc.'s object number";
"%(foo) => <who>.foo and %(Foo) => <who>.foo capitalized. %[dfoo] => dobj.foo, etc..";
"%<foo> -> whatever <who> does when normal people foo. This is determined by calling :verb_sub() on the <who>.";
"%<d:foo> -> whatever <dobj> does when normal people foo.";
{string, ?who = player, ?thing = caller, ?where = $nothing, ?dobject = dobj, ?iobject = iobj} = args;
where = valid(where) ? where | (valid(who) ? who.location | where);
set_task_perms($no_one);
if (typeof(string) == LIST)
plines = {};
for line in (string)
plines = {@plines, this:(verb)(line, who, thing, where)};
endfor
return plines;
endif
old = tostr(string);
new = "";
objspec = "nditl";
objects = {who, dobject, iobject, thing, where};
prnspec = "sopqrSOPQR";
prprops = {"ps", "po", "pp", "pq", "pr", "Ps", "Po", "Pp", "Pq", "Pr"};
oldlen = length(old);
while ((prcnt = index(old, "%")) && (prcnt < oldlen))
s = old[k = prcnt + 1];
if ((s == "<") && (gt = index(old[k + 2..$], ">")))
"handling %<verb> ";
gt = (gt + k) + 1;
vb = old[k + 1..gt - 1];
vbs = who;
if ((length(vb) > 2) && (vb[2] == ":"))
" %<d:verb>";
vbs = objects[index(objspec, vb[1]) || 1];
vb = vb[3..$];
endif
vb = $object_utils:has_callable_verb(vbs, "verb_sub") ? vbs:verb_sub(vb) | $gender_utils:get_conj(vb, vbs);
new = (new + old[1..prcnt - 1]) + vb;
k = gt;
else
cp_args = {};
if (brace = index("([", s))
if (!(w = index(old[k + 1..oldlen], ")]"[brace])))
return new + old;
else
p = old[prcnt + 2..(k = k + w) - 1];
if (brace == 1)
"%(property)";
cp_args = {who, p};
elseif (p[1] == "#")
"%[#n] => object number";
s = (o = index(objspec, p[2])) ? tostr(objects[o]) | (("[" + p) + "]");
elseif (!(o = index(objspec, p[1])))
s = ("[" + p) + "]";
else
" %[dproperty] ";
cp_args = {objects[o], p[2..w - 1], strcmp(p[1], "a") < 0};
endif
endif
elseif (o = index(objspec, s))
cp_args = {objects[o], "", strcmp(s, "a") < 0};
elseif (w = index(prnspec, s, 1))
cp_args = {who, prprops[w]};
elseif (s == "#")
s = tostr(who);
elseif (s != "%")
s = "%" + s;
endif
new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | (("%(" + tostr(sub)) + ")")));
endif
old = old[k + 1..oldlen];
oldlen = oldlen - k;
endwhile
return new + old;
.
#20:35
"$string_utils:pronoun_sub_secure(string[,who[,thing[,location]]], default)";
"Do pronoun_sub on string with the arguments given (see help";
"string_utils:pronoun_sub for more information).  Return pronoun_subbed";
"<default> if the subbed string does not contain <who>.name (<who>";
"defaults to player).";
who = (length(args) > 2) ? args[2] | player;
default = args[$];
result = this:pronoun_sub(@args[1..$ - 1]);
return this:index_delimited(result, who.name) ? result | this:pronoun_sub(@{default, @args[2..$ - 1]});
.
#20:36
" pronoun_quote(string) => quoted_string";
" pronoun_quote(list of strings) => list of quoted_strings";
" pronoun_quote(list of {key,string} pairs) => list of {key,quoted_string} pairs";
"";
"Here `quoted' means quoted in the sense of $string_utils:pronoun_sub, i.e., given a string X, the corresponding `quoted' string Y is such that pronoun_sub(Y) => X.  For example, pronoun_quote(\"--%Spam%--\") => \"--%%Spam%%--\".  This is for including literal text into a string that will eventually be pronoun_sub'ed, i.e., including it in such a way that the pronoun_sub will not expand anything in the included text.";
"";
"The 3rd form above (with {key,string} pairs) is for use with $string_utils:substitute().  If you have your own set of substitutions to be done in parallel with the pronoun substitutions, do";
"";
"  msg=$string_utils:substitute(msg,$string_utils:pronoun_quote(your_substs));";
"  msg=$string_utils:pronoun_sub(msg);";
if (typeof(what = args[1]) == STR)
return strsub(what, "%", "%%");
else
ret = {};
for w in (what)
if (typeof(w) == LIST)
ret = listappend(ret, listset(w, strsub(w[2], "%", "%%"), 2));
else
ret = listappend(ret, strsub(w, "%", "%%"));
endif
endfor
return ret;
endif
.
#20:37
"Pronoun (and other things) substitution. See 'help pronouns' for details.";
"syntax:  $string_utils:pronoun_sub(text[,who[,thing[,location]]])";
"%s,%o,%p,%q,%r    => <who>'s pronouns.  <who> defaults to player.";
"%n,%d,%i,%t,%l,%% => <who>, dobj, iobj, this, <who>.location and %";
"%S,%O,%P,%Q,%R, %N,%D,%I,%T,%L have corresponding capitalized substitutions.";
" %[#n], %[#d], ...  =>  <who>, dobj, etc.'s object number";
"%(foo) => <who>.foo and %(Foo) => <who>.foo capitalized. %[dfoo] => dobj.foo, etc..";
"%<foo> -> whatever <who> does when normal people foo. This is determined by calling :verb_sub() on the <who>.";
"%<d:foo> -> whatever <dobj> does when normal people foo.";
set_task_perms($no_one);
{string, ?who = player, ?thing = caller, ?where = $nothing} = args;
where = valid(who) ? who.location | where;
if (typeof(string) == LIST)
plines = {};
for line in (string)
plines = {@plines, this:(verb)(line, who, thing, where)};
endfor
return plines;
endif
old = tostr(string);
new = "";
objspec = "nditl";
objects = {who, dobj, iobj, thing, where};
prnspec = "sopqrSOPQR";
prprops = {"ps", "po", "pp", "pq", "pr", "Ps", "Po", "Pp", "Pq", "Pr"};
oldlen = length(old);
while ((prcnt = index(old, "%")) && (prcnt < oldlen))
s = old[k = prcnt + 1];
if ((s == "<") && (gt = index(old[k + 2..$], ">")))
"handling %<verb> ";
gt = (gt + k) + 1;
vb = old[k + 1..gt - 1];
vbs = who;
if ((length(vb) > 2) && (vb[2] == ":"))
" %<d:verb>";
vbs = objects[index(objspec, vb[1]) || 1];
vb = vb[3..$];
endif
vb = $object_utils:has_verb(vbs, "verb_sub") ? vbs:verb_sub(vb) | this:(verb)(vb, vbs);
new = (new + old[1..prcnt - 1]) + vb;
k = gt;
else
cp_args = {};
if (brace = index("([", s))
if (!(w = index(old[k + 1..oldlen], ")]"[brace])))
return new + old;
else
p = old[prcnt + 2..(k = k + w) - 1];
if (brace == 1)
"%(property)";
cp_args = {who, p};
elseif (p[1] == "#")
"%[#n] => object number";
s = (o = index(objspec, p[2])) ? tostr(objects[o]) | (("[" + p) + "]");
elseif (!(o = index(objspec, p[1])))
s = ("[" + p) + "]";
else
" %[dproperty] ";
cp_args = {objects[o], p[2..w - 1], strcmp(p[1], "a") < 0};
endif
endif
elseif (o = index(objspec, s))
cp_args = {objects[o], "", strcmp(s, "a") < 0};
elseif (w = index(prnspec, s, 1))
cp_args = {who, prprops[w]};
elseif (s == "#")
s = tostr(who);
elseif (s != "%")
s = "%" + s;
endif
new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | (("%(" + tostr(sub)) + ")")));
endif
old = old[k + 1..oldlen];
oldlen = oldlen - k;
endwhile
return new + old;
.
#20:38
"$string_utils:explode(subject [, break])";
"Return a list of those substrings of subject separated by runs of break[1].";
"break defaults to space.";
return explode(@args);
.
#20:39
"This breaks up the argument string into words, the resulting list being obtained exactly the way the command line parser obtains `args' from `argstr'.";
rest = args[1];
"...trim leading blanks...";
if (0)
rest[1..match(rest, "^ *")[2]] = "";
endif
rest = $string_utils:triml(rest);
if (!rest)
return {};
endif
quote = 0;
toklist = {};
token = "";
pattern = " +%|\\.?%|\"";
while (m = match(rest, pattern))
"... find the next occurence of a special character, either";
"... a block of spaces, a quote or a backslash escape sequence...";
char = rest[m[1]];
token = token + rest[1..m[1] - 1];
if (char == " ")
toklist = {@toklist, token};
token = "";
elseif (char == "\"")
"... beginning or end of quoted string...";
"... within a quoted string spaces aren't special...";
pattern = (quote = !quote) ? "\\.?%|\"" | " +%|\\.?%|\"";
elseif (m[1] < m[2])
"... char has to be a backslash...";
"... include next char literally if there is one";
token = token + rest[m[2]];
endif
rest[1..m[2]] = "";
endwhile
return (rest || (char != " ")) ? {@toklist, token + rest} | toklist;
.
#20:40
"This breaks up the argument string into words, returning a list of indices into argstr corresponding to the starting points of each of the arguments.";
rest = args[1];
"... find first nonspace...";
wstart = match(rest, "[^ ]%|$")[1];
wbefore = wstart - 1;
rest[1..wbefore] = "";
if (!rest)
return {};
endif
quote = 0;
wslist = {};
pattern = " +%|\\.?%|\"";
while (m = match(rest, pattern))
"... find the next occurence of a special character, either";
"... a block of spaces, a quote or a backslash escape sequence...";
char = rest[m[1]];
if (char == " ")
wslist = {@wslist, {wstart, (wbefore + m[1]) - 1}};
wstart = (wbefore + m[2]) + 1;
elseif (char == "\"")
"... beginning or end of quoted string...";
"... within a quoted string spaces aren't special...";
pattern = (quote = !quote) ? "\\.?%|\"" | " +%|\\.?%|\"";
endif
rest[1..m[2]] = "";
wbefore = wbefore + m[2];
endwhile
return (rest || (char != " ")) ? {@wslist, {wstart, wbefore + length(rest)}} | wslist;
.
#20:41
":to_value(string) tries to parse string as a value (i.e., object, number, string, error, or list thereof).";
"Returns {1,value} or {0,error_message} according as the attempt was successful or not.";
string = this:triml(args[1]);
if ((string[1] == "[") || (string[$] == "]"))
result = this:_tomap((string[1] == "[") ? string[2..$] | string);
if (typeof(result[2]) != MAP)
return {0, result[2]};
else
return {1, result[2]};
endif
else
result = this:_tolist(string = args[1] + "}");
if (result[1] && (result[1] != $string_utils:space(result[1])))
return {0, tostr("after char ", length(string) - result[1], ":  ", result[2])};
elseif (typeof(result[1]) == INT)
return {0, "missing } or \""};
elseif (length(result[2]) > 1)
return {0, "comma unexpected."};
elseif (result[2])
return {1, (typeof(result[2]) == LIST) ? result[2][1] | result[2]};
else
return {0, "missing expression"};
endif
endif
.
#20:42
":prefix_to_value(string) tries to parse string as a value (i.e., object, number, string, error, or list thereof).";
"Returns {rest-of-string,value} or {0,error_message} according as the attempt was successful or not.";
alen = length(args[1]);
slen = length(string = this:triml(args[1]));
if (!string)
return {0, "empty string"};
elseif (w = index("{[\"", string[1]))
result = this:({"_tolist", "_tomap", "_unquote"}[w])(string[2..slen]);
if (typeof(result[1]) != INT)
return result;
elseif (result[1] == 0)
return {0, "missing } or \""};
else
return {0, result[2], (alen - result[1]) + 1};
endif
else
thing = string[1..tlen = index(string + " ", " ") - 1];
if (typeof(s = this:_toscalar(thing)) != STR)
return {string[tlen + 1..slen], s};
else
return {0, s, (alen - slen) + 1};
endif
endif
.
#20:43
"_tolist(string) --- auxiliary for :to_value()";
rest = this:triml(args[1]);
vlist = {};
if (!rest)
return {0, {}};
elseif (rest[1] == "}")
return {rest[2..$], {}};
endif
while (1)
rlen = length(rest);
if (w = index("{\"", rest[1]))
result = this:({"_tolist", "_unquote"}[w])(rest[2..rlen]);
if (typeof(result[1]) == INT)
return result;
endif
vlist = {@vlist, result[2]};
rest = result[1];
else
thing = rest[1..tlen = min(index(rest + ",", ","), index(rest + "}", "}")) - 1];
if (typeof(s = this:_toscalar(thing)) == STR)
return {rlen, s};
endif
vlist = {@vlist, s};
rest = rest[tlen + 1..rlen];
endif
if (!rest)
return {0, vlist};
elseif (rest[1] == "}")
return {rest[2..$], vlist};
elseif (rest[1] == ",")
rest = this:triml(rest[2..$]);
else
return {length(rest), ", or } expected"};
endif
endwhile
.
#20:44
"_unquote(string)   (auxiliary for :to_value())";
"reads string as if it were preceded by a quote, reading up to the closing quote if any, then returns the corresponding unquoted string.";
" => {0, string unquoted}  if there is no closing quote";
" => {original string beyond closing quote, string unquoted}  otherwise";
rest = args[1];
result = "";
while (m = match(rest, "\\.?%|\""))
"Find the next special character";
if (rest[pos = m[1]] == "\"")
return {rest[pos + 1..$], result + rest[1..pos - 1]};
endif
result = (result + rest[1..pos - 1]) + rest[pos + 1..m[2]];
rest = rest[m[2] + 1..$];
endwhile
return {0, result + rest};
.
#20:45
":_toscalar(string)  --- auxiliary for :tovalue";
" => value if string represents a number, object or error";
" => string error message otherwise";
thing = args[1];
if (!thing)
return "missing value";
elseif (match(thing, "^#?[-+]?[0-9]+ *$"))
return (thing[1] == "#") ? toobj(thing) | toint(thing);
elseif (match(thing, "^[-+]?%([0-9]+%.[0-9]*%|[0-9]*%.[0-9]+%)%(e[-+]?[0-9]+%)? *$"))
"matches 2. .2 3.2 3.2e3 .2e-3 3.e3";
return `tofloat(thing) ! E_INVARG => tostr("Bad floating point value: ", thing)';
elseif (match(thing, "^[-+]?[0-9]+e[-+]?[0-9]+ *$"))
"matches 345e4. No decimal, but has an e so still a float";
return `tofloat(thing) ! E_INVARG => tostr("Bad floating point value: ", thing)';
elseif (thing == "true")
return true;
elseif (thing == "false")
return false;
elseif (thing[1] == "E")
return (e = $code_utils:toerr(thing)) ? tostr("unknown error code `", thing, "'") | e;
elseif (thing[1] == "#")
return tostr("bogus objectid `", thing, "'");
else
return tostr("`", thing[1], "' unexpected");
endif
.
#20:46
":parse_command(cmd_line[,player])";
" => {verb, {dobj, dobjstr}, {prep, prepstr}, {iobj, iobjstr}, {args, argstr},";
"     {dobjset, prepset, iobjset}}";
"This mimics the action of the builtin parser, returning what the values of the builtin variables `verb', `dobj', `dobjstr', `prepstr', `iobj', `iobjstr', `args', and `argstr' would be if `player' had typed `cmd_line'.  ";
"`prep' is the shortened version of the preposition found.";
"";
"`dobjset' and `iobjset' are subsets of {\"any\",\"none\"} and are used to determine possible matching verbs, i.e., the matching verb must either be on `dobj' and have verb_args[1]==\"this\" or else it has verb_args[1] in `dobjset'; likewise for `iobjset' and verb_args[3]; similarly we must have verb_args[2] in `prepset'.";
{c, ?who = player} = args;
y = $string_utils:words(c);
if (y == {})
return {};
endif
vrb = y[1];
y = y[2..$];
as = (y == {}) ? "" | c[length(vrb) + 2..$];
n = 1;
while ((!(gp = $code_utils:get_prep(@y[n..$]))[1]) && (n < length(y)))
n = n + 1;
endwhile
"....";
really = player;
player = who;
loc = who.location;
if (ps = gp[1])
ds = $string_utils:from_list(y[1..n - 1], " ");
is = $string_utils:from_list(listdelete(gp, 1), " ");
io = valid(loc) ? loc:match_object(is) | $string_utils:match_object(is, loc);
else
ds = $string_utils:from_list(y, " ");
is = "";
io = $nothing;
endif
do = valid(loc) ? loc:match_object(ds) | $string_utils:match_object(ds, loc);
player = really;
"....";
dset = {"any", @(ds == "") ? {"none"} | {}};
"\"this\" must be handled manually.";
pset = {"any", @ps ? {$code_utils:full_prep(ps)} | {"none"}};
iset = {"any", @(is == "") ? {"none"} | {}};
return {vrb, {do, ds}, {$code_utils:short_prep(ps), ps}, {io, is}, {y, as}, {dset, pset, iset}};
.
#20:47
"$string_utils:from_value(value [, quote_strings = 0 [, list_depth = 1]])";
"Print the given value into a string.";
{value, ?quote_strings = 0, ?list_depth = 1} = args;
if (typeof(value) == LIST)
if (value)
if (list_depth)
result = "{" + this:from_value(value[1], quote_strings, list_depth - 1);
for v in (listdelete(value, 1))
result = tostr(result, ", ", this:from_value(v, quote_strings, list_depth - 1));
endfor
return result + "}";
else
return "{...}";
endif
else
return "{}";
endif
elseif (quote_strings)
if (typeof(value) == STR)
result = "\"";
while (q = index(value, "\"") || index(value, "\\"))
if (value[q] == "\"")
q = min(q, index(value + "\\", "\\"));
endif
result = ((result + value[1..q - 1]) + "\\") + value[q];
value = value[q + 1..$];
endwhile
return (result + value) + "\"";
elseif (typeof(value) == ERR)
return $code_utils:error_name(value);
else
return tostr(value);
endif
else
return tostr(value);
endif
.
#20:48
"$string_utils:print(value)";
"Print the given value into a string. == from_value(value,1,-1)";
return toliteral(args[1]);
value = args[1];
if (typeof(value) == LIST)
if (value)
result = "{" + this:print(value[1]);
for val in (listdelete(value, 1))
result = tostr(result, ", ", this:print(val));
endfor
return result + "}";
else
return "{}";
endif
elseif (typeof(value) == STR)
return tostr("\"", strsub(strsub(value, "\\", "\\\\"), "\"", "\\\""), "\"");
elseif (typeof(value) == ERR)
return $code_utils:error_name(value);
else
return tostr(value);
endif
.
#20:49
":reverse(string) => \"gnirts\"";
"An example: :reverse(\"This is a test.\") => \".tset a si sihT\"";
string = args[1];
if ((len = length(string)) > 50)
return this:reverse(string[($ / 2) + 1..$]) + this:reverse(string[1..$ / 2]);
endif
index = len;
result = "";
while (index > 0)
result = result + string[index];
index = index - 1;
endwhile
return result;
.
#20:50
":char_list(string) => string as a list of characters.";
"   e.g., :char_list(\"abad\") => {\"a\",\"b\",\"a\",\"d\"}";
if (30 < (len = length(string = args[1])))
return {@this:char_list(string[1..$ / 2]), @this:char_list(string[($ / 2) + 1..$])};
else
l = {};
for c in [1..len]
l = {@l, string[c]};
endfor
return l;
endif
.
#20:51
":regexp_quote(string)";
" => string with all of the regular expression special characters quoted with %";
string = args[1];
quoted = "";
while (m = rmatch(string, "[][$^.*+?%].*"))
quoted = ("%" + string[m[1]..m[2]]) + quoted;
string = string[1..m[1] - 1];
endwhile
return string + quoted;
.
#20:52
"Return the host string for an object or extract it from a legacy connection_name() string. Assumes you are using bsd_network style connection names.";
(caller != #0) && set_task_perms(caller_perms());
{lookup} = args;
if (typeof(lookup) == OBJ)
return `connection_name(lookup) ! E_INVARG => ""';
elseif (typeof(lookup) == STR)
"Make the assumption here that connection_name() has been passed in from legacy code and contains just the host string.";
return (m = `match(lookup, "^.* %(from%|to%) %([^, ]+%)") ! ANY') ? substitute("%2", m) | lookup;
else
return "";
endif
.
#20:53
"$string_utils:from_value(value [, quote_strings = 0 [, list_depth = 1]])";
"Print the given value into a string.";
"This verb suspends as necessary for large values.";
set_task_perms(caller_perms());
{value, ?quote_strings = 0, ?list_depth = 1} = args;
if (typeof(value) == LIST)
if (value)
if (list_depth)
result = "{" + this:from_value(value[1], quote_strings, list_depth - 1);
for v in (listdelete(value, 1))
$command_utils:suspend_if_needed(0);
result = tostr(result, ", ", this:from_value(v, quote_strings, list_depth - 1));
endfor
return result + "}";
else
return "{...}";
endif
else
return "{}";
endif
elseif (quote_strings)
if (typeof(value) == STR)
result = "\"";
while (q = index(value, "\"") || index(value, "\\"))
$command_utils:suspend_if_needed(0);
if (value[q] == "\"")
q = min(q, index(value + "\\", "\\"));
endif
result = ((result + value[1..q - 1]) + "\\") + value[q];
value = value[q + 1..$];
endwhile
return (result + value) + "\"";
elseif (typeof(value) == ERR)
return $code_utils:error_name(value);
else
return tostr(value);
endif
else
return tostr(value);
endif
.
#20:54
":end_expression(string[,stop_at])";
"  assumes string starts with an expression; returns the index of the last char in expression or 0 if string appears not to be an expression.  Expression ends at any character from stop_at which occurs at top level.";
{string, ?stop_at = " "} = args;
gone = 0;
paren_stack = "";
inquote = 0;
search = top_level_search = ("[][{}()\"" + strsub(stop_at, "]", "")) + "]";
paren_search = "[][{}()\"]";
while (m = match(string, search))
char = string[m[1]];
string[1..m[2]] = "";
gone = gone + m[2];
if (char == "\"")
"...skip over quoted string...";
char = "\\";
while (char == "\\")
if (!(m = match(string, "%(\\.?%|\"%)")))
return 0;
endif
char = string[m[1]];
string[1..m[2]] = "";
gone = gone + m[2];
endwhile
elseif (index("([{", char))
"... push parenthesis...";
paren_stack[1..0] = char;
search = paren_search;
elseif (i = index(")]}", char))
if (paren_stack && ("([{"[i] == paren_stack[1]))
"... pop parenthesis...";
paren_stack[1..1] = "";
search = paren_stack ? paren_search | top_level_search;
else
"...parenthesis mismatch...";
return 0;
endif
else
"... stop character ...";
return gone - 1;
endif
endwhile
return (!paren_stack) && (gone + length(string));
.
#20:55
":first_word(string) => {first word, rest of string} or {}";
rest = args[1];
"...trim leading blanks...";
rest[1..match(rest, "^ *")[2]] = "";
if (!rest)
return {};
endif
quote = 0;
token = "";
pattern = " +%|\\.?%|\"";
while (m = match(rest, pattern))
"... find the next occurence of a special character, either";
"... a block of spaces, a quote or a backslash escape sequence...";
char = rest[m[1]];
token = token + rest[1..m[1] - 1];
if (char == " ")
rest[1..m[2]] = "";
return {token, rest};
elseif (char == "\"")
"... beginning or end of quoted string...";
"... within a quoted string spaces aren't special...";
pattern = (quote = !quote) ? "\\.?%|\"" | " +%|\\.?%|\"";
elseif (m[1] < m[2])
"... char has to be a backslash...";
"... include next char literally if there is one";
token = token + rest[m[2]];
endif
rest[1..m[2]] = "";
endwhile
return {token + rest, ""};
.
#20:56
":common(first,second) => length of longest common prefix";
{first, second} = args;
r = min(length(first), length(second));
l = 1;
while (r >= l)
h = (r + l) / 2;
if (first[l..h] == second[l..h])
l = h + 1;
else
r = h - 1;
endif
endwhile
return r;
.
#20:57
"wr_utils:title_list/title_listc(<obj-list>[, @<args>)";
"Creates an english list out of the titles of the objects in <obj-list>.  Optional <args> are passed on to $string_utils:english_list.";
"title_listc uses :titlec() for the first item.";
titles = $list_utils:map_verb(args[1], "title");
if (verb[length(verb)] == "c")
if (titles)
titles[1] = args[1][1]:titlec();
elseif (length(args) > 1)
args[2] = $string_utils:capitalize(args[2]);
else
args = listappend(args, "Nothing");
endif
endif
return $string_utils:english_list(titles, @args[2..$]);
.
#20:58
"name_and_number(object [,sepr] [,english_list_args]) => \"ObjectName (#object)\"";
"Return name and number for OBJECT.  Second argument is optional separator (for those who want no space, use \"\").  If OBJECT is a list of objects, this maps the above function over the list and then passes it to $string_utils:english_list.";
"The third through nth arguments to nn_list corresponds to the second through nth arguments to English_list, and are passed along untouched.";
{objs, ?sepr = " ", @eng_args} = args;
if (typeof(objs) != LIST)
objs = {objs};
endif
name_list = {};
for what in (objs)
name = valid(what) ? what.name | {"<invalid>", "$nothing", "$ambiguous_match", "$failed_match"}[1 + (what in {#-1, #-2, #-3})];
name = tostr(name, sepr, "(", what, ")");
name_list = {@name_list, name};
endfor
return this:english_list(name_list, @eng_args);
.
#20:59
"columnize_suspended (interval, items, n [, width]) - Turn a one-column list of items into an n-column list, suspending for `interval' seconds as necessary. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize_suspended(0, {1, 2, 3, 4, 5, 6, 7}, 3));'.";
{interval, items, n, ?width = 79} = args;
height = ((length(items) + n) - 1) / n;
items = {@items, @$list_utils:make((height * n) - length(items), "")};
colwidths = {};
for col in [1..n - 1]
colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));
endfor
result = {};
for row in [1..height]
line = tostr(items[row]);
for col in [1..n - 1]
$command_utils:suspend_if_needed(interval);
line = tostr(this:left(line, colwidths[col]), " ", items[row + (col * height)]);
endfor
result = listappend(result, line[1..min($, width)]);
endfor
return result;
.
#20:60
":a_or_an(<noun>) => \"a\" or \"an\"";
"To accomodate personal variation (e.g., \"an historical book\"), a player can override this by having a personal a_or_an verb.  If that verb returns 0 instead of a string, the standard algorithm is used.";
noun = args[1];
if ($object_utils:has_verb(player, "a_or_an") && ((custom_result = player:a_or_an(noun)) != 0))
return custom_result;
endif
if (noun in this.use_article_a)
return "a";
endif
if (noun in this.use_article_an)
return "an";
endif
a_or_an = "a";
if (noun != "")
if (index("aeiou", noun[1]))
a_or_an = "an";
"unicycle, unimplemented, union, united, unimpressed, unique";
if ((((noun[1] == "u") && (length(noun) > 2)) && (noun[2] == "n")) && ((index("aeiou", noun[3]) == 0) || (((noun[3] == "i") && (length(noun) > 3)) && (index("aeioubcghqwyz", noun[4]) || ((length(noun) > 4) && index("eiy", noun[5]))))))
a_or_an = "a";
endif
endif
endif
return a_or_an;
"Ported by Mickey with minor tweaks from a Moo far far away.";
"Last modified Sun Aug  1 22:53:07 1993 EDT by BabyBriar (#2).";
.
#20:61
"index_all(string,target) -- returns list of positions of target in string.";
"Usage: $string_utils:index_all(<string,pattern>)";
"       $string_utils:index_all(\"aaabacadae\",\"a\")";
{line, pattern} = args;
if ((typeof(line) != STR) || (typeof(pattern) != STR))
return E_TYPE;
else
where = {};
place = -1;
next = 0;
while ((place = index(line[next + 1..$], pattern)) != 0)
where = {@where, place + next};
next = ((place + next) + length(pattern)) - 1;
endwhile
return where;
endif
.
#20:62
"Copied from Puff (#1449):match_stringlist Tue Oct 19 08:18:13 1993 PDT";
"$string_utils:match_stringlist(string, {list of strings})";
"The list of strings should be just that, a list of strings.  The first string is matched against the list of strings.";
"If it exactly matches exactly one of them, the index of the match is returned. If it exactly matches more than one of them, $ambiguous_match is returned.";
"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of one of the strings.";
"Again, if exactly one match is found, the index of that string is returned, and if more than one match is found, $ambiguous match is returned.";
"Finally, if there are no exact or partial matches, then $failed_match is returned.";
{subject, stringlist} = args;
if ((subject == "") || (length(stringlist) < 1))
return $nothing;
endif
matches = {};
"First check for exact matches.";
for i in [1..length(stringlist)]
if (subject == stringlist[i])
matches = {@matches, i};
endif
endfor
"Now return a match, or $ambiguous, or check for partial matches.";
if (length(matches) == 1)
return matches[1];
elseif (length(matches) > 1)
return $ambiguous_match;
elseif (length(matches) == 0)
"Checking for partial matches is almost identical to checking for exact matches, but we use index(list[i], target) instead of list[i] == target to see if they match.";
for i in [1..length(stringlist)]
if (index(stringlist[i], subject) == 1)
matches = {@matches, i};
endif
endfor
if (length(matches) == 1)
return matches[1];
elseif (length(matches) > 1)
return $ambiguous_match;
elseif (length(matches) == 0)
return $failed_match;
endif
endif
.
#20:63
"This converts a ASCII character code in the range [32..126] into the ASCII character with that code, represented as a one-character string.";
"";
"Example:   $string_utils:from_ASCII(65) => \"A\"";
code = args[1];
return this.ascii[code - 31];
.
#20:64
"Convert a one-character string into the ASCII character code for that character.";
"";
"Example:  $string_utils:to_ASCII(\"A\") => 65";
return (index(this.ascii, args[1], 1) || raise(E_INVARG)) + 31;
.
#20:65
"Copied from Mickey (#52413):abbreviated_value Fri Sep  9 08:52:41 1994 PDT";
":abbreviated_value(value,max_reslen,max_lstlev,max_lstlen,max_strlen,max_toklen)";
"";
"Gets the printed representation of value, subject to these parameters:";
" max_reslen = Maximum desired result string length.";
" max_lstlev = Maximum list level to show.";
" max_lstlen = Maximum list length to show.";
" max_strlen = Maximum string length to show.";
" max_toklen = Maximum token length (e.g., numbers and errors) to show.";
"";
"A best attempt is made to get the exact target size, but in some cases the result is not exact.";
{value, ?max_reslen = $maxint, ?max_lstlev = $maxint, ?max_lstlen = $maxint, ?max_strlen = $maxint, ?max_toklen = $maxint} = args;
return this:_abbreviated_value(value, max_reslen, max_lstlev, max_lstlen, max_strlen, max_toklen);
"Originally written by Mickey.";
.
#20:66
"Copied from Mickey (#52413):_abbreviated_value Fri Sep  9 08:52:44 1994 PDT";
"Internal to :abbreviated_value.  Do not call this directly.";
{value, max_reslen, max_lstlev, max_lstlen, max_strlen, max_toklen} = args;
if ((type = typeof(value)) == LIST)
if (!value)
return "{}";
elseif (max_lstlev == 0)
return "{...}";
else
n = length(value);
result = "{";
r = max_reslen - 2;
i = 1;
eltstr = "";
while (((i <= n) && (i <= max_lstlen)) && (r > (x = (i == 1) ? 0 | 2)))
eltlen = length(eltstr = this:(verb)(value[i], r, max_lstlev - 1, max_lstlen, max_strlen, max_toklen));
lastpos = 1;
if (r >= (eltlen + x))
comma = (i == 1) ? "" | ", ";
result = tostr(result, comma);
if (r > 4)
lastpos = length(result);
endif
result = tostr(result, eltstr);
r = (r - eltlen) - x;
elseif (i == 1)
return "{...}";
elseif (r > 4)
return tostr(result, ", ...}");
else
return tostr(result[1..lastpos], "...}");
endif
i = i + 1;
endwhile
if (i <= n)
if (i == 1)
return "{...}";
elseif (r > 4)
return tostr(result, ", ...}");
else
return tostr(result[1..lastpos], "...}");
endif
else
return tostr(result, "}");
endif
endif
elseif (type == STR)
result = "\"";
while ((q = index(value, "\"")) ? q = min(q, index(value, "\\")) | (q = index(value, "\\")))
result = ((result + value[1..q - 1]) + "\\") + value[q];
value = value[q + 1..$];
endwhile
result = result + value;
if ((length(result) + 1) > (z = max(min(max_reslen, max(max_strlen, max_strlen + 2)), 6)))
z = z - 5;
k = 0;
while ((k < z) && (result[z - k] == "\\"))
k = k + 1;
endwhile
return tostr(result[1..z - (k % 2)], "\"+...");
else
return tostr(result, "\"");
endif
else
v = (type == ERR) ? $code_utils:error_name(value) | tostr(value);
len = max(4, min(max_reslen, max_toklen));
return (length(v) > len) ? v[1..len - 3] + "..." | v;
endif
"Originally written by Mickey.";
.
#20:67
"$string_utils:match_suspended(string [, obj-list, prop-name]*)";
"Each obj-list should be a list of objects or a single object, which is treated as if it were a list of that object.  Each prop-name should be string naming a property on every object in the corresponding obj-list.  The value of that property in each case should be either a string or a list of strings.";
"The argument string is matched against all of the strings in the property values.";
"If it exactly matches exactly one of them, the object containing that property is returned.  If it exactly matches more than one of them, $ambiguous_match is returned.";
"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of some property string.  Again, if exactly one match is found, the object with that property is returned, and if there is more than one match, $ambiguous_match is returned.";
"Finally, if there are no exact or partial matches, then $failed_match is returned.";
"This verb will suspend as needed, and should be used if obj-list is very large.";
subject = args[1];
if (subject == "")
return $nothing;
endif
no_exact_match = no_partial_match = 1;
for i in [1..length(args) / 2]
prop_name = args[(2 * i) + 1];
for object in ((typeof(olist = args[2 * i]) == LIST) ? olist | {olist})
if (valid(object))
if (typeof(str_list = `object.(prop_name) ! E_PERM, E_PROPNF => {}') != LIST)
str_list = {str_list};
endif
if (subject in str_list)
if (no_exact_match)
no_exact_match = object;
elseif (no_exact_match != object)
return $ambiguous_match;
endif
else
for string in (str_list)
if (index(string, subject) != 1)
elseif (no_partial_match)
no_partial_match = object;
elseif (no_partial_match != object)
no_partial_match = $ambiguous_match;
endif
endfor
endif
endif
$command_utils:suspend_if_needed(5);
endfor
endfor
return no_exact_match && (no_partial_match && $failed_match);
.
#20:68
"args[1] is a string.  'increments' the string by one. E.g., aaa => aab, aaz => aba.  empty string => a, zzz => aaaa.";
"args[2] is optional alphabet to use instead of $string_utils.alphabet.";
{s, ?alphabet = this.alphabet} = args;
index = length(s);
if (!s)
return alphabet[1];
elseif (s[$] == alphabet[$])
return this:incr_alpha(s[1..index - 1], alphabet) + alphabet[1];
else
t = index(alphabet, s[index]);
return s[1..index - 1] + alphabet[t + 1];
endif
.
#20:69
"Usage:  is_float(string)";
"Is string composed of one or more digits possibly preceded by a minus sign either followed by a decimal or by an exponent?";
"Return true or false";
return match(args[1], "^ *[-+]?%(%([0-9]+%.[0-9]*%|[0-9]*%.[0-9]+%)%(e[-+]?[0-9]+%)?%)%|%([0-9]+e[-+]?[0-9]+%) *$");
.
#20:70
"Copied from Moo_tilities (#332):inside_quotes by Mooshie (#106469) Tue Dec 23 10:26:49 1997 PST";
"Usage: inside_quotes(STR)";
"Is the  end of the given string `inside' a doublequote?";
"Called from $code_utils:substitute.";
{string} = args;
quoted = 0;
while (i = index(string, "\""))
if ((!quoted) || (string[i - 1] != "\\"))
quoted = !quoted;
endif
string = string[i + 1..$];
endwhile
return quoted;
.
#20:71
":strip_all_but_seq(string, keep) => chars in string not in exact sequence of keep removed.";
":strip_all_but() works similarly, only it does not concern itself with the sequence, just the specified chars.";
string = args[1];
wanted = args[2];
output = "";
while (m = match(string, wanted))
output = output + string[m[1]..m[2]];
string = string[m[2] + 1..length(string)];
endwhile
return output;
.
#20:72
"...redirects verbs to $ansi_utils...";
if (verb == "redirect_ansi")
elseif (valid(au = $ansi_utils))
return au:(verb)(@args);
else
return this:(verb + "(noansi)")(@args);
endif
.
#20:73
"_tomap(string) -- auxiliary for :to_value()";
"Last modified 11/28/18 11:48 p.m. by Sinistral (#2) on ChatMUD";
rest = this:triml(args[1]);
vhash = [];
if (!rest)
return {0, []};
elseif (rest[1] == "]")
return {rest[2..$], []};
endif
while (1)
rlen = length(rest);
key = 0;
if (rest[1] == "\"")
result = this:_unquote(rest[2..rlen]);
if (typeof(result[1] == INT))
return result;
endif
key = result[2];
rest = result[1];
if (!rest)
return {0, ""};
endif
key_end = index(rest, "->");
if (!key_end)
return {rlen, "missing arrow '->' in hash entry definition"};
endif
rest = rest[key_end + 2..$];
elseif (w = index("{[", rest[1]))
return {rlen, "hash key cannot be list or hash"};
else
key_end = index(rest, "->");
if (!key_end)
return {rlen, "missing arrow '->' in hash entry definition"};
endif
thing = rest[1..key_end - 1];
if (typeof(s = this:_toscalar(thing)) == STR)
return {rlen, s};
endif
key = s;
rest = rest[key_end + 2..rlen];
endif
val = 0;
rest = this:triml(rest);
rlen = length(rest);
if (w = index("{[\"", rest[1]))
result = this:({"_tolist", "_tomap", "_unquote"}[w])(rest[2..rlen]);
if (typeof(result[1] == INT))
return result;
endif
val = result[2];
rest = result[1];
else
val = rest[1..vlen = min(index(rest + ",", ","), index(rest + "]", "]")) - 1];
if (typeof(s = this:_toscalar(val)) == STR)
return {rlen, s};
endif
val = s;
rest = rest[vlen + 1..rlen];
endif
vhash[key] = val;
rest = this:triml(rest);
if (!rest)
return {0, vhash};
elseif (rest[1] == "]")
return {rest[2..$], vhash};
elseif (rest[1] == ",")
rest = this:triml(rest[2..$]);
else
return {length(rest), ", or ] expected"};
endif
endwhile
.
#20:74
":fit_to_screen({elements}, ?padding = 2, ?underline = 0, ?separator = \" \") => Returns a columnized display that is adapted to the linelength of the viewers screen.";
"If underline is set to 1, the first list is assumed to be a list of column headings and the code will insert an appropriate amount of dashes for you. e.g. {ur, mom, lawlz} will add {--, ---, -----}";
"If separator is set to a character, it will be passed to :neat. e.g. those things that use lots of periods instead of spaces";
"Verb Created by Lisdude@Toastsoft, 10/13/15";
{elements, ?padding = 2, ?underline = 0, ?separator = " "} = args;
ansi_utils = $ansi_utils;
command_utils = $command_utils;
if (underline)
lines = {};
for x in (elements[1])
lines = {@lines, ansi_utils:space(length(x), "-")};
endfor
elements = listinsert(elements, lines, 2);
endif
max = $list_utils:make(length(elements[1]));
for x in (elements)
command_utils:suspend_if_needed(0);
for y in [1..length(x)]
if ((len = ansi_utils:length(x[y])) > max[y])
max[y] = len;
endif
endfor
endfor
"Add padding.";
for x in [1..length(max)]
max[x] = max[x] + padding;
endfor
ret = {};
max = this:adjust_column_lengths(max);
for x in (elements)
command_utils:suspend_if_needed(0);
neat = {};
for y in [1..length(x)]
neat = {@neat, {x[y], max[y], separator}};
endfor
ret = {@ret, this:neat(@neat)};
endfor
return ret;
.
#20:75
":adjust_column_lengths({lengths}) => Takes a list of numbers that are assumed to be column lengths. Then, if the sum";
"                                       of those lengths exceeds the player's linelength, beginning systematically lowering";
"                                      individual columns until we fit on their screen.";
{ret, ?increment = 5, ?player = player} = args;
variable_picker = 0;
len = length(ret);
iterations = 0;
linelen = player:linelen();
while (1)
$sin(0);
iterations = iterations + 1;
if (iterations >= 500000)
break;
endif
sum = 0;
for x in (ret)
sum = sum + x;
endfor
if (sum <= linelen)
return ret;
else
variable_picker = variable_picker + 1;
if (variable_picker > len)
variable_picker = len;
endif
if ((ret[variable_picker] - increment) <= 4)
continue;
endif
endif
ret[variable_picker] = ret[variable_picker] - increment;
endwhile
return ret;
.
#20:76
"{string, length, [seperator]}";
AU = $ansi_utils;
ret = "";
for x in (args)
NUM = toint(x[2]);
x[1] = tostr(x[1]);
ret = tostr(ret, tostr(AU:left((AU:length(x[1]) >= NUM) ? AU:cutoff(x[1], 1, NUM - 1) | x[1], NUM, (length(x) == 3) ? x[3] | " ")));
$sin(0);
endfor
return ret;
.
#20:77
"This will capitalize each word in a string.";
"Add words to the ignore list if you want them to be left lowercase.";
{string, ?ignore_words = {}, ?always_capitalize_first = 1} = args;
words = $string_utils:words(string);
for x in [1..length(words)]
if ((!(words[x] in ignore_words)) || ((x == 1) && always_capitalize_first))
words[x] = $string_utils:capitalize(words[x]);
endif
endfor
return $string_utils:from_list(words, " ");
.
#20:78
{decode} = args;
decoded = "";
for x in (decode_binary(decode))
if (typeof(x) == STR)
decoded = decoded + x;
endif
endfor
return decoded;
.
#21:0
"make_exit(spec, source, dest[, use-$recycler-pool [, kind]])";
"";
"Uses $recycler by default; supplying fourth arg as 0 suppresses this.";
"Optional 5th arg gives a parent for the object to be created";
"(i.e., distinct from $exit)";
"Returns the object number as a list if successful, 0 if not.";
set_task_perms(caller_perms());
{spec, source, dest, ?use_recycler, ?exit_kind = $exit} = args;
exit = player:_create(exit_kind);
if (typeof(exit) == ERR)
player:notify(tostr("Cannot create new exit as a child of ", $string_utils:nn(exit_kind), ": ", exit, ".  See `help @build-options' for information on how to specify the kind of exit this command tries to create."));
return;
endif
for f in ($string_utils:char_list(player:build_option("create_flags") || ""))
exit.(f) = 1;
endfor
$building_utils:set_names(exit, spec);
exit.source = source;
exit.dest = dest;
source_ok = source:add_exit(exit);
dest_ok = dest:add_entrance(exit);
move(exit, $nothing);
via = $string_utils:from_value(setadd(exit.aliases, exit.name), 1);
if (source_ok)
player:tell("Exit from ", source.name, " (", source, ") to ", dest.name, " (", dest, ") via ", via, " created with id ", exit, ".");
if (!dest_ok)
player:tell("However, I couldn't add ", exit, " as a legal entrance to ", dest.name, ".  You may have to get its owner, ", dest.owner.name, " to add it for you.");
endif
return {exit};
elseif (dest_ok)
player:tell("Exit to ", dest.name, " (", dest, ") via ", via, " created with id ", exit, ".  However, I couldn't add ", exit, " as a legal exit from ", source.name, ".  Get its owner, ", source.owner.name, " to add it for you.");
return {exit};
else
player:_recycle(exit);
player:tell("I couldn't add a new exit as EITHER a legal exit from ", source.name, " OR as a legal entrance to ", dest.name, ".  Get their owners, ", source.owner.name, " and ", dest.owner.name, ", respectively, to add it for you.");
return 0;
endif
.
#21:1
"$building_utils:set_names(object, spec)";
set_task_perms(caller_perms());
object = args[1];
names = this:parse_names(args[2]);
name = names[1] || object.name;
return object:set_name(name) && object:set_aliases(names[2]);
.
#21:2
":recreate(object,newparent) -- effectively recycle and recreate the specified object as a child of parent.  Returns true if successful.";
"In any circumstance, either object OR newparent has to be a valid object.";
"If object is valid and newparent is invalid, object is effectively just recycled.";
"If object is invalid and newparent is valid, an attempt will be made to recreate the invalid object as newparent.";
{object, parent} = args;
who = caller_perms();
if (who.wizard)
"no problemo";
elseif ((valid(object) && (who != object.owner)) || (valid(parent) && ((who != parent.owner) && (!parent.f))))
return E_PERM;
endif
"No need to worry about orphans or contents, as recycle() will handle all of that for us.";
set_task_perms(who);
if (valid(object))
recycle(object);
endif
if (!valid(parent))
"We're done here. All we wanted to do was recycle with who's permissions.";
return 1;
else
recreate(object, parent, who);
object.name = "";
object.r = 0;
object.f = 0;
object.w = 0;
return 1;
endif
.
#21:3
"$building_utils:parse_names(spec)";
"Return {name, {alias, alias, ...}} from name,alias,alias or name:alias,alias";
spec = args[1];
if (!(colon = index(spec, ":")))
aliases = $string_utils:explode(spec, ",");
if (!aliases)
aliases = {spec};
endif
name = aliases[1];
else
aliases = $string_utils:explode(spec[colon + 1..$], ",");
name = spec[1..colon - 1];
endif
return {name, $list_utils:map_arg($string_utils, "trim", aliases)};
.
#21:4
if (is_player(what = args[1]))
return "P";
endif
while (valid(what))
if (i = what in this.classes)
return this.class_string[i];
endif
what = parent(what);
endwhile
return " ";
.
#21:5
":object_audit_string(object [,prospectus-style])";
{o, ?prospectus = 0} = args;
olen = length(tostr(max_object()));
if (!$recycler:valid(o))
return tostr(prospectus ? "          " | "", $quota_utils.byte_based ? "    " | "", $string_utils:right(o, olen), " Invalid Object!");
endif
if (prospectus)
kids = 0;
for k in (children(o))
$command_utils:suspend_if_needed(0);
if (k.owner != o.owner)
kids = 2;
break k;
elseif (kids == 0)
kids = 1;
endif
endfor
"The verbs() call below might fail, but that's OK";
"Well, actually it won't cuz we seem to be a wizard.  Since you can get the number of verbs information from @verbs anyway, it seems kind of pointless to hide it here.";
v = verbs(o);
if (v)
vstr = tostr("[", $string_utils:right(length(v), 3), "] ");
else
vstr = "      ";
endif
if (o.r && o.f)
r = "f";
elseif (o.r)
r = "r";
elseif (o.f)
r = "F";
else
r = " ";
endif
vstr = tostr(" kK"[kids + 1], r, $building_utils:audit_object_category(o), vstr);
else
vstr = "";
endif
if ($quota_utils.byte_based)
vstr = tostr(this:size_string(`o.object_size[1] ! ANY => 0'), " ", vstr);
name_field_len = 26;
else
name_field_len = 30;
endif
if (valid(o.location))
loc = ((((o.location.owner == o.owner) ? " " | "*") + "[") + o.location.name) + "]";
elseif (typeof(o) == ANON)
loc = " ";
elseif ($object_utils:has_property(o, "dest") && $object_utils:has_property(o, "source"))
if (typeof(o.source) != OBJ)
source = " <non-object> ";
elseif (!valid(o.source))
source = "<invalid>";
else
source = o.source.name;
if (o.source.owner != o.owner)
source = "*" + source;
endif
endif
if (typeof(o.dest) != OBJ)
destin = " <non-object> ";
elseif (!valid(o.dest))
destin = "<invalid>";
else
destin = o.dest.name;
if (o.dest.owner != o.owner)
destin = "*" + destin;
endif
endif
srclen = min(length(source), 19);
destlen = min(length(destin), 19);
loc = ((" " + source[1..srclen]) + "->") + destin[1..destlen];
elseif ($object_utils:isa(o, $room))
loc = "";
try
for x in (o.entrances)
if (((((typeof(x) == OBJ) && valid(x)) && (x.owner != o.owner)) && $object_utils:has_property(x, "dest")) && (x.dest == o))
loc = ((loc + (loc ? ", " | "")) + "<-*") + x.name;
endif
endfor
except (ANY)
if ($perm_utils:controls(player, o))
loc = " BROKEN PROPERTY: .entrances";
endif
endtry
else
loc = " [Nowhere]";
endif
if (length(loc) > 41)
loc = loc[1..37] + "..]";
endif
namelen = min(length(o.name), name_field_len - 1);
return tostr(vstr, $string_utils:right(o, olen), " ", $string_utils:left(o.name[1..namelen], name_field_len), loc);
.
#21:6
":do_audit(who, start, end, match)";
"audit who, with objects from start to end that match 'match'";
":do_prospectus(...)";
"same, but with verb counts";
{who, start, end, match} = args;
pros = verb == "do_prospectus";
"the set_task_perms is to make the task owned by the player. There are no other security aspects";
set_task_perms(caller_perms());
if ((((((start == 0) && (end == toint(max_object()))) && (!match)) && (typeof(who.owned_objects) == LIST)) && (length(who.owned_objects) > 100)) && (!$command_utils:yes_or_no(tostr(who.name, " has ", length(who.owned_objects), " objects.  This will be a very long list.  Do you wish to proceed?"))))
v = pros ? "@prospectus" | "@audit";
return player:tell(v, " aborted.  Usage:  ", v, " [player] [from <start>] [to <end>] [for <match>]");
endif
player:tell(tostr("Objects owned by ", who.name, " (from #", start, " to #", end, match ? " matching " + match | "", ")", ":"));
count = bytes = 0;
if (typeof(who.owned_objects) == LIST)
for o in (who.owned_objects)
$command_utils:suspend_if_needed(0);
if (!player:is_listening())
return;
endif
if ((typeof(o) == ANON) || ((toint(o) >= start) && (toint(o) <= end)))
didit = this:do_audit_item(o, match, pros);
count = count + didit;
if ((didit && $quota_utils.byte_based) && $object_utils:has_property(o, "object_size"))
bytes = bytes + o.object_size[1];
endif
endif
endfor
else
for i in [start..end]
$command_utils:suspend_if_needed(0);
o = toobj(i);
if ($recycler:valid(o) && (o.owner == who))
didit = this:do_audit_item(o, match, pros);
count = count + didit;
if ((didit && $quota_utils.byte_based) && $object_utils:has_property(o, "object_size"))
bytes = bytes + o.object_size[1];
endif
endif
endfor
endif
player:tell($string_utils:left(tostr("-- ", count, " object", (count == 1) ? "." | "s.", $quota_utils.byte_based ? tostr("  Total bytes: ", $string_utils:group_number(bytes), ".") | ""), player:linelen() - 1, "-"));
.
#21:7
":do_audit_item(object, match-name-string, prospectus-flag)";
{o, match, pros} = args;
found = match ? 0 | 1;
names = `{o.name, @o.aliases} ! ANY => {o.name}';
"Above to get rid of screwed up aliases";
while (names && (!found))
if (index(names[1], match) == 1)
found = 1;
endif
names = listdelete(names, 1);
endwhile
if (found)
"From Dred---don't wrap long lines.";
line = $building_utils:object_audit_string(o, pros);
player:tell(line[1..min($, player:linelen())]);
return 1;
endif
return 0;
.
#21:8
"Copied from Roebare (#109000):size_string at Sat Nov 26 18:41:12 2005 PST";
size = args[1];
if (typeof(size) != INT)
return E_INVARG;
endif
if (`!player:build_option("audit_float") ! ANY')
"...use integers to determine a four-char string...";
factor = 1000;
threshold = {{1000, "B"}, {1000000, "K"}, {1000000000, "M"}};
if (!size)
return " ???";
elseif ((size < 0) || (size > threshold[$][1]))
if ((size < 0) || (size > $maxint))
return " >2G";
else
"...floats still required to factor over $maxint...";
return tostr($string_utils:right(floatstr(tofloat(size) / 1000000000.0, 0), 3), "G");
endif
elseif ((size < threshold[1][1]) && `!player:build_option("audit_bytes") ! ANY')
return " <1K";
endif
for entry in ($list_utils:slice(threshold, 1))
$command_utils:suspend_if_needed(0);
i = $list_utils:iassoc(entry, threshold);
if (size == entry)
size = "1";
try
unit = threshold[i + 1][2];
except error (E_RANGE)
unit = "G";
endtry
break;
elseif (size < entry)
size = tostr(size / (entry / factor));
unit = threshold[i][2];
break;
endif
endfor
return tostr($string_utils:right(size, 3), unit);
else
"...use floats to determine a six-char string...";
size = tofloat(size);
factor = 1024.0;
"...be precise, `((1024.00 * 1024.00) * 1024.00) * 1024.00'...";
threshold = {{1048576.0, "K"}, {1073741824.0, "M"}, {1099511627776.0, "G"}};
if (!size)
return "   ???";
elseif ((size < 0.0) || (size > threshold[$][1]))
"...special handling for bad conversions & big numbers...";
if ((size < 0.0) || (size > tofloat($maxint)))
return "   >2G";
else
return tostr($string_utils:right(floatstr(size / 1000000000.0, 1), 3), "G");
endif
endif
for entry in ($list_utils:slice(threshold, 1))
$command_utils:suspend_if_needed(0);
i = $list_utils:iassoc(entry, threshold);
if (size == entry)
size = "1";
try
unit = threshold[i + 1][2];
except error (E_RANGE)
"...in another decade, maybe...";
unit = "T";
endtry
break;
elseif (size < entry)
size = floatstr(size / (entry / factor), 1);
unit = threshold[i][2];
break;
endif
endfor
return tostr($string_utils:right(size, 5), unit);
endif
"Rewritten by Roebare (#109000), 051119-26";
"With inspiration from Miral (#107983) and assistance from Diopter (#98842)";
"Byte & float display optional, per Nosredna (#2487), 051120-24";
.
#21:9
if (caller_perms().wizard)
pass(@args);
this.classes = {$player, $room, $exit, $note, $container, $thing, $feature, $mail_recipient, $generic_help, $generic_db, $generic_utils, $generic_options};
endif
.
#22:0
text = args[1];
for i in [1..length($code_utils.error_list)]
text = {@text, tostr("    ", $string_utils:left($code_utils.error_names[i], 15), $code_utils.error_list[i])};
endfor
return text;
.
#22:1
text = args[1];
for p in ($code_utils:prepositions())
text = {@text, tostr($string_utils:space(4), p)};
endfor
return text;
.
#24:0
":set_programmer(victim[,mail from])  => 1 or error.";
"Sets victim.programmer, chparents victim to $prog if necessary, and sends mail to $new_prog_log, mail is from optional second arg or caller_perms().";
whodunnit = caller_perms();
{victim, ?mailfrom = whodunnit} = args;
if (!whodunnit.wizard)
return E_PERM;
elseif (!(valid(victim) && (is_player(victim) && $object_utils:isa(victim, $player))))
return E_INVARG;
elseif (victim.programmer)
return E_NONE;
elseif (this:check_prog_restricted(victim))
return E_INVARG;
elseif (typeof(e = `victim.programmer = 1 ! ANY') == ERR)
return e;
else
$quota_utils:adjust_quota_for_programmer(victim);
if (!$object_utils:isa(victim, $prog))
if (typeof(e = `chparent(victim, $prog) ! ANY') == ERR)
"...this isn't really supposed to happen but it could...";
player:notify(tostr("chparent(", victim, ",", $prog, ") failed:  ", e));
player:notify("Check for common properties.");
endif
else
player:notify(tostr(victim.name, " was already a child of ", parent(victim).name, " (", parent(victim), ")"));
endif
if (!$mail_agent:send_message(mailfrom, {$new_prog_log, victim}, tostr("@programmer ", victim.name, " (", victim, ")"), tostr("I just gave ", victim.name, " a programmer bit."))[1])
$mail_agent:send_message(mailfrom, {$new_prog_log}, tostr("@programmer ", victim.name, " (", victim, ")"), tostr("I just gave ", victim.name, " a programmer bit."));
endif
return 1;
endif
.
#24:1
":set_player(victim[,nochown]) => 1 or error";
"Set victim's player flag, (maybe) chown to itself, add name and aliases to $player_db.";
" E_NONE == already a player,";
" E_NACC == player_db is frozen,";
" E_RECMOVE == name is unavailable";
{victim, ?nochown = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (!(valid(victim) && $object_utils:isa(victim, $player)))
return E_INVARG;
elseif (is_player(victim))
return E_NONE;
elseif ($player_db.frozen)
return E_NACC;
elseif (!$player_db:available(name = victim.name))
return E_RECMOVE;
else
set_player_flag(victim, 1);
if (0 && $object_utils:isa(victim, $prog))
victim.programmer = 1;
else
victim.programmer = $player.programmer;
endif
if (!nochown)
$wiz_utils:set_owner(victim, victim);
endif
$player_db:insert(name, victim);
for a in (setremove(aliases = victim.aliases, name))
if (index(a, " "))
"..ignore ..";
elseif ($player_db:available(a) in {this, 1})
$player_db:insert(a, victim);
else
aliases = setremove(aliases, a);
endif
endfor
victim.aliases = setadd(aliases, name);
return 1;
endif
.
#24:2
":set_owner(object,newowner[,suspendok])  does object.owner=newowner, taking care of c properties as well.  This should be used anyplace one is contemplating doing object.owner=newowner, since the latter leaves ownership of c properties unchanged.  (--Rog thinks this is a server bug). If force is specified and the object is already owned by newowner, c property ownership will proceed.";
{object, newowner, ?suspendok = 0, ?force = 0} = args;
if (!valid(object))
return E_INVIND;
elseif (!caller_perms().wizard)
return E_PERM;
elseif (!(valid(newowner) && is_player(newowner)))
return E_INVARG;
elseif ((object.owner == newowner) && (!force))
return 1;
endif
oldowner = object.owner;
object.owner = newowner;
for pname in ($object_utils:all_properties(object))
if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))
suspend(0);
endif
perms = property_info(object, pname)[2];
if (index(perms, "c"))
set_property_info(object, pname, {newowner, perms});
endif
endfor
if ($object_utils:isa(oldowner, $player))
if (is_player(oldowner) && (object != oldowner))
$quota_utils:reimburse_quota(oldowner, object);
endif
if (typeof(oldowner.owned_objects) == LIST)
oldowner.owned_objects = setremove(oldowner.owned_objects, object);
endif
endif
if ($object_utils:isa(newowner, $player))
if (object != newowner)
$quota_utils:charge_quota(newowner, object);
endif
if (typeof(newowner.owned_objects) == LIST)
newowner.owned_objects = setadd(newowner.owned_objects, object);
endif
endif
return 1;
.
#24:3
":set_property_owner(object,prop,newowner[,suspendok])  changes the ownership of object.prop to newowner.  If the property is !c, changes the ownership on all of the descendents as well.  Otherwise, we just chown the property on the object itself and give a warning if newowner!=object.owner (--Rog thinks this is a server bug that one is able to do this at all...).";
{object, pname, newowner, ?suspendok = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (!(info = `property_info(object, pname) ! ANY'))
"... handles E_PROPNF and invalid object errors...";
return info;
elseif (!is_player(newowner))
return E_INVARG;
elseif (index(info[2], "c"))
if (suspendok / 2)
"...(recursive call)...";
"...child property is +c while parent is -c??...RUN AWAY!!";
return E_NONE;
else
set_property_info(object, pname, listset(info, newowner, 1));
return (newowner == object.owner) || E_NONE;
endif
else
set_property_info(object, pname, listset(info, newowner, 1));
if ((suspendok % 2) && ((ticks_left() < 10000) || (seconds_left() < 2)))
suspend(0);
endif
suspendok = 2 + suspendok;
for c in (children(object))
this:set_property_owner(c, pname, newowner, suspendok);
endfor
return 1;
endif
.
#24:4
":unset_player(victim[,newowner])  => 1 or error";
"Reset victim's player flag, chown victim to newowner (if given), remove all of victim's names and aliases from $player_db.";
{victim, ?newowner = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (!valid(victim))
return E_INVARG;
elseif (!is_player(victim))
return E_NONE;
endif
if (typeof(newowner) == OBJ)
$wiz_utils:set_owner(victim, newowner);
endif
victim.programmer = 0;
victim.wizard = 0;
set_player_flag(victim, 0);
if ($object_utils:has_property($local, "second_char_registry"))
$local.second_char_registry:delete_player(victim);
`$local.second_char_registry:delete_shared(victim) ! ANY';
endif
if ($player_db.frozen)
player:tell("Warning:  player_db is in the middle of a :load().");
endif
$player_db:delete2(victim.name, victim);
for a in (victim.aliases)
$player_db:delete2(a, victim);
"I don't *think* this is bad---we've already toaded the guy.  And folks with lots of aliases screw us. --Nosredna";
$command_utils:suspend_if_needed(0);
endfor
return 1;
"Paragraph (#122534) - Sat Nov 5, 2005 - Remove any shared character registry listings for `victim'.";
.
#24:5
":set_property_flags(object,prop,flags[,suspendok])  changes the permissions on object.prop to flags.  Unlike a mere set_property_info, this changes the flags on all descendant objects as well.  We also change the ownership on the descendent properties where necessary.";
{object, pname, flags, ?suspendok = 0} = args;
perms = caller_perms();
if (!(info = `property_info(object, pname) ! ANY'))
"... handles E_PROPNF and invalid object errors...";
return info;
elseif ($set_utils:difference($string_utils:char_list(flags), {"r", "w", "c"}))
"...not r, w, or c?...";
return E_INVARG;
elseif ((pinfo = `property_info(parent(object), pname) ! ANY') && (flags != pinfo[2]))
"... property doesn't actually live here...";
"... only allowed to correct so that this property matches parent...";
return E_INVARG;
elseif (!(perms.wizard || (info[1] == perms)))
"... you have to own the property...";
return E_PERM;
elseif (!(((!(c = index(flags, "c"))) == (!index(info[2], "c"))) || $perm_utils:controls(perms, object)))
"... if you're changing the c flag, you have to own the object...";
return E_PERM;
else
if (c)
set_property_info(object, pname, {object.owner, kflags = flags});
else
set_property_info(object, pname, kflags = listset(info, flags, 2));
endif
for kid in (children(object))
this:_set_property_flags(kid, pname, kflags, suspendok);
endfor
return 1;
endif
.
#24:6
"_set_property_flags(object, pname, {owner, flags} or something+\"c\", suspendok)";
"auxiliary to :set_property_flags... don't call this directly.";
if (caller != this)
return E_PERM;
endif
if (args[4] && $command_utils:running_out_of_time(0))
suspend(0);
endif
object = args[1];
if (typeof(args[3]) != LIST)
set_property_info(object, args[2], {object.owner, args[3]});
else
set_property_info(@args[1..3]);
endif
for kid in (children(object))
this:_set_property_flags(@listset(args, kid, 1));
endfor
.
#24:7
"Generate a random password of length args[1].  Alternates vowels and consonants, for maximum pronounceability.  Uses its own list of consonants which exclude F and C and K to prevent generating obscene sounding passwords.";
"Capital I and lowercase L are excluded on the basis of looking like each other.";
vowels = "aeiouyAEUY";
consonants = "bdghjmnpqrstvwxzBDGHJLMNPQRSTVWXZ";
len = toint(args[1]);
if (len)
alt = random(2) - 1;
s = "";
for i in [1..len]
newchar = alt ? vowels[random($)] | consonants[random($)];
s = s + newchar;
alt = !alt;
endfor
return s;
else
return E_INVARG;
endif
.
#24:8
":queued_tasks(player) => list of queued tasks for that player.";
"shouldn't the server builtin should work this way?  oh well";
set_task_perms(caller_perms());
if (typeof(e = `set_task_perms(who = args[1]) ! ANY') == ERR)
return e;
elseif (who.wizard)
tasks = {};
for t in (queued_tasks())
if (t[5] == who)
tasks = {@tasks, t};
endif
endfor
return tasks;
else
return queued_tasks();
endif
.
#24:9
"Return 1 if args[1] is a newted player.";
if (!caller_perms().wizard)
return E_PERM;
else
return args[1] in $login.newted;
endif
.
#24:10
if (!caller_perms().wizard)
return E_PERM;
else
set_task_perms(caller_perms());
player:tell("Beginning initialize_owned:  ", ctime());
for o in [#0..max_object()]
if (valid(o))
if ($object_utils:isa(owner = o.owner, $player) && (typeof(owner.owned_objects) == LIST))
owner.owned_objects = setadd(owner.owned_objects, o);
endif
endif
$command_utils:suspend_if_needed(0);
endfor
player:tell("Done adding, beginning verification pass.");
this:verify_owned_objects();
player:tell("Finished:  ", ctime());
endif
.
#24:11
if (!caller_perms().wizard)
return E_PERM;
else
for p in (players())
if (typeof(p.owned_objects) == LIST)
for o in (p.owned_objects)
if (((typeof(o) != OBJ) || (!valid(o))) || (o.owner != p))
p.owned_objects = setremove(p.owned_objects, o);
player:tell("Removed ", $string_utils:nn(o), " from ", $string_utils:nn(p), "'s .owned_objects list.");
if (((typeof(o) == OBJ) && valid(o)) && (typeof(o.owner.owned_objects) == LIST))
o.owner.owned_objects = setadd(o.owner.owned_objects, o);
endif
endif
$command_utils:suspend_if_needed(0, p);
endfor
endif
endfor
endif
.
#24:12
":connected_wizards() => list of currently connected wizards and players mentioned in .public_identity properties as being wizard counterparts.";
wizzes = $object_utils:leaves($wiz);
wlist = {};
everyone = verb == "connected_wizards_unadvertised";
for w in (wizzes)
if (w.wizard && (w.advertised || everyone))
if (`connected_seconds(w) ! ANY => 0')
wlist = setadd(wlist, w);
endif
if (`connected_seconds(w.public_identity) ! ANY => 0')
wlist = setadd(wlist, w.public_identity);
endif
endif
endfor
return wlist;
.
#24:13
":all_wizards_advertised() => list of all wizards who have set .advertised true and players mentioned their .public_identity properties as being wizard counterparts";
wizzes = $object_utils:leaves($wiz);
wlist = {};
everyone = verb == "all_wizards_unadvertised";
for w in (wizzes)
if (w.wizard && (w.advertised || everyone))
if (is_player(w))
wlist = setadd(wlist, w);
endif
if (`is_player(w.public_identity) ! ANY')
wlist = setadd(wlist, w.public_identity);
endif
endif
endfor
return wlist;
.
#24:14
":rename_all_instances(object,oldname,newname)";
"Used to rename all instances of an unwanted verb (like recycle or disfunc)";
"if said verb is actually defined on the object itself";
if (caller_perms().wizard)
found = 0;
{object, oldname, newname} = args;
while (info = `verb_info(object, oldname) ! ANY')
`set_verb_info(object, oldname, listset(info, newname, 3)) ! ANY';
found = 1;
endwhile
return found;
else
return E_PERM;
endif
.
#24:15
if (this.record_missed_help && (callers()[1][4] == $player))
miss = args[1];
if (!(index = miss in this.missed_help_strings))
this.missed_help_strings = {miss, @this.missed_help_strings};
this.missed_help_counters = {{0, 0}, @this.missed_help_counters};
index = 1;
endif
which = args[2] ? 2 | 1;
this.missed_help_counters[index][which] = this.missed_help_counters[index][which] + 1;
endif
.
#24:16
mhs = this.missed_help_strings;
cnt = this.missed_help_counters;
"save values first, so subsequent changes during suspends wont affect it";
thresh = args ? args[1] | 5;
strs = {};
for i in [1..length(mhs)]
$command_utils:suspend_if_needed(0);
if ((cnt[i][1] + cnt[i][2]) > thresh)
strs = {@strs, ((($string_utils:right(tostr(cnt[i][1]), 5) + " ") + $string_utils:right(tostr(cnt[i][2]), 5)) + " ") + mhs[i]};
endif
endfor
sorted = $list_utils:sort_suspended(0, strs);
len = length(sorted);
player:tell(" miss ambig word");
for x in [1..len]
$command_utils:suspend_if_needed(0);
player:tell(sorted[(len - x) + 1]);
endfor
player:tell(" - - - - - - - - -");
.
#24:17
if (caller_perms().wizard)
pass(@args);
`delete_property(this, "guest_feature_restricted") ! ANY';
this.boot_exceptions = {};
this.programmer_restricted = {};
this.programmer_restricted_temp = {};
this.chparent_restricted = {};
this.rename_restricted = {};
this.change_password_restricted = {};
this.record_missed_help = 0;
this.missed_help_counters = this.missed_help_strings = {};
this.suicide_string = "You don't *really* want to commit suicide, do you?";
this.wizards = {#2};
this.next_perm_index = 1;
this.system_chars = {$hacker, $no_one, $housekeeper};
this.expiration_progress = $nothing;
this.expiration_recipient = {#2};
endif
.
#24:18
":show_netwho_listing(tell,player_list)";
" prints a listing of the indicated players showing connect sites.";
{who, unsorted} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (!unsorted)
return;
endif
su = $string_utils;
au = $ansi_utils;
alist = {};
footnotes = {};
nwidth = length("Player name");
for u in (unsorted)
$command_utils:suspend_if_needed(0);
if (u.programmer)
pref = "% ";
footnotes = setadd(footnotes, "prog");
else
pref = "  ";
endif
if (u in connected_players())
lctime = ctime(time() - connected_seconds(u));
where = $string_utils:connection_hostname(connection_name(u));
else
lctime = ctime(u.last_connect_time);
where = u.last_connect_place;
endif
u3 = {tostr(pref, su:nn(u)), lctime[5..10] + lctime[20..24]};
nwidth = max(au:length(u3[1]), nwidth);
if ($login:blacklisted(where))
where = "(*) " + where;
footnotes = setadd(footnotes, "black");
elseif ($login:graylisted(where))
where = "(+) " + where;
footnotes = setadd(footnotes, "gray");
endif
alist = {@alist, {@u3, where}};
endfor
alist = $list_utils:sort_alist_suspended(0, alist, 3);
$command_utils:suspend_if_needed(0);
headers = {"Player name", "Last Login", "From Where"};
before = {0, nwidth + 3, (nwidth + length(ctime(0))) - 11};
tell1 = "  " + headers[1];
tell2 = "  " + su:space(headers[1], "-");
for j in [2..3]
tell1 = su:left(tell1, before[j]) + headers[j];
tell2 = su:left(tell2, before[j]) + su:space(headers[j], "-");
endfor
who:notify(tell1);
who:notify(tell2);
for a in (alist)
$command_utils:suspend_if_needed(0);
tell1 = a[1];
for j in [2..3]
tell1 = su:left(tell1, before[j]) + a[j];
endfor
who:notify(tell1[1..min($, player:linelen())]);
endfor
if (footnotes)
who:notify("");
if ("prog" in footnotes)
who:notify(" %  == programmer.");
endif
if ("black" in footnotes)
who:notify("(*) == blacklisted site.");
endif
if ("gray" in footnotes)
who:notify("(+) == graylisted site.");
endif
endif
.
#24:19
":show_netwho_from_listing(tell,site)";
"@net-who from hoststring prints all players who have connected from that host or host substring.  Substring can include *'s, e.g. @net-who from *.foo.edu.";
if (!caller_perms().wizard)
return E_PERM;
endif
{tellwho, where} = args;
su = $string_utils;
if (!index(where, "*"))
"Oh good... search for users from a site... the fast way.  No wild cards.";
nl = 0;
bozos = {};
sites = $site_db:find_all_keys(where);
while (sites)
s = sites;
sites = {};
for domain in (s)
"Temporary kluge until $site_db is repaired. --Nosredna";
for b in ($site_db:find_exact(domain) || {})
$command_utils:suspend_if_needed(0, "..netwho..");
if (typeof(b) == STR)
sites = setadd(sites, (b + ".") + domain);
else
bozos = setadd(bozos, b);
nl = max(length(tostr(b, (valid(b) && is_player(b)) ? b.name | "*** recreated ***")), nl);
endif
endfor
endfor
endwhile
if (bozos)
tellwho:notify(tostr(su:left("  Player", nl + 7), "From"));
tellwho:notify(tostr(su:left("  ------", nl + 7), "----"));
for who in (bozos)
st = su:left(tostr((valid(who) && is_player(who)) ? (who.programmer ? "% " | "  ") + who.name | "", " (", who, ")"), nl + 7);
comma = 0;
if ($object_utils:isa(who, $player) && is_player(who))
for p in ({$wiz_utils:get_email_address(who) || "*Unregistered*", @who.all_connect_places})
if (comma && (length(p) >= (78 - length(st))))
tellwho:notify(tostr(st, ","));
st = su:space(nl + 7) + p;
else
st = tostr(st, comma ? ", " | "", p);
endif
comma = 1;
$command_utils:suspend_if_needed(0);
endfor
else
st = st + (valid(who) ? "*** recreated ***" | "*** recycled ***");
endif
tellwho:notify(st);
endfor
tellwho:notify("");
tellwho:notify(tostr(length(bozos), " player", (length(bozos) == 1) ? "" | "s", " found."));
else
tellwho:notify(tostr("No sites matching `", where, "'"));
endif
else
"User typed 'from'.  Go search for users from this site.  (SLOW!)";
howmany = 0;
for who in (players())
$command_utils:suspend_if_needed(0);
matches = {};
for name in (who.all_connect_places)
if ((index(where, "*") && su:match_string(name, where)) || ((!index(where, "*")) && index(name, where)))
matches = {@matches, name};
endif
endfor
if (matches)
howmany = howmany + 1;
tellwho:notify(tostr(who.name, " (", who, "): ", su:english_list(matches)));
endif
endfor
tellwho:notify(tostr(howmany || "No", " matches found."));
endif
.
#24:20
":check_player_request(name [,email [,connection]])";
" check if the request for player and email address is valid;";
" return empty string if it valid, or else a string saying why not.";
" The result starts with - if this is a 'send email, don't try again' situation.";
":check_reregistration(who, email, connection)";
"  Since name is ignored, only check the 'email' parts and use the first arg";
"  for the re-registering player.";
if (!caller_perms().wizard)
return E_PERM;
"accesses registration information -- wiz only";
endif
name = args[1];
if (verb == "check_reregistration")
"don't check player name";
elseif (!name)
return "A blank name isn't allowed.";
elseif (name == "<>")
return "Names with angle brackets aren't allowed.";
elseif (index(name, " "))
return "Names with spaces are not allowed. Use dashes or underscores.";
elseif (match(name, "^<.*>$"))
return tostr("Try using ", name[2..$ - 1], " instead of ", name, ".");
elseif ($player_db.frozen)
return "New players cannot be created at the moment, try again later.";
elseif (!$player_db:available(name))
return ("The name '" + name) + "' is not available.";
elseif ($login:_match_player(name) != $failed_match)
return ("The name '" + name) + "' doesn't seem to be available.";
endif
if (length(args) == 1)
"no email address supplied.";
return "";
endif
address = args[2];
addrargs = (verb == "check_reregistration") ? {name} | {};
if ($registration_db:suspicious_address(address, @addrargs))
return "-There has already been a character with that or a similar email address.";
endif
if (reason = $network:invalid_email_address(address))
return reason + ".";
endif
parsed = $network:parse_address(address);
if ($registration_db:suspicious_userid(parsed[1]))
return tostr("-Automatic registration from an account named ", parsed[1], " is not allowed.");
endif
connection = (length(args) > 2) ? args[3] | parsed[2];
check_connection = $wiz_utils.registration_domain_restricted && (verb == "check_player_request");
if ((connection[max($ - 2, 1)..$] == ".uk") && (parsed[2][1..3] == "uk."))
return tostr("Addresses must be in internet form. Try ", parsed[1], "@", $string_utils:from_list($list_utils:reverse($string_utils:explode(parsed[2], ".")), "."), ".");
elseif (check_connection && match(connection, "^[0-9.]+$"))
"Allow reregistration from various things we wouldn't allow registration from.  Let them register to their yahoo acct...";
return "-The system cannot resolve the name of the system you're connected from.";
elseif (check_connection && ((a = $network:local_domain(connection)) != (b = $network:local_domain(parsed[2]))))
return tostr("-The connection is from '", a, "' but the mail address is '", b, "'; these don't seem to be the same place.");
elseif ((verb == "check_player_request") && $login:spooflisted(parsed[2]))
return tostr("-Automatic registration is not allowed from ", parsed[2], ".");
endif
return "";
.
#24:21
"create a player named NAME with email address ADDRESS; return {object, password}.  Optional third arg is comment to be put in registration db.";
"assumes $wiz_utils:check_player_request() has been called and it passes.";
if (!caller_perms().wizard)
return E_PERM;
endif
{name, address, @rest} = args;
new = $quota_utils:bi_create($player_class, $nothing);
new.name = name;
new.aliases = {name};
new.password = $login:encrypt_password(password = $wiz_utils:random_password(5));
new.last_password_time = time();
new.last_connect_time = $maxint;
"Last disconnect time is creation time, until they login.";
new.last_disconnect_time = time();
$quota_utils:initialize_quota(new);
if (!(error = $wiz_utils:set_player(new)))
return player:tell("An error, ", error, " occurred while trying to make ", new, " a player. The database is probably inconsistent.");
endif
$wiz_utils:set_email_address(new, address);
$registration_db:add(new, address, @rest);
move(new, $player_start);
new.programmer = $player_class.programmer;
return {new, password};
.
#24:22
":send_new_player_mail(preface, name, address, character#, password)";
"  used by $wiz:@make-player and $guest:@request";
if (!caller_perms().wizard)
return E_PERM;
endif
{preface, name, address, new, password} = args;
msg = {preface};
msg = {@msg, tostr("A character has been created, with name \"", name, "\" and password \"", password, "\"."), "Passwords are case sensitive, which means you have to type it exactly as", "it appears here, including capital and lowercase letters.", "So, to log in, you would type:", tostr("  Connect ", name, " ", password)};
if ($object_utils:has_property($local, "new_player_message"))
msg = {@msg, @$local.new_player_message};
endif
return $network:sendmail(address, (("Your " + $network.moo_name) + " character, ") + name, "Reply-to: " + $login.registration_address, @msg);
.
#24:23
"do_maker_player(name,email,[comment])";
"Common code for @make-player";
"If no password is given, generates a random password for the player.";
"Email-address is stored in $registration_db and on the player object.";
if (!caller_perms().wizard)
return E_PERM;
endif
{name, email, @comments} = args;
comments = $string_utils:from_list(comments, " ");
reason = $wiz_utils:check_player_request(name, email);
if (others = $registration_db:find_exact(email))
player:notify(email + " is the registered address of the following characters:");
for x in (others)
player:notify(tostr(valid(x[1]) ? x[1].name | "<recycled>", (valid(x[1]) && (!is_player(x[1]))) ? " {nonplayer}" | "", " (", x[1], ") ", (length(x) > 1) ? ("[" + tostr(@x[2..$])) + "]" | ""));
endfor
if (!reason)
reason = "Already registered.";
endif
endif
if (reason)
player:notify(reason);
if (!$command_utils:yes_or_no("Create character anyway? "))
player:notify("Character not created.");
return;
endif
endif
new = $wiz_utils:make_player(name, email, comments);
player:notify(tostr(name, " (", new[1], ") created with password `", new[2], "' for ", email, comments ? (" [" + comments) + "]" | ""));
$mail_agent:send_message(player, $new_player_log, tostr(name, " (", new[1], ")"), tostr(email, comments ? " " + comments | ""));
if ($network.active)
if ($command_utils:yes_or_no(("Send email to " + email) + " with password? "))
player:notify(tostr("Sending the password to ", email, "."));
if ((result = $wiz_utils:send_new_player_mail(tostr("From ", player.name, "@", $network.moo_name, ":"), name, email, new[1], new[2])) == 0)
player:notify(tostr("Mail sent successfully to ", email, "."));
else
player:tell("Cannot send mail: ", result);
endif
else
player:notify("No mail sent.");
endif
else
player:notify("Sorry, the network isn't active.");
endif
.
#24:24
"do_register(name, email_address [,comments])";
"change player's email address.";
if (!caller_perms().wizard)
return E_PERM;
endif
{whostr, email, @comments} = args;
comments = $string_utils:from_list(comments);
who = $string_utils:match_player(whostr);
if ($command_utils:player_match_failed(who, whostr))
return;
endif
if (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))
player:notify(tostr("Must be a full name or an object number:  ", who.name, "(", who, ")"));
return;
endif
if (reason = $network:invalid_email_address(email))
player:notify(reason);
if (!$command_utils:yes_or_no("Register anyway?"))
return player:notify("re-registration aborted.");
endif
endif
if (comments)
$registration_db:add(who, email, comments);
else
$registration_db:add(who, email);
endif
old = $wiz_utils:get_email_address(who);
$wiz_utils:set_email_address(who, email);
player:notify(tostr(who.name, " (", who, ") formerly ", old ? old | "unregistered", ", registered at ", email, ".", comments ? (" [" + comments) + "]" | ""));
.
#24:25
"do_new_password(who, [password])";
if (!caller_perms().wizard)
return E_PERM;
endif
{who, ?password = $wiz_utils:random_password(6)} = args;
if (!password)
password = $wiz_utils:random_password(6);
endif
whostr = $string_utils:nn(who);
player:notify(tostr("About to change password for ", whostr, ". Old encrypted password is \"", who.password, "\""));
who.password = $login:encrypt_password(password);
who.last_password_time = time();
player:notify(tostr(whostr, " new password is `", password, "'."));
if (!$wiz_utils:get_email_address(who))
player:notify(tostr(whostr, " doesn't have a registered email_address, cannot mail password; tell them some some other way."));
elseif ((who.last_connect_time == $maxint) && $command_utils:yes_or_no(tostr(who.name, " has never logged in.  Send mail with the password as though this were a new player request?")))
if ((result = $wiz_utils:send_new_player_mail(tostr("From ", player.name, "@", $network.moo_name, ":"), who.name, $wiz_utils:get_email_address(who), who, password)) == 0)
player:tell("Mail sent.");
else
player:tell("Trouble sending mail: ", result);
endif
elseif ($command_utils:yes_or_no(tostr("Email new password to ", whostr, "?")))
player:notify("Sending the password via email.");
$network:adjust_postmaster_for_password("enter");
if ((result = $network:sendmail($wiz_utils:get_email_address(who), ("Your " + $network.moo_name) + " password", ("The password for your " + $network.moo_name) + " character:", " " + whostr, "has been changed. The new password is:", " " + password, "", "Please note that passwords are case sensitive.")) == 0)
player:tell("Mail sent.");
else
player:tell("Trouble sending mail: ", result);
endif
$network:adjust_postmaster_for_password("exit");
else
player:tell("No mail sent.");
endif
.
#24:26
":set_owner(object,newowner[,suspendok])  does object.owner=newowner, taking care of c properties as well.  This should be used anyplace one is contemplating doing object.owner=newowner, since the latter leaves ownership of c properties unchanged.  (--Rog thinks this is a server bug).";
{object, newowner, ?suspendok = 0} = args;
if (!valid(object))
return E_INVIND;
elseif (!caller_perms().wizard)
return E_PERM;
elseif (!(valid(newowner) && is_player(newowner)))
return E_INVARG;
endif
oldowner = object.owner;
object.owner = newowner;
for pname in ($object_utils:all_properties(object))
if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))
suspend(0);
endif
perms = property_info(object, pname)[2];
if (index(perms, "c"))
set_property_info(object, pname, {newowner, perms});
endif
endfor
if ($object_utils:isa(oldowner, $player))
if (is_player(oldowner) && (object != oldowner))
$quota_utils:reimburse_quota(oldowner, object);
endif
if (typeof(oldowner.owned_objects) == LIST)
oldowner.owned_objects = setremove(oldowner.owned_objects, object);
endif
endif
if ($object_utils:isa(newowner, $player))
if (object != newowner)
$quota_utils:charge_quota(newowner, object);
endif
if (typeof(newowner.owned_objects) == LIST)
newowner.owned_objects = setadd(newowner.owned_objects, object);
endif
endif
return 1;
.
#24:27
if (!caller_perms().wizard)
return E_PERM;
endif
"------- constants ---- ";
"20 minutes idle for regular players";
mintime = 60 * 20;
"10 minutes for guests";
minguest = 60 * 10;
"wait 3 minutes before actually booting";
bootdelay = 3;
"start booting when there are 20 less than max players";
threshold = 20;
" ----------------------";
if ($code_utils:task_valid(this.boot_task) && (task_id() != this.boot_task))
"starting a new one: kill the old one";
kill_task(this.boot_task);
this.boot_task = 0;
endif
fork taskn ((bootdelay * 60) * 3)
maxplayers = $login:max_connections() - threshold;
if (length(pl = connected_players()) > maxplayers)
pll = {};
plt = {};
for x in (pl)
suspend(0);
min = $object_utils:isa(x, $guest) ? minguest | mintime;
if ((((idle = `idle_seconds(x) ! ANY => 0') > min) && (!x.wizard)) && (!(x in this.boot_exceptions)))
pll = {x, @pll};
plt = {idle, @plt};
endif
endfor
if (pll)
"Sort by idle time, and choose person who has been idle longest.";
pll = $list_utils:sort(pll, plt);
booted = pll[$];
guest = $object_utils:isa(booted, $guest);
min = guest ? minguest | mintime;
if (`idle_seconds(booted) ! ANY => 0' > min)
notify(booted, tostr("*** You've been idle more than ", min / 60, " minutes, and there are more than ", maxplayers, " players connected. If you're still idle and ", $network.moo_name, " is still busy in ", bootdelay, " minute", (bootdelay == 1) ? "" | "s", ", you will be booted. ***"));
fork (60 * bootdelay)
idle = `idle_seconds(booted) ! ANY => 0';
if ((idle > min) && (length(connected_players()) > ($login:max_connections() - threshold)))
notify(booted, tostr("*** You've been idle too long and ", $network.moo_name, " is still too busy ***"));
server_log(tostr("IDLE: ", booted.name, " (", booted, ") idle ", idle / 60));
boot_player(booted);
endif
endfork
endif
endif
endif
this:(verb)(@args);
endfork
this.boot_task = taskn;
"This is set up so that it forks the task first, and this.boot_task is the task_id of whatever is running the idle booter";
.
#24:28
":grant_object(what, towhom);";
"Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).";
if (!caller_perms().wizard)
return E_PERM;
endif
{object, newowner} = args;
if (!is_player(newowner))
return E_INVARG;
endif
same = object.owner == newowner;
for vnum in [1..length(verbs(object))]
info = verb_info(object, vnum);
if (!((info[1] != object.owner) && (valid(info[1]) && is_player(info[1]))))
same = same && (info[1] == newowner);
set_verb_info(object, vnum, listset(info, newowner, 1));
endif
endfor
for prop in (properties(object))
$command_utils:suspend_if_needed(0);
info = property_info(object, prop);
if (!(index(info[2], "c") || (((info[1] != object.owner) && valid(info[1])) && is_player(info[1]))))
same = same && (info[1] == newowner);
$wiz_utils:set_property_owner(object, prop, newowner, 1);
endif
endfor
suspend(0);
$wiz_utils:set_owner(object, newowner, 1);
return same ? "nothing changed" | "grant changed";
.
#24:29
"connection_hash(forwhom, host [,seed])";
"Compute an encrypted hash of the host for 'forwhom', using 'crypt'.";
{forwhom, host, @seed} = args;
hash = toint(forwhom);
for i in [1..length(host)]
hash = (hash * 14) + index($string_utils.ascii, host[i]);
endfor
return crypt(tostr(hash), @seed);
.
#24:30
":newt_player(who [ , commentary] [, temporary])";
{who, ?comment = "", ?temporary = 0} = args;
if (!caller_perms().wizard)
$error:raise(E_PERM);
elseif (length(args) < 1)
$error:raise(E_ARGS);
elseif ((typeof(who = args[1]) != OBJ) || (!is_player(who)))
$error:raise(E_INVARG);
else
if (!comment)
player:notify("So why has this player been newted?");
comment = $command_utils:read();
endif
if (temporary)
comment = temporary + comment;
endif
$login.newted = setadd($login.newted, who);
if (msg = player:newt_victim_msg())
notify(who, msg);
endif
notify(who, $login:newt_registration_string());
boot_player(who);
player:notify(tostr(who.name, " (", who, ") has been turned into a newt."));
$mail_agent:send_message(player, $newt_log, tostr("@newt ", who.name, " (", who, ")"), {$string_utils:from_list(who.all_connect_places, " "), @comment ? {comment} | {}});
if ($object_utils:isa(who.location, $room) && (msg = player:newt_msg()))
who.location:announce_all_but({who}, msg);
endif
player:notify(tostr("Mail sent to ", $mail_agent:name($newt_log), "."));
endif
.
#24:31
":unset_programmer(victim[,reason[,start time,duration]]) => 1 or error.";
"Resets victim.programmer, adds victim to .programmer_restricted.";
"Put into temporary list if 3rd and 4th arguments are given. Which restricts the victim for uptime duration since start time. Must give a reason, though it can be blank, in this case.";
{victim, ?reason = "", ?start = 0, ?duration = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (!valid(victim))
return E_INVARG;
elseif ((!victim.programmer) && this:check_prog_restricted(victim))
return E_NONE;
else
victim.programmer = 0;
if (is_player(victim) && $object_utils:isa(victim, $player))
this.programmer_restricted = setadd(this.programmer_restricted, victim);
if (start)
this.programmer_restricted_temp = setadd(this.programmer_restricted_temp, {victim, start, duration});
endif
endif
$mail_agent:send_message(caller_perms(), {$newt_log}, tostr("@deprogrammer ", victim.name, " (", victim, ")"), reason ? (typeof(reason) == STR) ? {reason} | reason | {});
return 1;
endif
.
#24:32
":is_wizard(who) => whether `who' is a wizard or is the .public_identity of some wizard.";
"This verb is used for permission checks on commands that should only be accessible to wizards or their ordinary-player counterparts.  It will return true for unadvertised wizards.";
who = args[1];
if (who.wizard)
return 1;
else
for w in ($object_utils:leaves($wiz))
if ((w.wizard && is_player(w)) && (who == `w.public_identity ! ANY'))
return 1;
endif
endfor
endif
return 0;
.
#24:33
if (!caller_perms().wizard)
return E_PERM;
endif
this:expire_mail_lists();
this:expire_mail_players();
.
#24:34
if (!caller_perms().wizard)
return E_PERM;
endif
fork (((7 * 24) * 60) * 60)
this:(verb)();
endfork
this:expire_mail();
.
#24:35
"Checks to see if args[1] is restricted from programmer either permanently or temporarily. Removes from temporary list if time is up";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
if ((who = args[1]) in this.programmer_restricted)
"okay, who is restricted. Now check to see if it is temporary";
if (entry = $list_utils:assoc(who, this.programmer_restricted_temp))
if ($login:uptime_since(entry[2]) > entry[3])
"It's temporary and the time is up, remove and return false";
this.programmer_restricted_temp = setremove(this.programmer_restricted_temp, entry);
this.programmer_restricted = setremove(this.programmer_restricted, who);
return 0;
else
"time is not up";
return 1;
endif
else
return 1;
endif
else
return 0;
endif
.
#24:36
if (!caller_perms().wizard)
return E_PERM;
endif
s = 0;
for p in (players())
this.expiration_progress = p;
if ((p.owner == p) && is_player(p))
s = s + (p:expire_old_messages() || 0);
endif
if (ticks_left() < 10000)
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endfor
$mail_agent:send_message(player, this.expiration_recipient, verb, tostr(s, " messages have been expired from players."));
return s;
.
#24:37
if (!caller_perms().wizard)
return E_PERM;
endif
sum = 0;
for x in ($object_utils:leaves_suspended($mail_recipient))
this.expiration_progress = x;
temp = x:expire_old_messages();
if (typeof(temp) == INT)
sum = sum + temp;
endif
"just suspend for every fucker, I'm tired of losing.";
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endfor
$mail_agent:send_message(player, this.expiration_recipient, verb, tostr(sum, " messages have been expired from mailing lists."));
return sum;
.
#24:38
if (!caller_perms().wizard)
return E_PERM;
else
fork (86400 * 7)
this:(verb)();
endfork
player:tell("Flushing ancient editor sessions.");
for x in ({$verb_editor, $note_editor, $mail_editor})
x:do_flush(time() - (30 * 86400), 0);
$command_utils:suspend_if_needed(0);
endfor
endif
.
#24:39
"Put all your wizards in $wiz_utils.wizards.  Then various long-running tasks will cycle among the permissions, spreading out the scheduler-induced personal lag.";
w = this.wizards;
i = this.next_perm_index;
if (i >= length(w))
i = 1;
else
i = i + 1;
endif
this.next_perm_index = i;
return w[i];
.
#24:40
set_task_perms(caller_perms());
{who, email} = args;
if (typeof(who.email_address) == LIST)
who.email_address[1] = email;
else
who.email_address = email;
endif
.
#24:41
set_task_perms(caller_perms());
{who} = args;
if (typeof(who.email_address) == LIST)
return who.email_address[1];
else
return who.email_address;
endif
.
#25:0
return ((caller == this) || caller_perms().wizard) ? pass(@args) | E_PERM;
.
#25:1
":add(player,site)";
if (!caller_perms().wizard)
return E_PERM;
endif
{who, domain} = args;
if (this:domain_literal(domain))
"... just enter it...";
l = this:find_exact(domain);
if (l == $failed_match)
this:insert(domain, {who});
elseif (!(who in l))
this:insert(domain, setadd(l, who));
endif
else
"...an actual domain name; add player to list for that domain...";
"...then add domain itself to list for the next larger domain; repeat...";
"...  Example:  domain == foo.bar.edu:  ";
"...            enter #who  on foo.bar.edu list";
"...            enter `foo' on bar.edu list";
"...            enter `bar' on edu list";
if (!(dot = index(domain, ".")))
dot = length(domain) + 1;
domain = tostr(domain, ".", this.domain);
endif
prev = who;
while ($failed_match == (l = this:find_exact(domain)))
this:insert(domain, {prev});
if (dot)
prev = domain[1..dot - 1];
domain = domain[dot + 1..$];
else
return;
endif
dot = index(domain, ".");
endwhile
if (!(prev in l))
this:insert(domain, {@l, prev});
endif
return;
endif
.
#25:2
":load([start]) -- reloads site_db with the connection places of all players.";
"This routine calls suspend() if it runs out of time.";
"WIZARDLY";
"...needs to be able to read .all_connect_places";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
plist = players();
if (!args)
this:clearall();
elseif (i = args[1] in plist)
plist[1..i - 1] = {};
else
return E_INVARG;
endif
for p in (plist)
if (valid(p) && (is_player(p) && (!$object_utils:isa(p, $guest))))
"... player may be recycled or toaded during the suspend(),...";
"... guests login from everywhere...";
for c in (p.all_connect_places)
this:add(p, c);
if ($command_utils:running_out_of_time())
player:tell("...", p);
suspend(0);
endif
endfor
endif
endfor
.
#25:3
":domain_literal(string)";
" => true iff string is a domain literal (i.e., numeric IP address).";
if (10 <= (len = length(hnum = strsub(args[1], ".", ""))))
return toint(hnum[1..9]) && toint(hnum[6..len]);
else
return toint(hnum);
endif
"SLEAZY CODE ALERT";
"... what I wanted to do was return toint(strsub(args[1],\".\",\"\"))";
"... but on a 32-bit machine, this has a 1 in 4294967296 chance of failing";
"... (e.g., on \"42.94.967.296\", though I'll grant this particular example";
"...  entails some very strange subnetting on net 42, to say the least).";
"... So we do something that is guaranteed to work so long as internet";
"... addresses stay under 32 bits --- a while yet...";
"";
"... As soon as we're sure match() is working, this will become a one-liner:";
return match(args[1], "[0-9]+%.[0-9]+%.[0-9]+%.[0-9]+");
.
#25:4
if (caller_perms().wizard)
pass(@args);
this:clearall();
this.domain = "localdomain";
this:prune_reset();
endif
.
#25:5
"Carefully loop through the db and delete items associated with !valid and !is_player objects.  If that results in no objects remaining for a site, delete that site.";
"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.";
"Another thing it should do is be clever about string typed items.  (What did I mean by this?)";
"New feature: If the site name contains `dialup', then, if none of the users who have connected from there still have it in their .all_connect_places, then consider it trashable.  Maybe this will get some space savings.";
"To run: call $site_db:prune_reset() then $site_db:prune_alpha().";
"or $site_db:prune_alpha(1) for verbose output";
verbose = args && args[1];
if (!caller_perms().wizard)
raise(E_PERM);
endif
this.prune_task = task_id();
probe = this.prune_progress;
while ((probe <= this.prune_stop) && (length(probe) == length(this.prune_stop)))
for sitename in (z = this:find_all_keys(probe))
items = this:find_exact(sitename);
orig = items;
dialup = index(sitename, "dialup");
"Don't keep around dialups.";
for y in (items)
if ((typeof(y) == OBJ) && (((!valid(y)) || (!is_player(y))) || (dialup && (!(sitename in y.all_connect_places)))))
verbose && player:tell("removing ", $string_utils:nn(y), " from ", sitename);
items = setremove(items, y);
endif
$command_utils:suspend_if_needed(0);
endfor
useless = 1;
"If no player has this site in eir .all_connect_places, nuke it anyway.";
for y in (items)
if ((typeof(y) != OBJ) || (sitename in y.all_connect_places))
useless = 0;
break;
"unfortunately this can get kinna O(n^2).";
endif
$command_utils:suspend_if_needed(0);
endfor
if (useless)
verbose && player:tell(sitename, " declared useless and nuked");
items = {};
endif
if (!items)
this:delete(sitename);
this.total_pruned_sites = this.total_pruned_sites + 1;
elseif (items == orig)
else
this:insert(sitename, items);
this.total_pruned_people = (this.total_pruned_people + length(orig)) - length(items);
endif
$command_utils:suspend_if_needed(0);
if (probe >= this.prune_stop)
return player:tell("Prune stopped at ", toliteral(this.prune_progress));
endif
endfor
probe = $string_utils:incr_alpha(probe, this.alphabet);
this.prune_progress = probe;
if ($command_utils:running_out_of_time())
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endwhile
player:tell("Prune stopped at ", toliteral(this.prune_progress));
.
#25:6
player:tell("Prune is up to ", toliteral(this.prune_progress), ".");
mine = 0;
if (typeof(this.prune_progress) == STR)
alphalen = length(this.alphabet);
total = (alphalen * alphalen) * alphalen;
for x in [1..3]
mine = ((mine * alphalen) + index(this.alphabet, this.prune_progress[x])) - 1;
endfor
else
total = 256 * 256;
mine = (this.prune_progress[1] * 256) + this.prune_progress[2];
endif
percent = (100.0 * tofloat(mine)) / tofloat(total);
player:tell("We have processed ", mine, " entries out of ", total, ", or ", toint(percent), ".", toint(10.0 * percent) % 10, "%.");
player:tell("There were ", this.total_pruned_people, " individual list entries removed, and ", this.total_pruned_sites, " whole sites removed.");
if ($code_utils:task_valid(this.prune_task))
player:tell("Prune task is ", this.prune_task, ".  Stacktrace:");
for x in (task_stack(this.prune_task, 1))
if (valid(x[4]))
player:tell(x[4], ":", x[2], " [", x[1], "]  ", x[3].name, "  (", x[6], ")");
endif
endfor
else
player:tell("The recorded task_id is no longer valid.");
endif
.
#25:7
if (!caller_perms().wizard)
raise(E_PERM);
endif
if (!args)
for x in ({"com", "edu", "us", "au", "net", "za", "uk", "at", "ca", "org", "il", "mil", "no", "gov", "se", "fi", "it", "be", "jp", "de", "pt", "sg", "ie", "br", "nl", "gr", "ch", "pl", "nz", "<none>", "<bad>", "ee", "dk", "fr", "si", "cz", "th", "tw", "hk", "su", "es", "kr", "hr", "is", "mx", "my", "ro", "kw", "cl", "ph", "cr", "tr", "in", "eg", "ec", "lv", "ve", "sk", "ar", "co", "pe", "hu", "jm", "ni", "ru", "id", "bm", "mt", "cn", "bg", "pk", "uy", "yu", "ae", "zw", "gi", "sm", "nu"})
this:prune_fixup(x);
endfor
return;
endif
root = args[1];
items = this:find_exact(root);
orig = items;
if (items == #-3)
return 1;
endif
$site_db.prune_progress = root;
$site_db.prune_task = task_id();
for item in (items)
if (typeof(item) == STR)
if (this:prune_fixup((item + ".") + root))
items = setremove(items, item);
endif
endif
if ($command_utils:running_out_of_time())
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endfor
if (!items)
this:delete(root);
this.total_pruned_sites = this.total_pruned_sites + 1;
return 1;
elseif (orig == items)
else
this:insert(root, items);
endif
.
#25:8
"Carefully loop through the db and delete items associated with !valid and !is_player objects.  If that results in no objects remaining for a site, delete that site.";
"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.";
"Another thing it should do is be clever about string typed items.";
"Rewriting this to do numerics now.";
if (!caller_perms().wizard)
raise(E_PERM);
endif
this.prune_task = task_id();
probe = this.prune_progress;
while (probe[1] <= this.prune_stop)
probestring = tostr(probe[1], ".", probe[2], ".");
for sitename in (z = this:find_all_keys(probestring))
items = this:find_exact(sitename);
orig = items;
for y in (items)
if ((typeof(y) == OBJ) && ((!valid(y)) || (!is_player(y))))
items = setremove(items, y);
endif
$command_utils:suspend_if_needed(0);
endfor
if (!items)
this:delete(sitename);
this.total_pruned_sites = this.total_pruned_sites + 1;
elseif (items == orig)
else
this:insert(sitename, items);
this.total_pruned_people = (this.total_pruned_people + length(orig)) - length(items);
endif
$command_utils:suspend_if_needed(0);
endfor
if (probe[2] == 255)
probe[1] = probe[1] + 1;
probe[2] = 0;
else
probe[2] = probe[2] + 1;
endif
this.prune_progress = probe;
if ($command_utils:running_out_of_time())
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endwhile
player:tell("Prune stopped at ", toliteral(this.prune_progress));
.
#25:9
if (!caller_perms().wizard)
return E_PERM;
endif
day = 24 * 3600;
hour_of_day_GMT = 9;
target = (((hour_of_day_GMT * 60) * 60) + day) - (time() % day);
if (target > 86400)
target = target - 86400;
endif
fork (target)
"Stop at 2am before checkpoint.";
if ($code_utils:task_valid(this.prune_task))
$site_db.prune_stop = "aaa";
"Restart after 3am.  Er, 4am.";
suspend(7500);
this:schedule_prune();
$site_db.prune_stop = "zzz";
"Just in case it didn't actually stop...";
if (!$code_utils:task_valid(this.prune_task))
$site_db:prune_alpha();
endif
endif
endfork
.
#25:10
if (!caller_perms().wizard)
raise(E_PERM);
endif
this:report_prune_progress();
player:tell("Resetting...");
this.total_pruned_sites = 0;
this.total_pruned_people = 0;
this.prune_progress = "aaa";
this.prune_stop = "zzz";
`kill_task(this.prune_task) ! ANY';
.
#26:0
"xsin(INT x) -- calculates the taylor approximation for the sine function";
if (typeof(x = args[1]) != INT)
return E_TYPE;
endif
if ((x * x) > this.taylor)
return ((this:xsin(x / 2) * this:xcos((x + 1) / 2)) + (this:xsin((x + 1) / 2) * this:xcos(x / 2))) / 10000;
else
return (x * (17453000 - ((x * x) * 886))) / 100000;
endif
.
#26:1
"xcos(INT x) -- calculates the taylor approximation for the cosine function";
if (typeof(x = args[1]) != INT)
return E_TYPE;
endif
if ((x * x) > this.taylor)
return ((this:xcos(x / 2) * this:xcos((x + 1) / 2)) - (this:xsin(x / 2) * this:xsin((x + 1) / 2))) / 10000;
else
return (1000000000 - ((x * x) * (152309 + ((4 * x) * x)))) / 100000;
endif
.
#26:2
"factorial(INT n) -- returns n factorial for 0 <= n (<= 12).";
if ((number = args[1]) < 0)
return E_INVARG;
elseif (typeof(number) != INT)
return E_TYPE;
endif
fact = 1;
for i in [2..number]
fact = fact * i;
endfor
return fact;
.
#26:3
"fibonacci(INT n) -- calculates the fibonacci numbers to the nth term";
"and returns them in a list. n must be >= 0.";
if (typeof(n = args[1]) != INT)
return E_TYPE;
elseif (n < 0)
return E_INVARG;
elseif (n == 0)
return {0};
else
x = {0, 1};
for i in [2..n]
x = {@x, x[$ - 1] + x[$]};
endfor
return x;
endif
.
#26:4
"geometric(INT|FLOAT x [,INT n]) -- calculates the value of the geometric series at x to the nth term. i.e., approximates 1/(1-x) when |x| < 1. This, of course, is impossible in MOO, but someone may find it useful in some way.";
"n defaults to 5. n must be >= 0.";
"This verb was revised on 2006-03-16 by Gary (#110811) to allow for floating point input of the first argument.  The help documentation had said this was allowed but actually it caused a traceback.  How many people are actually using this, I wonder? ";
{n, ?order = 5} = args;
if ((!(typeof(n) in {INT, FLOAT})) || (typeof(order) != INT))
return E_TYPE;
elseif (order <= 0)
return E_INVARG;
endif
x = (typeof(n) == FLOAT) ? 1.0 | 1;
for i in [1..order]
x = x + (n ^ i);
endfor
return x;
.
#26:5
"divmod(INT n, INT d) => {q,r} such that n = dq + r";
"  handles negative numbers correctly   0<=r<d if d>0, -d<r<=0 if d<0.";
{n, d} = args;
if ((typeof(n) != INT) && (typeof(d) != INT))
return E_TYPE;
endif
r = ((n % d) + d) % d;
q = (n - r) / d;
return {q, r};
.
#26:6
"combinations(INT n, INT r) -- returns the number of ways one can choose r";
"objects from n distinct choices.";
"C(n,r) = n!/[r!(n-r)!]";
"  overflow may occur if n>29...";
{n, r} = args;
if ((typeof(n) != INT) && (typeof(r) != INT))
return E_TYPE;
endif
if (0 > (r = min(r, n - r)))
return 0;
else
c = 1;
n = n + 1;
for i in [1..r]
c = (c * (n - i)) / i;
endfor
return c;
endif
.
#26:7
"permutations(INT n, INT r) -- returns the number of ways possible for one to";
"order r distinct objects given n locations.";
"P(n,r) = n!/(n-r)!";
{n, r} = args;
if ((typeof(n) != INT) && (typeof(r) != INT))
return E_TYPE;
endif
if ((r < 1) || ((diff = n - r) < 0))
return 0;
else
p = n;
for i in [diff + 1..n - 1]
p = p * i;
endfor
return p;
endif
.
#26:8
"simpson({a,b},{f(a),f((a+b)/2),f(b)} [,INT ret-float])";
" -- given two endpoints, a and b, and the functions value at a, (a+b)/2, and b, this will calculate a numerical approximation of the integral using simpson's rule.";
"Entries can either be all INT or all FLOAT. Don't mix!";
"If the optional 3rd argument is provided and true, the answer is returned as a floating point regardless of what the input was. Otherwise, if the input was all INT, the answer is returned as {integer,fraction}";
{point, fcn, ?retfloat = 0} = args;
if ((!retfloat) && (typeof(point[1]) == INT))
numer = (point[2] - point[1]) * ((fcn[1] + (4 * fcn[2])) + fcn[3]);
return this:parts(numer, 6);
else
numer = tofloat(point[2] - point[1]) * ((tofloat(fcn[1]) + (4.0 * tofloat(fcn[2]))) + tofloat(fcn[3]));
return numer / 6.0;
endif
.
#26:9
"parts(INT n, INT q [,INT i]) -- returns a decomposition of n by q into integer and floating point parts with i = the number of digits after the decimal.";
"i defaults to 5.";
"warning: it is quite easy to hit maxint which results in unpredictable";
"         results";
{n, q, ?i = 5} = args;
if (((typeof(n) != INT) && (typeof(q) != INT)) && (typeof(i) != INT))
return E_TYPE;
endif
parts = {n / q, n % q};
return {parts[1], (parts[2] * (10 ^ i)) / q};
.
#26:10
"div(INT n, INT d) => q such that n = dq + r and  (0<=r<d if d>0, -d<r<=0 if d<0).";
return this:divmod(@args)[1];
.
#26:11
"A correct mod function.";
"mod(INT n, INT d) => r such that n = dq + r and (0<=r<d if d>0 or -d<r<=0 if d<0).";
{n, d} = args;
if ((typeof(n) != INT) && (typeof(d) != INT))
return E_TYPE;
endif
return ((n % d) + d) % d;
.
#26:12
"exp(INT|FLOAT x[,INT n]) -- calculates an nth order taylor approximation for e^x.";
"n defaults to 5. Any n given must be >= 0. you need to divide the result";
"the answer will be returned as {integer part,fractional part} if the input x was an integer. If it is floating point, so will the answer (and this uses the builtin function.)";
{x, ?n = 5} = args;
if (typeof(x) == FLOAT)
return exp(x);
elseif ((typeof(x) != INT) && (typeof(n) != INT))
return E_TYPE;
endif
ex = nfact = 1;
for i in [0..n - 1]
j = n - i;
ex = (ex * x) + (nfact = nfact * j);
endfor
return this:parts(ex, nfact);
.
#26:13
"returns 10000 exp (x/10000)";
"The accuracy seems to be ~0.1% for 0<x<4";
x = args[1];
if (x < 0)
z = this:(verb)(-x);
return (100000000 + (z / 2)) / z;
elseif (x > 1000)
z = this:(verb)(x / 2);
if (z > 1073741823)
return $maxint;
"maxint for overflows";
elseif (z > 460000)
z = ((z + 5000) / 10000) * z;
elseif (z > 30000)
z = ((((z + 50) / 100) * z) + 50) / 100;
else
z = ((z * z) + 5000) / 10000;
endif
if (x % 2)
return z + ((z + 5000) / 10000);
else
return z;
endif
else
return ((10000 + x) + (((x * x) + 10000) / 20000)) + ((((x * x) * x) + 300000000) / 600000000);
endif
.
#26:14
"random(INT n): returns a random integer in the following manner:";
"random(n > 0) will return a integer in the range 0 to n";
"random(n < 0) will return a integer in the range n to 0";
if (typeof(prob = args[1]) != INT)
return E_TYPE;
endif
mod = (prob < 0) ? -1 | 1;
return (mod * random(abs(prob + mod))) - mod;
.
#26:15
"random_range(INT range [,INT mean]): returns a random integer within the given range from the mean. if the mean isn't given, it defaults to 0";
"e.g., random_range(10) => -10..10";
"      random_range(10,4) => -6..14";
{range, ?mean = 0} = args;
if ((typeof(range) != INT) && (typeof(mean) != INT))
return E_TYPE;
endif
return mean + (((random(2) == 1) ? -1 | 1) * this:random(range));
.
#26:16
"is_prime(INT number) returns 1 if the number is prime or 0 if it isn't.";
"of course, only positive numbers are candidates for primality.";
if (typeof(number = args[1]) != INT)
return E_TYPE;
endif
if (number == 2)
return 1;
elseif ((number < 2) || ((number % 2) == 0))
return 0;
else
max = toint(ceil(sqrt(tofloat(number))));
choice = 3;
while (choice <= max)
if ((seconds_left() < 2) || (ticks_left() < 25))
suspend(0);
endif
if ((number % choice) == 0)
return 0;
endif
choice = choice + 2;
endwhile
endif
return 1;
.
#26:17
return -(1 + args[1]);
"";
"... here's what it used to be ...";
bl1 = this:BLFromInt(args[1]);
blOut = {};
for i in [1..32]
blOut = {@blOut, !bl1[i]};
endfor
return this:IntFromBL(blOut);
.
#26:18
"BlFromInt(INT x) => converts the number provided into a 32 bit binary number, which is returned via a 32 element LIST of 1's and 0's. Note that this verb was originally written to be used with the $math_utils verbs: AND, NOT, OR, XOR, but has since been taken out of them.";
if (typeof(x = args[1]) != INT)
return E_TYPE;
endif
l = {};
firstbit = x < 0;
if (firstbit)
x = x + $minint;
endif
for i in [1..31]
l = {x % 2, @l};
x = x / 2;
endfor
return {firstbit, @l};
.
#26:19
"IntFromBl(LIST of 1's and 0's) => converts the 32 bit binary representation given by the list of 1's and 0's and converts it to a normal decimal number. Note that this verb was originally written to be used with the $math_utils verbs: AND, NOT, OR, XOR, but has since been taken out of them.";
bl = args[1];
x = 0;
for l in (bl)
x = x * 2;
x = x + l;
endfor
return x;
.
#26:20
"gcd(INT num1,INT num2): find the greatest common divisor of the two numbers";
"using the division algorithm. the absolute values of num1 and num2 are";
"used without loss of generality.";
num1 = abs(args[1]);
num2 = abs(args[2]);
max = max(num1, num2);
min = min(num1, num2);
if (r1 = max % min)
while (r2 = min % r1)
min = r1;
r1 = r2;
endwhile
return r1;
else
return min;
endif
.
#26:21
"lcm(INT num1,INT num2): find the least common multiple of the two numbers.";
"we shall use the positive lcm value without loss of generality.";
"since we have gcd already, we'll just use lcm*gcd = num1*num2";
num1 = abs(args[1]);
num2 = abs(args[2]);
return (num1 * num2) / this:gcd(num1, num2);
.
#26:22
"are_rel_prime(INT num1,INT num2): returns 1 if num1 and num2 are relatively";
"prime.";
"since we have gcd, this is pretty easy.";
if (this:gcd(args[1], args[2]) == 1)
return 1;
else
return 0;
endif
.
#26:23
"Synopsis:    :base_conversion(number, current_base, desired_base)";
"---";
"Call with first arg either a number or a string, being the number";
"desired for conversion. capital letters denote values from 10-35;";
"lowercase letters from 36 to 61. Maximal base is 62.";
"You will be unable to use the extra 26 lowercases as separate unless";
"you pass a nonzero fourth argument. Passing zero or none uses the";
"default value, which is to have AAAA=aaaa.";
"The second and third arguments should be the base of the number and";
"the base you want it in, respectively.";
"Any of the arguments can be strings or nums, but high-base numbers";
"will need to be strings. This returns a string.";
"Any problems, talk to Ozymandias.";
sensitive = 0;
if (length(args) < 3)
return E_INVARG;
elseif (length(args) == 4)
sensitive = toint(args[4]);
endif
result = 0;
thenum = tostr(args[1]);
origbase = toint(args[2]);
newbase = toint(args[3]);
if ((((origbase < 2) || (newbase < 2)) || (origbase > 62)) || (newbase > 62))
return E_INVARG;
endif
for which in [1..length(thenum)]
value = index(this.base_alphabet, thenum[which], sensitive);
if ((!value) || (value > origbase))
return E_INVARG;
endif
result = ((result * origbase) + value) - 1;
endfor
thestring = "";
if (result < 0)
return E_INVARG;
endif
while (result)
if ((which = (result % newbase) + 1) <= length(this.base_alphabet))
thestring = this.base_alphabet[which] + thestring;
else
return E_INVARG;
endif
result = result / newbase;
endwhile
return thestring ? thestring | "0";
.
#26:24
":norm(a,b,c,d...) => sqrt(a^2+b^2+c^2+...)";
m = max(max(@args), -min(@args));
logm = length(tostr(m));
if (logm <= 4)
s = 0;
for a in (args)
s = s + (a * a);
endfor
return toint(sqrt(tofloat(s)));
else
factor = toint("1" + "0000000"[1..logm - 4]);
s = 0;
for a in (args)
a = a / factor;
s = s + (a * a);
endfor
return toint(sqrt(tofloat(s))) * factor;
endif
.
#26:25
"Copied from Trig_Utils (#25800):sin by Obvious (#54879) Fri Nov 17 06:07:39 1995 PST";
theta = args[1];
if (typeof(theta) == FLOAT)
return sin(theta);
elseif (typeof(theta) == INT)
degtheta = theta % 360;
mintheta = 0;
elseif (typeof(theta) == LIST)
degtheta = theta[1] % 360;
mintheta = theta[2] % 60;
else
return E_INVARG;
endif
if (mintheta < 0)
mintheta = mintheta + 60;
degtheta = degtheta - 1;
endif
while (degtheta < 1)
degtheta = degtheta + 360;
endwhile
if (mintheta == 0)
return this.sines[degtheta];
endif
lim1 = this.sines[degtheta];
lim2 = this.sines[degtheta + 1];
delta = lim2 - lim1;
result = (((delta * mintheta) + 30) / 60) + lim1;
return result;
.
#26:26
"Copied from Trig_Utils (#25800):cos by Obvious (#54879) Fri Nov 17 06:07:50 1995 PST";
theta = args[1];
if (typeof(theta) == FLOAT)
return cos(theta);
elseif (typeof(theta) == INT)
degtheta = 90 - theta;
mintheta = 0;
elseif (typeof(theta) == LIST)
degtheta = 89 - theta[1];
mintheta = 60 - theta[2];
else
return;
endif
return this:sin({degtheta, mintheta});
.
#26:27
"Copied from Trig_Utils (#25800):tan by Obvious (#54879) Fri Nov 17 06:07:53 1995 PST";
{theta} = args;
if (typeof(theta) == FLOAT)
return tan(theta);
endif
sine = this:sin(theta);
cosine = this:cos(theta);
return ((sine * 10000) + ((cosine + 1) / 2)) / cosine;
.
#26:28
"Copied from Trig_Utils (#25800):arcsin by Obvious (#54879) Fri Nov 17 06:08:01 1995 PST";
{given} = args;
if (typeof(given) == FLOAT)
return asin(given);
endif
given = abs(given);
if (given > 10000)
return E_RANGE;
endif
i = 1;
while (given > this.sines[i])
i = i + 1;
endwhile
if (given == this.sines[i])
if (args[1] < 0)
return {-i, 0};
else
return {i, 0};
endif
endif
degrees = i - 1;
if (i == 1)
lower = 0;
else
lower = this.sines[i - 1];
endif
upper = this.sines[i];
delta1 = given - lower;
delta2 = upper - lower;
minutes = ((delta1 * 60) + ((delta2 + 1) / 2)) / delta2;
if (args[1] < 0)
degrees = -degrees;
minutes = -minutes;
endif
return {degrees, minutes};
.
#26:29
"Copied from Trig_Utils (#25800):arccos by Obvious (#54879) Fri Nov 17 06:08:08 1995 PST";
given = args[1];
if (typeof(given) == FLOAT)
return acos(given);
endif
arcsin = this:arcsin(given);
degrees = 89 - arcsin[1];
minutes = 60 - arcsin[2];
"//* Changed (minutes > 60) to (minutes >= 60) following bug report by Loufah (#116455).  2000-03-24 23:00 CST  Gary (#110811).";
if (minutes >= 60)
minutes = minutes - 60;
degrees = degrees + 1;
endif
return {degrees, minutes};
.
#26:30
"Copied from Trig_Utils (#25800):arctan by Obvious (#54879) Fri Nov 17 06:08:18 1995 PST";
given = args[1];
if (typeof(given) == FLOAT)
return atan(given);
endif
reciprocal = ((given * given) / 10000) + 10000;
reciprocal = sqrt(reciprocal * 10000);
cosine = 100000000 / reciprocal;
return this:arccos(cosine);
.
#26:31
":deg2rad(FLOAT Degrees) => FLOAT Radians";
return tofloat(args[1]) * 0.0174532925199433;
.
#26:32
":rads2deg(FLOAT Radians) => FLOAT Degrees";
return tofloat(args[1]) * 57.2957795130824;
.
#26:33
":precision(FLOAT Number, INT Digits of Precision) => FLOAT Number";
"Cuts the given number to the given digits of precision.  Uses rounding.";
{digits, pre} = args;
mult = 10.0 ^ pre;
return this:rint(digits * mult) / mult;
.
#26:34
"Usage: round(INT number, INT round)";
"Rounds 'number' off to the nearest multiple of 'round'.";
"Rounds UP numbers exactly half way in between two round possibilities.";
{what, round} = args;
low = (what / round) * round;
return (what < (low + (round / 2))) ? low | (low + round);
.
#26:35
"Usage: mean(INT, INT, ... )";
"       mean({INT, INT, ...})";
"Returns the average of all integers provided.";
return this:sum(rlist = (typeof(args[1]) == LIST) ? args[1] | args) / length(rlist);
.
#26:36
":sum_float(FLOAT num, num, num ...) => Total of all arguments added together.";
":sum_float({num, num, num, ...}) will also work.";
{?total = 0.0, @rest} = args;
if (typeof(total) == LIST)
{?total = 0.0, @rest} = total;
endif
for number in (rest)
total = total + number;
endfor
return total;
.
#26:37
":sum_int(INT num, num, num ...) => Total of all arguments added together.";
":sum_int({num, num, num, ...}) will also work.";
"(...also named :sum for backward compatibility).";
"Use :sum_float to sum a list of floats.";
{?total = 0, @rest} = args;
if (typeof(total) == LIST)
{?total = 0, @rest} = total;
endif
for number in (rest)
total = total + number;
endfor
return total;
"... N.B.  For the sake of backward compatibility this routine will also return the float sum of a non-empty lists of floats, but using it this way should not be encouraged.";
.
#26:38
":rint(FLOAT Number) => FLOAT Number";
"Returns the given floating-point number rounded to the nearest integer, as a floating-point number.  In case of ties, rounds away from 0.";
{f} = args;
return trunc((f > 0.0) ? f + 0.5 | (f - 0.5));
.
#26:39
{per1, per2} = args;
return (tofloat(per1) / tofloat(per2)) * 100.0;
.
#27:0
"Returns the set union of all of the lists provided as arguments.";
if (!args)
return {};
endif
{set, @rest} = args;
for l in (rest)
for x in (l)
set = setadd(set, x);
endfor
endfor
return set;
.
#27:1
"Returns the set intersection of all the lists provided as arguments.";
if (!args)
return {};
endif
max = 0;
{result, @rest} = args;
for set in (rest)
if (length(result) < length(set))
set1 = result;
set2 = set;
else
set1 = set;
set2 = result;
endif
for x in (set1)
if (!(x in set2))
set1 = setremove(set1, x);
endif
endfor
result = set1;
endfor
return result;
.
#27:2
"Usage:  diff(set 1, set 2, ..., set n)";
"Returns all elements of set 1 that are not in sets 2..n";
{set, @rest} = args;
for l in (rest)
for x in (l)
set = setremove(set, x);
endfor
endfor
return set;
.
#27:3
"True if the first list given is a superset of all subsequent lists.";
"False otherwise.  {} is a superset of {} and nothing else; anything is";
"a superset of {}.  If only one list is given, return true.";
{?super = {}, @rest} = args;
for l in (rest)
for x in (l)
if (!(x in super))
return 0;
endif
endfor
endfor
return 1;
.
#27:4
"Usage:  exclusive_or(set, set, ...)";
"Return the set of all elements that are in exactly one of the input sets";
"For two sets, this is the equivalent of (A u B) - (A n B).";
if (!args)
return {};
endif
{set, @rest} = args;
so_far = set;
for l in (rest)
for x in (l)
if (x in so_far)
set = setremove(set, x);
else
set = setadd(set, x);
endif
endfor
so_far = {@so_far, @l};
endfor
return set;
.
#27:5
"Usage:  diff_suspended(set 1, set 2, ..., set n)";
"Returns all elements of set 1 that are not in sets 2..n";
"Suspends as needed if the lists are large.";
{set, @rest} = args;
for l in (rest)
for x in (l)
set = setremove(set, x);
$command_utils:suspend_if_needed(0);
endfor
endfor
return set;
.
#27:6
"True if the two lists given contain the same elements.";
"False otherwise.";
{set1, set2} = args;
while (set1)
{elt, @set1} = set1;
if (elt in set2)
set2 = setremove(set2, elt);
while (elt in set2)
set2 = setremove(set2, elt);
endwhile
while (elt in set1)
set1 = setremove(set1, elt);
endwhile
else
return 0;
endif
endwhile
if (set2)
return 0;
else
return 1;
endif
.
#27:7
"Copied from Fox (#54902):intersection Mon Dec 27 17:02:57 1993 PST";
"a version of $set_utils:intersection that maintains the property that everything in the return value is in the first argument, even considering case";
if (!args)
return {};
endif
{result, @rest} = args;
for s in (rest)
for x in (result)
if (!(x in s))
result = setremove(result, x);
endif
endfor
endfor
return result;
.
#29:0
if (caller_perms().wizard)
pass(@args);
this.mail_notify = {player};
player:set_current_message(this, 0, 0, 1);
this.moderated = 1;
else
return E_PERM;
endif
.
#29:1
if (!this:is_writable_by(caller_perms()))
return E_PERM;
else
if (msgs = this.messages)
new = msgs[$][1] + 1;
else
new = 1;
endif
if (rmsgs = this.messages_going)
lbrm = rmsgs[$][2];
new = max(new, lbrm[$][1] + 1);
endif
m = args[1];
if (index(m[4], "@programmer ") == 1)
m = {m[1], toobj(args[2]), o = $mail_agent:parse_address_field(m[4])[1], o.name};
endif
this.messages = {@msgs, {new, m}};
this.last_msg_date = m[1];
this.last_used_time = time();
return new;
endif
.
#29:2
":display_seq_headers(msg_seq[,cur])";
":display_seq_full(msg_seq[,cur]) => {cur}";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{msg_seq, ?cur = 0, ?read_date = $maxint} = args;
last = ldate = 0;
player:tell("       WHEN           ", $string_utils:left(this.keyword, -30), "BY");
for x in (msgs = this:messages_in_seq(args[1]))
msgnum = $string_utils:right(last = x[1], 4, (cur == x[1]) ? ">" | " ");
ldate = x[2][1];
if (typeof(x[2][2]) != OBJ)
hdr = this:msg_summary_line(@x[2]);
else
if (ldate < (time() - 31536000))
c = player:ctime(ldate);
date = c[5..11] + c[21..25];
else
date = player:ctime(ldate)[5..16];
endif
hdr = tostr(ctime(ldate)[5..16], "   ", $string_utils:left(tostr(x[2][4], " (", x[2][3], ")"), 30), valid(w = x[2][2]) ? w.name | "??", " (", x[2][2], ")");
endif
player:tell(msgnum, (ldate > read_date) ? ":+ " | ":  ", hdr);
$command_utils:suspend_if_needed(0);
endfor
if (verb == "display_seq_full")
return {last, ldate};
else
player:tell("----+");
endif
.
#29:3
":from_msg_seq(object or list[,mask])";
" => msg_seq of messages from any of these senders";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{plist, ?mask = {1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
i = 1;
fseq = {};
for msg in (this.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
if (msg[2][2] in plist)
fseq = $seq_utils:add(fseq, i, i);
endif
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
.
#29:4
":to_msg_seq(object or list[,mask]) => msg_seq of messages to those people";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{plist, ?mask = {1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
i = 1;
fseq = {};
for msg in (this.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
if (msg[2][3] in plist)
fseq = $seq_utils:add(fseq, i, i);
endif
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages about @programmer'ing " + $string_utils:english_list(plist, "no one", " or "));
.
#29:5
":%to_msg_seq/subject_msg_seq(string or list of strings[,mask])";
" => msg_seq of messages containing one of strings in the to line";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{nlist, ?mask = {1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
i = 1;
fseq = {};
for msg in (this.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
if (msg[2][4] in nlist)
fseq = $seq_utils:add(fseq, i, i);
endif
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages about @programmer'ing " + $string_utils:english_list(nlist, "no one", " or "));
.
#29:6
return this.name + " doesn't understand %%from:";
.
#30:0
"WIZARDLY";
if (args)
"...check for an exact match first...";
search = args[1];
if (`$object_utils:has_property(parent(this), search) ! ANY')
if ($object_utils:has_property(this, " " + search))
return {search};
endif
elseif ($object_utils:has_property(this, search))
return {search};
endif
"...search for partial matches, allowing for";
"...confusion between topics that do and don't start with @, and";
".. confusion between - and _ characters.";
props = properties(this);
topics = {};
if (search[1] == "@")
search = search[2..$];
endif
search = strsub(search, "-", "_");
if (!search)
"...don't try searching for partial matches if the string is empty or @";
"...we'd get *everything*...";
return {};
endif
for prop in (props)
if (((i = index(strsub(prop, "-", "_"), search)) == 1) || ((i == 2) && index(" @", prop[1])))
topics = {@topics, (prop[1] == " ") ? prop[2..$] | prop};
endif
endfor
return topics;
else
"...return list of all topics...";
props = setremove(properties(this), "");
for p in (`$object_utils:all_properties(parent(this)) ! ANY => {}')
if (i = (" " + p) in props)
props = {p, @listdelete(props, i)};
endif
endfor
return props;
endif
.
#30:1
"WIZARDLY";
{topic, ?dblist = {}} = args;
if (`$object_utils:has_property(parent(this), topic) ! ANY')
text = `this.(" " + topic) ! ANY';
else
text = `this.(topic) || this.(" " + topic) ! ANY';
endif
if (typeof(text) == LIST)
if (text && (text[1] == (("*" + (vb = strsub(text[1], "*", ""))) + "*")))
text = `this:(vb)(listdelete(text, 1), dblist) ! ANY';
endif
endif
return text;
.
#30:2
":sort_topics(list_of_topics) -- sorts the given list of strings, assuming that they're help-system topic names";
buckets = "abcdefghijklmnopqrstuvwxyz";
keys = names = $list_utils:make(length(buckets) + 1, {});
for name in (setremove(args[1], ""))
key = index(".@", name[1]) ? name[2..$] + " " | name;
k = index(buckets, key[1]) + 1;
bucket = keys[k];
i = $list_utils:find_insert(bucket, key);
keys[k] = listinsert(bucket, key, i);
names[k] = listinsert(names[k], name, i);
$command_utils:suspend_if_needed(0);
endfor
return $list_utils:append(@names);
.
#30:3
":columnize(@list_of_strings) -- prints the given list in a number of columns wide enough to accomodate longest entry. But no more than 4 columns.";
longest = $list_utils:longest(args);
for d in ({4, 3, 2, 1})
if ((79 / d) >= length(longest))
return $string_utils:columnize_suspended(0, args, d);
endif
endfor
.
#30:4
"{\"*forward*\", topic, @rest}  => text for topic from this help db.";
"{\"*pass*\",    topic, @rest}  => text for topic from next help db.";
"In both cases the text of @rest is appended.  ";
"@rest may in turn begin with a *<verb>*";
{text, ?dblist = {}} = args;
if (verb == "forward")
first = this:get_topic(text[1], dblist);
elseif ((result = $code_utils:help_db_search(text[1], dblist)) && ((db = result[1]) != $ambiguous_match))
first = db:get_topic(result[2], dblist[(db in dblist) + 1..$]);
else
first = {};
endif
if (2 <= length(text))
if (text[2] == (("*" + (vb = strsub(text[2], "*", ""))) + "*"))
return {@first, @`this:(vb)(text[3..$], dblist) ! ANY => {}'};
else
return {@first, @text[2..$]};
endif
else
return first;
endif
.
#30:5
"{\"*subst*\", @text} => text with the following substitutions:";
"  \"...%[expr]....\" => \"...\"+value of expr (assumed to be a string)+\"....\"";
"  \"%;expr\"         => @(value of expr (assumed to be a list of strings))";
newlines = {};
for old in (args[1])
new = "";
bomb = 0;
while ((prcnt = index(old, "%")) && (prcnt < length(old)))
new = new + old[1..prcnt - 1];
code = old[prcnt + 1];
old = old[prcnt + 2..$];
if (code == "[")
prog = "";
while ((b = index(old + "]", "]")) > (p = index(old + "%", "%")))
prog = (prog + old[1..p - 1]) + old[p + 1];
old = old[p + 2..$];
endwhile
prog = prog + old[1..b - 1];
old = old[b + 1..$];
value = $no_one:eval_d(prog);
if (value[1])
new = tostr(new, value[2]);
else
new = tostr(new, toliteral(value[2]));
bomb = 1;
endif
elseif ((code != ";") || new)
new = (new + "%") + code;
else
value = $no_one:eval_d(old);
if (value[1] && (typeof(r = value[2]) == LIST))
newlines = {@newlines, @r[1..$ - 1]};
new = tostr(r[$]);
else
new = tostr(new, toliteral(value[2]));
bomb = 1;
endif
old = "";
endif
endwhile
if (bomb)
newlines = {@newlines, new + old, tostr("@@@ Helpfile alert:  Previous line is messed up; notify ", this.owner.wizard ? "" | tostr(this.owner.name, " (", this.owner, ") or "), "a wizard. @@@")};
else
newlines = {@newlines, new + old};
endif
endfor
return newlines;
.
#30:6
"{\"*index*\" [, title]}";
"This produces a columnated list of topics in this help db, headed by title.";
$command_utils:suspend_if_needed(0);
title = args[1] ? args[1][1] | tostr(this.name, " (", this, ")");
su = $string_utils;
return {"", title, su:from_list($list_utils:map_arg(su, "space", su:explode(title), "-"), " "), @this:columnize(@this:sort_topics(this:find_topics()))};
.
#30:7
pass(@args);
if ($perm_utils:controls(caller_perms(), this))
this.r = 1;
this.f = 0;
endif
.
#30:8
"{\"*verbdoc*\", \"object\", \"verbname\"}  use documentation for this verb";
set_task_perms(this.owner);
if (!valid(object = $string_utils:match_object(args[1][1], player.location)))
return E_INVARG;
elseif (!(hv = $object_utils:has_verb(object, vname = args[1][2])))
return E_VERBNF;
else
return $code_utils:verb_documentation(hv[1], vname);
endif
.
#30:9
try
text = this.(fulltopic = args[1]);
return {tostr(";;", $code_utils:corify_object(this), ".(", toliteral(fulltopic), ") = $command_utils:read_lines()"), @$command_utils:dump_lines(text)};
except error (ANY)
return error[1];
endtry
.
#30:10
"{\"*objectdoc*\", \"object\"} => text for topic from object:help_msg";
if (!valid(object = $string_utils:literal_object(args[1][1])))
return E_INVARG;
elseif (!($object_utils:has_verb(object, "help_msg") || $object_utils:has_property(object, "help_msg")))
return E_VERBNF;
else
return $code_utils:verb_or_property(object, "help_msg");
endif
.
#30:11
":find_index_topic([search])";
"Return the list of index topics of this help DB";
"(i.e., those which contain an index (list of topics)";
"this DB, return it, otherwise return false.";
"If search argument is given and true,";
"we first remove any cached information concerning index topics.";
{?search = 0} = args;
if (this.index_cache && (!search))
"...make sure every topic listed in .index_cache really is an index topic";
for p in (this.index_cache)
if (!("*index*" in `this.(p) ! ANY => {}'))
search = 1;
endif
endfor
if (!search)
return this.index_cache;
endif
elseif ($generic_help == this)
return {};
endif
itopics = {};
for p in (properties(this))
if ((h = `this.(p) ! ANY') && ("*index*" in h))
itopics = {@itopics, p};
endif
endfor
this.index_cache = itopics;
return itopics;
.
#31:0
if (!caller_perms().wizard)
return;
endif
player = this;
this:notify(tostr("Sorry, but you've been here for ", $string_utils:from_seconds(connected_seconds(this)), " and someone else wants to be a guest now.  Feel free to come back", @$login:player_creation_enabled(player) ? {" or even create your own character if you want..."} | {" or type `create' to learn more about how to get a character of your own."}));
"boot_player(this)";
return;
"See #0:user_reconnected.";
.
#31:1
if ((((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (cp != this)) && (caller != #0))
return E_PERM;
endif
"Don't let another guest use this one until all this is done. See :defer, Ho_Yan 1/19/94";
this.free_to_use = 0;
this:log_disconnect();
this:erase_paranoid_data();
try
if (this.location != this.home)
this:room_announce(player.name, " has disconnected.");
this:room_announce($string_utils:pronoun_sub($housekeeper.take_away_msg, this, $housekeeper));
move(this, this.home);
this:room_announce($string_utils:pronoun_sub($housekeeper.drop_off_msg, this, $housekeeper));
endif
finally
this:do_reset();
this.free_to_use = 1;
endtry
.
#31:2
"Called by #0:connect_player when this object is about to be used as the next guest character.  Usually returns `this', but if for some reason some other guest character should be used, that player object is returned instead";
if (!caller_perms().wizard)
"...caller is not :do_login_command; doesn't matter what we return...";
return this;
elseif ($login:blacklisted($string_utils:connection_hostname(player)))
return #-2;
elseif (!(this in connected_players()))
"...not logged in, no problemo...";
return this;
endif
longest = 900;
"...guests get 15 minutes before they can be dislodged...";
candidate = #-1;
free = {};
for g in ($object_utils:leaves($guest))
if (!is_player(g))
"...a toaded guest?...";
elseif ((!(con = g in connected_players())) && g.free_to_use)
"...yay; found an unused guest...and their last :disfunc is complete";
free = {@free, g};
elseif (con && ((t = connected_seconds(g)) > longest))
longest = t;
candidate = g;
endif
endfor
if (free)
candidate = free[random($)];
elseif (valid(candidate))
"...someone's getting bumped...";
candidate:boot();
endif
return candidate;
.
#31:3
return;
.
#31:4
if ($login:player_creation_enabled(player))
player:tell("First @quit, then connect to the MOO again and, rather than doing `connect guest' do `create <name> <password>'");
else
player:tell($login:registration_string());
endif
.
#31:5
return pass(@args);
.
#31:6
":log(islogin,time,where) adds an entry to the connection log for this guest.";
if (caller != this)
return E_PERM;
elseif (length(this.connect_log) < this.max_connect_log)
this.connect_log = {args, @this.connect_log};
else
this.connect_log = {args, @this.connect_log[1..this.max_connect_log - 1]};
endif
.
#31:7
if ((((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (cp != this)) && (caller != #0))
return E_PERM;
else
$guest_log:enter(1, time(), $string_utils:connection_hostname(this));
ret = pass(@args);
this:tell_lines(this:extra_confunc_msg());
return ret;
endif
.
#31:8
if (caller != this)
return E_PERM;
else
$guest_log:enter(0, time(), $string_utils:connection_hostname((this in connected_players(1)) ? this | this.last_connect_place));
endif
.
#31:9
if (!valid(caller_perms()))
player:tell("Sorry, that information is not available.");
endif
.
#31:10
if (caller_perms() != this)
return E_PERM;
else
return pass(@args);
endif
.
#31:11
return pass(@args);
.
#31:12
return pass(@args);
"only for setting permission";
.
#31:13
if (caller_perms().wizard)
pass(@args);
this.extra_confunc_msg = "";
endif
.
#31:14
"disallow guests from setting aliases on themselves";
if ($perm_utils:controls(caller_perms(), this))
return pass(@args);
else
return E_PERM;
endif
.
#31:15
return $string_utils:pronoun_sub(this.(verb));
.
#31:16
if (!caller_perms().wizard)
return E_PERM;
else
flush_input(this, 0);
for x in ({"paranoid", "lines", "responsible", "linelen", "linebuffer", "brief", "gaglist", "rooms", "pagelen", "current_message", "current_folder", "messages", "messages_going", "request", "mail_options", "edit_options", "home", "spurned_objects", "web_info", "ansi_options", "replace_codes"})
if ($object_utils:has_property(parent(this), x))
clear_property(this, x);
endif
endfor
this:set_description(this.default_description);
this:set_gender(this.default_gender);
for x in (this.contents)
this:eject(x);
endfor
for x in (this.features)
if (!(x in $guest.features))
this:remove_feature(x);
endif
endfor
for x in ($guest.features)
if (!(x in this.features))
this:add_feature(x);
endif
endfor
for x in ($object_utils:descendants($generic_editor))
if (loc = this in x.active)
x:kill_session(loc);
endif
endfor
endif
.
#31:17
"Usage:  @request <player-name> for <email-address>";
if (player != this)
return player:tell(E_PERM);
endif
if (this.request)
return player:tell("Sorry, you appear to have already requested a character.");
endif
name = dobjstr;
if ((prepstr != "for") || ((!dobjstr) || index(address = iobjstr, " ")))
return player:notify_lines($code_utils:verb_usage());
endif
if ($login:request_character(player, name, address))
this.request = 1;
endif
"Copied from Generic Guest (#5678):@request by Froxx (#49853) Mon Apr  4 10:49:26 1994 PDT";
.
#31:18
"Compute an encrypted hash of the guest's (last) connection, using 'crypt'. Basically, you can't tell where the guest came from, but it is unlikely that two guests will have the same hash";
"You can use guest:connection_name_hash(seed) as a string to identify whether two guests are from the same place.";
hash = toint(caller_perms());
host = $string_utils:connection_hostname(this.last_connect_place);
for i in [1..length(host)]
hash = (hash * 14) + index($string_utils.ascii, host[i]);
endfor
return crypt(tostr(hash), @args);
.
#31:19
if ((caller_perms() != $nothing) && (caller_perms() != player))
return E_PERM;
endif
if (!args)
all_mlists = {@$mail_agent.contents, @this.mail_lists};
if ((length(all_mlists) > 50) && (!$command_utils:yes_or_no(tostr("There are ", length(all_mlists), " mailing lists.  Are you sure you want the whole list?"))))
return player:tell("OK, aborting.");
endif
for c in (all_mlists)
$command_utils:suspend_if_needed(0);
if ((c:is_usable_by(this) || c:is_readable_by(this)) && (verb != "@unsubscribed"))
`c:look_self(1) ! ANY';
endif
endfor
player:tell("--End of List--");
else
player:tell("Sorry, Guests don't have full mailing privileges.  You may use @read and @peek for mailing lists.  Or try @request to get yourself a character.");
endif
"Paragraph (#122534) - Tue Nov 8, 2005 - Added to prevent a silly traceback from occuring, since Guests can't read their own .current_message.";
.
#31:20
if (caller_perms() in {this, this.owner})
return pass(@args);
else
return E_PERM;
endif
.
#31:21
if ((caller_perms().wizard || (caller_perms() in {this, this.owner})) || (caller == this))
return pass(@args);
else
return E_PERM;
endif
.
#32:0
return (spellcheck(args[1]) == 1) || (args[1] in player.dict);
.
#32:1
set_task_perms(caller_perms());
source = args[1];
data = {};
ref = $code_utils:parse_propref(source);
if (ref)
"User entered a prop. Deal with it.";
{thing, prop} = ref;
thing = $string_utils:match_object(thing, player.location);
if (!valid(thing))
player:tell("No such object: ", ref[1]);
data = $failed_match;
elseif ((!prop) || (`thing.(tostr(prop)) ! ANY' == E_PROPNF))
player:tell("There is no such property `", prop, "' on object ", thing, ".");
data = $failed_match;
else
data = `thing.(tostr(prop)) ! ANY';
if (typeof(data) == STR)
data = {data};
endif
$command_utils:suspend_if_needed(3);
if (typeof(data) == ERR)
player:tell("Error: ", tostr(data));
data = $failed_match;
elseif (typeof(data) != LIST)
player:tell("Spellchecker needs a string or list as input.");
data = $failed_match;
endif
endif
else
ref = $code_utils:parse_verbref(source);
if (ref)
"User entered a verb. Deal with it.";
{thing, verb} = ref;
thing = $string_utils:match_object(thing, player.location);
if (!valid(thing))
player:tell("No such object: ", ref[1]);
data = $failed_match;
elseif (`verb_info(thing, verb) ! ANY' == E_VERBNF)
player:tell("There is no such verb `", verb, "' on object ", thing, ".");
data = $failed_match;
else
data = `verb_code(thing, verb) ! ANY => {}';
for i in [1..length(data)]
if (!index(data[i], "\""))
data[i] = "";
else
data[i] = data[i][index(data[i], "\"") + 1..$];
data[i] = data[i][1..rindex(data[i], "\"") - 1];
foo = "";
while (index(data[i], "\""))
foo = foo + data[i][1..index(data[i], "\"") - 1];
foo = foo + " ";
data[i] = data[i][index(data[i], "\"") + 1..$];
data[i] = data[i][index(data[i], "\"") + 1..$];
endwhile
if (foo == "")
foo = data[i];
else
foo = foo + data[i];
endif
data[i] = $string_utils:trim(foo);
endif
endfor
endif
else
"User entered word/phrase on command line.";
data = {argstr};
endif
endif
for i in [1..length(data)]
$command_utils:suspend_if_needed(1);
if (typeof(data[i]) != STR)
data[i] = "";
endif
data[i] = $string_utils:strip_chars(data[i], "!@#$%^&*()_+1234567890={}[]`<>?:;,./|\"~'");
endfor
return data;
.
#32:2
{nastyword} = args;
guesses = spellcheck(nastyword);
"Transpose adjacent characters";
nastyword = nastyword + " ";
for i in [1..length(nastyword) - 1]
foo = ((nastyword[1..i - 1] + nastyword[i + 1]) + nastyword[i]) + nastyword[i + 2..$];
foo = $string_utils:trim(foo);
if (this:valid(foo))
guesses = setadd(guesses, foo);
endif
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
nastyword = $string_utils:trim(nastyword);
"Erase each character - check for an extra typoed character";
for i in [1..length(nastyword)]
foo = nastyword[1..i - 1] + nastyword[i + 1..$];
if (this:valid(foo))
guesses = setadd(guesses, foo);
endif
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
"Alter one character";
for i in [1..length(nastyword)]
for ii in ({"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "'", "-"})
foo = (nastyword[1..i - 1] + ii) + nastyword[i + 1..$];
if (this:valid(foo))
guesses = setadd(guesses, foo);
endif
endfor
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
"insert one character";
for i in [1..length(nastyword)]
for ii in ({"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "'", "-"})
foo = (nastyword[1..i - 1] + ii) + nastyword[i..$];
if (this:valid(foo))
guesses = setadd(guesses, foo);
endif
endfor
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
"Clean up and go home";
guesses = $list_utils:sort(guesses);
return guesses;
.
#32:3
return this.description;
.
#32:4
return this;
.
#33:0
"   add(seq,start[,end]) => seq with range added.";
"remove(seq,start[,end]) => seq with range removed.";
"  both assume start<=end.";
remove = verb == "remove";
seq = args[1];
start = args[2];
s = (start == $minint) ? 1 | $list_utils:find_insert(seq, start - 1);
if (length(args) < 3)
return {@seq[1..s - 1], @((s + remove) % 2) ? {start} | {}};
else
e = $list_utils:find_insert(seq, after = args[3] + 1);
return {@seq[1..s - 1], @((s + remove) % 2) ? {start} | {}, @((e + remove) % 2) ? {after} | {}, @seq[e..$]};
endif
.
#33:1
":contains(seq,elt) => true iff elt is in seq.";
return ($list_utils:find_insert(@args) + 1) % 2;
.
#33:2
":complement(seq[,lower[,upper]]) => the sequence containing all integers *not* in seq.";
"If lower/upper are given, the resulting sequence is restricted to the specified range.";
"Bad things happen if seq is not a subset of [lower..upper]";
{seq, ?lower = $minint, ?upper = $nothing} = args;
if (upper != $nothing)
if (seq[$] >= (upper = upper + 1))
seq[$..$] = {};
else
seq[$ + 1..$] = {upper};
endif
endif
if (seq && (seq[1] <= lower))
return listdelete(seq, 1);
else
return {lower, @seq};
endif
.
#33:3
":union(seq1,seq2,...)        => union of all sequences...";
if ({} in args)
args = $list_utils:setremove_all(args, {});
endif
if (length(args) <= 1)
return args ? args[1] | {};
endif
return this:_union(@args);
.
#33:4
"tostr(seq [,delimiter]) -- turns a sequence into a string, delimiting ranges with delimiter, defaulting to .. (e.g. 5..7)";
{seq, ?separator = ".."} = args;
if (!seq)
return "empty";
endif
e = tostr((seq[1] == $minint) ? "" | seq[1]);
len = length(seq);
for i in [2..len]
e = e + ((i % 2) ? tostr(", ", seq[i]) | ((seq[i] == (seq[i - 1] + 1)) ? "" | tostr(separator, seq[i] - 1)));
endfor
return e + ((len % 2) ? separator | "");
.
#33:5
":for([n,]seq,obj,verb,@args) => for s in (seq) obj:verb(s,@args); endfor";
set_task_perms(caller_perms());
if (typeof(n = args[1]) == INT)
args = listdelete(args, 1);
else
n = 1;
endif
{seq, object, vname, @args} = args;
if (seq[1] == $minint)
return E_RANGE;
endif
for r in [1..length(seq) / 2]
for i in [seq[(2 * r) - 1]..seq[2 * r] - 1]
if (typeof(object:(vname)(@listinsert(args, i, n))) == ERR)
return;
endif
endfor
endfor
if (length(seq) % 2)
i = seq[$];
while (1)
if (typeof(object:(vname)(@listinsert(args, i, n))) == ERR)
return;
endif
i = i + 1;
endwhile
endif
.
#33:6
"extract(seq,array) => list of elements of array with indices in seq.";
{seq, array} = args;
if (alen = length(array))
e = $list_utils:find_insert(seq, 1);
s = $list_utils:find_insert(seq, alen);
seq = {@(e % 2) ? {} | {1}, @seq[e..s - 1], @(s % 2) ? {} | {alen + 1}};
ret = {};
for i in [1..length(seq) / 2]
$command_utils:suspend_if_needed(0);
ret = {@ret, @array[seq[(2 * i) - 1]..seq[2 * i] - 1]};
endfor
return ret;
else
return {};
endif
.
#33:7
seq = args[1];
if (!seq)
return {};
else
if (length(seq) % 2)
seq = {@seq, $minint};
endif
l = {};
for i in [1..length(seq) / 2]
for j in [seq[(2 * i) - 1]..seq[2 * i] - 1]
l = {@l, j};
endfor
endfor
return l;
endif
.
#33:8
":fromlist(list) => corresponding sequence.";
return this:from_sorted_list($list_utils:sort(args[1]));
.
#33:9
":from_sorted_list(sorted_list) => corresponding sequence.";
if (!(lst = args[1]))
return {};
else
seq = {i = lst[1]};
next = i + 1;
for i in (listdelete(lst, 1))
if (i != next)
seq = {@seq, next, i};
endif
next = i + 1;
endfor
return (next == $minint) ? seq | {@seq, next};
endif
.
#33:10
return (seq = args[1]) ? seq[1] | E_NONE;
.
#33:11
return (seq = args[1]) ? (length(seq) % 2) ? $minint - 1 | (seq[$] - 1) | E_NONE;
.
#33:12
":size(seq) => number of elements in seq";
"  for sequences consisting of more than half of the 4294967298 available integers, this returns a negative number, which can either be interpreted as (cardinality - 4294967298) or -(size of complement sequence)";
n = 0;
for i in (seq = args[1])
n = i - n;
endfor
return (length(seq) % 2) ? $minint - n | n;
.
#33:13
":from_string(string) => corresponding sequence or E_INVARG";
"  string should be a comma separated list of numbers and";
"  number..number ranges";
su = $string_utils;
if (!(words = su:explode(su:strip_chars(args[1], " "), ",")))
return {};
endif
parts = {};
for word in (words)
to = index(word, "..");
if ((!to) && su:is_numeric(word))
part = {toint(word), toint(word) + 1};
elseif (to)
if (to == 1)
start = $minint;
elseif (su:is_numeric(start = word[1..to - 1]))
start = toint(start);
else
return E_INVARG;
endif
end = word[to + 2..length(word)];
if (!end)
part = {start};
elseif (!su:is_numeric(end))
return E_INVARG;
elseif ((end = toint(end)) >= start)
part = {start, end + 1};
else
part = {};
endif
else
return E_INVARG;
endif
parts = {@parts, part};
endfor
return this:union(@parts);
.
#33:14
":firstn(seq,n) => first n elements of seq as a sequence.";
if ((n = args[2]) <= 0)
return {};
endif
l = length(seq = args[1]);
s = 1;
while (s <= l)
n = n + seq[s];
if ((s >= l) || (n <= seq[s + 1]))
return {@seq[1..s], n};
endif
n = n - seq[s + 1];
s = s + 2;
endwhile
return seq;
.
#33:15
":lastn(seq,n) => last n elements of seq as a sequence.";
n = args[2];
if ((l = length(seq = args[1])) % 2)
return {$minint - n};
else
s = l;
while (s)
n = seq[s] - n;
if (n >= seq[s - 1])
return {n, @seq[s..l]};
endif
n = seq[s - 1] - n;
s = s - 2;
endwhile
return seq;
endif
.
#33:16
":range(start,end) => sequence corresponding to [start..end] range";
return ((start = args[1]) <= (end = args[2])) ? {start, end + 1} | {};
.
#33:17
":expand(seq,eseq[,include=0])";
"eseq is assumed to be a finite sequence consisting of intervals ";
"[f1..a1-1],[f2..a2-1],...  We map each element i of seq to";
"  i               if               i < f1";
"  i+(a1-f1)       if         f1 <= i < f2-(a1-f1)";
"  i+(a1-f1+a2-f2) if f2-(a1-f1) <= i < f3-(a2-f2)-(a1-f1)";
"  ...";
"returning the resulting sequence if include=0,";
"returning the resulting sequence unioned with eseq if include=1;";
{old, insert, ?include = 0} = args;
exclude = !include;
if (!insert)
return old;
elseif ((length(insert) % 2) || (insert[1] == $minint))
return E_TYPE;
endif
olast = length(old);
ilast = length(insert);
"... find first o for which old[o] >= insert[1]...";
ifirst = insert[i = 1];
o = $list_utils:find_insert(old, ifirst - 1);
if (o > olast)
return ((olast % 2) == exclude) ? {@old, @insert} | old;
endif
new = old[1..o - 1];
oe = old[o];
diff = 0;
while (1)
"INVARIANT: oe == old[o]+diff";
"INVARIANT: oe >= ifirst == insert[i]";
"... at this point we need to dispose of the interval ifirst..insert[i+1]";
if (oe == ifirst)
new = {@new, insert[i + ((o % 2) == exclude)]};
if (o >= olast)
return ((olast % 2) == exclude) ? {@new, @insert[i + 2..ilast]} | new;
endif
o = o + 1;
else
if ((o % 2) != exclude)
new = {@new, @insert[i..i + 1]};
endif
endif
"... advance i...";
diff = (diff + insert[i + 1]) - ifirst;
if ((i = i + 2) > ilast)
for oe in (old[o..olast])
new = {@new, oe + diff};
endfor
return new;
endif
ifirst = insert[i];
"... find next o for which old[o]+diff >= ifirst )...";
while ((oe = old[o] + diff) < ifirst)
new = {@new, oe};
if (o >= olast)
return ((olast % 2) == exclude) ? {@new, @insert[i..ilast]} | new;
endif
o = o + 1;
endwhile
endwhile
.
#33:18
":contract(seq,cseq)";
"cseq is assumed to be a finite sequence consisting of intervals ";
"[f1..a1-1],[f2..a2-1],...  From seq, we remove any elements that ";
"are in those ranges and map each remaining element i to";
"  i               if       i < f1";
"  i-(a1-f1)       if a1 <= i < f2";
"  i-(a1-f1+a2-f2) if a2 <= i < f3 ...";
"returning the resulting sequence.";
"";
"For any finite sequence cseq, the following always holds:";
"  :contract(:expand(seq,cseq,include),cseq)==seq";
{old, removed} = args;
if (!removed)
return old;
elseif (((rlen = length(removed)) % 2) || (removed[1] == $minint))
return E_TYPE;
endif
rfirst = removed[1];
ofirst = $list_utils:find_insert(old, rfirst - 1);
new = old[1..ofirst - 1];
diff = 0;
rafter = removed[r = 2];
for o in [ofirst..olast = length(old)]
while (old[o] > rafter)
if ((o - ofirst) % 2)
new = {@new, rfirst - diff};
ofirst = o;
endif
diff = (diff + rafter) - rfirst;
if (r >= rlen)
for oe in (old[o..olast])
new = {@new, oe - diff};
endfor
return new;
endif
rfirst = removed[r + 1];
rafter = removed[r = r + 2];
endwhile
if (old[o] < rfirst)
new = {@new, old[o] - diff};
ofirst = o + 1;
endif
endfor
return ((olast - ofirst) % 2) ? new | {@new, rfirst - diff};
.
#33:19
":_union(seq,seq,...)";
"assumes all seqs are nonempty and that there are at least 2";
nargs = length(args);
"args  -- list of sequences.";
"nexts -- nexts[i] is the index in args[i] of the start of the first";
"         interval not yet incorporated in the return sequence.";
"heap  -- a binary tree of indices into args/nexts represented as a list where";
"         heap[1] is the root and the left and right children of heap[i]";
"         are heap[2*i] and heap[2*i+1] respectively.  ";
"         Parent index h is <= both children in the sense of args[h][nexts[h]].";
"         heap[i]==0 indicates a nonexistant child; we fill out the array with";
"         zeros so that length(heap)>2*length(args).";
"...initialize heap...";
heap = {0, 0, 0, 0, 0};
nexts = {1, 1};
hlen2 = 2;
while (hlen2 < nargs)
nexts = {@nexts, @nexts};
heap = {@heap, @heap};
hlen2 = hlen2 * 2;
endwhile
for n in [-nargs..-1]
s1 = args[i = -n][1];
while ((hleft = heap[2 * i]) && (s1 > (m = min(la = args[hleft][1], (hright = heap[(2 * i) + 1]) ? args[hright][1] | $maxint))))
if (m == la)
heap[i] = hleft;
i = 2 * i;
else
heap[i] = hright;
i = (2 * i) + 1;
endif
endwhile
heap[i] = -n;
endfor
"...";
"...find first interval...";
h = heap[1];
rseq = {args[h][1]};
if (length(args[h]) < 2)
return rseq;
endif
current_end = args[h][2];
nexts[h] = 3;
"...";
while (1)
if (length(args[h]) >= nexts[h])
"...this sequence has some more intervals in it...";
else
"...no more intevals left in this sequence, grab another...";
h = heap[1] = heap[nargs];
heap[nargs] = 0;
if ((nargs = nargs - 1) > 1)
elseif (args[h][nexts[h]] > current_end)
return {@rseq, current_end, @args[h][nexts[h]..$]};
elseif ((i = $list_utils:find_insert(args[h], current_end)) % 2)
return {@rseq, current_end, @args[h][i..$]};
else
return {@rseq, @args[h][i..$]};
endif
endif
"...";
"...sink the top sequence...";
i = 1;
first = args[h][nexts[h]];
while ((hleft = heap[2 * i]) && (first > (m = min(la = args[hleft][nexts[hleft]], (hright = heap[(2 * i) + 1]) ? args[hright][nexts[hright]] | $maxint))))
if (m == la)
heap[i] = hleft;
i = 2 * i;
else
heap[i] = hright;
i = (2 * i) + 1;
endif
endwhile
heap[i] = h;
"...";
"...check new top sequence ...";
if (args[h = heap[1]][nexts[h]] > current_end)
"...hey, a new interval! ...";
rseq = {@rseq, current_end, args[h][nexts[h]]};
if (length(args[h]) <= nexts[h])
return rseq;
endif
current_end = args[h][nexts[h] + 1];
nexts[h] = nexts[h] + 2;
else
"...first interval overlaps with current one ...";
i = $list_utils:find_insert(args[h], current_end);
if (i % 2)
nexts[h] = i;
elseif (i > length(args[h]))
return rseq;
else
current_end = args[h][i];
nexts[h] = i + 1;
endif
endif
endwhile
.
#33:20
":intersection(seq1,seq2,...) => intersection of all sequences...";
if ((U = {$minint}) in args)
args = $list_utils:setremove_all(args, U);
endif
if (length(args) <= 1)
return args ? args[1] | U;
endif
return this:complement(this:_union(@$list_utils:map_arg(this, "complement", args)));
.
#34:0
if (caller_perms().wizard)
pass(@args);
this.mail_notify = {player};
player:set_current_message(this, 0, 0, 1);
this.moderated = 1;
else
raise(E_PERM);
endif
.
#35:0
"$you:verb_sub(STR verbspec) -> returns verbspec conjugated for singular use as if `you' were saying it.";
return $gender_utils:get_conj(args[1], this);
x = args[1];
len = length(x);
if ((len > 3) && (rindex(x, "n't") == (len - 3)))
return this:verb_sub(x[1..len - 3]) + "n't";
endif
for y in (this.conjugations)
if (x == y[1])
return y[2];
endif
endfor
for y in ({{"ches", "ch"}, {"ies", "y"}, {"sses", "ss"}, {"shes", "sh"}, {"s", ""}})
if ((len > length(y[1])) && (rindex(x, y[1]) == ((len - length(y[1])) + 1)))
return x[1..len - length(y[1])] + y[2];
endif
endfor
return x;
.
#35:1
"$you:say_action(message [,who [,thing, [,where [, excluding-whom]]]])";
"announce 'message' with pronoun substitution as if it were just ";
"  where:announce_all_but(excluding-whom, ";
"    $string_utils:pronoun_sub(message, who, thing, where));";
"except that who (player), dobj, and iobj get modified messages, with the appropriate use of 'you' instead of their name, and except that `excluding-whom' isn't really a valid variable name.";
"who       default player";
"thing     default object that called this verb";
"where     default who.location";
"excluding default {}";
{msg, ?who = player, ?thing = caller, ?where = who.location, ?excluding = {}} = args;
you = this;
if (typeof(msg) == LIST)
tell = "";
for x in (msg)
tell = tell + ((typeof(x) == STR) ? x | x[random(length(x))]);
endfor
else
tell = msg;
endif
if (!(who in excluding))
who:tell($string_utils:pronoun_sub(this:fixpos(tell, "%n"), you, thing, where));
endif
if ($object_utils:has_callable_verb(where, "announce_all_but"))
where:announce_all_but({dobj, who, iobj, @excluding}, $string_utils:pronoun_sub(tell, who, thing, where));
endif
if ((valid(dobj) && (dobj != who)) && (!(dobj in excluding)))
x = dobj;
dobj = you;
x:tell($string_utils:pronoun_sub(this:fixpos(tell, "%d"), who, thing, where));
dobj = x;
endif
if (valid(iobj) && (!(iobj in {who, dobj, @excluding})))
x = iobj;
iobj = you;
x:tell($string_utils:pronoun_sub(this:fixpos(tell, "%i"), who, thing, where));
iobj = x;
endif
.
#35:2
"This is horribly dwimmy.  E.g. %x's gets turned into your, %X's gets turned into Your, and %X'S gets turned into YOUR. --Nosredna";
upper = $string_utils:uppercase(args[2]);
allupper = upper + "'S";
upper = upper + "'s";
lower = $string_utils:lowercase(args[2]) + "'s";
return strsub(strsub(strsub(args[1], lower, "your", 1), upper, "Your", 1), allupper, "YOUR", 1);
.
#35:3
"Copied from you (#67923):reflexive [verb author Blob (#21528)] at Wed Jul 13 05:09:32 2005 PDT";
":reflexive(msg, %[di])";
"Make a message reflexive by replacing %d or %i with %r.";
{msg, pos} = args;
upper = $string_utils:uppercase(pos) + "'s";
lower = $string_utils:lowercase(pos) + "'s";
msg = strsub(msg, lower, "%p", 1);
msg = strsub(msg, upper, "%P", 1);
msg = strsub(msg, pos, "%r", 1);
msg = strsub(msg, $string_utils:uppercase(pos), "%R", 1);
return msg;
.
#35:4
"$you:say_action(message [,who [,thing, [,where [, excluding-whom]]]])";
"announce 'message' with pronoun substitution as if it were just ";
"  where:announce_all_but(excluding-whom, ";
"    $string_utils:pronoun_sub(message, who, thing, where));";
"except that who (player), dobj, and iobj get modified messages, with the appropriate use of 'you' instead of their name, and except that `excluding-whom' isn't really a valid variable name.";
"who       default player";
"thing     default object that called this verb";
"where     default who.location";
"excluding default {}";
{msg, ?who = player, ?thing = caller, ?where = who.location, ?excluding = {}} = args;
you = this;
if (typeof(msg) == LIST)
tell = "";
for x in (msg)
tell = tell + ((typeof(x) == STR) ? x | x[random(length(x))]);
endfor
else
tell = msg;
endif
if (who == dobj)
tell = this:reflexive(tell, "%d");
endif
if (who == iobj)
tell = this:reflexive(tell, "%i");
endif
if (!(who in excluding))
msg = tell;
x = dobj;
y = iobj;
dobj = (dobj == who) ? you | dobj;
iobj = (iobj == who) ? you | iobj;
who:tell($string_utils:pronoun_sub(this:fixpos(msg, "%n"), you, thing, where));
dobj = x;
iobj = y;
endif
if ($object_utils:has_callable_verb(where, "announce_all_but"))
where:announce_all_but({dobj, who, iobj, @excluding}, $string_utils:pronoun_sub(tell, who, thing, where));
endif
if ((valid(dobj) && (dobj != who)) && (!(dobj in excluding)))
x = dobj;
y = iobj;
msg = this:fixpos(tell, "%d");
if (dobj == iobj)
iobj = you;
msg = this:fixpos(msg, "%i");
endif
dobj = you;
x:tell($string_utils:pronoun_sub(msg, who, thing, where));
dobj = x;
iobj = y;
endif
if (valid(iobj) && (!(iobj in {who, dobj, @excluding})))
x = iobj;
iobj = you;
x:tell($string_utils:pronoun_sub(this:fixpos(tell, "%i"), who, thing, where));
iobj = x;
endif
.
#36:0
if (caller_perms().wizard)
pass(@args);
this.mail_forward = {$owner};
endif
.
#37:0
"find(string[,n]) => datum corresponding to string with the search starting at node \" \"+string[1..n], n defaults to 0 (root node), $ambiguous_match or $failed_match";
"find_key(string[,n]) is like :find but returns the full string key rather than the associated datum.  Note that if several string keys present in the db share a common prefix, :find_key(prefix) will return $ambiguous_match, but if there is a unique datum associated with all of these strings :find(prefix) will return it rather than $ambiguous_match.";
"Assumes n<=length(string)";
{search, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
data = (verb == "find") ? this.data | 3;
if (i = search in info[3])
"...exact match for one of the strings in this node...";
return info[data][i];
elseif (index(info[1], rest) == 1)
"...ambiguous iff there's more than one object represented in this node..";
return this:_only(prefix, data);
elseif (index(rest, info[1]) != 1)
"...search string doesn't agree with common portion...";
return $failed_match;
elseif (index(info[2], search[nsofar = (sofar + length(info[1])) + 1]))
"...search string follows one of continuations leading to other nodes...";
return this:(verb)(search, nsofar);
else
"...search string may partially match one of the strings in this node...";
for i in [1..length(exacts = info[3])]
if (index(exacts[i], search) == 1)
return info[data][i];
endif
endfor
return $failed_match;
endif
.
#37:1
{search, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
if (i = search in info[3])
return info[this.data][i];
elseif ((length(rest) <= (common = length(info[1]))) || (rest[1..common] != info[1]))
return $failed_match;
elseif (index(info[2], search[(sofar + common) + 1]))
return this:find_exact(search, (sofar + common) + 1);
else
return $failed_match;
endif
.
#37:2
":find_all(string [,n=0])";
"assumes n <= length(string)";
{search, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
data = (verb == "find_all") ? this.data | 3;
if (index(info[1], rest) == 1)
"...return entire subtree.";
return this:((data == 3) ? "_every_key" | "_every")(prefix);
elseif (index(rest, info[1]) != 1)
"...common portion doesn't agree.";
return {};
elseif (index(info[2], rest[1 + (common = length(info[1]))]))
"...matching strings are in a subnode.";
return this:(verb)(search, (sofar + common) + 1);
else
"...matching string is in info[3].  length(rest) > common,";
"...so there will be at most one matching string.";
for i in [1..length(info[3])]
if (index(info[3][i], search) == 1)
return {info[data][i]};
endif
endfor
return {};
endif
.
#37:3
":_only(prefix,data) => if all strings in this node have the same datum, return it, otherwise, return $ambiguous_match.";
if (caller != this)
raise(E_PERM);
endif
{prefix, data} = args;
info = this.(" " + prefix);
if (data == 3)
"... life is much simpler if there's no separate datum.";
"... if there's more than one string here, we barf.";
if (info[2] || (length(info[3]) > 1))
return $ambiguous_match;
elseif (info[3])
return info[3][1];
else
"..this can only happen with the root node of an empty db.";
return $failed_match;
endif
elseif (info[2])
what = this:_only(tostr(prefix, info[1], info[2][1]), data);
if (what == $ambiguous_match)
return what;
endif
elseif (info[data])
what = info[data][1];
info[data] = listdelete(info[data], 1);
else
"..this can only happen with the root node of an empty db.";
return $failed_match;
endif
for x in (info[data])
if (what != x)
return $ambiguous_match;
endif
endfor
for i in [2..length(info[2])]
if (what != this:_only(tostr(prefix, info[1], info[2][i]), data))
return $ambiguous_match;
endif
endfor
return what;
.
#37:4
if (caller != this)
raise(E_PERM);
endif
info = this.(" " + args[1]);
prefix = args[1] + info[1];
r = $list_utils:remove_duplicates(info[4]);
for i in [1..length(branches = info[2])]
for new in (this:_every(prefix + branches[i]))
r = setadd(r, new);
endfor
endfor
return r;
.
#37:5
if (caller != this)
raise(E_PERM);
endif
info = this.(" " + args[1]);
prefix = args[1] + info[1];
r = info[3];
for i in [1..length(branches = info[2])]
for new in (this:_every_key(prefix + branches[i]))
r = setadd(r, new);
$command_utils:suspend_if_needed(0);
endfor
$command_utils:suspend_if_needed(0);
endfor
return r;
.
#37:6
":insert([n,]string,datum) -- inserts <string,datum> correspondence into tree starting at node \" \"+string[1..n], n defaulting to 0 (root node).";
"Assumes length(string) >= n";
"Returns {old_datum} (or 1) if there was a <string,old_datum> correspondence there before, otherwise returns 0";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
has_datum = this.data > 3;
if (typeof(sofar = args[1]) == INT)
search = args[2];
datum = has_datum ? args[3] | 0;
else
search = sofar;
sofar = 0;
datum = has_datum ? args[2] | 0;
endif
prefix = search[1..sofar];
info = this.(" " + prefix);
if (i = search in info[3])
"... exact match ...";
if (has_datum)
previous = {info[this.data][i]};
info[this.data][i] = datum;
this:set_node(prefix, @info);
return previous;
else
return 1;
endif
endif
rest = search;
rest[1..sofar] = "";
if (index(rest, info[1]) != 1)
"... find where new string disagrees with common portion...";
c = $string_utils:common(rest, info[1]) + 1;
"... make a new node with a shorter common portion....";
this:make_node(prefix + info[1][1..c], @listset(info, info[1][c + 1..$], 1));
this:set_node(prefix, info[1][1..c - 1], info[1][c], {search}, @has_datum ? {{datum}} | {});
return 0;
elseif (rest == info[1])
".. new string == common portion, insert...";
info[3] = {@info[3], search};
if (has_datum)
info[this.data] = {@info[this.data], datum};
endif
this:set_node(prefix, @info);
return 0;
elseif (index(info[2], search[nsofar = (sofar + length(info[1])) + 1]))
"... new string matches pre-existing continuation. insert in subnode....";
return this:insert(nsofar, search, datum);
else
"... new string may blow away one of the exact matches (i.e., matches one of them up to the first character beyond the common portion) in which case we need to create a new subnode....";
s = search[1..nsofar];
for m in (info[3])
if (index(m, s) == 1)
i = m in info[3];
"... we know m != search ...";
"... string m has been blown away.  create new node ...";
cbegin = cafter = length(s) + 1;
cend = $string_utils:common(search, m);
this:make_node(s, m[cbegin..cend], "", {search, m}, @has_datum ? {{datum, info[this.data][i]}} | {});
this:set_node(prefix, info[1], info[2] + s[nsofar], listdelete(info[3], i), @has_datum ? {listdelete(info[this.data], i)} | {});
return 0;
endif
endfor
"... new string hasn't blown away any of the exact matches, insert it as a new exact match...";
info[3] = {search, @info[3]};
if (has_datum)
info[this.data] = {datum, @info[this.data]};
endif
this:set_node(prefix, @info);
return 0;
endif
.
#37:7
":delete(string[,n]) deletes any <string,something> pair from the tree starting at node \" \"+string[1..n], n defaulting to 0 (root node)";
"Returns {something} if such a pair existed, otherwise returns 0";
"If that node is not the root node and ends up containing only one string and no subnodes, we kill it and return {something,string2,something2} where <string2,something2> is the remaining pair.";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
{search, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
if (i = search in info[3])
previous = {info[this.data][i]};
info[3] = listdelete(info[3], i);
if (this.data > 3)
info[this.data] = listdelete(info[this.data], i);
endif
elseif ((rest == info[1]) || ((index(rest, info[1]) != 1) || (!index(info[2], search[d = (sofar + length(info[1])) + 1]))))
"... hmm string isn't in here...";
return 0;
elseif ((previous = this:delete(search, d)) && (length(previous) > 1))
i = index(info[2], search[d]);
info[2][i..i] = "";
info[3] = {previous[2], @info[3]};
if (this.data > 3)
info[this.data] = {previous[3], @info[this.data]};
endif
previous = previous[1..1];
else
return previous;
endif
if ((!prefix) || ((length(info[3]) + length(info[2])) != 1))
this:set_node(prefix, @info);
return previous;
elseif (info[3])
this:kill_node(prefix);
return {@previous, info[3][1], info[this.data][1]};
else
sub = this.(" " + (p = tostr(prefix, info[1], info[2])));
this:kill_node(p);
this:set_node(prefix, @listset(sub, tostr(info[1], info[2], sub[1]), 1));
return previous;
endif
.
#37:8
":delete2(string,datum[,n]) deletes the pair <string,datum> from the tree starting at node \" \"+string[1..n], n defaulting to 0 (root node)";
"Similar to :delete except that if the entry for that string has a different associated datum, it will not be removed.  ";
":delete2(string,datum) is equivalent to ";
" ";
"  if(this:find_exact(string)==datum) ";
"    this:delete(string); ";
"  endif";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
{search, datum, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
if (i = search in info[3])
previous = {info[this.data][i]};
if (previous[1] != datum)
return previous;
endif
info[3] = listdelete(info[3], i);
if (this.data > 3)
info[this.data] = listdelete(info[this.data], i);
endif
elseif ((rest == info[1]) || ((index(rest, info[1]) != 1) || (!index(info[2], search[d = (sofar + length(info[1])) + 1]))))
"... hmm string isn't in here...";
return 0;
elseif ((previous = this:delete2(search, datum, d)) && (length(previous) > 1))
i = index(info[2], search[d]);
info[2][i..i] = "";
info[3] = {previous[2], @info[3]};
if (this.data > 3)
info[this.data] = {previous[3], @info[this.data]};
endif
previous = previous[1..1];
else
return previous;
endif
if ((!prefix) || ((length(info[3]) + length(info[2])) != 1))
this:set_node(prefix, @info);
return previous;
elseif (info[3])
this:kill_node(prefix);
return {@previous, info[3][1], info[this.data][1]};
else
sub = this.(" " + (p = tostr(prefix, info[1], info[2])));
this:kill_node(p);
this:set_node(prefix, @listset(sub, tostr(info[1], info[2], sub[1]), 1));
return previous;
endif
.
#37:9
return (caller != this) ? E_PERM | (this.(" " + args[1]) = listdelete(args, 1));
.
#37:10
"WIZARDLY";
return (caller != this) ? E_PERM | add_property(this, " " + args[1], listdelete(args, 1), {$generic_db.owner, this.node_perms});
.
#37:11
"WIZARDLY";
return (caller != this) ? E_PERM | delete_property(this, " " + args[1]);
.
#37:12
"WIZARDLY";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
if (args && ((d = args[1]) in {3, 4}))
this.data = d;
endif
root = {"", "", {}, @(this.data > 3) ? {{}} | {}};
"...since the for loop contains a suspend, we want to keep people";
"...from getting at properties which are now garbage but which we";
"...haven't had a chance to wipe yet.  Somebody might yet succeed";
"...in adding something; thus we have the outer while loop.";
this:set_node("", 37);
while (this.(" ") != root)
this:set_node("", @root);
for p in (properties(this))
if ((p[1] == " ") && (p != " "))
delete_property(this, p);
endif
"...Bleah; db is inconsistent now....";
"...At worst someone will add something that references an";
"...existing property.  He will deserve to die...";
$command_utils:suspend_if_needed(0);
endfor
endwhile
.
#37:13
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
this:_kill_subtrees("", 0);
this:clearall(@args);
.
#37:14
":_kill_subtree(node,count)...wipes out all subtrees";
"...returns count + number of nodes removed...";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
info = this.(" " + (prefix = args[1]));
count = args[2];
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", count);
suspend(0);
endif
for i in [1..length(info[2])]
count = this:_kill_subtrees(n = tostr(prefix, info[1], info[2][i]), count) + 1;
this:kill_node(n);
endfor
return count;
.
#37:15
info = this.(" " + (prefix = (args || {""})[1]));
depth = 0;
string = prefix;
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", prefix);
suspend(0);
endif
for i in [1..length(info[2])]
if ((r = this:depth(tostr(prefix, info[1], info[2][i])))[1] > depth)
depth = r[1];
string = r[2];
endif
endfor
return {depth + 1, string};
.
#37:16
info = this.(" " + (prefix = args[1]));
count = length(info[3]) + args[2];
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", count);
suspend(0);
endif
for i in [1..length(info[2])]
count = this:count_entries(tostr(prefix, info[1], info[2][i]), count);
endfor
return count;
.
#37:17
info = this.(" " + (prefix = args[1]));
count = args[2];
for s in (info[3])
count = count + length(s);
endfor
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", count);
suspend(0);
endif
for i in [1..length(info[2])]
count = this:count_chars(tostr(prefix, info[1], info[2][i]), count);
endfor
return count;
.
#37:18
"count [entries|chars] in <db>";
"  reports on the number of distinct string keys or the number of characters";
"  in all string keys in the db";
if (index("entries", dobjstr) == 1)
player:tell(this:count_entries("", 0), " strings in ", this.name, "(", this, ")");
elseif (index("chars", dobjstr) == 1)
player:tell(this:count_chars("", 0), " chars in ", this.name, "(", this, ")");
else
player:tell("Usage: ", verb, " entries|chars in <db>");
endif
.
#37:19
"Create a stand-in for the core-extraction process";
"  (rather than change the ownership on 80000 properties only to delete them).";
{core_variant, is_mcd} = args;
if (!is_mcd)
return this;
elseif (caller != #0)
raise(E_PERM);
elseif (children(this) || (length(properties(this)) < 100))
return this;
endif
proxy = $recycler:_create(parent(this), this.owner);
player:tell("Creating proxy object ", proxy, " for ", this.name, " (", this, ")");
for p in ({"name", "r", "w", "f"})
proxy.(p) = this.(p);
endfor
for p in ($object_utils:all_properties_suspended(parent(this)))
if (!is_clear_property(this, p))
$command_utils:suspend_if_needed(0, "...setting props from parent...");
proxy.(p) = this.(p);
endif
endfor
for p in (properties(this))
$command_utils:suspend_if_needed(0);
if ((p[1] == " ") && (p != " "))
continue;
endif
add_property(proxy, p, this.(p), property_info(this, p));
endfor
for v in [1..length(verbs(this))]
add_verb(proxy, verb_info(this, v), verb_args(this, v));
set_verb_code(proxy, v, verb_code(this, v));
$command_utils:suspend_if_needed(0);
endfor
proxy:clearall();
return proxy;
.
#38:0
"eval(code)";
"Evaluate code with $no_one's permissions (so you won't damage anything).";
"If code does not begin with a semicolon, set this = caller (in the code to be evaluated) and return the value of the first `line' of code.  This means that subsequent lines will not be evaluated at all.";
"If code begins with a semicolon, set this = caller and let the code decide for itself when to return a value.  This is how to do multi-line evals.";
exp = args[1];
if (this:bad_eval(exp))
return E_PERM;
endif
set_task_perms(this);
if (exp[1] != ";")
return eval(tostr("this=", caller, "; return ", exp, ";"));
else
return eval(tostr("this=", caller, ";", exp, ";"));
endif
.
#38:1
return 0;
.
#38:2
":eval_d(code)";
"exactly like :eval except that the d flag is unset";
"Evaluate code with $no_one's permissions (so you won't damage anything).";
"If code does not begin with a semicolon, set this = caller (in the code to be evaluated) and return the value of the first `line' of code.  This means that subsequent lines will not be evaluated at all.";
"If code begins with a semicolon, set this = caller and let the code decide for itself when to return a value.  This is how to do multi-line evals.";
exp = args[1];
if (this:bad_eval(exp))
return E_PERM;
endif
set_task_perms(this);
if (exp[1] != ";")
return $code_utils:eval_d(tostr("this=", caller, "; return ", exp, ";"));
else
return $code_utils:eval_d(tostr("this=", caller, ";", exp, ";"));
endif
.
#38:3
"call_verb(object, verb name, args)";
"Call verb with $no_one's permissions (so you won't damage anything).";
"One could do this with $no_one:eval, but ick.";
set_task_perms(this);
return args[1]:(args[2])(@args[3]);
.
#38:4
":bad_eval(exp)";
"  Returns 1 if the `exp' is inappropriate for use by $no_one.  In particular, if `exp' contains calls to `eval', `fork', `suspend', or `call_function' it is bad.  Similarly, if `player' is a nonvalid object the expression is considered `bad' because it is likely an attempt to anonymously spoof.";
"  At present, the checks for bad builtins are overzealous.  It should check for delimited uses of the above calls, in case someone has a variable called `prevalent'.";
{exp} = args;
if (((index(exp, "eval") || index(exp, "fork")) || index(exp, "suspend")) || index(exp, "call_function"))
"Well, they had one of the evil words in here.  See if it was in a quoted string or not -- we want to permit player:tell(\"Gentlemen use forks.\")";
for bad in ({"eval", "fork", "suspend", "call_function"})
tempindex = 1;
while (l = index(exp[tempindex..$], bad, 0))
if ($code_utils:inside_quotes(exp[1..(tempindex + l) - 1]))
tempindex = tempindex + l;
else
"it's there, bad unquoted string";
return 1;
endif
endwhile
endfor
endif
if ((!$recycler:valid(player)) && (player >= #0))
return 1;
endif
return 0;
.
#38:5
if (!caller_perms().wizard)
return E_PERM;
else
return pass(@args);
endif
.
#39:0
":load() -- reloads the player_db with the names of all existing players.";
"This routine calls suspend() if it runs out of time.";
".frozen is set to 1 while the load is in progress so that other routines are warned and don't try to do any updates.  Sometimes, an update is unavoidable (e.g., player gets recycled) in which case the offending routine should set .frozen to 2, causing the load to start over at the beginning.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
"...N.B. clearall suspends, therefore we put the .frozen mark on FIRST...";
this.frozen = 1;
this:clearall();
for p in (players())
this:suspend_restart(p);
"... note that if a player is recycled or toaded during the suspension,...";
"... it won't be removed from the for loop iteration; thus this test:     ";
if (valid(p) && is_player(p))
if (typeof(po = this:find_exact(p.name)) == ERR)
player:tell(p.name, ":  ", po);
return;
elseif (po != p)
if (valid(po) && is_player(po))
player:tell("name `", p.name, "' for ", p, " subsumes alias for ", po.name, "(", po, ").");
endif
this:insert(p.name, p);
endif
for a in (p.aliases)
this:suspend_restart(p);
if (index(a, " ") || index(a, "	"))
"don't bother, space or tab";
elseif (typeof(ao = this:find_exact(a)) == ERR)
player:tell(a, ":  ", ao);
return;
elseif (!(valid(ao) && is_player(ao)))
this:insert(a, p);
elseif (ao != p)
player:tell("alias `", a, "' for ", p.name, "(", p, ") used by ", ao.name, "(", ao, ").");
endif
endfor
endif
endfor
this.frozen = 0;
.
#39:1
":check() -- checks for recycled and toaded players that managed not to get expunged from the db.";
for p in (properties($player_db))
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", p);
suspend(0);
endif
if (p[1] == " ")
nlist = this.(p)[3];
olist = this.(p)[4];
for i in [1..length(nlist)]
if (valid(olist[i]) && (is_player(olist[i]) && (nlist[i] in olist[i].aliases)))
else
player:tell(".", p[2..$], " <- ", nlist[i], " ", olist[i]);
endif
endfor
endif
endfor
player:tell("done.");
.
#39:2
if (caller_perms().wizard)
pass(@args);
this.reserved = {};
this:load();
endif
.
#39:3
":available(name,who) => 1 if a name is available for use, or the object id of whoever is currently using it, or 0 if the name is otherwise forbidden.";
"If $player_db is not .frozen and :available returns 1, then $player:set_name will succeed.";
{name, ?target = valid(caller) ? caller | player} = args;
if ((name in this.stupid_names) || (name in this.reserved))
return 0;
elseif (target in $wiz_utils.rename_restricted)
return 0;
elseif (((((!name) || index(name, " ")) || index(name, "\\")) || index(name, "\"")) || index(name, "	"))
return 0;
elseif (index("*#()", name[1]))
return 0;
elseif (match(name, "(#[0-9]+)"))
return 0;
elseif (valid(who = this:find_exact(name)) && is_player(who))
return who;
elseif ($object_utils:has_callable_verb($local, "legal_name") && (!$local:legal_name(name, target)))
return 0;
else
return 1;
endif
.
#39:4
"used during :load to do the usual out-of-time check.";
"if someone makes a modification during the suspension (indicated by this.frozen being set to 2), we have to restart the entire load.";
if (caller != this)
return E_PERM;
elseif ($command_utils:running_out_of_time())
player:tell("...", args[1]);
set_task_perms($byte_quota_utils:task_perms());
suspend(0);
if (this.frozen != 1)
player:tell("...argh... restarting $player_db:load...");
fork (0)
this:load();
endfork
kill_task(task_id());
endif
endif
.
#39:5
":why_bad_name(player, namespec) => Returns a message explaining why a player name change is invalid.  Stolen from APHiD's #15411:name_okay.";
who = args[1];
name = $building_utils:parse_names(args[2])[1];
si = index(name, " ");
qi = index(name, "\"");
bi = index(name, "\\");
ti = index(name, "	");
if (((si || qi) || bi) || ti)
return tostr("You may not use a name containing ", $string_utils:english_list({@si ? {"spaces"} | {}, @qi ? {"quotation marks"} | {}, @bi ? {"backslashes"} | {}, @ti ? {"tabs"} | {}}, "ERROR", " or "), ".  Try \"", strsub(strsub(strsub(strsub(name, " ", "_"), "\"", "'"), "\\", "/"), "	", "___"), "\" instead.");
elseif (name == "")
return tostr("You may not use a blank name.");
elseif (i = index("*#()", name[1]))
return tostr("You may not begin a name with the \"", "*#()"[i], "\" character.");
elseif (match(name, "(#[0-9]+)"))
return tostr("A name can't contain a parenthesized object number.");
elseif (name in $player_db.stupid_names)
return tostr("The name \"", name, "\" would probably cause problems in command parsing or similar usage.");
elseif (name in $player_db.reserved)
return tostr("The name \"", name, "\" is reserved.");
elseif (length(name) > $login.max_player_name)
return tostr("The name \"", name, "\" is too long.  Maximum name length is ", $login.max_player_name, " characters.");
elseif ((valid(match = $player_db:find_exact(name)) && is_player(match)) && (who != match))
return tostr("The name \"", name, "\" is already being used by ", match.name, "(", match, ").");
elseif ($player_db.frozen)
return tostr("$player_db is not accepting new changes at the moment.");
elseif ($object_utils:has_callable_verb($local, "legal_name") && (!$local:legal_name(name, who)))
return "That name is reserved.";
elseif (who in $wiz_utils.rename_restricted)
return "This player is not allowed to change names.";
endif
.
#39:6
((typeof(args[1]) == NUM) && (typeof(args[2]) == STR)) && (args[2] = $ansi_utils:delete(args[2]));
(typeof(args[1]) == STR) && (args[1] = $ansi_utils:delete(args[1]));
return pass(@args);
.
#40:0
if (typeof(mf = this.(verb)) == STR)
return $string_utils:pronoun_sub(mf, @args);
else
return mf;
endif
.
#40:1
":receive_message(msg,from)";
if ((!$perm_utils:controls(caller_perms(), this)) && (caller != this))
return E_PERM;
endif
if (this:mail_option("no_dupcc", args[1][1], args[1][2]))
"pass to :mail_option the TEXT versions of who the message is from and to";
recipients = setremove($mail_agent:parse_address_field(args[1][3]), this);
for x in (recipients)
if (this:get_current_message(x))
return 0;
endif
endfor
endif
if (this:mail_option("netmail"))
msg = args[1];
message = {"Forwarded: " + msg[4], "Original-date: " + ctime(msg[1]), "Original-From: " + msg[2], "Original-To: " + msg[3], ((("Reply-To: " + $string_utils:substitute(args[2].name, {{"@", "%"}})) + "@") + $network.moo_name) + ".moo.mud.org"};
for x in (msg[5..$])
message = {@message, @$generic_editor:fill_string(x, this:linelen())};
endfor
if (this:send_self_netmail(message, @listdelete(args, 1)) == 0)
return 0;
endif
endif
set_task_perms(this.owner);
new = this:new_message_num();
ncur = (new <= 1) ? 0 | min(this:current_message(this), new);
this:set_current_message(this, ncur);
new = max(new, ncur + 1);
this.messages = {@this.messages, {new, args[1]}};
"... new-mail notification is now done directly by $mail_agent:raw_send";
"... see :notify_mail...";
return new;
.
#40:2
":display_message(preamble,msg) --- prints msg to player.";
vb = ((this._mail_task == task_id()) || (caller == $mail_editor)) ? "notify_lines_suspended" | "tell_lines_suspended";
preamble = args[1];
player:(vb)({@(typeof(preamble) == LIST) ? preamble | {preamble}, @args[2], "--------------------------"});
.
#40:3
"parse_message_seq(strings,cur)         => msg_seq";
"messages_in_seq(msg_seq);              => text of messages in msg_seq";
"display_seq_headers(msg_seq[,current]) :displays summary lines of those msgs";
"rmm_message_seq(msg_seq)               => string giving msg numbers removed";
"undo_rmm()    => msg_seq of restored messages";
"expunge_rmm() => number of messages expunged";
"list_rmm()    => number of messages awaiting expunge";
"renumber(cur) => {number of messages in folder, new_cur}";
"";
"See the corresponding routines on $mail_agent.";
if ((caller == $mail_agent) || $perm_utils:controls(caller_perms(), this))
set_task_perms(this.owner);
return $mail_agent:(verb)(@args);
else
return E_PERM;
endif
.
#40:4
return $mail_agent:msg_summary_line(@args);
.
#40:5
":msg_text(@msg) => list of strings.";
"msg is a mail message (in the usual transmission format) being read BY this player.";
"The default version of recipient:msg_full_text calls this to obtain the actual list of strings to display.  (this is a badly named verb).";
"returns the actual list of strings to display.";
return $mail_agent:to_text(@args);
.
#40:6
":notify_mail(from,recipients[,msgnums])";
" used by $mail_agent:raw_send to notify this player about mail being sent";
" from <from> to <recipients>.  <msgnums> if given gives the message number(s) assigned (in the event that the corresponding recipient actually kept the mail)";
if (!$object_utils:connected(this))
return;
elseif (!((caller in {this, $mail_agent}) || $perm_utils:controls(caller_perms(), this)))
return E_PERM;
else
{from, recipients, ?msgnums = {}} = args;
from_name = $mail_agent:name(from);
"... msgnums may be shorter than recipients or may have some slots filled";
"... with 0's if msg numbers are not available for some recipients.";
if ((t = this in recipients) && ((length(msgnums) >= t) && msgnums[t]))
"... you are getting the mail and moreover your :receive_message kept it.";
namelist = $string_utils:english_list($list_utils:map_arg($mail_agent, "name", setremove(recipients, this)), "");
this:notify(tostr("You have new mail (", msgnums[t], ") from ", from_name, namelist ? " which was also sent to " + namelist | "", "."));
if (!this:mail_option("expert"))
this:notify(tostr("Type `help mail' for info on reading it."));
endif
else
"... vanilla notification; somebody got sent mail and you're finding out.";
namelist = $string_utils:english_list({@t ? {"You"} | {}, @$list_utils:map_arg($mail_agent, "name", setremove(recipients, this))}, "");
this:tell(tostr(namelist, (length(recipients) == 1) ? " has" | " have", " just been sent new mail by ", from_name, "."));
endif
endif
.
#40:7
":current_message([recipient])";
" => current message number for the given recipient (defaults to this).";
" => 0 if we have no record of that recipient";
"      or current message happens to be 0.";
"This verb is mostly obsolete; consider using :get_current_message()";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
elseif ((!args) || (args[1] == this))
return this.current_message[1];
elseif (a = $list_utils:assoc(args[1], this.current_message))
return a[2];
else
return 0;
endif
.
#40:8
":get_current_message([recipient])";
" => {msg_num, last_read_date} for the given recipient.";
" => 0 if we have no record of that recipient.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
elseif ((!args) || (args[1] == this))
if (length(this.current_message) < 2)
"Whoops, this got trashed---fix it up!";
this.current_message = {0, time(), @this.current_message};
endif
return this.current_message[1..2];
elseif (a = $list_utils:assoc(args[1], this.current_message))
return a[2..3];
else
return 0;
endif
.
#40:9
":set_current_message(recipient[,number[,date]])";
"Returns the new {number,last-read-date} pair for recipient.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
endif
{recip, ?number = E_NONE, ?date = 0, ?force = 0} = args;
cm = this.current_message;
if (recip == this)
this.current_message[2] = max(date, cm[2]);
if (number != E_NONE)
this.current_message[1] = number;
endif
return this.current_message[1..2];
elseif (i = $list_utils:iassoc(recip, cm))
if (force)
"`force' is assumed to come from `@unread'";
return (this.current_message[i] = {recip, number, date})[2..3];
else
return (this.current_message[i] = {recip, (number == E_NONE) ? cm[i][2] | number, max(date, cm[i][3])})[2..3];
endif
else
entry = {recip, (number != E_NONE) && number, date};
this.current_message = {@cm, entry};
return entry[2..3];
endif
.
#40:10
":make_current_message(recipient[,index])";
"starts a new current_message record for recipient.";
"index, if given, indicates where recipient is to be";
"  placed (n = at or after nth entry in .current_message).";
recip = args[1];
cm = this.current_message;
if (length(args) > 1)
i = max(2, min(args[2], length(cm)));
else
i = 0;
endif
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
elseif (recip == this)
"...self...";
elseif (j = $list_utils:iassoc(recip, cm))
"...already present...";
if (i)
if (j < i)
this.current_message = {@cm[1..j - 1], @cm[j + 1..i], cm[j], @cm[i + 1..$]};
elseif (j > (i + 1))
this.current_message = {@cm[1..i], cm[j], @cm[i + 1..j - 1], @cm[j + 1..$]};
endif
endif
else
this.current_message = listappend(cm, {recip, 0, 0}, @i ? {i} | {});
endif
.
#40:11
":kill_current_message(recipient)";
"entirely forgets current message for this recipient...";
"Returns true iff successful.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
else
return ((recip = args[1]) != this) && ((i = $list_utils:iassoc(recip, cm = this.current_message)) && (this.current_message = listdelete(cm, i)));
endif
.
#40:12
":current_folder() => default folder to use, always an object, usually `this'";
set_task_perms(caller_perms());
return ((!this:mail_option("sticky")) || this.current_folder) && this;
.
#40:13
set_task_perms(caller_perms());
return this.current_folder = args[1];
.
#40:14
":parse_folder_spec(verb,args,expected_preposition[,allow_trailing_args_p])";
" => {folder, msg_seq_args, trailing_args}";
set_task_perms(caller_perms());
folder = this:current_folder();
if (!prepstr)
return {folder, args[2], {}};
endif
{verb, args, prep, ?extra = 0} = args;
p = prepstr in args;
if (prepstr != prep)
"...unexpected preposition...";
if (extra && (!index(prepstr, " ")))
return {folder, args[1..p - 1], args[p..$]};
else
player:tell("Usage:  ", verb, " [<message numbers>] [", prep, " <folder/list-name>]");
endif
elseif (!((p < length(args)) && (fname = args[p + 1])))
"...preposition but no iobj...";
player:tell(verb, " ", $string_utils:from_list(args, " "), " WHAT?");
elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(fname, this), fname))
"...bogus mail folder...";
else
return {folder, args[1..p - 1], args[p + 2..$]};
endif
return 0;
.
#40:15
":parse_mailread_cmd(verb,args,default,prep[,trailer])";
"  handles anything of the form  `VERB message_seq [PREP folder ...]'";
"    default is the default msg-seq to use if none given";
"    prep is the expected prepstr (assumes prepstr is set), usually `on'";
"    trailer, if present and true, indicates trailing args are permitted.";
"  returns {recipient object, message_seq, current_msg,\"...\"} or 0";
set_task_perms(caller_perms());
if (!(pfs = this:parse_folder_spec(@listdelete(args, 3))))
return 0;
endif
{verb, args, default, prep, ?extra = 0} = args;
folder = pfs[1];
cur = this:get_current_message(folder) || {0};
if (typeof(pms = folder:parse_message_seq(pfs[2], @cur)) == LIST)
rest = {@listdelete(pms, 1), @pfs[3]};
if ((!extra) && rest)
"...everything should have been gobbled by :parse_message_seq...";
player:tell("I don't understand `", rest[1], "'");
return 0;
elseif (pms[1])
"...we have a nonempty message sequence...";
return {folder, pms[1], cur, rest};
elseif (used = (length(pfs[2]) + 1) - length(pms))
"...:parse_message_seq used some words, but didn't get anything out of it";
pms = ("%f %<has> no `" + $string_utils:from_list(pfs[2][1..used], " ")) + "' messages.";
elseif (typeof(pms = folder:parse_message_seq(default, @cur)) == LIST)
"...:parse_message_seq used nothing, try the default; wow it worked";
return {folder, pms[1], cur, rest};
endif
elseif (typeof(pms) == ERR)
player:tell($mail_agent:name(folder), " is not readable by you.");
if (!$object_utils:isa(folder, $mail_recipient))
player:tell("Use * to indicate a non-player mail recipient.");
endif
return 0;
endif
if (folder == this)
subst = {{"%f's", "Your"}, {"%f", "You"}, {"%<has>", "have"}};
elseif (is_player(folder))
subst = {{"%f", folder.name}, {"%<has>", $gender_utils:get_conj("has", folder)}};
else
subst = {{"%f", $mail_agent:name(folder)}, {"%<has>", "has"}};
endif
player:tell($string_utils:substitute(pms, {@subst, {"%%", "%"}}));
return 0;
.
#40:16
"@mail <msg-sequence>                --- as in help @mail";
"@mail <msg-sequence> on <recipient> --- shows mail on mailing list or player.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (p = this:parse_mailread_cmd("@mail", args, this:mail_option("@mail") || $mail_agent.("player_default_@mail"), "on"))
this:set_current_folder(folder = p[1]);
msg_seq = p[2];
seq_size = $seq_utils:size(msg_seq);
if ((lim = player:mail_option("manymsgs")) && ((lim <= seq_size) && (!$command_utils:yes_or_no(tostr("You are about to see ", seq_size, " message headers.  Continue?")))))
player:notify(tostr("Aborted.  @mailoption manymsgs=", lim));
return;
endif
if (1 != seq_size)
player:notify(tostr(seq_size, " messages", (folder == this) ? "" | (" on " + $mail_agent:name(folder)), ":"));
endif
folder:display_seq_headers(msg_seq, @p[3]);
endif
.
#40:17
"@read <msg>...                  -- as in help @read";
"@read <msg>... on *<recipient>  -- reads messages on recipient.";
"@peek ...                       -- like @read, but don't set current message";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (p = this:parse_mailread_cmd("@read", args, "", "on"))
this:set_current_folder(folder = p[1]);
msg_seq = p[2];
if ((lim = player:mail_option("manymsgs")) && ((lim <= (seq_size = $seq_utils:size(msg_seq))) && (!$command_utils:yes_or_no(tostr("You are about to see ", seq_size, " messages.  Continue?")))))
player:notify(tostr("Aborted.  @mailoption manymsgs=", lim));
return;
endif
this._mail_task = task_id();
if (cur = folder:display_seq_full(msg_seq, tostr("Message %d", (folder == this) ? "" | (" on " + $mail_agent:name(folder)), ":")))
if (verb != "@peek")
this:set_current_message(folder, @cur);
endif
endif
endif
.
#40:18
set_task_perms(player.owner);
if (dobjstr && (!(n = toint(dobjstr))))
player:notify(tostr("Usage:  ", verb, " [<number>] [on <recipient>]"));
elseif (dobjstr)
this:("@read")(tostr(verb[2..5], n), @listdelete(args, 1));
else
this:("@read")(verb[2..5], @args);
endif
.
#40:19
"@rmm <message-sequence> [from <recipient>].   Use @unrmm if you screw up.";
" Beware, though.  @unrmm can only undo the most recent @rmm.";
set_task_perms(player);
if (!(p = this:parse_mailread_cmd("@rmm", args, "cur", "from")))
"...parse failed, we've already complained...";
elseif ((!prepstr) && ((p[1] != this) && (!$command_utils:yes_or_no(("@rmmail from " + $mail_agent:name(p[1])) + ".  Continue?"))))
"...wasn't the folder player was expecting...";
player:notify("@rmmail aborted.");
else
this:set_current_folder(folder = p[1]);
e = folder:rm_message_seq(p[2]);
if (typeof(e) == ERR)
player:notify(tostr($mail_agent:name(folder), ":  ", e));
else
count = ((n = $seq_utils:size(p[2])) == 1) ? "." | tostr(" (", n, " messages).");
fname = (folder == this) ? "" | (" from " + $mail_agent:name(folder));
player:notify(tostr("Deleted ", e, fname, count));
endif
endif
.
#40:20
set_task_perms(player);
if (!dobjstr)
folder = this:current_folder();
elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(dobjstr), dobjstr))
return;
endif
cur = this:current_message(folder);
fname = $mail_agent:name(folder);
if (typeof(h = folder:renumber(cur)) == ERR)
player:notify(tostr(h));
else
if (!h[1])
player:notify(tostr("No messages on ", fname, "."));
else
player:notify(tostr("Messages on ", fname, " renumbered 1-", h[1], "."));
this:set_current_folder(folder);
if (h[2] && this:set_current_message(folder, h[2]))
player:notify(tostr("Current message is now ", h[2], "."));
endif
endif
endif
.
#40:21
"@unrmm [on <recipient>]  -- undoes the previous @rmm on that recipient.";
set_task_perms(player);
if (!(p = this:parse_folder_spec("@unrmm", args, "on")))
return;
endif
dobjstr = $string_utils:from_list(p[2], " ");
keep = 0;
if ((!dobjstr) || (keep = index("keep", dobjstr) == 1))
do = "undo_rmm";
elseif (index("expunge", dobjstr) == 1)
do = "expunge_rmm";
elseif (index("list", dobjstr) == 1)
do = "list_rmm";
else
player:notify(tostr("Usage:  ", verb, " [expunge|list] [on <recipient>]"));
return;
endif
this:set_current_folder(folder = p[1]);
if (msg_seq = folder:(do)(@keep ? {keep} | {}))
if (do == "undo_rmm")
player:notify(tostr($seq_utils:size(msg_seq), " messages restored to ", $mail_agent:name(folder), "."));
folder:display_seq_headers(msg_seq, 0);
else
player:notify(tostr(msg_seq, " zombie message", (msg_seq == 1) ? " " | "s ", (do == "expunge_rmm") ? "expunged from " | "on ", $mail_agent:name(folder), "."));
endif
elseif (typeof(msg_seq) == ERR)
player:notify(tostr($mail_agent:name(folder), ":  ", msg_seq));
else
player:notify(tostr("No messages to ", (do == "expunge_rmm") ? "expunge from " | "restore to ", $mail_agent:name(folder)));
endif
.
#40:22
if (args && (args[1] == "to"))
args = listdelete(args, 1);
endif
subject = {};
for a in (args)
if (((i = index(a, "=")) > 3) && (index("subject", a[1..i - 1]) == 1))
args = setremove(args, a);
a[1..i] = "";
subject = {a};
endif
endfor
$mail_editor:invoke(args, verb, @subject);
.
#40:23
"@answer <msg> [on *<recipient>] [<flags>...]";
set_task_perms(who = valid(caller_perms()) ? caller_perms() | player);
if (p = this:parse_mailread_cmd(verb, args, "cur", "on", 1))
if ($seq_utils:size(p[2]) != 1)
player:notify("You can only answer *one* message at a time.");
elseif (LIST != typeof(flags_replytos = $mail_editor:check_answer_flags(@p[4])))
player:notify_lines({tostr("Usage:  ", verb, " [message-# [on <recipient>]] [flags...]"), "where flags include any of:", "  all        reply to everyone", "  sender     reply to sender only", "  include    include the original message in your reply", "  noinclude  don't include the original in your reply"});
else
this:set_current_folder(p[1]);
$mail_editor:invoke(2, verb, p[1]:messages_in_seq(p[2])[1][2], @flags_replytos);
endif
endif
.
#40:24
"@forward <msg> [on *<recipient>] to <recipient> [<recipient>...]";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (!(p = this:parse_mailread_cmd(verb, args, "", "on", 1)))
"...lose...";
return;
elseif ($seq_utils:size(sequence = p[2]) != 1)
player:notify("You can only forward *one* message at a time.");
return;
elseif ((length(p[4]) < 2) || (p[4][1] != "to"))
player:notify(tostr("Usage:  ", verb, " [<message>] [on <folder>] to <recip>..."));
return;
endif
recips = {};
for rs in (listdelete(p[4], 1))
if ($mail_agent:match_failed(r = $mail_agent:match_recipient(rs), rs))
return;
endif
recips = {@recips, r};
endfor
this:set_current_folder(folder = p[1]);
m = folder:messages_in_seq(sequence)[1];
msgnum = m[1];
msgtxt = m[2];
from = msgtxt[2];
if (msgtxt[4] != " ")
subject = tostr("[", from, ":  ", msgtxt[4], "]");
elseif ((h = "" in msgtxt) && (h < length(msgtxt)))
subject = tostr("[", from, ":  `", msgtxt[h + 1][1..min(20, $)], "']");
else
subject = tostr("[", from, "]");
endif
result = $mail_agent:send_message(player, recips, subject, $mail_agent:to_text(@msgtxt));
if (!result)
player:notify(tostr(result));
elseif (result[1])
player:notify(tostr("Message ", msgnum, @(folder == this) ? {} | {" on ", $mail_agent:name(folder)}, " @forwarded to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
else
player:notify("Message not sent.");
endif
.
#40:25
$mail_editor:invoke($wiz_utils.gripe_recipients, "@gripe", "@gripe: " + argstr);
.
#40:26
subject = tostr($string_utils:capitalize(verb[2..$]), ":  ", (loc = this.location).name, "(", loc, ")");
if (this != player)
return E_PERM;
elseif (argstr)
result = $mail_agent:send_message(this, {loc.owner}, subject, argstr);
if (result && result[1])
player:notify(tostr("Your ", verb, " sent to ", $mail_agent:name_list(@listdelete(result, 1)), ".  Input is appreciated, as always."));
else
player:notify(tostr("Huh?  This room's owner (", loc.owner, ") is invalid?  Tell a wizard..."));
endif
return;
elseif (!($object_utils:isa(loc, $room) && loc.free_entry))
player:notify_lines({tostr("You need to make it a one-liner, i.e., `", verb, " something or other'."), "This room may not let you back in if you go to the Mail Room."});
elseif ($object_utils:isa(loc, $generic_editor))
player:notify_lines({tostr("You need to make it a one-liner, i.e., `", verb, " something or other'."), "Sending you to the Mail Room from an editor is usually a bad idea."});
else
$mail_editor:invoke({tostr(loc.owner)}, verb, subject);
endif
if (verb == "@bug")
player:notify("For a @bug report, be sure to mention exactly what it was you typed to trigger the error...");
endif
.
#40:27
"@skip [*<folder/mailing_list>...]";
"  sets your last-read time for the given lists to now, indicating your";
"  disinterest in any new messages that might have appeared recently.";
set_task_perms(player);
current_folder = this:current_folder();
for a in (args || {0})
if (a ? $mail_agent:match_failed(folder = $mail_agent:match_recipient(a), a) | (folder = this:current_folder()))
"...bogus folder name, done...  No, try anyway.";
if (this:kill_current_message(this:my_match_object(a)))
player:notify("Invalid folder, but found it subscribed anyway.  Removed.");
endif
else
lseq = folder:length_all_msgs();
unread = (n = this:get_current_message(folder)) ? folder:length_date_gt(n[2]) | lseq;
this:set_current_message(folder, lseq && folder:messages_in_seq({lseq, lseq + 1})[1][1], time());
player:notify(tostr(unread ? tostr("Ignoring ", unread) | "No", " unread message", (unread != 1) ? "s" | "", " on ", $mail_agent:name(folder)));
if (current_folder == folder)
this:set_current_folder(this);
endif
endif
endfor
.
#40:28
"@subscribe *<folder/mailing_list> [with notification] [before|after *<folder>]";
"  causes you to be notified when new mail arrives on this list";
"@subscribe";
"  just lists available mailing lists.";
"@unsubscribed";
"  prints out available mailing lists you aren't already subscribed to.";
"@subscribe-quick and @unsubscribed-quick";
"  prints out same as above except without mail list descriptions, just names.";
set_task_perms(player);
quick = 0;
if (qi = index(verb, "-q"))
verb = verb[1..qi - 1];
quick = 1;
endif
fname = {@args, 0}[1];
if (!fname)
ml = $list_utils:slice(this.current_message[3..$]);
all_mlists = {@$mail_agent.contents, @this.mail_lists};
if ((length(all_mlists) > 50) && (!$command_utils:yes_or_no(tostr("There are ", length(all_mlists), " mailing lists.  Are you sure you want the whole list?"))))
return player:tell("OK, aborting.");
endif
for c in (all_mlists)
$command_utils:suspend_if_needed(0);
if ((c:is_usable_by(this) || c:is_readable_by(this)) && ((verb != "@unsubscribed") || (!(c in ml))))
c:look_self(quick);
endif
endfor
player:notify(tostr("-------- end of ", verb, " -------"));
return;
elseif (verb == "@unsubscribed")
player:notify("@unsubscribed does not take arguments.");
return;
elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(fname), fname))
return;
elseif (folder == this)
player:notify("You don't need to @subscribe to yourself");
return;
elseif ($object_utils:isa(folder, $mail_recipient) ? !folder:is_readable_by(this) | (!$perm_utils:controls(this, folder)))
player:notify("That mailing list is not readable by you.");
return;
endif
notification = this in folder.mail_notify;
i = 0;
beforeafter = 0;
while (length(args) >= 2)
if (length(args) < 3)
player:notify(args[2] + " what?");
return;
elseif (args[2] in {"with", "without"})
with = args[2] == "with";
if (index("notification", args[3]) != 1)
player:notify(tostr("with ", args[3], "?"));
return;
elseif (!$object_utils:isa(folder, $mail_recipient))
player:notify(tostr("You cannot use ", verb, " to change mail notification from a non-$mail_recipient."));
elseif ((!with) == (!notification))
"... nothing to do...";
elseif (with)
if (this in folder:add_notify(this))
notification = 1;
else
player:notify("This mail recipient does not allow immediate notification.");
endif
else
folder:delete_notify(this);
notification = 0;
endif
elseif (args[2] in {"before", "after"})
if (beforeafter)
player:notify((args[2] == beforeafter) ? tostr("two `", beforeafter, "'s?") | "Only use one of `before' or `after'");
return;
elseif ($mail_agent:match_failed(other = $mail_agent:match_recipient(args[3]), args[3]))
return;
elseif (other == this)
i = 2;
elseif (!(i = $list_utils:iassoc(other, this.current_message)))
player:notify(tostr("You aren't subscribed to ", $mail_agent:name(other), "."));
return;
endif
beforeafter = args[2];
i = i - (beforeafter == "before");
if (this:mail_option("rn_order") != "fixed")
player:notify("Warning:  Do `@mail-option rn_order=fixed' if you do not want your @rn listing reordered when you next login.");
endif
endif
args[2..3] = {};
endwhile
this:make_current_message(folder, @i ? {i} | {});
len = folder:length_all_msgs();
player:notify(tostr($mail_agent:name(folder), " has ", len, " message", (len == 1) ? "" | "s", ".", notification ? "  You will be notified immediately when new messages are posted." | "  Notification of new messages will be printed when you connect."));
this:set_current_folder(folder);
.
#40:29
set_task_perms((caller == this) ? this.owner | caller_perms());
this:set_current_folder(this);
dates = new_cm = head = {};
sort = this:mail_option("rn_order") || "read";
for n in (this.current_message)
$command_utils:suspend_if_needed(0);
if (typeof(n) != LIST)
head = {@head, n};
elseif ($object_utils:isa(folder = n[1], $mail_recipient) && folder:is_readable_by(this))
"...set current msg to be the last one you could possibly have read.";
if (n[3] < folder.last_msg_date)
i = folder:length_date_le(n[3]);
n[2] = i && folder:messages_in_seq(i)[1];
endif
if (sort == "fixed")
new_cm = {n, @new_cm};
elseif (sort == "send")
j = $list_utils:find_insert(dates, folder.last_msg_date - 1);
dates = listinsert(dates, folder.last_msg_date, j);
new_cm = listinsert(new_cm, n, j);
else
new_cm = listappend(new_cm, n, $list_utils:iassoc_sorted(n[3] - 1, new_cm, 3));
endif
endif
endfor
this.current_message = {@head, @$list_utils:reverse(new_cm)};
.
#40:30
set_task_perms((caller == this) ? this.owner | caller_perms());
which = {};
cm = this.current_message;
cm[1..2] = ((verb == "@rn") || (verb == "@rn-full")) ? {{this, @cm[1..2]}} | {};
all = verb == "@subscribed";
fast = this:mail_option("fast_check") && (verb != "@rn-full");
for n in (cm)
rcpt = n[1];
if (rcpt == $news)
"... $news is handled separately ...";
elseif ($mail_agent:is_recipient(rcpt))
if (fast)
if (rcpt == this)
nmsgs = ((m = this.messages) && (m[length(m)][2][1] > n[3])) ? $maxint | 0;
else
try
nmsgs = (n[1].last_msg_date > n[3]) ? $maxint | 0;
except (E_PERM, E_PROPNF)
player:notify(tostr("Bogus recipient ", rcpt, " removed from .current_message."));
this.current_message = setremove(this.current_message, n);
nmsgs = 0;
endtry
endif
else
nmsgs = n[1]:length_date_gt(n[3]);
endif
if (nmsgs || all)
which = {@which, {n[1], nmsgs}};
endif
else
player:notify(tostr("Bogus recipient ", rcpt, " removed from .current_message."));
this.current_message = setremove(this.current_message, n);
endif
$command_utils:suspend_if_needed(0);
endfor
if (which)
player:notify(tostr((verb == "@subscribed") ? "You are subscribed to the following" | "There is new activity on the following", (length(which) > 1) ? " lists:" | " list:"));
for w in (which)
name = (w[1] == this) ? " me" | $mail_agent:name(w[1]);
player:notify(tostr($string_utils:left("    " + name, 40), " ", (w[2] == $maxint) ? "has" | w[2], " new message", (w[2] == 1) ? "" | "s"));
$command_utils:suspend_if_needed(0);
endfor
if (verb != "check_mail_lists")
player:notify("-- End of listing");
endif
elseif ((verb == "@rn") || (verb == "@rn-full"))
player:notify("No new activity on any of your lists.");
elseif (verb == "@subscribed")
player:notify("You aren't subscribed to any mailing lists.");
endif
return which;
.
#40:31
":mail_option(name)";
"Returns the value of the specified mail option";
if ((caller in {this, $mail_editor, $mail_agent}) || $perm_utils:controls(caller_perms(), this))
return $options["mail"]:get(this.mail_options, args[1]);
else
return E_PERM;
endif
.
#40:32
"@unsubscribe [*<folder/mailing_list> ...]";
"entirely removes the record of your current message for the named folders,";
"indicating your disinterest in anything that might appear there in the future.";
set_task_perms(player);
unsubscribed = {};
current_folder = this:current_folder();
for a in (args || {0})
if (a != 0)
folder = $mail_agent:match_recipient(a);
if (folder == $failed_match)
folder = this:my_match_object(a);
endif
else
folder = current_folder;
endif
if (!valid(folder))
"...bogus folder name...  try removing it anyway.";
if (this:kill_current_message(folder))
player:notify("Invalid folder, but found it subscribed anyway.  Removed.");
else
$mail_agent:match_failed(folder, a);
endif
elseif (folder == this)
player:notify(tostr("You can't ", verb, " yourself."));
else
if (!this:kill_current_message(folder))
player:notify(tostr("You weren't subscribed to ", $mail_agent:name(folder)));
if ($object_utils:isa(folder, $mail_recipient))
result = folder:delete_notify(this);
if ((typeof(result) == LIST) && (result[1] == this))
player:notify("Removed you from the mail notifications list.");
endif
endif
else
unsubscribed = {@unsubscribed, folder};
if ($object_utils:isa(folder, $mail_recipient))
folder:delete_notify(this);
endif
endif
endif
endfor
if (unsubscribed)
player:notify(tostr("Forgetting about ", $string_utils:english_list($list_utils:map_arg($mail_agent, "name", unsubscribed))));
if (current_folder in unsubscribed)
this:set_current_folder(this);
endif
endif
.
#40:33
":send_self_netmail(msg [ ,from ])";
"return 0 if successful, otherwise error.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif (error = $network:invalid_email_address($wiz_utils:get_email_address(this)))
return "Invalid email address: " + error;
else
msg = args[1];
if (length(args) > 1)
from = args[2];
this:notify(tostr("Receiving mail from ", from:title(), " (", from, ") and forwarding it to your .email_address."));
endif
oplayer = player;
player = this;
error = $network:sendmail($wiz_utils:get_email_address(this), @msg);
if (error && (length(args) > 1))
this:notify(tostr("Mail sending failed: ", error));
endif
player = oplayer;
return error;
endif
.
#40:34
"@netforward <msg>...                  -- as in help on @netforward";
"@netforward <msg>... on *<recipient>  -- netforwards messages on recipient.";
"This command forwards mail-messages to your registered email-address.";
if (player != this)
return player:tell(E_PERM);
endif
if (reason = $network:email_will_fail(email = $wiz_utils:get_email_address(player)))
return player:notify(tostr("Cannot forward mail to your email address: ", reason));
endif
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (p = player:parse_mailread_cmd(verb, args, "", "on"))
player:set_current_folder(folder = p[1]);
msg_seq = p[2];
folderstr = (folder == player) ? "" | tostr(" from ", $mail_agent:name(folder));
if ((!this:mail_option("expert_netfwd")) && (!$command_utils:yes_or_no(tostr("You are about to forward ", seq_size = $seq_utils:size(msg_seq), " message(s)", folderstr, " to your registered email-address, ", email, ".  Continue?"))))
player:notify(tostr("@Netforward cancelled."));
return;
endif
player:notify("Attempting to send network mail...");
player._mail_task = task_id();
multiple_vals = this:format_for_netforward(folder:messages_in_seq(msg_seq), folderstr);
netmail = multiple_vals[1];
header = multiple_vals[2];
reason = player:send_self_netmail({header, @netmail});
player:notify((reason == 0) ? tostr("@netforward of ", header, " completed.") | tostr("@netforward failed: ", reason, "."));
endif
.
#40:35
"Syntax: @@sendmail";
"This is intended for use with client editors.  You probably don't want to try using this command manually.";
"Reads a formatted mail message, extracts recipients, subject line and/or reply-to header and sends message without going to the mailroom.  Example:";
"";
"@@send";
"To: Rog (#4292)";
"Subject: random";
"";
"first line";
"second line";
".";
"";
"Currently, header lines must have the same format as in an actual message.";
set_task_perms(player);
if (args)
player:notify(tostr("The ", verb, " command takes no arguments."));
$command_utils:read_lines();
return;
elseif (this != player)
player:notify(tostr("You can't use ", this.pp, " ", verb, " verb."));
$command_utils:read_lines();
return;
endif
msg = $command_utils:read_lines();
end_head = ("" in msg) || (length(msg) + 1);
from = this;
subject = "";
replyto = "";
rcpts = {};
body = msg[end_head + 1..$];
for i in [1..end_head - 1]
line = msg[i];
if (index(line, "Subject:") == 1)
subject = $string_utils:trim(line[9..$]);
elseif (index(line, "To:") == 1)
if (!(rcpts = $mail_agent:parse_address_field(line)))
player:notify("No recipients found in To: line");
return;
endif
elseif (index(line, "Reply-to:") == 1)
if ((!(replyto = $mail_agent:parse_address_field(line))) && $string_utils:trim(line[10..$]))
player:notify("No address found in Reply-to: line");
return;
endif
elseif (index(line, "From:") == 1)
"... :send_message() bombs if designated sender != player ...";
if (!(from = $mail_agent:parse_address_field(line)))
player:notify("No sender found in From: line");
return;
elseif (length(from) > 1)
player:notify("Multiple senders?");
return;
endif
from = from[1];
elseif (i = index(line, ":"))
player:notify(tostr("Unknown header \"", line[1..i], "\""));
return;
else
player:notify("Blank line must separate headers from body.");
return;
endif
endfor
if (!rcpts)
player:notify("No To: line found.");
elseif (!(subject || body))
player:notify("Blank message not sent.");
else
player:notify("Sending...");
result = $mail_agent:send_message(from, rcpts, replyto ? {subject, replyto} | subject, body);
if (e = result && result[1])
if (length(result) == 1)
player:notify("Mail actually went to no one.");
else
player:notify(tostr("Mail actually went to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
endif
else
player:notify(tostr((typeof(e) == ERR) ? e | ("Bogus recipients:  " + $string_utils:from_list(result[2]))));
player:notify("Mail not sent.");
endif
endif
.
#40:36
"@keep-mail [<msg-sequence>|none] [on <recipient>]";
"marks the indicated messages as `kept'.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (!args)
return player:notify("Usage:  @keep-mail [<msg-sequence>|none] [on <recipient>]");
elseif (args[1] == "none")
args[1..1] = {};
if (!(pfs = this:parse_folder_spec(verb, args, "on", 0)))
return;
elseif (pfs[2])
player:notify(tostr(verb, " <message-sequence> or `none', but not both."));
return;
endif
this:set_current_folder(folder = pfs[1]);
if (e = folder:keep_message_seq({}))
player:notify(tostr("Messages on ", $mail_agent:name(folder), " are no longer marked as kept."));
else
player:notify(tostr(e));
endif
return;
elseif (p = this:parse_mailread_cmd(verb, args, "", "on"))
if ((folder = p[1]) != this)
"... maybe I'll take this clause out some day...";
player:notify(tostr(verb, " can only be used on your own mail collection."));
return;
endif
this:set_current_folder(folder);
if (e = folder:keep_message_seq(msg_seq = p[2]))
player:notify(tostr("Message", match(e, "[.,]") ? "s " | " ", e, " now marked as kept."));
elseif (typeof(e) == ERR)
player:notify(tostr(e));
else
player:notify(tostr(((seq_size = $seq_utils:size(msg_seq)) == 1) ? "That message is" | "Those messages are", " already marked as kept."));
endif
endif
.
#40:37
":my_match_recipient(string) => matches string against player's private mailing lists.";
if (!(string = args[1]))
return $nothing;
elseif (string[1] == "*")
string = string[2..$];
endif
return $string_utils:match(string, this.mail_lists, "aliases");
.
#40:38
set_task_perms(caller_perms());
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
else
seq = this:expirable_msg_seq();
if (seq)
this:rm_message_seq(seq);
return this:expunge_rmm();
else
return 0;
endif
endif
.
#40:39
":msg_full_text(@msg) => list of strings.";
"msg is a mail message (in the usual transmission format).";
"display_seq_full calls this to obtain the actual list of strings to display.";
return player:msg_text(@args);
"default is to leave it up to the player how s/he wants it to be displayed.";
.
#40:40
"@resend <msg> [on *<recipient>] to <recipient> [<recipient>...]";
set_task_perms(valid(caller_perms()) ? caller_perms() | player);
"...";
"... parse command...";
"...";
if (!(p = this:parse_mailread_cmd(verb, args, "", "on", 1)))
"...lose...";
return;
elseif ($seq_utils:size(sequence = p[2]) != 1)
player:notify("You can only resend *one* message at a time.");
return;
elseif ((length(p[4]) < 2) || (p[4][1] != "to"))
player:notify(tostr("Usage:  ", verb, " [<message>] [on <folder>] to <recip>..."));
return;
endif
recips = {};
for rs in (listdelete(p[4], 1))
if ($mail_agent:match_failed(r = $mail_agent:match_recipient(rs), rs))
return;
endif
recips = {@recips, r};
endfor
this:set_current_folder(folder = p[1]);
"...";
"... retrieve original message...";
"...";
{msgnum, msgtxt} = folder:messages_in_seq(sequence)[1];
if (forward_style = this:mail_option("resend_forw"))
"...message will be from player...";
pmh = $mail_agent:parse_misc_headers(msgtxt, "Reply-To", "Original-Date", "Original-From");
orig_from = pmh[3][3] || msgtxt[2];
else
"...message will be from author...";
pmh = $mail_agent:parse_misc_headers(msgtxt, "Reply-To", "Original-Date", "Original-From", "Resent-By", "Resent-To");
orig_from = pmh[3][3];
from = $mail_agent:parse_address_field(msgtxt[2])[1];
to = $mail_agent:parse_address_field(msgtxt[3]);
endif
"...";
"... report bogus headers...";
"...";
if (bogus = pmh[2])
player:notify("Bogus headers stripped from original message:");
for b in (bogus)
player:notify("  " + b);
endfor
if (!$command_utils:yes_or_no("Continue?"))
player:notify("Message not resent.");
return;
endif
endif
"...";
"... subject, replyto, original-date, original-from ...";
"...";
hdrs = {msgtxt[4], pmh[3][1], {"Original-Date", pmh[3][2] || ctime(msgtxt[1])}, @orig_from ? {{"Original-From", orig_from}} | {}, @pmh[1]};
"...";
"... send it ...";
"...";
if (forward_style)
result = $mail_agent:send_message(player, recips, hdrs, pmh[4]);
else
"... resend inserts resent-to and resent-by...";
result = $mail_agent:resend_message(player, recips, from, to, hdrs, pmh[4]);
endif
"...";
"... report outcome...";
"...";
if (!result)
player:notify(tostr(result));
elseif (result[1])
player:notify(tostr("Message ", msgnum, @(folder == this) ? {} | {" on ", $mail_agent:name(folder)}, " @resent to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
else
player:notify("Message not resent.");
endif
.
#40:41
"Return a sequence indicating the expirable messages for this player.";
set_task_perms(caller_perms());
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif (!(curmsg = this:get_current_message(this)))
"No messages!  Don't even try.";
return {};
elseif (0 >= (period = this:mail_option("expire") || $mail_agent.player_expire_time))
"...no expiration allowed here...";
return {};
else
return $seq_utils:remove(this:unkept_msg_seq(), 1 + this:length_date_le(min(time() - period, curmsg[2] - 86400)));
"... the 86400 is pure fudge...";
endif
.
#40:42
"Takes a message sequence (the actual messages, not just the sequence describing it) and grovels over it filling text etc.  Returns a two valued list: {formatted message, header for same}";
set_task_perms(caller_perms());
{message_seq, folderstr} = args;
netmail = {};
linelen = this:linelen();
maxmsg = minmsg = 0;
for msg in (message_seq)
minmsg = minmsg ? min(msg[1], minmsg) | msg[1];
maxmsg = maxmsg ? max(msg[1], maxmsg) | msg[1];
lines = {tostr("Message ", msg[1], folderstr, ":"), tostr("Date:     ", ctime(msg[2][1])), "From:     " + msg[2][2], "To:       " + msg[2][3], @(length(subj = msg[2][4]) > 1) ? {"Subject:  " + subj} | {}};
for line in (msg[2][5..$])
if (typeof(line) != STR)
"I don't know how this can happen, but apparently non-strings can end up in the mail message.  So, cope.";
line = tostr(line);
endif
lines = {@lines, @$generic_editor:fill_string(line, linelen)};
$command_utils:suspend_if_needed(0);
endfor
netmail = {@netmail, @lines, "", "--------------------------", "", ""};
endfor
header = tostr($network.MOO_name, " Message(s) ", minmsg, @(minmsg != maxmsg) ? {" - ", maxmsg} | {}, folderstr);
return {netmail, header};
.
#40:43
"Takes a message sequence (the actual messages, not just the sequence describing it) and grovels over it filling text etc.  Returns a two valued list: {formatted message, header for same}";
set_task_perms(caller_perms());
{message_seq, folderstr} = args;
netmail = {};
linelen = this:linelen();
maxmsg = minmsg = 0;
for msg in (message_seq)
minmsg = minmsg ? min(msg[1], minmsg) | msg[1];
maxmsg = maxmsg ? max(msg[1], maxmsg) | msg[1];
lines = {tostr("Message ", msg[1], folderstr, ":"), tostr("Date:     ", ctime(msg[2][1])), "From:     " + msg[2][2], "To:       " + msg[2][3], @(length(subj = msg[2][4]) > 1) ? {"Subject:  " + subj} | {}};
for line in (msg[2][5..$])
if (typeof(line) != STR)
"I don't know how this can happen, but apparently non-strings can end up in the mail message.  So, cope.";
line = tostr(line);
endif
lines = {@lines, @$generic_editor:fill_string(line, linelen)};
$command_utils:suspend_if_needed(0);
endfor
netmail = {@netmail, @lines, "", "--------------------------", "", ""};
endfor
header = tostr($network.MOO_name, " Message(s) ", minmsg, @(minmsg != maxmsg) ? {" - ", maxmsg} | {}, folderstr);
return {netmail, header};
.
#40:44
"@nn  -- reads the first new message on the first mail_recipient (in .current_message) where new mail exists.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
cm = this.current_message;
cm[1..2] = {{this, @cm[1..2]}};
for n in (cm)
if ($mail_agent:is_recipient(n[1]))
if (new = n[1]:length_date_gt(n[3]))
next = (n[1]:length_all_msgs() - new) + 1;
this:set_current_folder(folder = n[1]);
this._mail_task = task_id();
cur = folder:display_seq_full({next, next + 1}, tostr("Message %d", " on ", $mail_agent:name(folder), ":"));
this:set_current_message(folder, @cur);
return;
endif
else
player:notify(tostr("Bogus recipient ", n[1], " removed from .current_message."));
this.current_message = setremove(this.current_message, n);
endif
endfor
player:tell("No News (is good news)");
.
#40:45
"@unread <msg> [on *<recipient>]  -- resets last-read-date for recipient to just before the first of the indicated messages.";
set_task_perms(player);
if (p = this:parse_mailread_cmd("@unread", args, "cur", "on"))
this:set_current_folder(folder = p[1]);
msg_ord = $seq_utils:first(msg_seq = p[2]);
msgdate = folder:messages_in_seq(msg_ord)[2][1] - 1;
if ((!(cm = this:get_current_message(folder))) || (cm[2] < msgdate))
player:notify("Already unread.");
else
if (folder == this)
this.current_message[2] = msgdate - 1;
else
"this:kill_current_message(folder);";
this:set_current_message(folder, cm[1], min(cm[2], msgdate), 1);
endif
folder:display_seq_headers({msg_ord, msg_ord + 1}, cm[1], msgdate);
endif
endif
.
#40:46
"@refile/@copym*ail <msg-sequence> [on <recipient>] to <recipient>";
"@refile will delete the messages from the source folder.  @copym does not.";
"I'm not happy with this one, yet...";
set_task_perms(player);
if (!(p = this:parse_mailread_cmd("@refile", args, "cur", "on", 1)))
"...lose...";
elseif ((length(p[4]) != 2) || (p[4][1] != "to"))
player:notify(tostr("Usage:  ", verb, " [<message numbers>] [on <folder>] to <folder>"));
elseif ($mail_agent:match_failed(dest = $mail_agent:match_recipient(p[4][2]), p[4][2]))
"...bogus destination folder...";
else
source = p[1];
msg_seq = p[2];
for m in (source:messages_in_seq(msg_seq))
if (!(e = dest:receive_message(m[2], source)))
player:notify(tostr("Copying msg. ", m[1], ":  ", e));
return;
endif
$command_utils:suspend_if_needed(0);
endfor
if (refile = verb == "@refile")
if (typeof(e = source:rm_message_seq(msg_seq)) == ERR)
player:notify(tostr("Deleting from ", source, ":  ", e));
endif
endif
count = tostr(n = $seq_utils:size(msg_seq), " message", (n == 1) ? "" | "s");
fname = (source == this) ? "" | tostr(is_player(source) ? " from " | " from *", source.name, "(", source, ")");
suffix = tostr(is_player(dest) ? " to " | " to *", dest.name, "(", dest, ").");
player:notify(tostr(refile ? "Refiled " | "Copied ", count, fname, suffix));
endif
.
#40:47
"@qreply <msg> [on *<recipient>] [<flags>...]";
"like @reply only, as in @qsend, we prompt for the message text using ";
"$command_utils:read_lines() rather than invoking the $mail_editor.";
set_task_perms(who = valid(cp = caller_perms()) ? cp | player);
if (!(p = this:parse_mailread_cmd(verb, args, "cur", "on", 1)))
"...garbled...";
elseif ($seq_utils:size(p[2]) != 1)
player:notify("You can only answer *one* message at a time.");
elseif (LIST != typeof(flags_replytos = $mail_editor:check_answer_flags("noinclude", @p[4])))
player:notify_lines({tostr("Usage:  ", verb, " [message-# [on <recipient>]] [flags...]"), "where flags include any of:", "  all        reply to everyone", "  sender     reply to sender only", tostr("  include    include the original message in reply (can't do this for ", verb, ")"), "  noinclude  don't include the original in your reply"});
elseif ("include" in flags_replytos[1])
player:notify(tostr("Can't include message on a ", verb));
else
this:set_current_folder(p[1]);
if (to_subj = $mail_editor:parse_msg_headers(p[1]:messages_in_seq(p[2])[1][2], flags_replytos[1]))
player:notify(tostr("To:       ", $mail_agent:name_list(@to_subj[1])));
if (to_subj[2])
player:notify(tostr("Subject:  ", to_subj[2]));
endif
if (replytos = flags_replytos[2])
player:notify(tostr("Reply-to: ", $mail_agent:name_list(@replytos)));
endif
hdrs = {to_subj[2], replytos || {}};
player:notify("Enter lines of message:");
message = $command_utils:read_lines_escape((active = player in $mail_editor.active) ? {} | {"@edit"}, {tostr("You are composing mail to ", $mail_agent:name_list(@to_subj[1]), "."), @active ? {} | {"Type `@edit' to take this into the mail editor."}});
if (typeof(message) == ERR)
player:notify(tostr(message));
elseif (message[1] == "@edit")
$mail_editor:invoke(1, verb, to_subj[1], @hdrs, message[2]);
elseif (!message[2])
player:notify("Blank message not sent.");
else
result = $mail_agent:send_message(this, to_subj[1], hdrs, message[2]);
if (result && result[1])
player:notify(tostr("Message sent to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
else
player:notify("Message not sent.");
endif
endif
endif
endif
.
#40:48
"@mail-all-new-mail";
" Prints headers for all new mail on every mail-recipient mentioned in .current_message.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
cm = this.current_message;
cm[1..2] = {{this, @cm[1..2]}};
this._mail_task = task_id();
nomail = 1;
new_cms = {};
for f in (cm)
if (!($object_utils:isa(folder = f[1], $player) || $object_utils:isa(folder, $mail_recipient)))
player:notify(tostr(folder, " is neither a $player nor a $mail_recipient"));
elseif (typeof(flen = folder:length_all_msgs()) == ERR)
player:notify(tostr($mail_agent:name(folder), " ", flen));
elseif (msg_seq = $seq_utils:range(folder:length_date_le(f[3]) + 1, flen))
nomail = 0;
player:notify("===== " + $string_utils:left(tostr($mail_agent:name(folder), " (", s = $seq_utils:size(msg_seq), " message", (s == 1) ? ") " | "s) "), 40, "="));
folder:display_seq_headers(msg_seq, @f[2..3]);
player:notify("");
$command_utils:suspend_if_needed(2);
endif
endfor
if (nomail)
player:notify("You don't have any new mail anywhere.");
else
player:notify("===== " + $string_utils:left("End of new mail ", 40, "="));
endif
.
#40:49
"@read-all-new-mail [yes]";
" Prints all new mail on every mail-recipient mentioned in .current_message";
" Generally this will spam you into next Tuesday.";
" You will be queried for whether you want your last-read dates updated";
"   but you can specify \"yes\" on the command line to suppress this.";
"   If you do so, last-read dates will be updated after each folder read.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
noconfirm = args && args[1];
if ((noconfirm && (noconfirm != "yes")) && (noconfirm != "no"))
player:notify("Unexpected argument(s): " + argstr);
return;
endif
cm = this.current_message;
cm[1..2] = {{this, @cm[1..2]}};
this._mail_task = task_id();
nomail = 1;
new_cms = {};
for f in (cm)
if (!($object_utils:isa(folder = f[1], $player) || $object_utils:isa(folder, $mail_recipient)))
player:notify(tostr(folder, " is neither a $player nor a $mail_recipient"));
elseif (typeof(flen = folder:length_all_msgs()) == ERR)
player:notify(tostr($mail_agent:name(folder), " ", flen));
elseif (msg_seq = $seq_utils:range(folder:length_date_le(f[3]) + 1, flen))
nomail = 0;
player:notify("===== " + $string_utils:left(tostr($mail_agent:name(folder), " (", s = $seq_utils:size(msg_seq), " message", (s == 1) ? ") " | "s) "), 40, "="));
player:notify("");
if (cur = folder:display_seq_full(msg_seq, tostr("Message %d", (folder == this) ? "" | (" on " + $mail_agent:name(folder)), ":")))
if (noconfirm == "yes")
this:set_current_message(folder, @cur);
this:set_current_folder(folder);
else
new_cms = {@new_cms, {folder, @cur}};
endif
player:notify("");
endif
endif
$command_utils:suspend_if_needed(1);
this._mail_task = task_id();
endfor
if (nomail)
player:notify("You don't have any new mail anywhere.");
elseif (player:notify("===== " + $string_utils:left("End of new mail ", 40, "=")) || (noconfirm ? noconfirm == "yes" | $command_utils:yes_or_no("Did you get all of that?")))
for n in (new_cms)
this:set_current_message(@n);
this:set_current_folder(n[1]);
endfor
player:notify("Last-read-dates updated");
else
player:notify("Last-read-dates not updated");
endif
.
#40:50
"Syntax: @quicksend <recipients(s)> [subj=<text>] [<message>]";
"Sends the recipients(s) a quick message, wit{out having to go to the mailroom. If there is more than one recipients, place them all in quotes. If the subj contains spaces, place it in quotes.";
"To put line breaks in the message, use a caret (^).";
"If no message is given, prompt for lines of message.";
"Examples:";
"@quicksend Alice subj=\"Wonderland is neat!\" Have you checked out the Wonderland scenario yet? I think you'd like it!";
"@quicksend \"Ethel Fred\" Have you seen Lucy around?^--Ricky";
set_task_perms($object_utils:isa(player, $guest) ? player.owner | player);
if (!args)
player:notify(tostr("Usage: ", verb, " <recipients(s)> [subj=<text>] [<message>]"));
return E_INVARG;
elseif (this != player)
player:notify(tostr("You can't use ", this.pp, " @quicksend verb."));
return E_PERM;
elseif (!(recipients = $mail_editor:parse_recipients({}, $string_utils:explode(args[1]))))
return;
else
if ((length(args) > 1) && ((eq = index(args[2], "=")) && (index("subject", args[2][1..eq - 1]) == 1)))
subject = $string_utils:trim(args[2][eq + 1..$]);
ws = $string_utils:word_start(argstr);
argstr = argstr[1..ws[1][2]] + argstr[ws[2][2] + 1..$];
args = listdelete(args, 2);
else
subject = "";
endif
if (length(args) > 1)
unbroken = argstr[(argstr[1] == "\"") ? length(args[1]) + 4 | (length(args[1]) + 2)..$] + "^";
message = {};
while (unbroken)
if (i = index(unbroken, "^"))
message = {@message, unbroken[1..i - 1]};
endif
unbroken = unbroken[i + 1..$];
endwhile
else
if (!(subject || player:mail_option("nosubject")))
player:notify("Subject:");
subject = $command_utils:read();
endif
player:notify("Enter lines of message:");
message = $command_utils:read_lines_escape((active = player in $mail_editor.active) ? {} | {"@edit"}, {tostr("You are composing mail to ", $mail_agent:name_list(@recipients), "."), @active ? {} | {"Type `@edit' to take this into the mail editor."}});
if (typeof(message) == ERR)
player:notify(tostr(message));
return;
elseif (message[1] == "@edit")
$mail_editor:invoke(1, verb, recipients, subject, {}, message[2]);
return;
elseif (!(message[2] || subject))
player:notify("Blank message not sent.");
return;
endif
message = message[2];
endif
result = $mail_agent:send_message(this, recipients, subject, message);
if (result && result[1])
player:notify(tostr("Message sent to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
else
player:notify("Message not sent.");
endif
endif
.
#40:51
if (caller_perms().wizard)
pass(@args);
this.mail_options = {};
endif
.
#40:52
if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))
return E_PERM;
endif
this:check_mail();
this:mail_catch_up();
this:check_mail_lists();
pass(@args);
.
#40:53
"Ideally, in order for one person to be notified that another person has new mail, both the mail recipient and the notification recipient should agree that this is an OK transfer of information.";
"Usage:  @add-notify me to player";
"    Sends mail to player saying that I want to be added to their mail notification property.";
"Usage:  @add-notify player to me";
"    Makes sure that player wants to be notified, if so, adds them to my .mail_notify property.  (Deletes from temporary record.)";
if (this == dobj)
target = $string_utils:match_player(iobjstr);
if ($command_utils:player_match_failed(target, iobjstr))
return;
elseif (this in target.mail_notify[1])
player:tell("You already receive notifications when ", target.name, " receives mail.");
elseif (this in target.mail_notify[2])
player:tell("You already asked to be notified when ", target.name, " receives mail.");
else
$mail_agent:send_message(player, {target}, "mail notification request", {tostr($string_utils:nn(this), " would like to receive mail notifications when you get mail."), "Please type:", tostr("  @add-notify ", this.name, " to me"), "if you wish to allow this action."});
player:tell("Notifying ", $string_utils:nn(target), " that you would like to be notified when ", target.ps, " receives mail.");
target.mail_notify[2] = setadd(target.mail_notify[2], this);
endif
elseif (this == iobj)
target = $string_utils:match_player(dobjstr);
if ($command_utils:player_match_failed(target, dobjstr))
return;
elseif (target in this.mail_notify[2])
this.mail_notify[1] = setadd(this.mail_notify[1], target);
this.mail_notify[2] = setremove(this.mail_notify[2], target);
player:tell(target.name, " will be notified when you receive mail.");
else
player:tell("It doesn't look like ", target.name, " wants to be notified when you receive mail.");
endif
else
player:tell("Usage:  @add-notify me to player");
player:tell("        @add-notify player to me");
endif
.
#40:54
if ((length(this.mail_notify) > 0) && (typeof(this.mail_notify[1]) == LIST))
return this.mail_notify[1];
else
return this.mail_notify;
endif
.
#40:55
"USAGE: @unsend [message-sequence] from <player>";
"Attempts to unsend messages you sent to <player>. Per *B:Unsend, messages may not be unsent if they have been read, have been netforwarded to the player (@mail-option +netmail), or if the player has set emself so that mail may not be unsent from em (@mail-option +no_unsend). In addition, mail sent to multiple players may not be unsent unless it can be unsent from each recipient.";
"";
"The following message sequences are the only ones allowed:";
"";
"  before:<date>    - Strictly before the given date.";
"  after:<date>     - Strictly after the given date.";
"  since:<date>     - On or after the given date.";
"  until:<date>     - On or before the given date.";
"  subject:<string> - The subject contains the given string.";
"  body:<string>    - The message body contains the given string.";
"  last:<number>    - The last <number> messages you sent.";
"";
"If you do not specify a sequence, the default sequence stored in @mail-option @unsend will be used.";
base = (dobjstr || this:mail_option(verb)) || $mail_agent.("player_default_@unsend");
if (player != this)
return player:tell(E_PERM);
elseif (typeof(base) == STR)
seq = $string_utils:words(base);
else
seq = base;
endif
who = $string_utils:match_player(iobjstr);
fail_msg = "Message(s) were not removed as expected. As per *B:Unsend, I cannot elaborate on why.";
if ($command_utils:player_match_failed(who, iobjstr))
return;
elseif (typeof(res = $options["mail"]:parse({verb, @seq})) == STR)
return player:notify(res);
elseif (who:mail_option("no_unsend") || ($object_utils:has_callable_verb(who, "do_unsend") != {$mail_recipient_class}))
"Author's note: I'm not checking for +netmail. The player could have turned it on (or off) later. Netmailed messages are not saved on the player, so they can't be removed, anyway.";
return player:notify(fail_msg);
endif
"The following loop weeds out `last:#' references, which need to be proccessed in a specific way.";
newseq = otherpeople = {};
last = 0;
for x in (seq)
if (`x[1..5] == "last:" ! ANY')
last = toint(x[6..$]);
else
newseq = {@newseq, x};
endif
endfor
seq = {"new", "unkept:", tostr("from:", player), @newseq};
if (last > 0)
seq = {@seq, tostr("last:", last)};
endif
ok = who:parse_message_seq(seq, who:current_message());
if (typeof(ok) != LIST)
return player:notify(fail_msg);
endif
allmsgs = length($seq_utils:tolist(@ok));
count = missed = 0;
for position in ($list_utils:reverse($list_utils:range(allmsgs)))
time = time() + 60;
ok = (position == allmsgs) ? ok | who:parse_message_seq(seq, who:current_message());
if ((typeof(ok) == STR) || (!ok[1]))
break;
elseif (time() > time)
player:notify("Due to a mysterious time delay (probably incredible lag), your @unsend command has been aborted. Try again later.");
count && player:notify(tostr(count, "message", (count == 1) ? "" | "s", " were unsent before the command was aborted."));
return otherpeople && player:notify(tostr("Message(s) were also removed from ", $string_utils:nn(otherpeople), "."));
endif
x = $seq_utils:tolist(@ok)[$ - missed];
ok = {x, x + 1};
whomail = who.messages;
bad = 0;
possible = {};
"Check if a message was sent to multiple people and set them up for @unsend, too.";
if ((recips = $mail_agent:parse_address_field((msg = whomail[x][2])[3])) == {who})
who:do_unsend(ok);
"Leaving the zombie messages kinda defeats the purpose of @unsend. Since use of @unsend removes any old zombie mail, and since I can't find any nice, tidy way to save the old zombie mail, we're just going to delete the new zombie mail outright. Those who don't like this can set emselves +no_unsend.";
who.messages_going = {};
count = count + 1;
((ticks_left() < 5000) || (seconds_left() < 2)) && suspend(1);
continue;
else
if (((ticks_left() / 5000) < length(recips)) || (seconds_left() < 2))
suspend(1);
endif
"This runs on the principle that the same message text will be sent to each person. If their .messages is in a non-standard format, this will probably bomb. Such people should set themselves +no_unsend, anyway.";
for y in (setremove(recips, who))
time = time() + 60;
if (((((!is_player(y)) || y:mail_option("no_unsend")) || ($object_utils:has_callable_verb(y, "do_unsend") != {$mail_recipient_class})) || (typeof(z = y:parse_message_seq({"new", "unkept:"}, y:current_message())) == STR)) || (!z))
bad = 1;
elseif (time() > time)
player:notify("Due to a mysterious time delay (probably incredible lag), your @unsend command has been aborted. Try again later.");
count && player:notify(tostr(count, "message", (count == 1) ? "" | "s", " were unsent before the command was aborted."));
return otherpeople && player:notify(tostr("Message(s) were also removed from ", $string_utils:nn(otherpeople), "."));
else
ymail = y.messages;
numnum = 0;
for post in ($seq_utils:tolist(@z))
if (ymail[post][2] == msg)
numnum = post;
break;
endif
endfor
if (!numnum)
bad = 1;
else
z = {numnum, numnum + 1};
endif
endif
possible = bad ? {} | {@possible, {y, z}};
if (bad)
break;
endif
endfor
endif
if (bad)
missed = missed + 1;
else
for foo in ({{who, ok}, @possible})
{person, sequence} = foo;
person:do_unsend(sequence);
"Leaving the zombie messages kinda defeats the purpose of @unsend. Since use of @unsend removes any old zombie mail, and since I can't find any nice, tidy way to save the old zombie mail, we're just going to delete the new zombie mail outright. Those who don't like this can set emselves +no_unsend.";
person.messages_going = {};
if (person != who)
otherpeople = setadd(otherpeople, person);
endif
endfor
count = count + 1;
endif
endfor
if ((!count) || (count != allmsgs))
player:notify(fail_msg);
endif
count && player:notify(tostr(count, " message", (count == 1) ? "" | "s", " unsent."));
otherpeople && player:notify(tostr("Message(s) were also removed from ", $string_utils:nn(otherpeople), "."));
.
#40:56
":do_unsend(seq) -> Remove the specified messages. Used by @unsend. Cannot be overridden by players or player classes; @unsend won't bother to call the verb.";
if (!caller_perms().wizard)
return E_PERM;
endif
return $mail_agent:rm_message_seq(@args);
.
#40:57
"@annotate <msg-sequence> [on <recipient>] with \"annotation\"";
"prefix the specified messages with the given annotation.";
set_task_perms(player);
if (!(p = this:parse_mailread_cmd("@annotate", args, "cur", "on", 1)))
"...lose...";
elseif ((length(p[4]) != 2) || (p[4][1] != "with"))
player:notify(tostr("Usage:  ", verb, " [<message numbers>] [on <folder>] with <annotation>"));
else
{target, message_sequence, _, trailing_args} = p;
annotation = trailing_args[2..$];
annotation[1] = tostr("[", player.name, " (", player, "):  ", annotation[1], "]");
if (typeof(e = target:annotate_message_seq(annotation, "prepend", message_sequence)) in {ERR, STR})
player:notify(tostr("Annotation Failed:  ", e));
else
count = $seq_utils:size(message_sequence);
player:notify(tostr("Annotating ", count, " message", (count == 1) ? "" | "s", " on ", $mail_agent:name(target), " with:"));
player:notify_lines(annotation);
endif
endif
"Copied from annotatetest (#87053):@annotate [verb author Puff (#1449)] at Mon Feb 14 14:45:41 2005 PST";
.
#40:58
return "Cannot annotate player messages.";
.
#40:59
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
nm = this:length_all_msgs() - this:length_date_le(this:get_current_message()[2]);
if (nm)
this:notify(tostr("You have new mail (", nm, " message", (nm == 1) ? "" | "s", ").", this:mail_option("expert") ? "" | "  Type 'help mail' for info on reading it."));
endif
endif
.
#41:0
"$gender_utils:set(object,gender) --- sets the pronoun properties of object.";
"gender is a string: one of the strings in $gender_utils.genders, the list of rcognized genders.  If the gender change is successful, the (full) name of the gender (e.g., \"male\") is returned.  E_NONE is returned if gender does not match any recognized gender.  Any other error encountered (e.g., E_PERM, E_PROPNF) is likewise returned and the object's pronoun properties are left unaltered.";
set_task_perms(caller_perms());
{object, gender} = args;
if (this == object)
return E_DIV;
elseif (gnum = $string_utils:find_prefix(gender, this.genders))
gender = this.genders[gnum];
else
return E_NONE;
endif
save = {};
prons = this.pronouns;
for p in (prons)
save = {@save, e = `object.(p) ! ANY'};
if ((typeof(e) != STR) || (typeof(e = `object.(p) = this.(p)[gnum] ! ANY') == ERR))
for i in [1..length(save) - 1]
object.(prons[i]) = save[i];
endfor
return e;
endif
endfor
return gender;
.
#41:1
"$gender_utils:add(object[,perms[,owner]])";
"--- adds pronoun properties to object if they're not already there.";
"    perms default to \"rc\", owner defaults to the object owner.";
set_task_perms(caller_perms());
{object, ?perms = "rc", ?owner = object.owner} = args;
prons = this.pronouns;
e = 1;
for p in (prons)
if (!$object_utils:has_property(object, p))
e = `add_property(object, p, "", {owner, perms}) ! ANY';
if (typeof(e) == ERR)
player:tell("Couldn't add ", object, ".", p, ":  ", e);
return;
endif
elseif ((typeof(object.(p)) != STR) && (typeof(e = `object.(p) = "" ! ANY') == ERR))
player:tell("Couldn't reset ", object, ".", p, ":  ", e);
return;
elseif (!object.(p))
e = 0;
endif
endfor
if ((!e) && (ERR == typeof(e = this:set(object, "neuter"))))
player:tell("Couldn't initialize pronouns:  ", e);
endif
.
#41:2
"get_pronoun(key,object) => pronoun corresponding to object.";
"key can be one of s,o,p,q,r,S,O,P,Q,R to refer to the pronoun properties relatively directly or it can be something of the form \"he/she\" or \"He/She\".";
"Next the object is checked for the desired pronoun property.  If that doesn't exist, we look at object.gender and infer the pronoun from the corresponding $gender_utils property.  If .gender doesn't exist or the object itself is invalid, we use the corresponding property on $player.";
{key, ?object = player} = args;
if (key[1] == ":")
key = key[2..$];
endif
if ((length(key) == 1) && (i = index("sopqrSOPQR", key, 1)))
prop = this.pronouns[i];
else
search = "$1:he$s:she$1:he/she$2:him$2:him/her$3:his/her$4:hers$4:his/hers$5:himself$5:herself$5:himself/herself";
i = index(search, (":" + key) + "$");
if (!i)
return "";
endif
cap = strcmp("a", key) > 0;
prop = this.pronouns[toint(search[i - 1]) + (5 * cap)];
endif
if (!valid(object))
return $player.(prop);
elseif (STR == typeof(p = `object.(prop) ! ANY'))
return p;
elseif ((STR == typeof(g = `object.gender ! ANY')) && (i = g in this.genders))
return this.(prop)[i];
else
return $player.(prop);
endif
.
#41:3
"get_conj(verbspec,object) => verb conjugated according to object.";
"verbspec can be one of \"singular/plural\", \"singular\", \"singular/\", or \"/plural\", e.g., \"is/are\", \"is\", \"is/\", or \"/are\".";
"The object is checked to see whether it is singular or plural.  This is inferred from its .gender property.  If .gender doesn't exist or the object itself is invalid, we assume singular.";
{spec, ?object = player} = args;
i = index(spec + "/", "/");
sing = spec[1..i - 1];
if (i < length(spec))
plur = spec[i + 1..$];
else
plur = "";
endif
cap = strcmp("a", (i == 1) ? spec[2] | spec) > 0;
if (((valid(object) && (STR == typeof(g = `object.gender ! ANY'))) && (i = g in this.genders)) && this.is_plural[i])
vb = plur || this:_verb_plural(sing, i);
else
vb = sing || this:_verb_singular(plur, i);
endif
if (cap)
return $string_utils:capitalize(vb);
else
return vb;
endif
.
#41:4
{st, idx} = args;
if (typeof(st) != STR)
return E_INVARG;
endif
len = length(st);
if ((len >= 3) && (rindex(st, "n't") == (len - 2)))
return this:_verb_plural(st[1..len - 3], idx) + "n't";
elseif (i = st in {"has", "is"})
return this.({"have", "be"}[i])[idx];
elseif (st == "was")
return (idx > 6) ? "were" | st;
elseif ((len <= 3) || (st[len] != "s"))
return st;
elseif (st[len - 1] != "e")
return st[1..len - 1];
"elseif ((r = (rindex(st, \"sses\") || rindex(st, \"zzes\"))) && (r == (len - 3)))";
elseif ((r = rindex(st, "zzes")) && (r == (len - 3)))
return st[1..len - 3];
elseif ((((st[len - 2] == "h") && index("cs", st[len - 3])) || index("ox", st[len - 2])) || (st[len - 3..len - 2] == "ss"))
return st[1..len - 2];
"washes => wash, belches => belch, boxes => box";
"used to have || ((st[len - 2] == \"s\") && (!index(\"aeiouy\", st[len - 3])))";
"so that <consonant>ses => <consonant>s";
"known examples: none";
"counterexample: browses => browse";
"update of sorts--put in code to handle passes => pass";
elseif (st[len - 2] == "i")
return st[1..len - 3] + "y";
else
return st[1..len - 1];
endif
.
#41:5
{st, ?idx = 1} = args;
if (typeof(st) != STR)
return E_INVARG;
endif
len = length(st);
if ((len >= 3) && (rindex(st, "n't") == (len - 2)))
return this:_verb_singular(st[1..len - 3], idx) + "n't";
elseif (i = st in {"have", "are"})
return this.({"have", "be"}[i])[idx];
elseif ((st[len] == "y") && (!index("aeiou", st[len - 1])))
return st[1..len - 1] + "ies";
elseif (index("sz", st[len]) && index("aeiou", st[len - 1]))
return (st + st[len]) + "es";
elseif (index("osx", st[len]) || ((len > 1) && (index("chsh", st[len - 1..len]) % 2)))
return st + "es";
else
return st + "s";
endif
.
#41:6
"_do(cap,object,modifiers...)";
{cap, object, modifiers} = args;
if (!modifiers)
if (typeof(object) != OBJ)
return tostr(object);
elseif (!valid(object))
return (cap ? "N" | "n") + "othing";
else
return cap ? object:titlec() | object:title();
endif
elseif (modifiers[1] == ".")
if (i = index(modifiers[2..$], "."))
i = i + 1;
elseif (!(i = (index(modifiers, ":") || index(modifiers, "#")) || index(modifiers, "!")))
i = length(modifiers) + 1;
endif
if (typeof(o = `object.(modifiers[2..i - 1]) ! ANY') == ERR)
return tostr("%(", o, ")");
else
return this:_do(cap || (strcmp("a", modifiers[2]) > 0), o, modifiers[i..$]);
endif
elseif (modifiers[1] == ":")
if (typeof(object) != OBJ)
return tostr("%(", E_TYPE, ")");
elseif (p = this:get_pronoun(modifiers, object))
return p;
else
return tostr("%(", modifiers, "??)");
endif
elseif (modifiers[1] == "#")
return tostr(object);
elseif (modifiers[1] == "!")
return this:get_conj(modifiers[2..$], object);
else
i = (((index(modifiers, ".") || index(modifiers, ":")) || index(modifiers, "#")) || index(modifiers, "!")) || (length(modifiers) + 1);
s = modifiers[1..i - 1];
if (j = s in {"dobj", "iobj", "this"})
return this:_do(cap, {dobj, iobj, callers()[2][1]}[j], modifiers[i..$]);
else
return tostr("%(", s, "??)");
endif
endif
.
#41:7
"Experimental pronoun substitution. The official version is on $string_utils.";
"syntax:  :pronoun_sub(text[,who])";
"experimental version that accomodates Aladdin's style...";
set_task_perms($no_one);
{old, ?who = player} = args;
if (typeof(old) == LIST)
plines = {};
for line in (old)
plines = {@plines, this:pronoun_sub(line, who)};
endfor
return plines;
endif
new = "";
here = valid(who) ? who.location | $nothing;
objspec = "nditl";
objects = {who, dobj, iobj, caller, here};
prnspec = "sopqrSOPQR";
prprops = {"ps", "po", "pp", "pq", "pr", "Ps", "Po", "Pp", "Pq", "Pr"};
oldlen = length(old);
while ((prcnt = index(old, "%")) && (prcnt < oldlen))
cp_args = {};
s = old[k = prcnt + 1];
if (brace = index("([{", s))
if (!(w = index(old[k + 1..oldlen], ")]}"[brace])))
return new + old;
elseif (brace == 3)
s = this:_do(0, who, old[prcnt + 2..(k = k + w) - 1]);
else
p = old[prcnt + 2..(k = k + w) - 1];
if (brace == 1)
cp_args = {who, p};
elseif (p[1] == "#")
s = (o = index(objspec, p[2])) ? tostr(objects[o]) | (("[" + p) + "]");
elseif (!(o = index(objspec, p[1])))
s = ("[" + p) + "]";
else
cp_args = {objects[o], p[2..w - 1], strcmp(p[1], "a") < 0};
endif
endif
elseif (o = index(objspec, s))
cp_args = {objects[o], "", strcmp(s, "a") < 0};
elseif (w = index(prnspec, s, 1))
cp_args = {who, prprops[w]};
elseif (s == "#")
s = tostr(who);
elseif (s != "%")
s = "%" + s;
endif
new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | (("%(" + tostr(sub)) + ")")));
old = old[k + 1..oldlen];
oldlen = oldlen - k;
endwhile
return new + old;
.
#42:0
"$perm_utils:controls(who, what)";
"Is WHO allowed to hack on WHAT?";
{who, what} = args;
return (valid(who) && valid(what)) && (who.wizard || (who == what.owner));
.
#42:1
":apply(permstring,mods) => new permstring.";
"permstring is a permissions string, mods is a concatenation of strings of the form +<letters>, !<letters>, or -<letters>, where <letters> is a string of letters as might appear in a permissions string (`+' adds the specified permissions, `-' or `!' removes them; `-' and `!' are entirely equivalent).";
{perms, mods} = args;
if ((!mods) || (!index("!-+", mods[1])))
return mods;
endif
i = 1;
while (i <= length(mods))
if (mods[i] == "+")
while (((i = i + 1) <= length(mods)) && (!index("!-+", mods[i])))
if (!index(perms, mods[i]))
perms = perms + mods[i];
endif
endwhile
else
"mods[i] must be ! or -";
while (((i = i + 1) <= length(mods)) && (!index("!-+", mods[i])))
perms = strsub(perms, mods[i], "");
endwhile
endif
endwhile
return perms;
.
#42:2
":caller([include line numbers])";
"  -- returns the first caller in the callers() stack distinct from `this'";
{?lineno = 0} = args;
c = callers(lineno);
{stage, lc, nono} = {1, length(c), {c[1][1], $nothing}};
while (((stage = stage + 1) <= lc) && (c[stage][1] in nono))
endwhile
return c[stage];
.
#42:3
"Syntax:  controls_prop(OBJ who, OBJ what, STR propname)   => 0 | 1";
"         controls_verb(OBJ who, OBJ what, STR verbname)   => 0 | 1";
"";
"Is WHO allowed to hack on WHAT's PROPNAME? Or VERBNAME?";
{who, what, name} = args;
bi = (verb == "controls_verb") ? "verb_info" | "property_info";
return who.wizard || (who == call_function(bi, what, name)[1]);
.
#43:0
"Given a time() or ctime()-style date, this returns the full name of the day.";
if (typeof(args[1]) == INT)
time = ctime(args[1]);
elseif (typeof(args[1]) == STR)
time = args[1];
else
return E_TYPE;
endif
dayabbr = $string_utils:explode(time)[1];
return this.days[dayabbr in this.dayabbrs];
.
#43:1
"Given a time() or ctime()-style date, this returns the full name";
"of the month.";
if (typeof(args[1]) == INT)
time = ctime(args[1]);
elseif (typeof(args[1]) == STR)
time = args[1];
else
return E_TYPE;
endif
monthabbr = $string_utils:explode(time)[2];
return this.months[monthabbr in this.monthabbrs];
.
#43:2
"Return a time in the form [h]h[:mm[:ss]] {a.m.|p.m.}.  Args are";
"[1]   either a time()- or a ctime()-style date, and";
"[2]   (optional) the precision desired--1 for hours, 2 for minutes,";
"        3 for seconds.  If not given, precision defaults to minutes";
{time, ?precision = 2} = args;
if (typeof(time) == INT)
time = ctime(time);
elseif (typeof(time) != STR)
return E_TYPE;
endif
time = $string_utils:explode(time)[4];
hour = toint(time[1..2]);
if (hour == 0)
time = ("12" + time[3..(precision * 3) - 1]) + " a.m.";
elseif (hour == 12)
time = time[1..(precision * 3) - 1] + " p.m.";
elseif (hour > 12)
time = (tostr(hour - 12) + time[3..(precision * 3) - 1]) + " p.m.";
else
time = (tostr(hour) + time[3..(precision * 3) - 1]) + " a.m.";
endif
return time;
.
#43:3
"Given string hh:mm:ss ($string_utils:explode(ctime(time))[4]), this returns";
"the number of seconds elapsed since 00:00:00.  I can't remember why I";
"created this verb, but I'm sure it serves some useful purpose.";
return (((60 * 60) * toint(args[1][1..2])) + (60 * toint(args[1][4..5]))) + toint(args[1][7..8]);
.
#43:4
{?time = time()} = args;
r = 10000;
h = (r * r) + (r / 2);
t = ((time + 120) % 86400) / 240;
s = (5 * ((time - 14957676) % 31556952)) / 438291;
phi = (s + t) + this.corr;
cs = $trig_utils:cos(s);
spss = ((($trig_utils:sin(phi) * $trig_utils:sin(s)) + h) / r) - r;
cpcs = ((($trig_utils:cos(phi) * cs) + h) / r) - r;
return (((((this.stsd * cs) - (this.ctcd * cpcs)) - (this.ct * spss)) + h) / r) - r;
.
#43:5
"Given a string such as returned by ctime(), return the corresponding time-in-seconds-since-1970 time returned by time(), or E_DIV if the format is wrong in some essential way.";
words = $string_utils:explode(args[1]);
if (length(words) == 5)
"Arrgh!  the old ctime() didn't return a time zone, yet it arbitrarily decides whether it's standard or daylight savings time.  URK!!!!!";
words = listappend(words, "PST");
endif
if ((((length(words) != 6) || (length(hms = $string_utils:explode(words[4], ":")) != 3)) || (!(month = words[2] in this.monthabbrs))) || (!(zone = $list_utils:assoc(words[6], this.timezones))))
return E_DIV;
endif
year = toint(words[5]);
day = ({-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + toint(words[3])) + (year * 366);
zone = zone[2];
return (((((((((((((day - ((day + 1038) / 1464)) - ((day + 672) / 1464)) - ((day + 306) / 1464)) - ((day + 109740) / 146400)) - ((day + 73140) / 146400)) - ((day + 36540) / 146400)) - 719528) * 24) + toint(hms[1])) + zone) * 60) + toint(hms[2])) * 60) + toint(hms[3]);
.
#43:6
s = args[1];
if (s < 0)
return "-" + this:(verb)(-s);
endif
m = s / 60;
s = s % 60;
if (m)
ss = tostr((s < 10) ? ":0" | ":", s);
h = m / 60;
m = m % 60;
if (h)
ss = tostr((m < 10) ? ":0" | ":", m, ss);
d = h / 24;
h = h % 24;
return tostr(@d ? {d, (h < 10) ? ":0" | ":"} | {}, h, ss);
else
return tostr(m, ss);
endif
else
return tostr(s);
endif
.
#43:7
"english_time(time [,reference time]): returns the time as a string of";
"years, months, days, hours, minutes and seconds using the reference time as";
"the start time and incrementing forwards. it can be given in either ctime()";
"or time() format. if a reference time is not given, it is set to time().";
{_time, ?reftime = time()} = args;
if (_time < 1)
return "0 seconds";
endif
_ctime = (typeof(reftime) == INT) ? ctime(reftime) | reftime;
seclist = {60, 60, 24};
units = {"year", "month", "day", "hour", "minute", "second"};
timelist = {};
for unit in (seclist)
timelist = {_time % unit, @timelist};
_time = _time / unit;
endfor
months = 0;
month = _ctime[5..7] in $time_utils.monthabbrs;
year = toint(_ctime[21..24]);
"attribution: the algorithm used is from the eminently eminent g7.";
while (_time >= (days = this.monthlens[month] + (((month == 2) && ((year % 4) == 0)) && (!((year % 400) in {100, 200, 300})))))
_time = _time - days;
months = months + 1;
if ((month = month + 1) > 12)
year = year + 1;
month = 1;
endif
if (months > 2400)
return tostr(">", months / 12, " years");
endif
$command_utils:suspend_if_needed(0);
endwhile
timelist = {months / 12, months % 12, _time, @timelist};
for unit in (units)
i = unit in units;
if (timelist[i] > 0)
units[i] = ((tostr(timelist[i]) + " ") + units[i]) + ((timelist[i] == 1) ? "" | "s");
else
units = listdelete(units, i);
timelist = listdelete(timelist, i);
endif
endfor
return $string_utils:english_list(units);
.
#43:8
"from_day(day_of_week,which [,reference time])";
"numeric time (seconds since 1970) corresponding to midnight (PST) of the given weekday.  Use either the name of the day or a 1..7 number (1==Sunday,...)";
"  which==-1 => use most recent such day.";
"  which==+1 => use first upcoming such day.";
"  which==0  => use closest such day.";
"larger (absolute) values for which specify a certain number of weeks into the future or past.";
{day, ?dir = 0, ?reftime = time()} = args;
if (!(toint(day) || (day = $string_utils:find_prefix(day, this.days))))
return E_DIV;
endif
delta = {288000, 374400, 460800, 547200, 28800, 115200, 201600}[toint(day)];
time = reftime - delta;
if (dir)
time = (time / 604800) + ((dir > 0) ? dir | (dir + 1));
else
time = (time + 302400) / 604800;
endif
return (time * 604800) + delta;
.
#43:9
"from_month(month,which[,d])";
"numeric time (seconds since 1970) corresponding to midnight (PST) of the dth (first) day of the given month.  Use either the month name or a 1..12 number (1==January,...)";
"  which==-1 => use most recent such month.";
"  which==+1 => use first upcoming such month.";
"  which==0  => use closest such month.";
"larger (absolute) values for which specify a certain number of years into the future or past.";
{month, ?dir = 0, ?dth = 1} = args;
if (!(toint(month) || (month = $string_utils:find_prefix(month, this.months))))
return E_DIV;
endif
delta = ({0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + dth) - 1;
day = (time() - 28800) / 86400;
day = (day - ((day + 672) / 1461)) - delta;
if (dir)
day = ((day / 365) + dir) + (dir <= 0);
else
day = ((2 * day) + 365) / 730;
endif
day = (day * 365) + delta;
day = day + ((day + 671) / 1460);
return (day * 86400) + 28800;
.
#43:10
"Takes a time that is midnight PST and converts it to the nearest PDT midnight time if it's during that part of the year where we use PDT.";
time = args[1];
return time - (3600 * (((toint(ctime(time)[12..13]) + 12) % 24) - 12));
.
#43:11
"Works like pronoun substitution, but substitutes time stuff.";
"Call with time_sub(string, time). returns a string.";
"time is an optional integer in time() format.  If omitted, time() is used.";
"Macros which are unknown are ignored. $Q -> the empty string.";
"Terminal $ are ignored.";
"$H -> hour #. $M -> min #. $S -> second #. 24-hour format, fixed width.";
"$h, $m, $s same x/c have not-fixed format. 00:03:24 vs. 0:3:24";
"$O/$o -> numeric hour in 12-hour format.";
"$D -> long day name. $d -> short day name.";
"$N -> long month name. $n -> short month name.";
"$Y -> long year # (e.g. '1991'). $y -> short year # (e.g. '91')";
"$Z -> the time zone    (added in by r'm later)";
"$P/$p -> AM/PM, or am/pm.";
"$T -> date number. $t -> date number with no extra whitespace etc.";
"$1 -> Month in fixed-width numeric format (01-12)   (added by dpk)";
"$2 -> Month in nonfixed numeric format (1-12)";
"$3 -> Date in fixed-width format, 0-fill";
"$$ -> $.";
"";
"This verb stolen from Ozymandias's #4835:time_subst.";
res = "";
{thestr, ?thetime = time()} = args;
if ((typeof(thestr) != STR) || (typeof(thetime) != INT))
player:tell("Bad arguments to time_subst.");
return;
endif
itslength = length(thestr);
if (!itslength)
return "";
endif
done = 0;
cctime = ctime(thetime);
while (dollar = index(thestr, "$"))
res = res + thestr[1..dollar - 1];
if (dollar == length(thestr))
return res;
endif
thechar = thestr[dollar + 1];
thestr[1..dollar + 1] = "";
if (thechar == "$")
res = res + "$";
elseif (!strcmp(thechar, "h"))
res = res + $string_utils:trim(tostr(toint(cctime[12..13])));
elseif (thechar == "H")
res = res + cctime[12..13];
elseif (!strcmp(thechar, "m"))
res = res + $string_utils:trim(tostr(toint(cctime[15..16])));
elseif (thechar == "M")
res = res + cctime[15..16];
elseif (!strcmp(thechar, "s"))
res = res + $string_utils:trim(tostr(toint(cctime[18..19])));
elseif (thechar == "S")
res = res + cctime[18..19];
elseif (!strcmp(thechar, "D"))
res = res + $time_utils:day(thetime);
elseif (thechar == "d")
res = res + cctime[1..3];
elseif (!strcmp(thechar, "N"))
res = res + $time_utils:month(thetime);
elseif (thechar == "n")
res = res + cctime[5..7];
elseif (!strcmp(thechar, "T"))
res = res + cctime[9..10];
elseif (thechar == "t")
res = res + $string_utils:trim(cctime[9..10]);
elseif (!strcmp(thechar, "o"))
res = tostr(res, ((toint(cctime[12..13]) + 11) % 12) + 1);
elseif (thechar == "O")
res = res + $string_utils:right(tostr(((toint(cctime[12..13]) + 11) % 12) + 1), 2, "0");
elseif (!strcmp(thechar, "p"))
res = res + ((toint(cctime[12..13]) >= 12) ? "pm" | "am");
elseif (thechar == "P")
res = res + ((toint(cctime[12..13]) >= 12) ? "PM" | "AM");
elseif (!strcmp(thechar, "y"))
res = res + cctime[23..24];
elseif (thechar == "Y")
res = res + cctime[21..24];
elseif (thechar == "Z")
res = res + cctime[26..$];
elseif (thechar == "1")
res = res + $string_utils:right(tostr($string_utils:explode(cctime)[2] in this.monthabbrs), 2, "0");
elseif (thechar == "2")
res = res + tostr($string_utils:explode(cctime)[2] in this.monthabbrs);
elseif (thechar == "3")
res = res + $string_utils:subst(cctime[9..10], {{" ", "0"}});
endif
endwhile
return res + thestr;
.
#43:12
"Copied from Archer (#52775):mmddyy Tue Apr  6 17:04:26 1993 PDT";
"Given a time() or ctime()-style date and an optional separator, this returns the MM/DD/YY or DD/MM/YY form of the date (depending on the verb called.)  The default seperator is '/'";
{time, ?divstr = "/"} = args;
if (typeof(time) == INT)
time = ctime(time);
elseif (typeof(time) != STR)
return E_TYPE;
endif
date = $string_utils:explode(time);
day = toint(date[3]);
month = date[2] in $time_utils.monthabbrs;
year = date[5];
daystr = (day < 10) ? "0" + tostr(day) | tostr(day);
monthstr = (month < 10) ? "0" + tostr(month) | tostr(month);
yearstr = tostr(year)[3..4];
if (verb == "mmddyy")
return tostr(monthstr, divstr, daystr, divstr, yearstr);
else
return tostr(daystr, divstr, monthstr, divstr, yearstr);
endif
.
#43:13
"$time_utils:parse_english_time_interval(n1,u1,n2,u2,...)";
"or $time_utils:parse_english_time_interval(\"n1 u1[,] [and] n2[,] u2 [and] ...\")";
"There must be an even number of arguments, all of which must be strings,";
" or there must be just one argument which is the entire string to be parsed.";
"The n's are are numeric strings, and the u's are unit names.";
"The known units are in $time_utils.time_units,";
" which must be kept sorted with bigger times at the head.";
"Returns the time represented by those words.";
"For example,";
" $time_utils:parse_english_time_interval(\"30\",\"secs\",\"2\",\"minutes\",\"31\",\"seconds\") => 181";
if ((length(args) == 1) && index(args[1], " "))
return $time_utils:parse_english_time_interval(@$string_utils:words(args[1]));
endif
a = $list_utils:setremove_all(args, "and");
nargs = length(a);
if (nargs % 2)
return E_ARGS;
endif
nsec = 0;
n = 0;
for i in [1..nargs]
if ((i % 2) == 1)
if ($string_utils:is_numeric(a[i]))
n = toint(a[i]);
elseif (a[i] in {"a", "an"})
n = 1;
elseif (a[i] in {"no"})
n = 0;
else
return E_INVARG;
endif
else
unit = a[i];
if (unit[$] == ",")
unit = unit[1..$ - 1];
endif
ok = 0;
for entry in ($time_utils.time_units)
if ((!ok) && (unit in entry[2..$]))
nsec = nsec + (entry[1] * n);
ok = 1;
endif
endfor
if (!ok)
return E_INVARG;
endif
endif
endfor
return nsec;
.
#43:14
"Copied from Ballroom Complex (#29992):from_date by Keelah! (#30246) Tue Jul 13 19:42:32 1993 PDT";
":seconds_until_date(month,day,time,which)";
"month is a string or the numeric representation of the month, day is a number, time is a string in the following format, hh:mm:ss.";
"which==-1 => use most recent such month.";
"which==+1 => use first upcoming such month.";
"which==0 => use closest such month.";
"This will return the number of seconds until the month, day and time given to it.";
"Written by Keelah, on July 5, 1993.";
{month, day, time, which} = args;
converted = 0;
converted = converted + $time_utils:from_month(month, which, day);
current = this:seconds_until_time("12:00:00");
get_seconds = this:seconds_until_time(time);
if (get_seconds < 0)
get_seconds = (get_seconds + 39600) - current;
else
get_seconds = (get_seconds + 39600) - current;
endif
converted = (converted + get_seconds) - time();
return converted;
.
#43:15
"Copied from Ballroom Complex (#29992):seconds_until by Keelah! (#30246) Tue Jul 13 19:42:37 1993 PDT";
":seconds_until_time(hh:mm:ss)";
"Given the string hh:mm:ss, this returns the number of seconds until that hh:mm:ss. If the hh:mm:ss is before the current time(), the number returned is a negative, else the number is a positive.";
"Written by Keelah, on July 4, 1993.";
current = $time_utils:to_seconds(ctime()[12..19]);
time = $time_utils:to_seconds(args[1]);
return toint(time) - toint(current);
.
#43:16
"Just like ctime(), but rfc-822 compliant.  I hope.";
c = $string_utils:Explode(ctime(@args));
return tostr(c[1], ", ", c[3], " ", c[2], " ", c[5], " ", c[4], " ", c[6]);
"Last modified Fri Oct 17 23:17:25 1997 EDT by neuro (#3642) on opal moo.";
.
#43:17
"Given a time() or ctime()-style date and an optional separator, this returns the MM/DD/YYYY or DD/MM/YYYY form of the date (depending on the verb called.)  The default seperator is '/'";
{time, ?divstr = "/"} = args;
if (typeof(time) == INT)
time = ctime(time);
elseif (typeof(time) != STR)
return E_TYPE;
endif
date = $string_utils:explode(time);
day = toint(date[3]);
month = date[2] in $time_utils.monthabbrs;
year = date[5];
daystr = (day < 10) ? "0" + tostr(day) | tostr(day);
monthstr = (month < 10) ? "0" + tostr(month) | tostr(month);
yearstr = tostr(year);
if (verb == "mmddyyyy")
return tostr(monthstr, divstr, daystr, divstr, yearstr);
else
return tostr(daystr, divstr, monthstr, divstr, yearstr);
endif
.
#45:0
"For changing mailing list aliases, we check to make sure that none of the aliases match existing mailing list aliases.  Aliases containing spaces are not used in addresses and so are not subject to this restriction ($mail_agent:match will not match on them, however, so they only match if used in the immediate room, e.g., with match_object() or somesuch).";
"  => E_PERM   if you don't own this";
{newaliases} = args;
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (this.location != $mail_agent)
"... we don't care...";
return pass(@args);
elseif (length(newaliases) > $mail_agent.max_list_aliases)
return E_QUOTA;
else
for a in (aliases = newaliases)
if (index(a, " "))
"... we don't care...";
elseif (rp = $mail_agent:reserved_pattern(a))
player:tell("Mailing list name \"", a, "\" uses a reserved pattern: ", rp[1]);
aliases = setremove(aliases, a);
elseif (valid(p = $mail_agent:match(a, #-1)) && ((p != this) && (a in p.aliases)))
player:tell("Mailing list name \"", a, "\" in use on ", p.name, "(", p, ")");
aliases = setremove(aliases, a);
endif
endfor
return pass(aliases) && (newaliases == aliases);
endif
.
#45:1
"Returns full name and mail aliases for this list, read and write status by the player, and a short description. Calling :look_self(1) will omit the description.";
{?brief = 0} = args;
namelist = "*" + ((names = this:mail_names()) ? $string_utils:from_list(names, ", *") | tostr(this));
if (typeof(fwd = this:mail_forward()) != LIST)
fwd = {};
endif
if (this:is_writable_by(player))
if (player in fwd)
read = " [Writable/Subscribed]";
else
read = " [Writable]";
endif
elseif (this.readers == 1)
read = tostr(" [Public", (player in fwd) ? "/Subscribed]" | "]");
elseif (player in fwd)
read = " [Subscribed]";
elseif (this:is_readable_by(player))
read = " [Readable]";
else
read = "";
endif
if (this:is_usable_by($no_one))
mod = "";
elseif (this:is_usable_by(player))
mod = " [Approved]";
else
mod = " [Moderated]";
endif
player:tell(namelist, "  (", this, ")", read, mod);
if (!brief)
d = this:description();
if (typeof(d) == STR)
d = {d};
endif
for l in (d)
if (length(l) <= 75)
ls = {l};
else
ls = $generic_editor:fill_string(l, 76);
endif
for line in (ls)
player:tell("    ", line);
$command_utils:suspend_if_needed(0);
endfor
endfor
endif
.
#45:2
return $perm_utils:controls(who = args[1], this) || `who in this.writers ! E_TYPE';
.
#45:3
return (typeof(this.readers) != LIST) || (((who = args[1]) in this.readers) || (this:is_writable_by(who) || $mail_agent:sends_to(1, this, who)));
.
#45:4
who = args[1];
if (this.moderated)
return `who in this.moderated ! E_TYPE' || (this:is_writable_by(who) || who.wizard);
else
return this.guests_can_send_here || (!$object_utils:isa(who, $guest));
endif
.
#45:5
if ((args && (!this:is_usable_by(args[1]))) && (!args[1].wizard))
return this:moderator_notify(@args);
else
return this.(verb);
endif
.
#45:6
if ((args && (!this:is_usable_by(args[1]))) && (!args[1].wizard))
return this:moderator_forward(@args);
elseif (typeof(mf = this.(verb)) == STR)
return $string_utils:pronoun_sub(mf, @args);
else
return mf;
endif
.
#45:7
if (typeof(mf = this.(verb)) == STR)
return $string_utils:pronoun_sub(mf, args ? args[1] | $player);
else
return mf;
endif
.
#45:8
":add_forward(recip[,recip...]) adds new recipients to this list.  Returns a string error message or a list of results (recip => success, E_PERM => not allowed, E_INVARG => not a valid recipient, string => other kind of failure)";
if (caller == $mail_editor)
perms = player;
else
perms = caller_perms();
endif
result = {};
forward_self = (!this.mail_forward) || (this in this.mail_forward);
for recip in (args)
if ((!valid(recip)) || ((!is_player(recip)) && (!($mail_recipient in $object_utils:ancestors(recip)))))
r = E_INVARG;
elseif ($perm_utils:controls(perms, this) || ((typeof(this.readers) != LIST) && $perm_utils:controls(perms, recip)))
this.mail_forward = setadd(this.mail_forward, recip);
r = recip;
else
r = E_PERM;
endif
result = listappend(result, r);
endfor
if ((length(this.mail_forward) > 1) && ($nothing in this.mail_forward))
this.mail_forward = setremove(this.mail_forward, $nothing);
endif
if (forward_self)
this.mail_forward = setadd(this.mail_forward, this);
endif
return result;
.
#45:9
":delete_forward(recip[,recip...]) removes recipients to this list.  Returns a list of results (E_PERM => not allowed, E_INVARG => not on list)";
if (caller == $mail_editor)
perms = player;
else
perms = caller_perms();
endif
result = {};
forward_self = (!this.mail_forward) || (this in this.mail_forward);
for recip in (args)
if (!(recip in this.mail_forward))
r = E_INVARG;
elseif (((!valid(recip)) || $perm_utils:controls(perms, recip)) || $perm_utils:controls(perms, this))
if (recip == this)
forward_self = 0;
endif
this.mail_forward = setremove(this.mail_forward, recip);
r = recip;
else
r = E_PERM;
endif
result = listappend(result, r);
endfor
if (!(forward_self || this.mail_forward))
this.mail_forward = {$nothing};
elseif (this.mail_forward == {this})
this.mail_forward = {};
endif
return result;
.
#45:10
":add_notify(recip[,recip...]) adds new notifiees to this list.  Returns a list of results (recip => success, E_PERM => not allowed, E_INVARG => not a valid recipient)";
if (caller == $mail_editor)
perms = player;
else
perms = caller_perms();
endif
result = {};
for recip in (args)
if ((!valid(recip)) || (recip == this))
r = E_INVARG;
elseif ($perm_utils:controls(perms, this) || (this:is_readable_by(perms) && $perm_utils:controls(perms, recip)))
this.mail_notify = setadd(this.mail_notify, recip);
r = recip;
else
r = E_PERM;
endif
result = listappend(result, r);
endfor
return result;
.
#45:11
":delete_notify(recip[,recip...]) removes notifiees from this list.  Returns a list of results (E_PERM => not allowed, E_INVARG => not on list)";
if (caller == $mail_editor)
perms = player;
else
perms = caller_perms();
endif
result = {};
rmthis = 0;
for recip in (args)
if (!(recip in this.mail_notify))
r = E_INVARG;
elseif ((!valid(recip)) || ($perm_utils:controls(perms, recip) || $perm_utils:controls(perms, this)))
if (recip == this)
rmthis = 1;
endif
this.mail_notify = setremove(this.mail_notify, recip);
r = recip;
else
r = E_PERM;
endif
result = listappend(result, r);
endfor
return result;
.
#45:12
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
else
this.messages = {@this.messages, {new = this:new_message_num(), args[1]}};
this.last_msg_date = args[1][1];
this.last_used_time = time();
return new;
endif
.
#45:13
":ok(caller,callerperms) => true iff caller can do read operations";
return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_readable_by(args[2]));
.
#45:14
":ok_write(caller,callerperms) => true iff caller can do write operations";
return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_writable_by(args[2]));
.
#45:15
":parse_message_seq(strings,cur) => {msg_seq,@unused_strings} or string error";
"";
":from_msg_seq(olist)     => msg_seq of messages from those people";
":%from_msg_seq(strings)  => msg_seq of messages with strings in the From: line";
":to_msg_seq(olist)       => msg_seq of messages to those people";
":%to_msg_seq(strings)    => msg_seq of messages with strings in the To: line";
":subject_msg_seq(target) => msg_seq of messages with target in the Subject:";
":body_msg_seq(target)    => msg_seq of messages with target in the body";
":new_message_num()    => number that the next incoming message will receive.";
":length_num_le(num)   => number of messages in folder numbered <= num";
":length_date_le(date) => number of messages in folder dated <= date";
":length_all_msgs()    => number of messages in folder";
":exists_num_eq(num)   => index of message in folder numbered == num, or 0";
"";
":display_seq_headers(msg_seq[,cur])   display message summary lines";
":display_seq_full(msg_seq[,preamble]) display entire messages";
"            => number of final message displayed";
":list_rmm() displays contents of .messages_going.";
"            => the number of messages in .messages_going.";
"";
":messages_in_seq(msg_seq) => list of messages in msg_seq on folder";
"";
"See the corresponding routines on $mail_agent for more detail.";
return this:ok(caller, caller_perms()) ? $mail_agent:(verb)(@args) | E_PERM;
.
#45:16
":length_date_le(date) => number of messages in folder dated > date";
"";
if (this:ok(caller, caller_perms()))
date = args[1];
return (this.last_msg_date <= date) ? 0 | $mail_agent:(verb)(date);
else
return E_PERM;
endif
.
#45:17
":rm_message_seq(msg_seq) removes the given sequence of from folder";
"               => string giving msg numbers removed";
"See the corresponding routine on $mail_agent.";
if (this:ok_write(caller, caller_perms()))
return $mail_agent:(verb)(@args);
elseif (this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args)))
return $mail_agent:(verb)(@listset(args, seq, 1));
else
return E_PERM;
endif
.
#45:18
":rm_message_seq(msg_seq) removes the given sequence of from folder";
"               => string giving msg numbers removed";
":list_rmm()    displays contents of .messages_going.";
"               => number of messages in .messages_going.";
":undo_rmm()    restores previously deleted messages from .messages_going.";
"               => msg_seq of restored messages";
":expunge_rmm() destroys contents of .messages_going once and for all.";
"               => number of messages in .messages_going.";
":renumber([cur])  renumbers all messages";
"               => {number of messages,new cur}.";
":set_message_body_by_index(i,newbody)";
"               changes the body of the i-th message.";
"";
"See the corresponding routines on $mail_agent.";
return this:ok_write(caller, caller_perms()) ? $mail_agent:(verb)(@args) | E_PERM;
.
#45:19
":own_messages_filter(who,msg_seq) => subsequence of msg_seq consisting of those messages that <who> is actually allowed to remove (on the assumption that <who> is not one of the allowed writers of this folder.";
if (!this.rmm_own_msgs)
return E_PERM;
elseif ((typeof(seq = this:from_msg_seq({args[1]}, args[2])) != LIST) || (seq != args[2]))
return {};
else
return seq;
endif
.
#45:20
"NOTE:  this routine is obsolete, use :messages_in_seq()";
":messages(num) => returns the message numbered num.";
":messages()    => returns the entire list of messages (can be SLOW).";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!args)
return this:messages_in_seq({1, this:length_all_msgs() + 1});
elseif (!(n = this:exists_num_eq(args[1])))
return E_RANGE;
else
return this:messages_in_seq(n)[2];
endif
.
#45:21
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
date_seq = {};
for msg in (this.messages)
date_seq = {@date_seq, msg[2][1]};
endfor
msg_order = $list_utils:sort($list_utils:range(n = length(msgs = this.messages)), date_seq);
newmsgs = {};
for i in [1..n]
if ($command_utils:suspend_if_needed(0))
player:tell("...", i);
endif
newmsgs = {@newmsgs, {i, msgs[msg_order[i]][2]}};
endfor
if (length(this.messages) != n)
"...shit, new mail received,... start again...";
fork (0)
this:date_sort();
endfork
else
this.messages = newmsgs;
this.last_used_time = newmsgs[$][2][1];
endif
.
#45:22
mlen = this:length_all_msgs();
this.last_msg_date = mlen && this:messages_in_seq(mlen)[2][1];
.
#45:23
return this.(verb);
.
#45:24
return $mail_agent:msg_summary_line(@args);
.
#45:25
for m in (this.messages)
$mail_agent:__convert_new(@m[2]);
$command_utils:suspend_if_needed(0);
endfor
.
#45:26
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
msgs = {};
i = 1;
for m in (oldmsgs = this.messages)
msgs = {@msgs, {m[1], $mail_agent:__convert_new(@m[2])}};
if ($command_utils:running_out_of_time())
player:notify(tostr("...", i, " ", this));
suspend(0);
if (oldmsgs != this.messages)
return 0;
endif
endif
i = i + 1;
endfor
this.messages = msgs;
return 1;
.
#45:27
if (caller_perms().wizard)
pass(@args);
if (!(this in {$mail_recipient, $big_mail_recipient}))
"...generic mail recipients stay in #-1...";
move(this, $mail_agent);
this:rm_message_seq($seq_utils:range(1, this:length_all_msgs()));
this:expunge_rmm();
this:_fix_last_msg_date();
this.mail_forward = {};
for p in ({"mail_notify", "moderator_forward", "moderator_notify", "writers", "readers", "expire_period", "last_used_time"})
this.(p) = $mail_recipient.(p);
endfor
endif
endif
.
#45:28
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
this.mail_forward = {};
return pass(@args);
endif
.
#45:29
return "*" + this.aliases[1];
.
#45:30
names = {};
for a in (this.aliases)
if (!index(a, " "))
names = setadd(names, strsub(a, "_", "-"));
endif
endfor
return names;
.
#45:31
if (this:ok_write(caller, caller_perms()))
if ($network.active)
"Passed security check...";
set_task_perms($wiz_utils:random_wizard());
for x in (this.mail_notify)
if (!$object_utils:has_verb(x, "notify_mail"))
"In theory I should call this:delete_notify but it's ugly and ticky as sin and I'm lazy.";
this.mail_notify = setremove(this.mail_notify, x);
endif
endfor
if (this.expire_period && (rmseq = $seq_utils:remove(this:unkept_msg_seq(), 1 + this:length_date_le(time() - this.expire_period))))
"... i.e., everything not marked kept that is older than expire_period";
if (this.registered_email && this.email_validated)
format = this.owner:format_for_netforward(this:messages_in_seq(rmseq), " expired from " + $mail_agent:name(this));
$network:sendmail(this.registered_email, @{format[2], @format[1]});
"Do nothing if it bounces, etc.";
endif
this:rm_message_seq(rmseq);
return this:expunge_rmm();
else
return 0;
endif
endif
else
return E_PERM;
endif
.
#45:32
if (this:is_writable_by(caller_perms()) || this:is_writable_by(caller))
pass(@args);
else
return E_PERM;
endif
.
#45:33
":msg_full_text(@msg) => list of strings.";
"msg is a mail message (in the usual transmission format).";
"display_seq_full calls this to obtain the actual list of strings to display.";
return player:msg_text(@args);
"default is to leave it up to the player how s/he wants it to be displayed.";
.
#45:34
"Syntax:  @set_expire <recipient> to <time>";
"         @set_expire <recipient> to";
"";
"Allows the list owner to set the expiration period of this mail recipient. This is the time messages will remain before they are removed from the list. The <time> given can be in english terms (e.g., 2 months, 45 days, etc.).";
"Non-wizard mailing list owners are limited to a maximum expire period of 180 days. They are also prohibited from setting the list to non-expiring.";
"Wizards may set the expire period to 0 for no expiration.";
"The second form, leaving off the time specification, will tell you what the recipient's expire period is currently set to.";
if ((caller_perms() != #-1) && (caller_perms() != player))
return player:tell(E_PERM);
elseif (!this:is_writable_by(player))
return player:tell(E_PERM);
elseif (!iobjstr)
return player:tell(this.expire_period ? tostr("Messages will automatically expire from ", this:mail_name(), " after ", $time_utils:english_time(this.expire_period), ".") | tostr("Messages will not expire from ", this:mail_name()));
elseif (typeof(time = $time_utils:parse_english_time_interval(iobjstr)) == ERR)
return player:tell(time);
elseif ((time == 0) && (!player.wizard))
return player:tell("Only wizards may set a mailing list to not expire.");
elseif ((time > (180 * 86400)) && (!player.wizard))
return player:tell("Only a wizard may set the expiration period on a mailing list to greater than 180 days.");
endif
this.expire_period = time;
player:tell("Messages will ", (time != 0) ? tostr("automatically expire from ", this:mail_name(), " after ", $time_utils:english_time(time)) | tostr("not expire from ", this:mail_name()), ".");
.
#45:35
"Syntax:   @register <recipient> to <email-address>";
"alias     @netregister <recipient> to <email-address>";
"          @register <recipient> to";
"";
"The list owner may use this command to set a registered email address for the mail recipient. When set, mail messages that expire off of the mail recipient will be mailed to that address.";
"If you leave the email address off of the command, it will return the current registration and expiration information for that recipient if you own it.";
"The owner may register a mail recipient to any email address. However, if the address does not match his registered email address, then a password will be generated and sent to the address specified when this command is used. Then, the owner may retrieve that password and verify the address with the command:";
"";
"  @validate <recipient> with <password>";
"";
"See *B:MailingListReform #98087 for full details.";
if ((caller_perms() != #-1) && (caller_perms() != player))
return player:tell(E_PERM);
elseif (!$perm_utils:controls(player, this))
return player:tell(E_PERM);
elseif (!iobjstr)
if (this.registered_email)
player:tell(this:mail_name(), " is registered to ", this.registered_email, ". Messages will be sent there when they expire after ", (this.expire_period == 0) ? "never" | $time_utils:english_time(this.expire_period), ".");
else
player:tell(this:mail_name(), " is not registered to any address. Messages will be deleted when they expire after ", (this.expire_period == 0) ? "never" | $time_utils:english_time(this.expire_period), ".");
player:tell("Usage:  @register <recipient> to <email-address>");
endif
return;
elseif (iobjstr == $wiz_utils:get_email_address(player))
this.registered_email = $wiz_utils:get_email_address(player);
this.email_validated = 1;
player:tell("Messages expired from ", this:mail_name(), " after ", (this.expire_period == 0) ? "never" | $time_utils:english_time(this.expire_period), " will be emailed to ", this.registered_email, " (which is your registered email address).");
elseif (reason = $network:invalid_email_address(iobjstr))
return player:tell(reason, ".");
elseif (!$network.active)
return player:tell("The network is not up at the moment. Please try again later or contact a wizard for help.");
else
password = $wiz_utils:random_password(5);
result = $network:sendmail(iobjstr, tostr($network.MOO_Name, " mailing list verification"), @$generic_editor:fill_string(tostr("The mailing list ", this:mail_name(), " on ", $network.MOO_Name, " has had this address designated as the recipient of expired mail messages. If this is not correct, then you need do nothing but ignore this message. If this is correct, you must log into the MOO and type:  `@validate ", this:mail_name(), " with ", password, "' to start receiving expired mail messages."), 75));
if (result != 0)
return player:tell("Mail sending did not work: ", result, ". Address not set.");
endif
this.registered_email = iobjstr;
this.email_validated = 0;
this.validation_password = password;
player:tell("Registration complete. Password sent to the address you specified. When you receive the email, log back in to validate it with the command:  @validate <recipient> with <password>. If you do not receive the password email, try again or notify a wizard if this is a recurring problem.");
endif
.
#45:36
"Syntax:  @validate <recipient> with <password>";
"";
"This command is used to validate an email address set to receive expired messages that did not match the list owner's registered email address. When using the @register command, a password was sent via email to the address specified. This command is to verify that the password was received properly.";
if ((caller_perms() != #-1) && (caller_perms() != player))
return player:tell(E_PERM);
elseif (!$perm_utils:controls(player, this))
return player:tell(E_PERM);
elseif (!this.registered_email)
return player:tell("No email address has even been set for ", this:mail_name(), ".");
elseif (this.email_validated)
return player:tell("The email address for ", this:mail_name(), " has already been validated.");
elseif (!iobjstr)
return player:tell("Usage:  @validate <recipient> with <password>");
elseif (iobjstr != this.validation_password)
return player:tell("That is not the correct password.");
else
this.email_validated = 1;
player:tell("Password validated. Messages that expire after ", (this.expire_period == 0) ? "never" | $time_utils:english_time(this.expire_period), " from ", this:mail_name(), " will be emailed to ", this.registered_email, ".");
endif
.
#45:37
{name} = args;
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (this.location != $mail_agent)
"... we don't care...";
return pass(@args);
elseif (index(name, " "))
"... we don't care...";
elseif (rp = $mail_agent:reserved_pattern(name))
player:tell("Mailing list name \"", a, "\" uses a reserved pattern: ", rp[1]);
return 0;
elseif (valid(p = $mail_agent:match(name, #-1)) && ((p != this) && (name in p.aliases)))
player:tell("Mailing list name \"", name, "\" in use on ", p.name, "(", p, ")");
return 0;
endif
return pass(name);
.
#45:38
":ok_annotate(caller,callerperms) => true iff caller can do annotations";
return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_annotatable_by(args[2]));
.
#45:39
"annotate_message_seq(note, \"append\"|\"prepend\", message_seq) ;";
"";
"Prepend or append (default is prepend) note (a list of strings) to each message in message_seq";
"Recipient must be annotatable (:is_annotatable_by() returns 1) by the caller for this to work.";
{note, appendprepend, message_seq} = args;
if (!this:ok_annotate(caller, caller_perms()))
return E_PERM;
endif
for i in ($seq_utils:tolist(message_seq))
body = this:message_body_by_index(i);
if (appendprepend == "append")
body = {@body, "", @note};
else
body = {@note, "", @body};
endif
this:set_message_body_by_index(i, body);
endfor
return 1;
"Copied from annotatetest (#87053):annotate_message_seq [verb author Puff (#1449)] at Mon Feb 14 14:04:56 2005 PST";
.
#46:0
"resolve(name,from,seen,prevrcpts,prevnotifs) => {rcpts,notifs} or E_INVARG";
"resolve(list,from,seen,prevrcpts,prevnotifs) => {bogus,rcpts,notifs}";
"Given either an address (i.e., objectid) or a list of such, traces down all .mail_forward lists and .mail_notify to determine where a message should actually go and who should be told about it.  Both forms take previous lists of recipients/notifications and add only those addresses that weren't there before.  `seen' is the stack of addresses we are currently resolving (for detecting loops).  The first form returns E_INVARG if `name' is invalid.  The second form returns all invalid addresses in the `bogus' list but still does the appropriate search on the remaining addresses.";
{recip, from, ?seen = {}, ?prevrcpts = {}, ?prevnotifs = {}} = args;
sofar = {prevrcpts, prevnotifs};
if (typeof(recip) == LIST)
bogus = {};
for r in (recip)
result = this:resolve_addr(r, from, seen, @sofar);
if (result)
sofar = result;
else
bogus = setadd(bogus, r);
endif
endfor
return {bogus, @sofar};
else
fwd = include_recip = 0;
if ((recip == $nothing) || (recip in seen))
return sofar;
elseif ((!valid(recip)) || ((!(is_player(recip) || $object_utils:isa(recip, $mail_recipient))) || (typeof(fwd = recip:mail_forward(from)) != LIST)))
"recip is a non-player non-mailing-list/folder or forwarding is screwed.";
if (typeof(fwd) == STR)
player:tell(fwd);
endif
return E_INVARG;
elseif (is_player(recip) && `recip:refuses_action(from, "mail") ! E_VERBNF')
player:tell(recip:mail_refused_msg());
return E_INVARG;
elseif (fwd)
if (r = recip in fwd)
include_recip = 1;
fwd = listdelete(fwd, r);
endif
result = this:resolve_addr(fwd, recip, setadd(seen, recip), @sofar);
if (bogus = result[1])
player:tell(recip.name, "(", recip, ")'s .mail_forward list includes the following bogus entr", (length(bogus) > 1) ? "ies:  " | "y:  ", $string_utils:english_list(bogus));
endif
sofar = result[2..3];
else
include_recip = 1;
endif
if ((ticks_left() < 1000) || (seconds_left() < 2))
suspend(0);
endif
biffs = sofar[2];
for n in (this:mail_notify(recip, from))
if (valid(n))
if (i = $list_utils:iassoc_suspended(n, biffs))
biffs[i] = setadd(biffs[i], recip);
else
biffs = {{n, recip}, @biffs};
endif
endif
if ((ticks_left() < 1000) || (seconds_left() < 2))
suspend(0);
endif
endfor
return {include_recip ? setadd(sofar[1], recip) | sofar[1], biffs};
endif
.
#46:1
"sends_to(from,addr,rcpt[,seen]) ==> true iff mail sent to addr passes through rcpt.";
{from, addr, rcpt, ?seen = {}} = args;
if (addr == rcpt)
return 1;
elseif (!(addr in seen))
seen = {@seen, addr};
for a in ((typeof(fwd = this:mail_forward(addr, @from ? {} | {from})) == LIST) ? fwd | {})
if (this:sends_to(addr, a, rcpt, seen))
return 1;
endif
$command_utils:suspend_if_needed(0);
endfor
endif
return 0;
.
#46:2
"send_message(from,rcpt-list,hdrs,msg) -- formats and sends a mail message.  hders is either the text of the subject line, or a {subject,{reply-to,...}} list.";
"Return E_PERM if from isn't owned by the caller.";
"Return {0, @invalid_rcpts} if rcpt-list contains any invalid addresses.  No mail is sent in this case.";
"Return {1, @actual_rcpts} if successful.";
{from, to, orig_hdrs, msg} = args;
"...";
"... remove bogus Resent-To/Resent-By headers...";
"...";
if ((typeof(orig_hdrs) == LIST) && (length(orig_hdrs) > 2))
hdrs = orig_hdrs[1..2];
orig_hdrs[1..2] = {};
strip = {"Resent-To", "Resent-By"};
for h in (orig_hdrs)
(h[1] in strip) || (hdrs = {@hdrs, h});
endfor
else
hdrs = orig_hdrs;
endif
"...";
"... send it...";
"...";
if ($perm_utils:controls(caller_perms(), from))
text = $mail_agent:make_message(from, to, hdrs, msg);
return this:raw_send(text, to, from);
else
return E_PERM;
endif
.
#46:3
"Copied from Mail Distribution Center (#6418):raw_send by Nosredna (#2487) Mon Feb 24 10:46:26 1997 PST";
"WIZARDLY";
"raw_send(text,rcpts,sender) -- does the actual sending of a message.  Assumes that text has already been formatted correctly.  Decides who to send it to and who wants to be notified about it and does so.";
"Return {E_PERM} if the caller is not entitled to use this verb.";
"Return {0, @invalid_rcpts} if rcpts contains any invalid addresses.  No mail is sent in this case.";
"Return {1, @actual_rcpts} if successful.";
{text, rcpts, from} = args;
if (typeof(rcpts) != LIST)
rcpts = {rcpts};
endif
if (!(caller in {$mail_agent, $mail_editor}))
return {E_PERM};
elseif (bogus = (resolve = this:resolve_addr(rcpts, from))[1])
return {0, bogus};
else
set_task_perms($wiz_utils:random_wizard());
this:touch(rcpts);
actual_rcpts = resolve[2];
biffs = resolve[3];
results = {};
for recip in (actual_rcpts)
if ((ticks_left() < 10000) || (seconds_left() < 2))
player:notify(tostr("...", recip));
suspend(1);
endif
if (typeof(e = recip:receive_message(text, from)) in {ERR, STR})
"...receive_message bombed...";
player:notify(tostr(recip, ":receive_message:  ", e));
e = 0;
elseif ((!is_player(recip)) || (!e))
"...not a player or receive_message isn't giving out the message number";
"...no need to force a notification...";
elseif (i = $list_utils:iassoc(recip, biffs))
"...player-recipient was already getting a notification...";
"...make sure notification includes a mention of him/her/itself.";
if (!(recip in listdelete(biffs[i], 1)))
biffs[i][2..1] = {recip};
endif
else
"...player-recipient wasn't originally being notified at all...";
biffs = {{recip, recip}, @biffs};
endif
results = {@results, e};
endfor
"The following is because the scheduler can BITE ME. --Nosredna";
fork (0)
for b in (biffs)
if ((ticks_left() < 10000) || (seconds_left() < 2))
suspend(1);
endif
if ($object_utils:has_callable_verb(b[1], "notify_mail"))
mnums = {};
for r in (listdelete(b, 1))
mnums = {@mnums, (rn = r in actual_rcpts) && results[rn]};
endfor
b[1]:notify_mail(from, listdelete(b, 1), mnums);
endif
endfor
endfork
return {1, @actual_rcpts};
endif
.
#46:4
who = args[1];
if ($object_utils:has_verb(who, verb))
return who:(verb)(@listdelete(args, 1));
else
return {};
endif
.
#46:5
"touch(name or list,seen) => does .last_used_time = time() if we haven't already touched this in the last hour";
{recip, ?seen = {}} = args;
if (typeof(recip) == LIST)
for r in (recip)
result = this:touch(r, seen);
$command_utils:suspend_if_needed(0);
endfor
else
if (((!valid(recip)) || (recip in seen)) || ((!is_player(recip)) && (!($mail_recipient in $object_utils:ancestors(recip)))))
"recip is neither a player nor a mailing list/folder";
else
if (fwd = this:mail_forward(recip))
this:touch(fwd, {@seen, recip});
endif
if (!is_player(recip))
recip.last_used_time = time();
endif
endif
endif
.
#46:6
player:tell_lines(this.description);
for c in (this.contents)
$command_utils:suspend_if_needed(0);
c:look_self();
endfor
.
#46:7
"Only allow mailing lists/folders in here and only if their names aren't already taken.";
what = args[1];
return ($object_utils:isa(what, $mail_recipient) && this:check_names(what, @what.aliases)) && (what:description() != parent(what):description());
.
#46:8
"...make sure the list has at least one usable name.";
"...make sure none of the aliases are already taken.";
{object, @aliases} = args;
if (typeof(object) == STR)
"... legacy; old version of this verb did not take on OBJ argument";
aliases = args;
endif
ok = 0;
if (length(aliases) > this.max_list_aliases)
player:tell("Mailing lists may not have more than ", this.max_list_aliases, " aliases.");
return 0;
endif
for a in (aliases)
sub1 = strsub(a, "_", "-");
sub2 = strsub(a, "-", "_");
if (sub1 == sub2)
check = 0;
else
check = 1;
endif
if (index(a, " "))
elseif (rp = $mail_agent:reserved_pattern(a))
player:tell("Mailing list name \"", a, "\" uses a reserved pattern: ", rp[1]);
return 0;
elseif (valid(p = $mail_agent:match(a, #-1)) && ((p != object) && (a in p.aliases)))
player:tell("Mailing list name \"", a, "\" in use on ", p.name, "(", p, ")");
return 0;
elseif (check && (valid(p = $mail_agent:match(sub1, #-1)) && ((p != object) && (sub1 in p.aliases))))
player:tell("Mailing list name \"", sub1, "\" in use on ", p.name, "(", p, ")");
return 0;
elseif (check && (valid(p = $mail_agent:match(sub2, #-1)) && ((p != object) && (sub2 in p.aliases))))
player:tell("Mailing list name \"", sub2, "\" in use on ", p.name, "(", p, ")");
return 0;
else
ok = 1;
endif
endfor
return ok;
.
#46:9
":match(string) => mailing list object in here that matches string.";
":match(string,player) => similar but also matches against player's private mailing lists (as kept in .mail_lists).";
if (!(string = args[1]))
return $nothing;
elseif (string[1] == "*")
string = string[2..$];
endif
if (valid(o = $string_utils:literal_object(string)) && ($mail_recipient in $object_utils:ancestors(o)))
return o;
elseif (rp = this:reserved_pattern(string))
return rp[2]:match_mail_recipient(string);
else
if (valid(who = {@args, player}[2]) && (typeof(use = `who.mail_lists ! E_PROPNF, E_PERM') == LIST))
use = {@this.contents, @use};
else
use = this.contents;
endif
partial = 1;
string = strsub(string, "_", "-");
for l in (use)
if (string in l.aliases)
return l;
endif
if (partial != $ambiguous_match)
for a in (l.aliases)
if ((index(a, string) == 1) && (!index(a, " ")))
if (partial)
partial = l;
elseif (partial != l)
partial = $ambiguous_match;
endif
endif
$command_utils:suspend_if_needed(0);
endfor
endif
endfor
return partial && $failed_match;
endif
.
#46:10
":match_recipient(string[,meobj]) => $player or $mail_recipient object that matches string.  Optional second argument (defaults to player) is returned in the case string==\"me\" and is also used to obtain a list of private $mail_recipients to match against.";
{string, ?me = player} = args;
if (valid(me) && ($failed_match != (o = me:my_match_recipient(string))))
return o;
elseif (!string)
return $nothing;
elseif ((string[1] == "*") && (string != "*"))
return this:match(@args);
elseif (string[1] == "`")
args[1][1..1] = "";
return $string_utils:match_player(@args);
elseif (valid(o = $string_utils:match_player(@args)) || (o == $ambiguous_match))
return o;
else
return this:match(@args);
endif
.
#46:11
{match_result, string, ?cmd_id = ""} = args;
cmd_id = cmd_id || "";
if (match_result == $nothing)
player:tell(cmd_id, "You must specify a valid mail recipient.");
elseif (match_result == $failed_match)
player:tell(cmd_id, "There is no mail recipient called \"", string, "\".");
elseif (match_result == $ambiguous_match)
if ((nostar = index(string, "*") != 1) && (lst = $player_db:find_all(string)))
player:tell(cmd_id, "\"", string, "\" could refer to ", (length(lst) > 20) ? tostr("any of ", length(lst), " players") | $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", lst), "no one", " or "), ".");
else
player:tell(cmd_id, "I don't know which \"", nostar ? "*" | "", string, "\" you mean.");
endif
elseif (!valid(match_result))
player:tell(cmd_id, match_result, " does not exist.");
else
return 0;
endif
return 1;
.
#46:12
":make_message(sender,recipients,subject/replyto/additional-headers,body)";
" => message in the form as it will get sent.";
{from, recips, hdrs, body} = args;
try
fromowner = from.owner;
except (E_INVIND)
raise(E_PERM);
endtry
fromline = this:name_list(from);
if (typeof(recips) != LIST)
recips = {recips};
endif
recips = this:name_list(@recips);
others = {};
replyto = 0;
if (typeof(hdrs) != LIST)
hdrs = {hdrs};
endif
subj = hdrs[1];
if (!valid(from))
others = {"Probable-Sender:   " + this:name(fromowner)};
"  others = {'Possible-Sender:   ' + this:name(player)}";
"  if (caller_perms() != player)";
"    others = {@others, 'Possible-Sender:   ' + this:name(caller_perms())}";
"  endif";
elseif (!is_player(from))
others = {"Sender:   " + this:name(from.owner)};
endif
replyto = {@hdrs, 0}[2] && this:name_list(@hdrs[2]);
if (length(hdrs) > 2)
hdrs[1..2] = {};
for h in (hdrs)
if (match(h[1], "[a-z1-9-]+"))
others = {@others, $string_utils:left(h[1] + ": ", 15) + h[2]};
endif
endfor
endif
if (typeof(body) != LIST)
body = body ? {body} | {};
endif
return {this:time(), fromline, recips, subj || " ", @replyto ? {"Reply-to: " + replyto} | {}, @others, "", @body};
.
#46:13
what = args[1];
if (!valid(what))
name = "???";
elseif ((!is_player(what)) && $object_utils:has_callable_verb(what, "mail_name"))
name = what:mail_name();
else
name = what.name;
endif
while (m = match(name, "(#[0-9]+)"))
{s, e} = m[1..2];
name[s..e] = "";
endwhile
return tostr(name, " (", what, ")");
.
#46:14
return $string_utils:english_list($list_utils:map_arg(this, "name", args), "no one");
.
#46:15
":parse_address_field(string) => list of objects";
"This is the standard routine for parsing address lists that appear in From:, To: and Reply-To: lines";
objects = {};
string = args[1];
while (m = match(string, "(#[0-9]+)"))
{s, e} = m[1..2];
if (#0 != (o = toobj(string[s + 1..e - 1])))
objects = {@objects, o};
endif
string = string[e + 1..$];
endwhile
return objects;
.
#46:16
":display_seq_full(msg_seq[,preamble]) => {cur, last-read-date}";
"This is the default message display routine.";
"Prints entire messages on folder (caller) to player.  msg_seq is the handle returned by :parse_message_seq(...) and indicates which messages should be printed.  preamble, if given will precede the output of the message itself, in which case the message number will be substituted for \"%d\".  Returns the number of the final message in the sequence (which can be then used as the new current message number).";
set_task_perms(caller_perms());
{msg_seq, ?preamble = ""} = args;
cur = date = 0;
for x in (msgs = caller:messages_in_seq(msg_seq))
cur = x[1];
date = x[2][1];
player:display_message(preamble ? strsub(preamble, "%d", tostr(cur)) | {}, caller:msg_full_text(@x[2]));
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
return {cur, date};
.
#46:17
":display_seq_headers(msg_seq[,cur[,last_read_date]])";
"This is the default header display routine.";
"Prints a list of headers of messages on caller to player.  msg_seq is the handle returned by caller:parse_message_seq(...).  cur is the player's current message.  last_read_date is the date of the last of the already-read messages.";
set_task_perms(caller_perms());
{msg_seq, ?cur = 0, ?last_old = $maxint} = args;
keep_seq = {@$seq_utils:contract(caller:kept_msg_seq(), $seq_utils:complement(msg_seq, 1, caller:length_all_msgs())), $maxint};
k = 1;
mcount = 0;
width = player:linelen() || 79;
for x in (msgs = caller:messages_in_seq(msg_seq))
if (keep_seq[k] <= (mcount = mcount + 1))
k = k + 1;
endif
annot = ((d = x[2][1]) > last_old) ? "+" | ((k % 2) ? " " | "=");
line = tostr($string_utils:right(x[1], 4, (cur == x[1]) ? ">" | " "), ":", annot, " ", caller:msg_summary_line(@x[2]));
player:tell(line[1..min(width, $)]);
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
player:tell("----+");
.
#46:18
":rm_message_seq(msg_seq)  removes the given sequence of from folder (caller)";
"...removed messages are saved in .messages_going for possible restoration.";
set_task_perms(caller_perms());
old = caller.messages;
new = save = nums = {};
next = 1;
for i in [1..length(seq = args[1]) / 2]
if ($command_utils:running_out_of_time())
player:tell("... rmm ", old[next][1] - 1);
suspend(0);
endif
start = seq[(2 * i) - 1];
new = {@new, @old[next..start - 1]};
save = {@save, {start - next, old[start..(next = seq[2 * i]) - 1]}};
nums = {@nums, old[start][1], old[next - 1][1] + 1};
endfor
new = {@new, @old[next..$]};
$command_utils:suspend_if_needed(0, "... rmm ...");
save_kept = $seq_utils:intersection(caller.messages_kept, seq);
$command_utils:suspend_if_needed(0, "... rmm ...");
new_kept = $seq_utils:contract(caller.messages_kept, seq);
$command_utils:suspend_if_needed(0, "... rmm ...");
caller.messages_going = save_kept ? {save_kept, save} | save;
caller.messages = new;
caller.messages_kept = new_kept;
if ($object_utils:has_callable_verb(caller, "_fix_last_msg_date"))
caller:_fix_last_msg_date();
endif
return $seq_utils:tostr(nums);
.
#46:19
":undo_rmm()  restores previously deleted messages in .messages_going to .messages.";
set_task_perms(caller_perms());
old = caller.messages;
going = caller.messages_going;
new = seq = {};
last = 0;
next = 1;
"there are two possible formats here:";
"OLD: {{n,msgs},{n,msgs},...}";
"NEW: {kept_seq, {{n,msgs},{n,msgs},...}}";
if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))
kept = going[1];
going = going[2];
else
kept = {};
endif
for s in (going)
new = {@new, @old[last + 1..last + s[1]], @s[2]};
last = last + s[1];
seq = {@seq, next + s[1], next = length(new) + 1};
endfor
caller.messages = {@new, @old[last + 1..$]};
caller.messages_going = {};
caller.messages_kept = $seq_utils:union(kept, $seq_utils:expand(caller.messages_kept, seq));
if ($object_utils:has_callable_verb(caller, "_fix_last_msg_date"))
caller:_fix_last_msg_date();
endif
return seq;
.
#46:20
":list_rmm()    displays contents of .messages_going.";
":expunge_rmm() destroys contents of .messages_going once and for all.";
"... both return the number of messages in .messages_going.";
set_task_perms(caller_perms());
cmg = caller.messages_going;
if (cmg && ((!cmg[1]) || (typeof(cmg[1][2]) == INT)))
kept = cmg[1];
cmg = cmg[2];
else
kept = {};
endif
if (verb == "expunge_rmm")
caller.messages_going = {};
count = 0;
for s in (cmg)
count = count + length(s[2]);
endfor
return count;
elseif (!cmg)
return 0;
else
msgs = seq = {};
next = 1;
for s in (cmg)
msgs = {@msgs, @s[2]};
seq = {@seq, next = next + s[1], next = next + length(s[2])};
endfor
kept = {@$seq_utils:contract(kept, $seq_utils:complement(seq, 1, $seq_utils:last(seq))), $maxint};
k = 1;
mcount = 0;
for x in (msgs)
if (kept[k] <= (mcount = mcount + 1))
k = k + 1;
endif
player:tell($string_utils:right(x[1], 4), ":", (k % 2) ? "  " | "= ", caller:msg_summary_line(@x[2]));
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
if (msgs)
player:tell("----+");
endif
return length(msgs);
endif
.
#46:21
":renumber([cur]) -- assumes caller is a $mail_recipient or a $player.";
"...renumbers caller.messages, doing a suspend() if necessary.";
"...returns {number of messages,new cur}.";
set_task_perms(caller_perms());
{?cur = 0} = args;
caller.messages_going = {};
"... blow away @rmm'ed messages since there's no way to tell what their new numbers should be...";
msgs = caller.messages;
if (cur)
cur = $list_utils:iassoc_sorted(cur, msgs);
endif
while (1)
"...find first out-of-sequence message...";
l = 0;
r = (len = length(msgs)) + 1;
while ((r - 1) > l)
if (msgs[i = (r + l) / 2][1] > i)
r = i;
else
l = i;
endif
endwhile
"... r == first out-of-sequence, l == last in-sequence, l+1 == r ...";
if (l >= len)
return {l, cur};
endif
"...renumber as many messages as we have time for...";
chunk = {};
while (((r <= len) && (ticks_left() > 3000)) && (seconds_left() > 2))
for x in (msgs[r..min(r + 9, len)])
chunk = {@chunk, {r, x[2]}};
r = r + 1;
endfor
endwhile
caller.messages = {@msgs[1..l], @chunk, @msgs[r..len]};
if (chunk)
player:tell("...(renumbering ", l + 1, " -- ", r - 1, ")");
suspend(0);
else
player:tell("You lose.  This message collection is just too big.");
return;
endif
"... have to be careful since new mail may be received at this point...";
msgs = caller.messages;
endwhile
.
#46:22
":msg_summary_line(@msg) => date/from/subject as a single string.";
body = ("" in {@args, ""}) + 1;
if ((body > length(args)) || (!(subject = args[body])))
subject = "(None.)";
endif
if (args[1] < (time() - 31536000))
c = player:ctime(args[1]);
date = c[5..11] + c[21..25];
else
date = player:ctime(args[1])[5..16];
endif
from = args[2];
if (args[4] != " ")
subject = args[4];
endif
return tostr(date, "   ", $string_utils:left(from, 20), "   ", subject);
.
#46:23
"parse_message_seq(strings,cur[,last_old])";
"This is the default <message-sequence> parsing routine for those mail commands that refer to sequences of messages (@mail, @read,...) on a folder.";
"  caller (the folder) is assumed to be a $mail_recipient or a player.";
"  strings is the <message-sequence> portion of the arg list.";
"  cur is the number of the player's current message for this folder.";
"Returns a string error message if the parse fails, otherwise";
"returns a list {msg_seq, @unused_strings}, where";
"   msg_seq is a handle understood by caller:display_seq_full/headers(), and ";
"   unused_strings is the list of remaining uninterpreted strings";
set_task_perms(caller_perms());
{strings, ?cur = 0, ?last_old = 0} = args;
if (!(nummsgs = caller:length_all_msgs()))
return "%f %<has> no messages.";
elseif (typeof(strings) != LIST)
strings = {strings};
endif
seq = result = {};
mode = #0;
"... changes to 0 if we start seeing message numbers, to 1 if we see masks...";
keywords = ":from:%from:to:%to:subject:body:before:after:since:until:first:last:kept:unkept";
keyalist = {{1, "from"}, {6, "%from"}, {12, "to"}, {15, "%to"}, {19, "subject"}, {27, "body"}, {32, "before"}, {39, "after"}, {45, "since"}, {51, "until"}, {57, "first"}, {63, "last"}, {68, "kept"}, {73, "unkept"}};
strnum = 0;
for string in (strings)
strnum = strnum + 1;
$command_utils:suspend_if_needed(0);
if (string && ((c = index(string, ":")) && ((k = index(keywords, ":" + string[1..c - 1])) && (k == rindex(keywords, ":" + string[1..c - 1])))))
"...we have a mask to apply...";
keywd = $list_utils:assoc(k, keyalist)[2];
if (mode == #0)
seq = {1, nummsgs + 1};
endif
mode = 1;
if (k <= 27)
"...from, subject, to, body...";
pattern = string[c + 1..$];
if (keywd in {"subject", "body"})
elseif (keywd[1] == "%")
pattern = $string_utils:explode(pattern, "|");
else
pattern = this:((keywd == "to") ? "_parse_to" | "_parse_from")(pattern);
if (typeof(pattern) == STR)
return pattern;
endif
endif
seq = caller:(keywd + "_msg_seq")(pattern, seq);
if (typeof(seq) == STR)
if (strnum == 1)
return seq;
else
seq = {};
endif
endif
elseif (k <= 51)
"...before, since, after, until...";
if (typeof(date = this:_parse_date(string[c + 1..$])) != INT)
return tostr("Bad date `", string, "':  ", date);
endif
s = caller:length_date_le((keywd in {"before", "since"}) ? date - 1 | (date + 86399));
if (keywd in {"before", "until"})
seq = $seq_utils:remove(seq, s + 1, nummsgs);
else
seq = $seq_utils:remove(seq, 1, s);
endif
elseif (k <= 63)
"...first, last...";
if (n = toint(string[c + 1..$]))
seq = $seq_utils:(keywd + "n")(seq, n);
else
return tostr("Bad number in `", string, "'");
endif
else
"...kept, unkept...";
if (c < length(string))
return tostr("Unexpected junk after `", keywd, ":'");
elseif ((!(seq = caller:(keywd + "_msg_seq")(seq))) && (strnum == 1))
return tostr("%f %<has> no ", keywd, " messages.");
endif
endif
else
"...continue building the present sequence...";
if (mode)
seq && (result = $seq_utils:union(result, seq));
seq = {};
endif
mode = 0;
if (!string)
"...default case for @read: get the current message but skip to the next one if it's not there...";
if (cur)
i = min(caller:length_num_le(cur - 1) + 1, nummsgs);
seq = $seq_utils:add(seq, i, i);
else
return "%f %<has> no current message.";
endif
elseif ((index(string, "next") == 1) && (!index(string, "-")))
string[1..4] = "";
if ((n = string ? toint(string) | 1) <= 0)
return tostr("Bad number `", string, "'");
elseif ((i = caller:length_num_le(cur) + 1) <= nummsgs)
seq = $seq_utils:add(seq, i, min((i + n) - 1, nummsgs));
else
return "%f %<has> no next message.";
endif
elseif ((index(string, "prev") == 1) && (!index(string, "-")))
string[1..4] = "";
if ((n = string ? toint(string) | 1) <= 0)
return tostr("Bad number `", string, "'");
elseif (i = caller:length_num_le(cur - 1))
seq = $seq_utils:add(seq, max(1, (i - n) + 1), i);
else
return "%f %<has> no previous message.";
endif
elseif (string == "new")
s = last_old ? caller:length_date_le(last_old) | caller:length_num_le(cur);
if (s < nummsgs)
seq = $seq_utils:add(seq, s + 1, nummsgs);
else
return "%f %<has> no new messages.";
endif
elseif (string == "first")
seq = $seq_utils:add(seq, 1, 1);
elseif (n = toint(string) || (((string in {"last", "$"}) && -1) || ((string == "cur") && cur)))
if (n <= 0)
seq = $seq_utils:add(seq, max(0, nummsgs + n) + 1, nummsgs);
elseif (i = caller:exists_num_eq(n))
seq = $seq_utils:add(seq, i, i);
else
return (string == "cur") ? "%f's current message has been removed." | tostr("%f %<has> no message numbered `", string, "'.");
endif
elseif (((i = index(string, "..")) > 1) || ((i = index(string, "-")) > 1))
if ((start = toint(sst = string[1..i - 1])) > 0)
s = caller:length_num_le(start - 1);
elseif (sst in {"next", "prev", "cur"})
s = max(0, caller:length_num_le(cur - (sst != "next")) - (sst == "prev"));
elseif (sst in {"last", "$"})
s = nummsgs - 1;
elseif (sst == "first")
s = 0;
else
return {$seq_utils:union(result, seq), @strings[strnum..$]};
endif
j = (string[i] == ".") ? i + 2 | (i + 1);
if ((end = toint(est = string[j..$])) > 0)
e = caller:length_num_le(end);
elseif (est in {"next", "prev", "cur"})
e = min(nummsgs, caller:length_num_le(cur - (est == "prev")) + (est == "next"));
elseif (est in {"last", "$"})
e = nummsgs;
elseif (est == "first")
e = 1;
else
return {$seq_utils:union(result, seq), @strings[strnum..$]};
endif
if (s < e)
seq = $seq_utils:add(seq, s + 1, e);
else
return tostr("%f %<has> no messages in range ", string, ".");
endif
elseif (string == "cur")
return "%f %<has> no current message.";
else
return {$seq_utils:union(result, seq), @strings[strnum..$]};
endif
endif
endfor
return {$seq_utils:union(result, seq)};
.
#46:24
":_parse_from(string with |'s in it) => object list";
":_parse_to(string with |'s in it) => object list";
"  for from:string and to:string items in :parse_message_seq";
if (verb == "_parse_to")
match_obj = fail_obj = this;
match_verb = "match_recipient";
fail_verb = "match_failed";
else
match_obj = $string_utils;
match_verb = "match_player";
fail_obj = $command_utils;
fail_verb = "player_match_failed";
endif
plist = {};
for w in ($string_utils:explode(args[1], "|"))
if (fail_obj:(fail_verb)(p = match_obj:(match_verb)(w), w))
p = $string_utils:literal_object(w);
if ((p == $failed_match) || (!$command_utils:yes_or_no("Continue? ")))
return "Bad address list:  " + args[1];
endif
endif
plist = setadd(plist, p);
endfor
return plist;
.
#46:25
words = $string_utils:explode(args[1], "-");
if (length(words) == 1)
if (index("yesterday", words[1]) == 1)
time = $time_utils:dst_midnight((time() - (time() % 86400)) - 86400);
elseif (index("today", words[1]) == 1)
time = $time_utils:dst_midnight(time() - (time() % 86400));
elseif (typeof(time = $time_utils:from_day(words[1], -1)) == ERR)
time = "weekday, `Today', `Yesterday', or date expected.";
endif
elseif ((!words) || ((length(words) > 3) || ((!toint(words[1])) || (E_TYPE == (year = $code_utils:toint({@words, "-1"}[3]))))))
time = "Date should be of the form `5-Jan', `5-Jan-92', `Wed',`Wednesday'";
else
day = toint(words[1]);
time = $time_utils:dst_midnight($time_utils:from_month(words[2], -1, day));
if (length(words) == 3)
thisyear = toint(ctime(time)[21..24]);
if (100 > year)
year = (thisyear + 50) - (((thisyear - year) + 50) % 100);
endif
time = $time_utils:dst_midnight($time_utils:from_month(words[2], (year - thisyear) - (year <= thisyear), day));
endif
endif
return time;
.
#46:26
":new_message_num() => number that the next incoming message will receive.";
set_task_perms(caller_perms());
new = (msgs = caller.messages) ? msgs[$][1] + 1 | 1;
if (rmsgs = caller.messages_going)
if ((!rmsgs[1]) || (typeof(rmsgs[1][2]) == INT))
rmsgs = rmsgs[2];
endif
lbrm = rmsgs[$][2];
return max(new, lbrm[$][1] + 1);
else
return new;
endif
.
#46:27
set_task_perms(caller_perms());
return length(caller.messages);
.
#46:28
set_task_perms(caller_perms());
date = args[1];
msgs = caller.messages;
if ((r = length(caller.messages)) < 25)
for l in [1..r]
if (msgs[l][2][1] > date)
return l - 1;
endif
endfor
return r;
else
l = 1;
while (l <= r)
if (date < msgs[i = (r + l) / 2][2][1])
r = i - 1;
else
l = i + 1;
endif
endwhile
return r;
endif
.
#46:29
set_task_perms(caller_perms());
date = args[1];
msgs = caller.messages;
if ((len = length(caller.messages)) < 25)
for r in [0..len - 1]
if (msgs[len - r][2][1] <= date)
return r;
endif
endfor
return len;
else
l = 1;
r = len;
while (l <= r)
if (date < msgs[i = (r + l) / 2][2][1])
r = i - 1;
else
l = i + 1;
endif
endwhile
return len - r;
endif
.
#46:30
":length_num_le(num) => number of messages in folder numbered <= num";
set_task_perms(caller_perms());
return $list_utils:iassoc_sorted(args[1], caller.messages);
.
#46:31
":exists_num_eq(num) => index of message in folder numbered == num";
set_task_perms(caller_perms());
return (i = $list_utils:iassoc_sorted(args[1], caller.messages)) && ((caller.messages[i][1] == args[1]) && i);
.
#46:32
":from_msg_seq(object or list[,mask])";
" => msg_seq of messages from any of these senders";
set_task_perms(caller_perms());
{plist, ?mask = {1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
i = 1;
fseq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
fromline = msg[2][2];
for f in ($mail_agent:parse_address_field(fromline))
if (f in plist)
fseq = $seq_utils:add(fseq, i, i);
endif
endfor
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
.
#46:33
":%from_msg_seq(string or list of strings[,mask])";
" => msg_seq of messages with one of these strings in the from line";
set_task_perms(caller_perms());
{nlist, ?mask = {1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
i = 1;
fseq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
fromline = " " + msg[2][2];
for n in (nlist)
if (index(fromline, n))
fseq = $seq_utils:add(fseq, i, i);
endif
endfor
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg($string_utils, "print", nlist), "no one", " or "));
.
#46:34
":to_msg_seq(object or list[,mask]) => msg_seq of messages to those people";
set_task_perms(caller_perms());
{plist, ?mask = {1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
i = 1;
seq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
toline = msg[2][3];
for r in ($mail_agent:parse_address_field(toline))
if (r in plist)
seq = $seq_utils:add(seq, i, i);
endif
endfor
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return seq || ("%f %<has> no messages to " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
.
#46:35
":%to_msg_seq(string or list of strings[,mask])";
" => msg_seq of messages containing one of strings in the to line";
set_task_perms(caller_perms());
{nlist, ?mask = {1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
i = 1;
seq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
toline = " " + msg[2][3];
for n in (nlist)
if (index(toline, n))
seq = $seq_utils:add(seq, i, i);
endif
endfor
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return seq || ("%f %<has> no messages to " + $string_utils:english_list($list_utils:map_arg($string_utils, "print", nlist), "no one", " or "));
.
#46:36
":subject_msg_seq(target) => msg_seq of messages with target in the Subject:";
set_task_perms(caller_perms());
{target, ?mask = {1}} = args;
i = 1;
seq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
subject = msg[2][4];
if (index(subject, target))
seq = $seq_utils:add(seq, i, i);
endif
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return seq || (("%f %<has> no messages with subjects containing `" + target) + "'");
.
#46:37
":body_msg_seq(target[,mask]) => msg_seq of messages with target in the body";
set_task_perms(caller_perms());
{target, ?mask = {1}} = args;
i = 1;
seq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ({@mask, $maxint}[2] <= i)
mask = mask[3..$];
"Old code follows. Lets save ticks and munge up the whole message body into one big string and index it. Don't need to know where target is in there, just that it is or isn't there";
elseif (((bstart = "" in (msg = msg[2])) && (length(msg) > bstart)) && index(tostr(@msg[bstart + 1..$]), target))
seq = $seq_utils:add(seq, i, i);
"elseif ((bstart = \"\" in (msg = msg[2])) && (l = length(msg)) > bstart)";
"while (!index(msg[l], target) && (l = l - 1) > bstart)";
"$command_utils:suspend_if_needed(0);";
"endwhile";
"if (l > bstart)";
"seq = $seq_utils:add(seq, i, i);";
"endif";
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return seq || tostr("%f %<has> no messages containing `", target, "' in the body.");
.
#46:38
":messages_in_seq(msg_seq) => list of messages in msg_seq on folder (caller)";
set_task_perms(caller_perms());
if (typeof(msgs = args[1]) != LIST)
return caller.messages[msgs];
elseif (length(msgs) == 2)
return caller.messages[msgs[1]..msgs[2] - 1];
else
return $seq_utils:extract(msgs, caller.messages);
endif
.
#46:39
":__convert_new(@msg) => msg in new format (if it isn't already)";
"               ^ don't forget the @ here.";
"If the msg is already in the new format it passes through unchanged.";
"If the msg format is unrecognizable, warnings are printed.";
if (typeof(date = args[1]) != INT)
date = 0;
start = 1;
else
start = 2;
if (!((colon = index(args[2], ":")) && (args[2][1..colon] in {"From:", "To:", "Subject:"})))
return args;
endif
endif
from = to = 0;
subject = " ";
blank = "" in {@args, ""};
newhdr = {};
for line in (args[start..blank - 1])
if (index(line, "Date:") == 1)
if (date)
player:notify("Warning: two dates?");
endif
date = $time_utils:from_ctime(line[6..$]);
elseif (index(line, "From:") == 1)
if (from)
player:notify("Warning: two from-lines?");
endif
from = $string_utils:triml(line[6..$]);
elseif (index(line, "To:") == 1)
if (to)
player:notify("Warning: two to-lines?");
endif
to = $string_utils:triml(line[6..$]);
elseif (index(line, "Subject:") == 1)
subject = $string_utils:triml(line[9..$]);
else
newhdr = {@newhdr, line};
endif
endfor
if (!from)
player:notify("Warning: no from-line.");
endif
if (!to)
player:notify("Warning: no to-line.");
endif
return {date, from, to, subject, @newhdr, @args[blank..$]};
.
#46:40
":to_text(@msg) => message in text form (suitable for printing)";
return {"Date:     " + player:ctime(args[1]), "From:     " + args[2], "To:       " + args[3], @(args[4] == " ") ? {} | {"Subject:  " + args[4]}, @args[5..$]};
.
#46:41
what = args[1];
if ($object_utils:isa(what, $mail_recipient))
return what:(verb)(@listdelete(args, 1));
else
"...it's a player:";
"...  anyone can send mail to it.";
"...  only the player itself or a wizard can read it.";
return (verb == "is_usable_by") || $perm_utils:controls(args[2], what);
endif
.
#46:42
":reserved_pattern(string)";
"  if string matches one of the reserved patterns for mailing list names, ";
"  we return that element of .reserved_patterns.";
string = args[1];
for p in (this.reserved_patterns)
if (match(string, p[1]))
return p;
endif
endfor
return 0;
.
#46:43
return valid(what = args[1]) && (($mail_recipient_class in (ances = $object_utils:ancestors(what))) || ($mail_recipient in ances));
.
#46:44
":keep_message_seq(msg_seq)";
"...If msg_seq nonempty {}, this marks the indicated messages on this folder (caller)";
"...as immune from expiration.";
"...If msg_seq == {}, this clears all such marks.";
set_task_perms(caller_perms());
msg_seq = args[1];
if (!msg_seq)
caller.messages_kept = {};
return 1;
endif
prev_kept = caller.messages_kept;
caller.messages_kept = new_kept = $seq_utils:union(prev_kept, msg_seq);
added = $seq_utils:intersection(new_kept, $seq_utils:complement(prev_kept));
if (!added)
return "";
endif
"... urk.  now we need to get the actual numbers of the messages being kept.";
nums = {};
start = 0;
for a in (added)
nums = {@nums, (start = !start) ? caller:messages_in_seq(a)[1] | (caller:messages_in_seq(a - 1)[1] + 1)};
endfor
return $seq_utils:tostr(nums);
.
#46:45
":kept_msg_seq([mask])";
" => msg_seq of messages that are marked kept";
":unkept_msg_seq([mask])";
" => msg_seq of messages that are not marked kept";
set_task_perms(caller_perms());
{?mask = {1}} = args;
if (k = verb == "kept_msg_seq")
kseq = $seq_utils:intersection(mask, caller.messages_kept);
else
kseq = $seq_utils:intersection(mask, $seq_utils:range(1, caller:length_all_msgs()), $seq_utils:complement(caller.messages_kept));
endif
return kseq;
.
#46:46
":msg_seq_to_msg_num_string(msg_seq) => string giving the corresponding message numbers";
set_task_perms(caller_perms());
return $seq_utils:tostr($seq_utils:from_list($list_utils:slice(caller:messages_in_seq(args[1]))));
.
#46:47
":msg_seq_to_msg_num_list(msg_seq) => list of corresponding message numbers";
set_task_perms(caller_perms());
return $list_utils:slice(caller:messages_in_seq(args[1]));
.
#46:48
"send_log_message(perms,from,rcpt-list,hdrs,msg) -- formats and sends a mail message. hders is either the text of the subject line, or a {subject,{reply-to,...}} list.";
"KLUDGE.  this may go away.";
"Send a message while supplying a different permission for use by :mail_forward to determine moderation action.";
"Return E_PERM unless called by a wizard.";
"Return {0, @invalid_rcpts} if rcpt-list contains any invalid addresses.  No mail is sent in this case.";
"Return {1, @actual_rcpts} if successful.";
{perms, from, to, hdrs, msg} = args;
if (caller_perms().wizard)
text = $mail_agent:make_message(from, to, hdrs, msg);
return this:raw_send(text, to, perms);
else
return E_PERM;
endif
.
#46:49
":parse_misc_headers(msg,@extract_names)";
"Extracts the miscellaneous (i.e., not including Date: From: To: Subject:)";
"from msg (a mail message in the usual transmission format).";
"Extract_names is a list of header names";
"=> {other_headers,bogus_headers,extract_texts,body}";
"where each element of extract_texts is a string or 0";
"  according as the corresponding header in extract_names is present.";
"bogus_headers is a list of those headers that are undecipherable";
"other_headers is a list of {header_name,header_text} for the remaining";
"  miscellaneous headers.";
"headers in msg";
msgtxt = args[1];
extract_names = listdelete(args, 1);
extract_texts = $list_utils:make(length(extract_names));
heads = bogus = {};
for h in (msgtxt[5..(bstart = "" in {@msgtxt, ""}) - 1])
if (m = match(h, "%([a-z1-9-]+%): +%(.*%)"))
hname = h[m[3][1][1]..m[3][1][2]];
htext = h[m[3][2][1]..m[3][2][2]];
if (i = hname in extract_names)
extract_texts[i] = htext;
else
heads = {@heads, {hname, htext}};
endif
else
bogus = {@bogus, h};
endif
endfor
return {heads, bogus, extract_texts, msgtxt[bstart + 1..$]};
.
#46:50
"resend_message(new_sender,new_rcpts,from,to,hdrs,body)";
" -- reformats and resends a previously sent message to new recipients.";
"msg is the previous message";
"Return E_PERM if new_sender isn't owned by the caller.";
"Return {0, @invalid_rcpts} if new_rcpts contains any invalid addresses.  No mail is sent in this case.";
"Return {1, @actual_rcpts} if successful.";
{new_sender, new_rcpts, from, to, hdrs, body} = args;
if (typeof(hdrs) != LIST)
hdrs = {hdrs, 0};
elseif (length(hdrs) < 2)
hdrs = {@hdrs || {""}, 0};
endif
hdrs[3..2] = {{"Resent-By", this:name_list(new_sender)}, {"Resent-To", this:name_list(@new_rcpts)}};
if ($perm_utils:controls(caller_perms(), new_sender))
text = $mail_agent:make_message(from, to, hdrs, body);
return this:raw_send(text, new_rcpts, new_sender);
else
return E_PERM;
endif
.
#46:51
if (caller_perms().wizard)
this.reserved_patterns = {};
this.last_mail_time = 0;
this.time_collisions = {0, 0};
pass(@args);
endif
.
#46:52
"This was inspired by Xeric's port 4632 on *Core-DB-Issues";
now = time();
return now;
"skipping the below for now because the mail system's clock is getting very out of sync. suspect someone's playing games to run up the clock. HTC 6 Jan 2003";
if (caller == this)
if (now > this.last_mail_time)
return this.last_mail_time = now;
else
this.time_collisions[2] = this.time_collisions[2] + 1;
return this.last_mail_time = this.last_mail_time + 1;
endif
else
return now;
endif
.
#46:53
":set_message_body_by_index(i,newbody)";
"Replaces the body of the i-th message on the (caller) recipient.";
"i must be a message index (not a message number) in the range 1 .. number of messages,";
"newbody must be a list of strings.";
set_task_perms(caller_perms());
{i, body} = args;
bstart = "" in caller.messages[i][2];
if (bstart)
caller.messages[i][2][bstart + 1..$] = body;
else
caller.messages[i][2][$ + 1..$] = {"", @body};
endif
.
#46:55
":message_body_by_index(i)";
"Return the body of the i-th message on the (caller) recipient.";
"i must be a message index (not a message number) in the range 1 .. number of messages,";
set_task_perms(caller_perms());
{i} = args;
msg = caller:messages_in_seq({i, i + 1})[1][2];
bstart = "" in msg;
return msg[bstart ? bstart + 1 | ($ + 1)..$];
.
#47:0
return this:ok(who = args[1]) && tostr("a letter ", this:sending(who) ? "(in transit) " | "", "to ", this:recipient_names(who), (subject = `this.subjects[who] ! ANY') && tostr(" entitled \"", subject, "\""));
.
#47:1
"invoke(rcptstrings,verb[,subject]) for a @send";
"invoke(1,verb,rcpts,subject,replyto,body) if no parsing is needed";
"invoke(2,verb,msg,flags,replytos) for an @answer";
if (!(which = args[1]))
player:tell_lines({tostr("Usage:  ", args[2], " <list-of-recipients>"), tostr("        ", args[2], "                      to continue with a previous draft")});
elseif (typeof(which) == LIST)
"...@send...";
if (rcpts = this:parse_recipients({}, which))
if (replyto = player:mail_option("replyto"))
replyto = this:parse_recipients({}, replyto, ".mail_options: ");
endif
if (0 == (subject = {@args, 0}[3]))
if (player:mail_option("nosubject"))
subject = "";
else
player:tell("Subject:");
subject = $command_utils:read();
endif
endif
return {rcpts, subject, replyto, {}};
endif
elseif (which == 1)
return args[3..6];
elseif (!(to_subj = this:parse_msg_headers(msg = args[3], flags = args[4])))
else
include = {};
if ("include" in flags)
prefix = ">            ";
for line in ($mail_agent:to_text(@msg))
if (!line)
prefix = ">  ";
include = {@include, prefix};
else
include = {@include, @this:fill_string(">  " + line, 70, prefix)};
endif
endfor
endif
return {@to_subj, args[5], include};
endif
return 0;
.
#47:2
{who, recip, subj, replyto, msg} = args;
if (this:ok(who))
this.sending[who] = 0;
this.recipients[who] = recip;
this.subjects[who] = subj;
this.replytos[who] = replyto || {};
this:load(who, msg);
this.active[who]:tell("Composing ", this:working_on(who));
p = this.active[who];
"if (p:mail_option(\"enter\") && !args[5])";
"Changed from above so that @reply can take advantage of @mailoption +enter. Ho_Yan 11/9/94";
if (p:mail_option("enter"))
if (typeof(lines = $command_utils:read_lines()) == ERR)
p:tell(lines);
else
this:insert_line(p in this.active, lines, 0);
endif
endif
endif
.
#47:3
if (!dobjstr)
plyr = player;
elseif ($command_utils:player_match_result(plyr = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
endif
if ((plyr != player) && (!this:readable(plyr in this.active)))
player:tell(plyr.name, "(", plyr, ") has not published anything here.");
elseif (typeof(msg = this:message_with_headers(plyr in this.active)) != LIST)
player:tell(msg);
else
player:display_message({((plyr == player) ? "Your" | tostr(plyr.name, "(", plyr, ")'s")) + " message so far:", ""}, player:msg_text(@msg));
endif
.
#47:4
return (this:readable(who = args[1]) || this:ok(who)) && $mail_agent:make_message(this.active[who], this.recipients[who], {this.subjects[who], this.replytos[who]}, this:text(who));
.
#47:5
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (!argstr)
player:tell(this.subjects[who]);
elseif (ERR == typeof(subj = this:set_subject(who, argstr)))
player:tell(subj);
else
player:tell(subj ? ("Setting the subject line for your message to \"" + subj) + "\"." | "Deleting the subject line for your message.");
endif
.
#47:6
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
else
this.subjects[who] = subj = args[2];
this:set_changed(who, 1);
return subj;
endif
.
#47:7
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
elseif ((!(task = this.sending[who])) || $code_utils:task_valid(task))
return task;
else
"... uh oh... sending task crashed...";
this:set_changed(who, 1);
return this.sending[who] = 0;
endif
.
#47:8
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (!args)
player:tell("Your message is currently to ", this:recipient_names(who), ".");
else
this.recipients[who] = this:parse_recipients({}, args);
this:set_changed(who, 1);
player:tell("Your message is now to ", this:recipient_names(who), ".");
endif
.
#47:9
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
this.recipients[who] = this:parse_recipients(this.recipients[who], args);
this:set_changed(who, 1);
player:tell("Your message is now to ", this:recipient_names(who), ".");
endif
.
#47:10
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
recips = this.recipients[who];
nonmrs = {};
mrs = {};
for o in (recips)
if ($object_utils:isa(o, $mail_recipient))
mrs = {@mrs, o};
else
nonmrs = {@nonmrs, o};
endif
endfor
for a in (args)
if (!a)
player:tell("\"\"?");
return;
elseif (valid(aobj = $mail_agent:match_recipient(a)) && (aobj in recips))
elseif ($failed_match != (aobj = $string_utils:literal_object(a)))
if (!(aobj in recips))
player:tell(aobj, " was not a recipient.");
return;
endif
elseif ((a[1] == "*") && valid(aobj = $string_utils:match(a[2..$], mrs, "aliases")))
elseif ((a[1] != "*") && valid(aobj = $string_utils:match(a, nonmrs, "aliases")))
elseif (valid(aobj = $string_utils:match(a, recips, "aliases")))
else
player:tell("couldn't find \"", a, "\" in To: list.");
return;
endif
recips = setremove(recips, aobj);
endfor
this.recipients[who] = recips;
this:set_changed(who, 1);
player:tell("Your message is now to ", this:recipient_names(who), ".");
endif
.
#47:11
"parse_recipients(prev_list,list_of_strings) -- parses list of strings and adds any resulting player objects to prev_list.  Optional 3rd arg is prefixed to any mismatch error messages";
{recips, l, ?cmd_id = ""} = args;
cmd_id = cmd_id || "";
for s in ((typeof(l) == LIST) ? l | {l})
if (typeof(s) != STR)
if ($mail_agent:is_recipient(s))
recips = setadd(recips, s);
else
player:tell(cmd_id, s, " is not a valid mail recipient.");
endif
elseif (!$mail_agent:match_failed(md = $mail_agent:match_recipient(s), s, cmd_id))
recips = setadd(recips, md);
endif
endfor
return recips;
.
#47:12
return this:ok(who = args[1]) && $mail_agent:name_list(@this.recipients[who]);
.
#47:13
return $mail_agent:make_message(@args);
.
#47:14
"(obsolete verb... see $mail_agent:name_list)";
return $mail_agent:(verb)(@args[1]);
.
#47:15
"parse_msg_headers(msg,flags)";
"  parses msg to extract reply recipients and construct a subject line";
"  if the \"all\" flag is present, reply goes to all of the original recipients";
"  returns a list {recipients, subjectline} or 0 in case of error.";
{msg, flags} = args;
replyall = "all" in flags;
objects = {};
if ("followup" in flags)
"...look for first non-player recipient in To: line...";
for o in ($mail_agent:parse_address_field(msg[3]))
if (objects)
break o;
elseif ($object_utils:isa(o, $mail_recipient))
objects = {o};
endif
endfor
endif
objects = objects || $mail_agent:parse_address_field(msg[2] + (replyall ? msg[3] | ""));
for line in (msg[5..("" in {@msg, ""}) - 1])
if (rt = index(line, "Reply-to:") == 1)
objects = $mail_agent:parse_address_field(line);
endif
endfor
recips = {};
for o in (objects)
if (o == #0)
player:tell("Sorry, but I can't parse the header of that message.");
return 0;
elseif ((!valid(o)) || (!(is_player(o) || ($mail_recipient in $object_utils:ancestors(o)))))
player:tell(o, " is no longer a valid player or maildrop; ignoring that recipient.");
elseif (o != player)
recips = setadd(recips, o);
endif
endfor
subject = msg[4];
if (subject == " ")
subject = "";
elseif (subject && (index(subject, "Re: ") != 1))
subject = "Re: " + subject;
endif
return {recips, subject};
.
#47:16
flags = {};
for o in ({"all", "include", "followup"})
if (player:mail_option(o))
flags = {@flags, o};
endif
endfor
reply_to = player:mail_option("replyto") || {};
flaglist = "+1#include -1#noinclude +2#all -2#sender 0#replyto +3#followup ";
for a in (args)
if (i = index(a, "="))
value = a[i + 1..$];
a = a[1..i - 1];
else
value = "";
endif
if ((typeof(a) != STR) || ((i = index(flaglist, "#" + a)) < 3))
player:tell("Unrecognized answer/reply option:  ", a);
return 0;
elseif (i != rindex(flaglist, "#" + a))
player:tell("Ambiguous answer/reply option:  ", a);
return 0;
elseif (j = index("0123456789", flaglist[i - 1]) - 1)
if (value)
player:tell("Flag does not take a value:  ", a);
return 0;
endif
f = {"include", "all", "followup"}[j];
flags = (flaglist[i - 2] == "+") ? setadd(flags, f) | setremove(flags, f);
if (f == "all")
flags = setremove(flags, "followup");
endif
elseif ((!value) || (value = this:parse_recipients({}, $string_utils:explode(value), "replyto flag:  ")))
reply_to = value || {};
endif
endfor
return {flags, reply_to};
.
#47:17
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
if (args)
this.replytos[who] = rt = this:parse_recipients({}, args);
this:set_changed(who, 1);
else
rt = this.replytos[who];
endif
player:tell(rt ? ("Replies will go to " + $mail_agent:name_list(@this.replytos[who])) + "." | "Reply-to field is empty.");
endif
.
#47:18
"WIZARDLY";
if (!(who = this:loaded(player)))
player:notify(this:nothing_loaded_msg());
elseif (!(recips = this.recipients[who]))
player:notify("Umm... your message isn't addressed to anyone.");
elseif (this:sending(who))
player:notify("Again? ... relax... it'll get there eventually.");
else
msg = this:message_with_headers(who);
this.sending[who] = old_sending = task_id();
this:set_changed(who, 0);
player:notify("Sending...");
"... this sucker can suspend BIG TIME...";
result = $mail_agent:raw_send(msg, recips, player);
"... the world changes...";
who = player in this.active;
if (who && (this.sending[who] == old_sending))
"... same editing session; no problemo...";
previous = "";
this.sending[who] = 0;
else
"... uh oh, different session... tiptoe quietly out...";
"... Don't mess with the session.";
previous = "(prior send) ";
endif
if (!(e = result[1]))
player:notify(tostr(previous, (typeof(e) == ERR) ? e | ("Bogus recipients:  " + $string_utils:from_list(result[2]))));
player:notify(tostr(previous, "Mail not sent."));
previous || this:set_changed(who, 1);
elseif (length(result) == 1)
player:notify(tostr(previous, "Mail not actually sent to anyone."));
previous || this:set_changed(who, 1);
else
player:notify(tostr(previous, "Mail actually sent to ", $mail_agent:name_list(@listdelete(result, 1))));
if (previous)
"...don't even think about it...";
elseif (player.location == this)
if (ticks_left() < 10000)
suspend(0);
endif
this:done();
elseif (!this:changed(who))
"... player is gone, no further edits...";
this:kill_session(who);
endif
endif
endif
.
#47:19
if (dobjstr)
if (!(recips = this:parse_recipients({}, args)))
"parse_recipients has already complained about anything it doesn't like";
return;
endif
elseif (caller != player)
return E_PERM;
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
else
recips = this.recipients[who];
endif
resolve = $mail_agent:resolve_addr(recips, player);
if (resolve[1])
player:tell("Bogus addresses:  ", $string_utils:english_list(resolve[1]));
else
player:tell(dobjstr ? ("Mail to " + $mail_agent:name_list(@recips)) + " actually goes to " | "Your mail will actually go to ", $mail_agent:name_list(@resolve[2]));
endif
.
#47:20
player:tell_lines({"Available aliases:", ""});
for c in ((dobjstr == "all") ? $object_utils:descendants($mail_recipient) | $mail_agent.contents)
if (c:is_usable_by(player) || c:is_readable_by(player))
c:look_self();
endif
endfor
.
#47:21
if (!iobjstr)
player:tell("Usage:  ", verb, " [<list-of-people/lists>] from <list>");
return;
elseif ($mail_agent:match_failed(iobj = $mail_agent:match(iobjstr), iobjstr))
return;
endif
rstrs = dobjstr ? $string_utils:explode(dobjstr) | {"me"};
recips = this:parse_recipients({}, rstrs);
outcomes = iobj:delete_forward(@recips);
if (typeof(outcomes) != LIST)
player:tell(outcomes);
return;
endif
removed = {};
for r in [1..length(recips)]
if (typeof(e = outcomes[r]) == ERR)
player:tell(verb, " ", recips[r].name, " from ", iobj.name, ":  ", (e == E_INVARG) ? "Not on list." | e);
else
removed = setadd(removed, recips[r]);
endif
endfor
if (removed)
player:tell($string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%(name) (%#)", removed)), " removed from ", iobj.name, " (", iobj, ")");
endif
.
#47:22
return this:ok(who = args[1]) && (this:sending(who) || pass(@args));
.
#47:23
"recall that this only gets called if :retain_session_on_exit returns true";
return (this:ok(who = player in this.active) && (!this:changed(who))) ? {"Your message is in transit."} | this.(verb);
.
#47:24
lines = {"To:       " + (toline = $mail_agent:name_list(@args[1])), "Subject:  " + $string_utils:trim(subject = args[2])};
if (args[3])
lines = {@lines, "Reply-to: " + $mail_agent:name_list(@args[3])};
endif
lines = {@lines, "", @args[4]};
return {tostr("MOOMail", subject ? ("(" + subject) + ")" | (("-to(" + toline) + ")")), lines, "@@sendmail", "sendmail", "string-list"};
.
#48:0
if (this:changed(who = player in this.active))
player:tell("You are still editing ", this:working_on(who), ".  Please type ABORT or SAVE first.");
elseif (spec = this:parse_invoke(dobjstr, verb))
this:init_session(who, @spec);
endif
.
#48:1
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
if (!dobjstr)
note = this.objects[who];
elseif (1 == (note = this:note_match_failed(dobjstr)))
return;
else
this.objects[who] = note;
endif
text = this:text(who);
strmode = (length(text) <= 1) && this.strmode[who];
if (strmode)
text = text ? text[1] | "";
endif
if (ERR == typeof(result = this:set_note_text(note, text)))
player:tell("Text not saved to ", this:working_on(who), ":  ", result);
if ((result == E_TYPE) && (typeof(note) == OBJ))
player:tell("Do `mode list' and try saving again.");
elseif (!dobjstr)
player:tell("Use `save' with an argument to save the text elsewhere.");
endif
else
player:tell("Text written to ", this:working_on(who), strmode ? " as a single string." | ".");
this:set_changed(who, 0);
endif
.
#48:2
if (this:ok(who = args[1]))
this.strmode[who] = strmode = typeof(text = args[3]) == STR;
this:load(who, strmode ? text ? {text} | {} | text);
this.objects[who] = args[2];
player:tell("Now editing ", this:working_on(who), ".", strmode ? "  [string mode]" | "");
endif
.
#48:3
if (!(who = args[1]))
return "????";
endif
spec = this.objects[who];
if (typeof(spec) == LIST)
object = spec[1];
prop = spec[2];
else
object = spec;
prop = 0;
endif
return valid(object) ? tostr("\"", object.name, "\"(", object, ")", prop ? "." + prop | "") | tostr(prop ? ("." + prop) + " on " | "", "invalid object (", object, ")");
.
#48:4
":parse_invoke(string,verb)";
" string is the actual commandline string indicating what we are to edit";
" verb is the command verb that is attempting to invoke the editor";
if (caller != this)
raise(E_PERM);
elseif (!(string = args[1]))
player:tell_lines({("Usage:  " + args[2]) + " <note>   (where <note> is some note object)", ("        " + args[2]) + "          (continues editing an unsaved note)"});
elseif (1 == (note = this:note_match_failed(string)))
elseif (ERR == typeof(text = this:note_text(note)))
player:tell("Couldn't retrieve text:  ", text);
elseif ((player:edit_option("local") == 0) && $edit_utils:get_option("default_editor", player))
fork (0)
text = $edit_utils:editor((!text) ? {} | text);
result = $note_editor:set_note_text(note, text);
if (typeof(result) == ERR)
player:tell("Unable to set text: ", e[2]);
else
player:tell("Edited ", note[2], " of ", $su:nn(note[1]), ".");
endif
endfork
kill_task(task_id());
else
return {note, text};
endif
return 0;
.
#48:5
"WIZARDLY";
if ((caller != $note_editor) || (caller_perms() != $note_editor.owner))
return E_PERM;
endif
set_task_perms(player);
if (typeof(spec = args[1]) == OBJ)
text = spec:text();
else
text = `spec[1].(spec[2]) ! ANY';
endif
if (typeof(text) in {ERR, STR, LIST})
return text;
else
return E_TYPE;
endif
.
#48:6
"WIZARDLY";
if ((caller != $note_editor) || (caller_perms() != $note_editor.owner))
return E_PERM;
endif
set_task_perms(player);
attempt = E_NONE;
if (typeof(spec = args[1]) == OBJ)
return spec:set_text(args[2]);
elseif ($object_utils:has_callable_verb(spec[1], "set_" + spec[2]))
attempt = spec[1]:("set_" + spec[2])(args[2]);
endif
if (typeof(attempt) == ERR)
return `spec[1].(spec[2]) = args[2] ! ANY';
else
return attempt;
endif
.
#48:7
if (pp = $code_utils:parse_propref(string = args[1]))
object = pp[1];
prop = pp[2];
else
object = string;
prop = 0;
endif
if ($command_utils:object_match_failed(note = player:my_match_object(object, this:get_room(player)), object))
elseif (prop)
if (!$object_utils:has_property(note, prop))
player:tell(object, " has no \".", prop, "\" property.");
else
return {note, prop};
endif
elseif ((!$object_utils:has_callable_verb(note, "text")) || (!$object_utils:has_callable_verb(note, "set_text")))
return {note, "description"};
"... what we used to do.  but why barf?   that's no fun...";
player:tell(object, "(", note, ") doesn't look like a note.");
else
return note;
endif
return 1;
.
#48:8
pass(@args);
if ((who = this:loaded(player)) && this.strmode[who])
player:tell("Text will be stored as a single string instead of a list when possible.");
endif
.
#48:9
"mode [string|list]";
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
if (dobjstr && (index("string", dobjstr) == 1))
this.strmode[who] = mode = 1;
player:tell("Now in string mode:");
elseif (dobjstr && (index("list", dobjstr) == 1))
this.strmode[who] = mode = 0;
player:tell("Now in list mode:");
elseif (dobjstr)
player:tell("Unrecognized mode:  ", dobjstr);
player:tell("Should be one of `string' or `list'");
return;
else
player:tell("Currently in ", (mode = this.strmode[who]) ? "string " | "list ", "mode:");
endif
if (mode)
player:tell("  store text as a single string instead of a list when possible.");
else
player:tell("  always store text as a list of strings.");
endif
.
#48:10
{what, text} = args;
cmd = (typeof(text) == STR) ? "@set-note-string" | "@set-note-text";
name = (typeof(what) == OBJ) ? what.name | tostr(what[1].name, ".", what[2]);
note = (typeof(what) == OBJ) ? what | tostr(what[1], ".", what[2]);
"Check if the text is a list of strings. If so, edit it like text. Otherwise, parse values.";
type = "str:";
for x in (text)
if (typeof(x) != STR)
type = "val:";
break;
endif
endfor
ref = tostr(type, (typeof(what) == OBJ) ? tostr(what, ".text") | tostr(what[1], ".", what[2]));
return {name, text, tostr(cmd, " ", note), ref, "string-list"};
.
#48:11
if ($perm_utils:controls(caller_perms(), this))
return pass(@args);
else
return E_PERM;
endif
.
#49:0
if (!args)
player:tell("edit what?");
else
this:invoke(argstr, verb);
endif
.
#49:1
pas = {{}, {}};
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
elseif (!args)
object = this.objects[who];
vname = this.verbnames[who];
if (typeof(vname) == LIST)
vargs = listdelete(vname, 1);
vname = vname[1];
else
vargs = {};
endif
changeverb = 0;
elseif ((args[1] != "as") || ((length(args) < 2) || ((!(spec = $code_utils:parse_verbref(args[2]))) || ((typeof(pas = $code_utils:parse_argspec(@args[3..$])) != LIST) || pas[2]))))
if (typeof(pas) != LIST)
player:tell(pas);
elseif (pas[2])
player:tell("I don't understand \"", $string_utils:from_list(pas[2], " "), "\"");
endif
player:tell("Usage: ", verb, " [as <object>:<verb>]");
return;
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1], this:get_room(player)), spec[1]))
return;
else
vname = spec[2];
vargs = pas[1] && {@pas[1], "none", "none"}[1..3];
if (vargs)
vargs[2] = $code_utils:full_prep(vargs[2]) || vargs[2];
endif
changeverb = 1;
endif
if (vargs)
vnum = $code_utils:find_verb_named(object, vname);
while (vnum && (this:fetch_verb_args(object, vnum) != vargs))
vnum = $code_utils:find_verb_named(object, vname, vnum + 1);
endwhile
if (!vnum)
player:tell("There is no ", object, ":", vname, " verb with args (", $string_utils:from_list(vargs, " "), ").");
if (!changeverb)
player:tell("Use 'compile as ...' to write your code to another verb.");
endif
return;
endif
objverbname = tostr(object, ":", vname, " (", $string_utils:from_list(vargs, " "), ")");
else
vnum = 0;
objverbname = tostr(object, ":", ($code_utils:toint(vname) == E_TYPE) ? vname | this:verb_name(object, vname));
endif
"...";
"...perform eval_subs on verb code if necessary...";
"...";
if (player.eval_subs && player:edit_option("eval_subs"))
verbcode = {};
for x in (this:text(who))
verbcode = {@verbcode, $code_utils:substitute(x, player.eval_subs)};
endfor
else
verbcode = this:text(who);
endif
"...";
"...write it out...";
"...";
if (result = this:set_verb_code(object, vnum ? vnum | vname, verbcode))
player:tell(objverbname, " not compiled because:");
for x in (result)
player:tell("  ", x);
endfor
elseif (typeof(result) == ERR)
player:tell({result, ("You do not have write permission on " + objverbname) + ".", ("The verb " + objverbname) + " does not exist (!?!)", ("The object " + tostr(object)) + " does not exist (!?!)"}[1 + (result in {E_PERM, E_VERBNF, E_INVARG})]);
if (!changeverb)
player:tell("Do 'compile as <object>:<verb>' to write your code to another verb.");
endif
changeverb = 0;
else
player:tell(objverbname, verbcode ? " successfully compiled." | " verbcode removed.");
this:set_changed(who, 0);
endif
if (changeverb)
this.objects[who] = object;
this.verbnames[who] = vargs ? {vname, @vargs} | vname;
endif
.
#49:2
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
else
object = this.objects[who];
verbname = this.verbnames[who];
if (typeof(verbname) == LIST)
return tostr(object, ":", verbname[1], " (", $string_utils:from_list(listdelete(verbname, 1), " "), ")");
else
return tostr(object, ":", this:verb_name(object, verbname), " (", this:verb_args(object, verbname), ")");
endif
endif
"return this:ok(who = args[1]) && tostr(this.objects[who]) + \":\" + this.verbnames[who];";
.
#49:3
{who, object, vname, vcode} = args;
if (this:ok(who))
this:load(who, vcode);
this.verbnames[who] = vname;
this.objects[who] = object;
this.active[who]:tell("Now editing ", this:working_on(who), ".");
"this.active[who]:tell(\"Now editing \", object, \":\", vname, \".\");";
endif
.
#49:4
":parse_invoke(string,v,?code)";
"  string is the commandline string to parse to obtain the obj:verb to edit";
"  v is the actual command verb used to invoke the editor";
" => {object, verbname, verb_code} or error";
if (caller != this)
raise(E_PERM);
endif
vref = $string_utils:words(args[1]);
if ((!vref) || (!(spec = $code_utils:parse_verbref(vref[1]))))
player:tell("Usage: ", args[2], " object:verb");
return;
endif
if (argspec = listdelete(vref, 1))
if (typeof(pas = $code_utils:parse_argspec(@argspec)) == LIST)
if (pas[2])
player:tell("I don't understand \"", $string_utils:from_list(pas[2], " "), "\"");
return;
endif
argspec = {@pas[1], "none", "none"}[1..3];
argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];
else
player:tell(pas);
return;
endif
endif
if (!$command_utils:object_match_failed(match = player:my_match_object(spec[1], this:get_room(player)), spec[1]))
ancestors = $object_utils:ancestors(match, 1);
vname = spec[2];
for object in (ancestors)
vnum = $code_utils:find_verb_named(object, vname);
if (argspec)
while (vnum && (this:fetch_verb_args(object, vnum) != argspec))
vnum = $code_utils:find_verb_named(object, vname, vnum + 1);
endwhile
endif
if (length(args) > 2)
code = args[3];
elseif (vnum)
code = this:fetch_verb_code(object, vnum);
else
code = E_VERBNF;
endif
if (typeof(code) != ERR)
if ((object in ancestors) != 1)
player:tell("Object ", ancestors[1], " does not define that verb, but its ancestor ", object, " does.");
endif
if ((!player:edit_option("local")) && $edit_utils:get_option("default_editor", player))
fork (0)
$edit_utils:editor(code, tostr("[Edit your code; use ", $edit_utils:get_option("cmd_char", player), "compile' to compile.]"), $edit_utils:get_option("cmd_char", player), 1, {{object, vname}});
endfork
kill_task(task_id());
else
return {object, argspec ? {vname, @argspec} | vname, code};
endif
endif
endfor
endif
player:tell((code != E_VERBNF) ? code | "That object does not define that verb", argspec ? " with those args." | ".");
return 0;
.
#49:5
"WIZARDLY";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
return E_PERM;
else
set_task_perms(player);
return `verb_code(args[1], args[2], !player:edit_option("no_parens")) ! ANY';
endif
.
#49:6
"WIZARDLY";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
return E_PERM;
else
set_task_perms(player);
return `set_verb_code(args[1], args[2], args[3]) ! ANY';
endif
.
#49:7
if (caller == $verb_editor)
set_task_perms(player);
endif
{object, vname, code} = args;
if (typeof(vname) == LIST)
vargs = tostr(" ", vname[2], " ", $code_utils:short_prep(vname[3]), " ", vname[4]);
vname = vname[1];
else
vargs = "";
endif
name = tostr(object.name, ":", vname);
ref = tostr(object, ":", vname);
"... so the next 2 lines are actually wrong, since verb_info won't";
"... necessarily retrieve the correct verb if we have more than one";
"... matching the given same name; anyway, if parse_invoke understood vname,";
"... so will @program.  I suspect these were put here because in the";
"... old scheme of things, vname was always a number.";
"vname = strsub($string_utils:explode(verb_info(object, vname)[3])[1], \"*\", \"\")";
"vargs = verb_args(object, vname)";
"";
simpleedit = $mcp.registry:match_package("dns-org-mud-moo-simpleedit");
if ((simpleedit != $failed_match) && simpleedit.v_filter_out)
code = simpleedit.v_filter_out[1]:(simpleedit.v_filter_out[2])(code);
endif
return {name, code, tostr("@program ", object, ":", vname, vargs), ref, "moo-code"};
.
#49:8
"verb_name(object, vname)";
"Find vname on object and return its full name (quoted).";
"This is useful for when we're working with verb numbers.";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
return E_PERM;
else
set_task_perms(player);
given = args[2];
if (typeof(info = `verb_info(args[1], given) ! ANY') == ERR)
return tostr(given, "[", info, "]");
elseif (info[3] == given)
return given;
else
return tostr(given, "/\"", info[3], "\"");
endif
endif
.
#49:9
"verb_name(object, vname)";
"Find vname on object and return its full name (quoted).";
"This is useful for when we're working with verb numbers.";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
return E_PERM;
else
set_task_perms(player);
return $string_utils:from_list(`verb_args(args[1], args[2]) ! ANY', " ");
endif
.
#49:10
"Syntax: comment [<range>]";
"";
"Turns the specified range of lines, into comments.";
if ((caller != player) && (caller_perms() != player))
return E_PERM;
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"."}, @args)) != LIST)
player:tell(tostr(range));
elseif (range[3])
player:tell_lines($code_utils:verb_documentation());
else
text = this.texts[who];
{from, to, crap} = range;
cut = $maxint;
for line in [from..to]
cut = min(cut, `match(text[line], "[^ ]")[1] ! E_RANGE => 1');
endfor
for line in [from..to]
text[line] = toliteral(text[line][cut..$]) + ";";
endfor
this.texts[who] = text;
player:tell((to == from) ? "Line" | "Lines", " changed.");
this.changes[who] = 1;
this.times[who] = time();
endif
.
#49:11
"Syntax: uncomment [<range>]";
"";
"Turns the specified range of lines from comments to, uh, not comments.";
if ((caller != player) && (caller_perms() != player))
return E_PERM;
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"."}, @args)) != LIST)
player:tell(tostr(range));
elseif (range[3])
player:tell_lines($code_utils:verb_documentation());
else
text = this.texts[who];
{from, to, crap} = range;
bogus = {};
for line in [from..to]
if (match(text[line], "^ *\"%([^\\\"]%|\\.%)*\";$"))
"check from $code_utils:verb_documentation";
if (!bogus)
text[line] = $no_one:eval(text[line])[2];
endif
else
bogus = setadd(bogus, line);
endif
endfor
if (bogus)
player:tell((length(bogus) == 1) ? "Line" | "Lines", " ", $string_utils:english_list(bogus), " ", (length(bogus) == 1) ? "is" | "are", " not comments.");
player:tell("No changes.");
return;
endif
this.texts[who] = text;
player:tell((to == from) ? "Line" | "Lines", " changed.");
this.changes[who] = 1;
this.times[who] = time();
endif
.
#49:12
"WIZARDLY";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
raise(E_PERM);
else
set_task_perms(player);
return `verb_args(args[1], args[2]) ! ANY';
endif
.
#50:0
if ((caller != player) && (caller_perms() != player))
return E_PERM;
endif
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
this:insert_line(who, argstr);
endif
.
#50:1
if ((caller != player) && (caller_perms() != player))
return E_PERM;
endif
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
this:append_line(who, argstr);
endif
.
#50:2
if (!this:loaded(player))
player:tell(this:nothing_loaded_msg());
else
lines = $command_utils:read_lines();
if (typeof(lines) == ERR)
player:notify(tostr(lines));
return;
endif
this:insert_line(this:loaded(player), lines, 0);
endif
.
#50:3
nonum = 0;
if (verb == "view")
if (!args)
l = {};
for i in [1..length(this.active)]
if (this.readable[i])
l = {@l, this.active[i]};
endif
endfor
if (l)
player:tell("Players having readable texts in this editor:  ", $string_utils:names_of(l));
else
player:tell("No one has published anything in this editor.");
endif
return;
elseif ($command_utils:player_match_result(plyr = $string_utils:match_player(args[1]), args[1])[1])
"...no such player";
return;
elseif ((!(who = this:loaded(plyr))) || (!this:readable(who)))
player:tell(plyr.name, "(", plyr, ") has not published anything in this editor.");
return;
endif
args = listdelete(args, 1);
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
len = length(this.texts[who]);
ins = this.inserting[who];
window = 8;
if (len < (2 * window))
default = {"1-$"};
elseif (ins <= window)
default = {tostr("1-", 2 * window)};
else
default = {tostr(window, "_-", window, "^"), tostr(2 * window, "$-$")};
endif
if (typeof(range = this:parse_range(who, default, @args)) != LIST)
player:tell(tostr(range));
elseif (range[3] && (!(nonum = "nonum" == $string_utils:trim(range[3]))))
player:tell("Don't understand this:  ", range[3]);
elseif (nonum)
player:tell_lines(this.texts[who][range[1]..range[2]]);
else
for line in [range[1]..range[2]]
this:list_line(who, line);
if ($command_utils:running_out_of_time())
suspend(0);
if (!(who = this:loaded(player)))
player:tell("ack!  something bad happened during a suspend...");
return;
endif
endif
endfor
if ((ins > len) && (len == range[2]))
player:tell("^^^^");
endif
endif
.
#50:4
if (i = index(argstr, "\""))
text = argstr[i + 1..$];
argstr = argstr[1..i - 1];
else
text = 0;
endif
spec = $string_utils:trim(argstr);
if (index("next", verb) == 1)
verb = "next";
spec = "+" + (spec || "1");
elseif (index("prev", verb) == 1)
verb = "prev";
spec = "-" + (spec || "1");
else
spec = spec || ".";
endif
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (ERR == typeof(number = this:parse_insert(who, spec)))
if (verb in {"next", "prev"})
player:tell("Argument must be a number.");
else
player:tell("You must specify an integer or `$' for the last line.");
endif
elseif ((number > (max = length(this.texts[who]) + 1)) || (number < 1))
player:tell("That would take you out of range (to line ", number, "?).");
else
this.inserting[who] = number;
if (typeof(text) == STR)
this:insert_line(who, text);
else
if (verb != "next")
(number > 1) ? this:list_line(who, number - 1) | player:tell("____");
endif
if (verb != "prev")
(number < max) ? this:list_line(who, number) | player:tell("^^^^");
endif
endif
endif
.
#50:5
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"_", "1"}, @args)) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk at end of cmd:  ", range[3]);
else
player:tell_lines((text = this.texts[who])[from = range[1]..to = range[2]]);
player:tell("---Line", (to > from) ? "s" | "", " deleted.  Insertion point is before line ", from, ".");
this.texts[who] = {@text[1..from - 1], @text[to + 1..$]};
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
this.inserting[who] = from;
endif
.
#50:6
if (callers() && (caller != this))
return E_PERM;
endif
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(subst = this:parse_subst(argstr && (argstr[1] + argstr), "c", "Empty search string?")) != LIST)
player:tell(tostr(subst));
elseif (typeof(start = subst[4] ? this:parse_insert(who, subst[4]) | this.inserting[who]) == ERR)
player:tell("Starting from where?", subst[4] ? ("  (can't parse " + subst[4]) + ")" | "");
else
search = subst[2];
case = !index(subst[3], "c", 1);
text = this.texts[who];
tlen = length(text);
while ((start <= tlen) && (!index(text[start], search, case)))
start = start + 1;
endwhile
if (start > tlen)
player:tell("`", search, "' not found.");
else
this.inserting[who] = start + 1;
this:list_line(who, start);
endif
endif
.
#50:7
verb = (is_move = verb[1] == "m") ? "move" | "copy";
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
wargs = args;
t = to_pos = 0;
while (t = "to" in (wargs = wargs[t + 1..$]))
to_pos = to_pos + t;
endwhile
range_args = args[1..to_pos - 1];
if ((!to_pos) || (ERR == typeof(dest = this:parse_insert(who, $string_utils:from_list(wargs, " ")))))
player:tell(verb, " to where? ");
elseif ((dest < 1) || (dest > ((last = length(this.texts[who])) + 1)))
player:tell("Destination (", dest, ") out of range.");
elseif (("from" in range_args) || ("to" in range_args))
player:tell("Don't use that kind of range specification with this command.");
elseif (typeof(range = this:parse_range(who, {"_", "^"}, @args[1..to_pos - 1])) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk before `to':  ", range[3]);
elseif ((is_move && (dest >= range[1])) && (dest <= (range[2] + 1)))
player:tell("Destination lies inside range of lines to be moved.");
else
from = range[1];
to = range[2];
ins = this.inserting[who];
text = this.texts[who];
if (!is_move)
this.texts[who] = {@text[1..dest - 1], @text[from..to], @text[dest..last]};
if (ins >= dest)
this.inserting[who] = ((ins + to) - from) + 1;
endif
else
"oh shit... it's a move";
if (dest < from)
newtext = {@text[1..dest - 1], @text[from..to], @text[dest..from - 1], @text[to + 1..last]};
if ((ins >= dest) && (ins <= to))
ins = (ins > from) ? (ins - from) + dest | (((ins + to) - from) + 1);
endif
else
newtext = {@text[1..from - 1], @text[to + 1..dest - 1], @text[from..to], @text[dest..last]};
if ((ins > from) && (ins < dest))
ins = (ins <= to) ? ((ins + dest) - to) - 1 | (((ins - to) + from) - 1);
endif
endif
this.texts[who] = newtext;
this.inserting[who] = ins;
endif
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
player:tell("Lines ", is_move ? "moved." | "copied.");
endif
.
#50:8
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"_-^", "_", "^"}, @args)) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk at end of cmd:  ", range[3]);
elseif (!(result = this:join_lines(who, @range[1..2], length(verb) <= 4)))
player:tell((result == 0) ? "Need at least two lines to join." | result);
else
this:list_line(who, range[1]);
endif
.
#50:9
fill_column = 70;
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"_", "1"}, @args)) != LIST)
player:tell(range);
elseif (range[3] && ((range[3][1] != "@") || ((fill_column = toint(range[3][2..$])) < 10)))
player:tell("Usage:  fill [<range>] [@ column]   (where column >= 10).");
else
join = this:join_lines(who, @range[1..2], 1);
newlines = this:fill_string((text = this.texts[who])[from = range[1]], fill_column);
if (fill = ((nlen = length(newlines)) > 1) || (newlines[1] != text[from]))
this.texts[who] = {@text[1..from - 1], @newlines, @text[from + 1..$]};
if (((insert = this.inserting[who]) > from) && (nlen > 1))
this.inserting[who] = (insert + nlen) - 1;
endif
endif
if (fill || join)
for line in [from..(from + nlen) - 1]
this:list_line(who, line);
endfor
else
player:tell("No changes.");
endif
endif
.
#50:10
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
if (typeof(e = this:set_readable(who, index("publish", verb) == 1)) == ERR)
player:tell(e);
elseif (e)
player:tell("Your text is now globally readable.");
else
player:tell("Your text is read protected.");
endif
.
#50:11
if (!(this:ok(who = player in this.active) && (typeof(this.texts[who]) == LIST)))
player:tell(this:nothing_loaded_msg());
else
player:tell("You are editing ", this:working_on(who), ".");
player:tell("Your insertion point is ", (this.inserting[who] > length(this.texts[who])) ? "after the last line: next line will be #" | "before line ", this.inserting[who], ".");
player:tell(this.changes[who] ? this:change_msg() | this:no_change_msg());
if (this.readable[who])
player:tell("Your text is globally readable.");
endif
endif
.
#50:12
if (!this.changes[who = player in this.active])
player:tell("No changes to throw away.  Editor cleared.");
else
player:tell("Throwing away session for ", this:working_on(who), ".");
endif
this:reset_session(who);
if (this.exit_on_abort)
this:done();
endif
.
#50:13
if (!(caller in {this, player}))
return E_PERM;
elseif (!(who = player in this.active))
player:tell("You are not actually in ", this.name, ".");
return;
elseif (!valid(origin = this.original[who]))
player:tell("I don't know where you came here from.");
else
player:moveto(origin);
if (player.location == this)
player:tell("Hmmm... the place you came from doesn't want you back.");
else
if (msg = this:return_msg())
player.location:announce($string_utils:pronoun_sub(msg));
endif
return;
endif
endif
player:tell("You'll have to use 'home' or a teleporter.");
.
#50:14
"This catches subst and find commands that don't fit into the usual model, e.g., s/.../.../ without the space after the s, and find commands without the verb `find'.  Still behaves in annoying ways (e.g., loses if the search string contains multiple whitespace), but better than before.";
set_task_perms(caller_perms());
if ((c = callers()) && ((c[1][1] != this) || (length(c) > 1)))
return pass(@args);
endif
verb = args[1];
v = 1;
vmax = min(length(verb), 5);
while ((v <= vmax) && (verb[v] == "subst"[v]))
v = v + 1;
endwhile
argstr = $code_utils:argstr(verb, args[2]);
if (((v > 1) && (v <= length(verb))) && (((vl = verb[v]) < "A") || (vl > "Z")))
argstr = (verb[v..$] + (argstr && " ")) + argstr;
return this:subst();
elseif ("/" == verb[1])
argstr = (verb + (argstr && " ")) + argstr;
return this:find();
else
pass(@args);
endif
.
#50:15
return this:ok(who = args[1]) && this.inserting[who];
.
#50:16
return this:ok(who = args[1]) && ((((ins = toint(args[2])) < 1) ? E_INVARG | ((ins <= (max = length(this.texts[who]) + 1)) || (ins = max))) && (this.inserting[who] = ins));
.
#50:17
return this:ok(who = args[1]) && this.changes[who];
.
#50:18
return this:ok(who = args[1]) && (((unchanged = !args[2]) || (this.times[who] = time())) && (this.changes[who] = !unchanged));
.
#50:19
return this:ok(who = args[1]) && this.original[who];
.
#50:20
return this:ok(who = args[1]) && (((valid(origin = args[2]) && (origin != this)) || ((origin == $nothing) || E_INVARG)) && (this.original[who] = origin));
.
#50:21
return (((who = args[1]) < 1) || (who > length(this.active))) ? E_RANGE | this.readable[who];
.
#50:22
return this:ok(who = args[1]) && (this.readable[who] = !(!args[2]));
.
#50:23
{?who = player in this.active} = args;
return (this:readable(who) || this:ok(who)) && this.texts[who];
.
#50:24
texts = args[2];
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
elseif (typeof(texts) == STR)
texts = {texts};
elseif ((typeof(texts) != LIST) || (length(texts) && (typeof(texts[1]) != STR)))
return E_TYPE;
endif
this.texts[who] = texts;
this.inserting[who] = length(texts) + 1;
this.changes[who] = 0;
this.readable[who] = 0;
this.times[who] = time();
.
#50:25
"Dummy routine.  The child editor should provide something informative";
return this:ok(who = args[1]) && (("something [in " + this.name) + "]");
.
#50:26
who = args[1];
if ((who < 1) || (who > length(this.active)))
return E_RANGE;
elseif ((length(c = callers()) < 2) ? player == this.active[who] | ((c[2][1] == this) || ($perm_utils:controls(c[2][3], this.active[who]) || (c[2][3] == $generic_editor.owner))))
return 1;
else
return E_PERM;
endif
.
#50:27
return ((who = args[1] in this.active) && (typeof(this.texts[who]) == LIST)) && who;
.
#50:28
$ansi_utils:add_noansi();
if (this:ok(who = args[1]))
f = 1 + ((line = args[2]) in {(ins = this.inserting[who]) - 1, ins});
player:tell($string_utils:right(line, 3, " _^"[f]), ":_^"[f], " ", this.texts[who][line]);
endif
$ansi_utils:remove_noansi();
.
#50:29
":insert_line([who,] line or list of lines [,quiet])";
"  inserts the given text at the insertion point.";
"  returns E_NONE if the session has no text loaded yet.";
if (typeof(args[1]) != INT)
args = {player in this.active, @args};
endif
{who, lines, ?quiet = this.active[who]:edit_option("quiet_insert")} = args;
if (!(fuckup = this:ok(who)))
return fuckup;
elseif (typeof(text = this.texts[who]) != LIST)
return E_NONE;
else
if (typeof(lines) != LIST)
lines = {lines};
endif
p = this.active[who];
insert = this.inserting[who];
this.texts[who] = {@text[1..insert - 1], @lines, @text[insert..$]};
this.inserting[who] = insert + length(lines);
if (lines)
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
if (!quiet)
if (length(lines) != 1)
p:tell("Lines ", insert, "-", (insert + length(lines)) - 1, " added.");
else
p:tell("Line ", insert, " added.");
endif
endif
else
p:tell("No lines added.");
endif
endif
.
#50:30
":append_line([who,] string)";
"  appends the given string to the line before the insertion point.";
"  returns E_NONE if the session has no text loaded yet.";
if (typeof(args[1]) != INT)
args = {player in this.active, @args};
endif
{who, string} = args;
if (!(fuckup = this:ok(who)))
return fuckup;
elseif ((append = this.inserting[who] - 1) < 1)
return this:insert_line(who, {string});
elseif (typeof(text = this.texts[who]) != LIST)
return E_NONE;
else
this.texts[who][append] = text[append] + string;
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
p = this.active[who];
if (!p:edit_option("quiet_insert"))
p:tell("Appended to line ", append, ".");
endif
endif
.
#50:31
{who, from, to, english} = args;
if (!(fuckup = this:ok(who)))
return fuckup;
elseif (from >= to)
return 0;
else
nline = "";
for line in ((text = this.texts[who])[from..to])
if (!english)
nline = nline + line;
else
len = length(line) + 1;
while ((len = len - 1) && (line[len] == " "))
endwhile
if (len > 0)
nline = (nline + line) + (index(".:", line[len]) ? "  " | " ");
endif
endif
endfor
this.texts[who] = {@text[1..from - 1], nline, @text[to + 1..$]};
if ((insert = this.inserting[who]) > from)
this.inserting[who] = (insert <= to) ? from + 1 | ((insert - to) + from);
endif
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
return to - from;
endif
.
#50:32
"parse_number(who,string,before)   interprets string as a line number.  In the event that string is `.', `before' tells us which line to use.  Return 0 if string is bogus.";
{who, string, before} = args;
if (!(fuckup = this:ok(who)))
return fuckup;
endif
last = length(this.texts[who]);
ins = this.inserting[who] - 1;
after = !before;
if (!string)
return 0;
elseif ("." == string)
return ins + after;
elseif (!(i = index("_^$", string[slen = length(string)])))
return toint(string);
else
start = {ins + 1, ins, last + 1}[i];
n = 1;
if ((slen > 1) && (!(n = toint(string[1..slen - 1]))))
return 0;
elseif (i % 2)
return start - n;
else
return start + n;
endif
endif
.
#50:33
"parse_range(who,default,@args) => {from to rest}";
numargs = length(args);
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
elseif (!(last = length(this.texts[who])))
return this:no_text_msg();
endif
default = args[2];
r = 0;
while (default && (LIST != typeof(r = this:parse_range(who, {}, default[1]))))
default = listdelete(default, 1);
endwhile
if (typeof(r) == LIST)
from = r[1];
to = r[2];
else
from = to = 0;
endif
saw_from_to = 0;
not_done = 1;
a = 2;
while (((a = a + 1) <= numargs) && not_done)
if (args[a] == "from")
if ((a == numargs) || (!(from = this:parse_number(who, args[a = a + 1], 0))))
return "from ?";
endif
saw_from_to = 1;
elseif (args[a] == "to")
if ((a == numargs) || (!(to = this:parse_number(who, args[a = a + 1], 1))))
return "to ?";
endif
saw_from_to = 1;
elseif (saw_from_to)
a = a - 1;
not_done = 0;
elseif (i = index(args[a], "-"))
from = this:parse_number(who, args[a][1..i - 1], 0);
to = this:parse_number(who, args[a][i + 1..$], 1);
not_done = 0;
elseif (f = this:parse_number(who, args[a], 0))
from = f;
if ((a == numargs) || (!(to = this:parse_number(who, args[a + 1], 1))))
to = from;
else
a = a + 1;
endif
not_done = 0;
else
a = a - 1;
not_done = 0;
endif
endwhile
if (from < 1)
return tostr("from ", from, "?  (out of range)");
elseif (to > last)
return tostr("to ", to, "?  (out of range)");
elseif (from > to)
return tostr("from ", from, " to ", to, "?  (backwards range)");
else
return {from, to, $string_utils:from_list(args[a..numargs], " ")};
endif
.
#50:34
"parse_ins(who,string)  interprets string as an insertion point, i.e., a position between lines and returns the number of the following line or 0 if bogus.";
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
endif
{who, string} = args;
if (length(string) == 0)
return E_INVARG;
endif
last = length(this.texts[who]) + 1;
ins = this.inserting[who];
if (i = index("-+", string[1]))
rest = string[2..$];
return ((n = toint(rest)) || (rest == "0")) ? {ins - n, ins + n}[i] | E_INVARG;
else
if (!(j = index(string, "^") || index(string, "_")))
offset = 0;
else
offset = (j == 1) || toint(string[1..j - 1]);
if (!offset)
return E_INVARG;
elseif (string[j] == "^")
offset = -offset;
endif
endif
rest = string[j + 1..$];
if (i = rest in {".", "$"})
return offset + {ins, last}[i];
elseif (!(n = toint(rest)))
return E_INVARG;
else
return (offset + (j && (string[j] == "^"))) + n;
endif
endif
.
#50:35
{cmd, ?recognized_flags = "gcr", ?null_subst_msg = "Null substitution?"} = args;
if (!cmd)
return "s*ubst/<str1>/<str2>[/[g][c][r][<range>]] expected...";
endif
bchar = cmd[1];
cmd = cmd[2..$];
fromstr = cmd[1..(b2 = index(cmd + bchar, bchar, 1)) - 1];
cmd = cmd[b2 + 1..$];
tostr = cmd[1..(b2 = index(cmd + bchar, bchar, 1)) - 1];
cmd = cmd[b2 + 1..$];
cmdlen = length(cmd);
b2 = 0;
while (((b2 = b2 + 1) <= cmdlen) && index(recognized_flags, cmd[b2]))
endwhile
return ((fromstr == "") && (tostr == "")) ? null_subst_msg | {fromstr, tostr, cmd[1..b2 - 1], cmd[b2..$]};
.
#50:36
":invoke(...)";
"to find out what arguments this verb expects,";
"see this editor's parse_invoke verb.";
new = args[1];
if ((!(caller in {this, player})) && (!$perm_utils:controls(caller_perms(), player)))
"...non-editor/non-player verb trying to send someone to the editor...";
return E_PERM;
endif
if ((who = this:loaded(player)) && this:changed(who))
if (!new)
if (this:suck_in(player))
player:tell("You are working on ", this:working_on(who));
endif
return;
elseif (player.location == this)
player:tell("You are still working on ", this:working_on(who));
if (msg = this:previous_session_msg())
player:tell(msg);
endif
return;
endif
"... we're not in the editor and we're about to start something new,";
"... but there's still this pending session...";
player:tell("You were working on ", this:working_on(who));
if (!$command_utils:yes_or_no("Do you wish to delete that session?"))
if (this:suck_in(player))
player:tell("Continuing with ", this:working_on(player in this.active));
if (msg = this:previous_session_msg())
player:tell(msg);
endif
endif
return;
endif
"... note session number may have changed => don't trust `who'";
this:kill_session(player in this.active);
endif
spec = this:parse_invoke(@args);
if (typeof(spec) == LIST)
if ((player:edit_option("local") && $object_utils:has_verb(this, "local_editing_info")) && (info = this:local_editing_info(@spec)))
this:invoke_local_editor(@info);
elseif (this:suck_in(player))
this:init_session(player in this.active, @spec);
endif
endif
.
#50:37
"The correct way to move someone into the editor.";
if (((loc = (who_obj = args[1]).location) != this) && (caller == this))
this.invoke_task = task_id();
who_obj:moveto(this);
if (who_obj.location == this)
try
"...forked, just in case loc:announce is broken...";
"changed to a try-endtry. Lets reduce tasks..Ho_Yan 12/20/96";
if (valid(loc) && (msg = this:depart_msg()))
loc:announce($string_utils:pronoun_sub(msg));
endif
except (ANY)
"Just drop it and move on";
endtry
else
who_obj:tell("For some reason, I can't move you.   (?)");
this:exitfunc(who_obj);
endif
this.invoke_task = 0;
endif
return who_obj.location == this;
.
#50:38
"WIZARDLY";
{who_obj, from} = args;
if ($object_utils:isa(from, $generic_editor))
"... never put an editor in .original, ...";
if (w = who_obj in from.active)
from = from.original[w];
else
from = #-1;
endif
endif
if (caller != this)
return E_PERM;
elseif (who = who_obj in this.active)
"... edit in progress here...";
if (valid(from))
this.original[who] = from;
endif
return -1;
else
for p in ({{"active", who_obj}, {"original", valid(from) ? from | $nothing}, {"times", time()}, @this.stateprops})
this.(p[1]) = {@this.(p[1]), p[2]};
endfor
return length(this.active);
endif
.
#50:39
"WIZARDLY";
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
else
for p in ({@this.stateprops, {"original"}, {"active"}, {"times"}})
this.(p[1]) = listdelete(this.(p[1]), who);
endfor
return who;
endif
.
#50:40
"WIZARDLY";
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
else
for p in (this.stateprops)
this.(p[1])[who] = p[2];
endfor
this.times[who] = time();
return who;
endif
.
#50:41
"WIZARDLY";
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
else
for victim in (this.contents)
victim:tell("Sorry, ", this.name, " is going down.  Your editing session is hosed.");
victim:moveto(((who = victim in this.active) && valid(origin = this.original[who])) ? origin | (valid(victim.home) ? victim.home | $player_start));
endfor
for p in ({@this.stateprops, {"original"}, {"active"}, {"times"}})
this.(p[1]) = {};
endfor
return 1;
endif
.
#50:42
return is_player(who_obj = args[1]) && (who_obj.wizard || pass(@args));
.
#50:43
who_obj = args[1];
if (who_obj.wizard && (!(who_obj in this.active)))
this:accept(who_obj);
endif
pass(@args);
if (this.invoke_task == task_id())
"Means we're about to load something, so be quiet.";
this.invoke_task = 0;
elseif (who = this:loaded(who_obj))
who_obj:tell("You are working on ", this:working_on(who), ".");
elseif (msg = this:nothing_loaded_msg())
who_obj:tell(msg);
endif
.
#50:44
if (!(who = (who_obj = args[1]) in this.active))
elseif (this:retain_session_on_exit(who))
if (msg = this:no_littering_msg())
who_obj:tell_lines(msg);
endif
else
this:kill_session(who);
endif
pass(@args);
.
#50:45
"@flush <editor>";
"@flush <editor> at <month> <day>";
"@flush <editor> at <weekday>";
"The first form removes all sessions from the editor; the other two forms remove everything older than the given date.";
if ((caller_perms() != #-1) && (caller_perms() != player))
raise(E_PERM);
elseif (!$perm_utils:controls(player, this))
player:tell("Only the owner of the editor can do a ", verb, ".");
return;
endif
if (!prepstr)
player:tell("Trashing all sessions.");
this:kill_all_sessions();
elseif (prepstr != "at")
player:tell("Usage:  ", verb, " ", dobjstr, " [at [mon day|weekday]]");
else
p = prepstr in args;
if (t = $time_utils:from_day(iobjstr, -1))
elseif (t = $time_utils:from_month(args[p + 1], -1))
if (length(args) > (p + 1))
if (!(n = toint(args[p + 2])))
player:tell(args[p + 1], " WHAT?");
return;
endif
t = t + ((n - 1) * 86400);
endif
else
player:tell("couldn't parse date");
return;
endif
this:do_flush(t, "noisy");
endif
player:tell("Done.");
.
#50:46
if (!$perm_utils:controls(player, this))
player:tell(E_PERM);
return;
endif
if (i = index(dobjstr, "="))
default = dobjstr[i + 1..$];
prop = dobjstr[1..i - 1];
if (argstr[1 + index(argstr, "=")] == "\"")
elseif (default[1] == "#")
default = toobj(default);
elseif (index("0123456789", default[1]))
default = toint(default);
elseif (default == "{}")
default = {};
endif
else
default = 0;
prop = dobjstr;
endif
if (typeof(result = this:set_stateprops(prop, default)) == ERR)
player:tell((result == E_RANGE) ? tostr(".", prop, " needs to hold a list of the same length as .active (", length(this.active), ").") | ((result != E_NACC) ? result | (prop + " is already a property on an ancestral editor.")));
else
player:tell("Property added.");
endif
.
#50:47
if (!$perm_utils:controls(player, this))
player:tell(E_PERM);
elseif (typeof(result = this:set_stateprops(dobjstr)) == ERR)
player:tell((result != E_NACC) ? result | (dobjstr + " is already a property on an ancestral editor."));
else
player:tell("Property removed.");
endif
.
#50:48
if ($perm_utils:controls(caller_perms(), this))
pass(@args);
this:kill_all_sessions();
endif
.
#50:49
if (caller_perms().wizard)
pass(@args);
this:kill_all_sessions();
if (this == $generic_editor)
this.help = $help_db["editor"];
endif
if ($object_utils:defines_verb(this, "is_not_banned"))
delete_verb(this, "is_not_banned");
endif
endif
.
#50:50
remove = length(args) < 2;
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (!(length(args) in {1, 2}))
return E_ARGS;
elseif (typeof(prop = args[1]) != STR)
return E_TYPE;
elseif (i = $list_utils:iassoc(prop, this.stateprops))
if (!remove)
this.stateprops[i] = {prop, args[2]};
elseif ($object_utils:has_property(parent(this), prop))
return E_NACC;
else
this.stateprops = listdelete(this.stateprops, i);
endif
elseif (remove)
elseif (prop in `properties(this) ! ANY => {}')
if (this:_stateprop_length(prop) != length(this.active))
return E_RANGE;
endif
this.stateprops = {{prop, args[2]}, @this.stateprops};
else
return $object_utils:has_property(this, prop) ? E_NACC | E_PROPNF;
endif
return 0;
.
#50:51
is_look_self = 1;
for c in (callers())
if (is_look_self && (c[2] in {"enterfunc", "confunc"}))
return {"", "Do a 'look' to get the list of commands, or 'help' for assistance.", "", @this.description};
elseif ((c[2] != "look_self") && (c[2] != "pass"))
is_look_self = 0;
endif
endfor
d = {"Commands:", ""};
col = {{}, {}};
for c in [1..2]
for cmd in (this.commands2[c])
cmd = this:commands_info(cmd);
col[c] = {cmdargs = $string_utils:left(cmd[1] + " ", 12) + cmd[2], @col[c]};
endfor
endfor
i1 = length(col[1]);
i2 = length(col[2]);
right = 0;
while (i1 || i2)
if (!((i1 && (length(col[1][i1]) > 35)) || (i2 && (length(col[2][i2]) > 35))))
d = {@d, $string_utils:left(i1 ? col[1][i1] | "", 40) + (i2 ? col[2][i2] | "")};
i1 && (i1 = i1 - 1);
i2 && (i2 = i2 - 1);
right = 0;
elseif (right && i2)
d = {@d, (length(col[2][i2]) > 35) ? $string_utils:right(col[2][i2], 75) | ($string_utils:space(40) + col[2][i2])};
i2 = i2 - 1;
right = 0;
elseif (i1)
d = {@d, col[1][i1]};
i1 = i1 - 1;
right = 1;
else
right = 1;
endif
endwhile
return {@d, "", "----  Do `help <cmdname>' for help with a given command.  ----", "", "  <ins> ::= $ (the end) | [^]n (above line n) | _n (below line n) | . (current)", "<range> ::= <lin> | <lin>-<lin> | from <lin> | to <lin> | from <lin> to <lin>", "  <lin> ::= n | [n]$ (n from the end) | [n]_ (n before .) | [n]^ (n after .)", "`help insert' and `help ranges' describe these in detail.", @this.description};
.
#50:52
cmd = args[1];
if (pc = $list_utils:assoc(cmd, this.commands))
return pc;
elseif (this == $generic_editor)
return {cmd, "<<<<<======= Need to add this to .commands"};
else
return parent(this):commands_info(cmd);
endif
.
#50:53
{objstr, ?who = player} = args;
origin = this;
while ((where = player in origin.active) && ($recycler:valid(origin = origin.original[where]) && (origin != this)))
if (!$object_utils:isa(origin, $generic_editor))
return origin:match_object(objstr, who);
endif
endwhile
return who:my_match_object(objstr, #-1);
.
#50:54
who = args[1];
where = {#-1, @this.original}[1 + (who in this.active)];
wherestr = `where:who_location_msg(who) ! ANY => "An Editor"';
if (typeof(wherestr) != STR)
wherestr = "broken who_location_msg";
endif
return strsub(this.who_location_msg, "%L", wherestr);
return $string_utils:pronoun_sub(this.who_location_msg, who, this, where);
.
#50:55
return $code_utils:verb_or_property(player, verb, this) || this.(verb);
.
#50:56
return;
.
#50:57
"fill(string [, width [, prefix]])";
"tries to cut <string> into substrings of length < <width> along word boundaries.  Prefix, if supplied, will be prefixed to the 2nd..last substrings.";
{string, ?width = 1 + player:linelen(), ?prefix = ""} = args;
width = width + 1;
if (width < (3 + length(prefix)))
return E_INVARG;
endif
string = ("$" + string) + " $";
len = length(string);
if (len <= width)
last = len - 1;
next = len;
else
last = rindex(string[1..width], " ");
if (last < ((width + 1) / 2))
last = width + index(string[width + 1..len], " ");
endif
next = last;
while (string[next = next + 1] == " ")
endwhile
endif
while (string[last = last - 1] == " ")
endwhile
ret = {string[2..last]};
width = width - length(prefix);
minlast = (width + 1) / 2;
while (next < len)
string = "$" + string[next..len];
len = (len - next) + 2;
if (len <= width)
last = len - 1;
next = len;
else
last = rindex(string[1..width], " ");
if (last < minlast)
last = width + index(string[width + 1..len], " ");
endif
next = last;
while (string[next = next + 1] == " ")
endwhile
endif
while (string[last = last - 1] == " ")
endwhile
if (last > 1)
ret = {@ret, prefix + string[2..last]};
endif
endwhile
return ret;
.
#50:58
"This catches subst and find commands that don't fit into the usual model, e.g., s/.../.../ without the space after the s, and find commands without the verb `find'.  Still behaves in annoying ways (e.g., loses if the search string contains multiple whitespace), but better than before.";
if ((caller != this) && (caller_perms() != player))
return E_PERM;
endif
{verb, args} = args;
v = 1;
vmax = min(length(verb), 5);
while ((v <= vmax) && (verb[v] == "subst"[v]))
v = v + 1;
endwhile
argstr = $code_utils:argstr(verb, args);
if ((v > 1) && ((v <= length(verb)) && (((vl = verb[v]) < "A") || (vl > "Z"))))
argstr = (verb[v..$] + (argstr && " ")) + argstr;
this:subst();
return 1;
elseif ("/" == verb[1])
argstr = (verb + (argstr && " ")) + argstr;
this:find();
return 1;
else
return 0;
endif
.
#50:59
return $failed_match;
.
#50:60
":get_room([player])  => correct room to match in on invocation.";
{?who = player} = args;
if (who.location != this)
return who.location;
else
origin = this;
while ((where = player in origin.active) && (valid(origin = origin.original[where]) && (origin != this)))
if (!$object_utils:isa(origin, $generic_editor))
return origin;
endif
endwhile
return this;
endif
.
#50:61
"$generic_editor:invoke_local_editor(name, text, upload, reference, type)";
"Spits out the magic text that invokes the local editor in the player's client.";
"NAME is a good human-readable name for the local editor to use for this particular piece of text.";
"TEXT is a string or list of strings, the initial body of the text being edited.";
"UPLOAD, a string, is a MOO command that the local editor can use to save the text when the user is done editing.  The local editor is going to send that command on a line by itself, followed by the new text lines, followed by a line containing only `.'.  The UPLOAD command should therefore call $command_utils:read_lines() to get the new text as a list of strings.";
"REFERENCE is a string representing the MCP/2.1 reference (usually <obj>.<prop> or <obj>:<verb>) for clients who speak MCP/2.1 simpleedit.";
"TYPE is a string representing the MCP/2.1 type (moo-code, string...) for clients who speak MCP/2.1 simpleedit.";
if (caller != this)
return;
endif
{name, text, upload, reference, type} = args;
if (typeof(text) == STR)
text = {text};
endif
session = $mcp:session_for(player);
package = $mcp:match_package("dns-org-mud-moo-simpleedit");
if (session:handles_package(package) == {1, 0})
package:send_content(session, reference, name, type, text);
return;
endif
notify(player, tostr("#$# edit name: ", name, " upload: ", upload));
":dump_lines() takes care of the final `.' ...";
for line in ($command_utils:dump_lines(text))
notify(player, line);
endfor
.
#50:62
"+c properties on children cannot necessarily be read, so we need this silliness...";
if (caller != this)
return E_PERM;
else
return length(this.(args[1]));
endif
.
#50:63
txt = this:text(player in this.active);
if (typeof(txt) == LIST)
player:tell_lines(txt);
else
player:tell("Text unreadable:  ", txt);
endif
player:tell("--------------------------");
.
#50:64
return this:acceptable(who_obj = args[1]) && this:new_session(who_obj, who_obj.location);
.
#50:65
"Usage: yank from <note>";
"       yank <message-sequence> from <mail-recipient>";
"       yank from <object>:<verb>";
"       yank from <object>.<property>";
"Grabs the specified text and inserts it at the cursor.";
set_task_perms(player);
if (dobjstr)
"yank <message-sequence> from <mail-recipient>";
if (!(p = player:parse_mailread_cmd(verb, args, "", "from")))
return;
elseif ($seq_utils:size(sequence = p[2]) != 1)
player:notify(tostr("You can only ", verb, " one message at a time"));
return;
else
m = (folder = p[1]):messages_in_seq(sequence);
msg = m[1];
header = tostr("Message ", msg[1]);
if (folder != player)
header = tostr(header, " on ", $mail_agent:name(folder));
endif
header = tostr(header, ":");
lines = {header, @player:msg_full_text(@msg[2])};
this:insert_line(this:loaded(player), lines, 0);
endif
elseif (pr = $code_utils:parse_propref(iobjstr))
o = player:my_match_object(pr[1]);
if ($command_utils:object_match_failed(o, pr[1]))
return;
elseif ((lines = `o.(pr[2]) ! ANY') == E_PROPNF)
player:notify(tostr("There is no `", pr[2], "' property on ", $string_utils:nn(o), "."));
return;
elseif (lines == E_PERM)
player:notify(tostr("Error: Permission denied reading ", iobjstr));
return;
elseif (typeof(lines) == ERR)
player:notify(tostr("Error: ", lines, " reading ", iobjstr));
return;
elseif (typeof(lines) == STR)
this:insert_line(this:loaded(player), lines, 0);
return;
elseif (typeof(lines) == LIST)
for x in (lines)
if (typeof(x) != STR)
player:notify(tostr("Error: ", iobjstr, " does not contain a ", verb, "-able value."));
return;
endif
endfor
this:insert_line(this:loaded(player), lines, 0);
return;
else
player:notify(tostr("Error: ", iobjstr, " does not contain a ", verb, "-able value."));
return;
endif
elseif (pr = $code_utils:parse_verbref(iobjstr))
o = player:my_match_object(pr[1]);
if ($command_utils:object_match_failed(o, pr[1]))
return;
elseif (lines = `verb_code(o, pr[2], !player:edit_option("no_parens")) ! ANY')
this:insert_line(this:loaded(player), lines, 0);
return;
elseif (lines == E_PERM)
player:notify(tostr("Error: Permission denied reading ", iobjstr));
return;
elseif (lines == E_VERBNF)
player:notify(tostr("There is no `", pr[2], "' verb on ", $string_utils:nn(o), "."));
else
player:notify(tostr("Error: ", lines, " reading ", iobjstr));
return;
endif
elseif ($command_utils:object_match_failed(iobj = player:my_match_object(iobjstr), iobjstr))
return;
elseif ((lines = `iobj:text() ! ANY') == E_PERM)
player:notify(tostr("Error: Permission denied reading ", iobjstr));
return;
elseif (lines == E_VERBNF)
player:notify(tostr($string_utils:nn(iobj), " doesn't seem to be a note."));
elseif (typeof(lines) == ERR)
player:notify(tostr("Error: ", lines, " reading ", iobjstr));
return;
else
this:insert_line(this:loaded(player), lines, 0);
endif
.
#50:66
"Flushes editor sessions older than args[1].  If args[2] is true, prints status as it runs.  If args[2] is false, runs silently.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
else
{t, noisy} = args;
for i in [-length(this.active)..-1]
if (this.times[-i] < t)
if (noisy)
player:tell($string_utils:nn(this.active[-i]), ctime(this.times[-i]));
endif
this:kill_session(-i);
endif
endfor
endif
.
#50:67
if (callers() && (caller != this))
return E_PERM;
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(subst = this:parse_subst(argstr)) != LIST)
player:tell(tostr(subst));
elseif (typeof(range = this:parse_range(who, {"_", "1"}, @$string_utils:explode(subst[4]))) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk at end of cmd:  ", range[3]);
else
{fromstr, tostr, specs, dummy} = subst;
global = index(specs, "g", 1);
regexp = index(specs, "r", 1);
case = !index(specs, "c", 1);
munged = {};
text = this.texts[who];
changed = {};
{from, to} = range[1..2];
for line in [from..to]
t = t0 = text[line];
if (!fromstr)
t = tostr + t;
elseif (global)
if (regexp)
while (new = this:subst_regexp(t, fromstr, tostr, case))
t = new;
endwhile
else
t = strsub(t, fromstr, tostr, case);
endif
else
if (regexp)
(new = this:subst_regexp(t, fromstr, tostr, case)) && (t = new);
else
(i = index(t, fromstr, case)) && (t = (t[1..i - 1] + tostr) + t[i + length(fromstr)..length(t)]);
endif
endif
if (strcmp(t0, t))
changed = {@changed, line};
endif
munged = {@munged, t};
endfor
if (!changed)
player:tell("No changes in line", (from == to) ? tostr(" ", from) | tostr("s ", from, "-", to), ".");
else
this.texts[who] = {@text[1..from - 1], @munged, @text[to + 1..$]};
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
for line in (changed)
this:list_line(who, line);
endfor
endif
endif
.
#50:68
"Copied from Domain (#8111):subst_regexp by Mooshie (#106469) Mon Jan  5 19:27:26 1998 PST";
"Usage: subst_regexp(STR text, STR from string, STR to string, INT case)";
{text, from, to, case} = args;
if (m = match(text, from, case))
{start, end} = m[1..2];
text[start..end] = substitute(to, m);
return text;
else
return m;
endif
.
#50:69
return (this == $generic_editor) ? {"owner"} | {};
.
#50:70
if (valid(au = $ansi_utils) && au.active)
return au:(verb)(@args);
else
return this:(verb + "(noansi)")(@args);
endif
.
#51:0
":match(string, object-list)";
"Return object in 'object-list' aliased to 'string'.";
"Matches on a wide variety of syntax, including:";
" \"5th axe\" -- The fifth object matching \"axe\" in the object list.";
" \"where's sai\" -- The only object contained in 'where' matching \"sai\" (possible $ambiguous_match).";
" \"where's second staff\" -- The second object contained in 'where' matching \"staff\".";
" \"my third dagger\" -- The third object in your inventory matching \"dagger\".";
"Ordinal matches are determined according to the match's position in 'object-list' or, if a possessive (such as \"where\" above) is given, then the ordinal is the nth match in that object's inventory.";
"In the matching room (#3879@LambdaMOO), the 'object-list' consists of first the player's contents, then the room's, and finally all exits leading from the room.";
{string, olist} = args;
if (!string)
return $nothing;
elseif (string == "me")
return player;
elseif (string == "here")
return player.location;
elseif (valid(object = $string_utils:literal_object(string)))
return object;
elseif (valid(object = $string_utils:match(string, olist, "aliases")))
return object;
elseif (parsed = this:parse_ordinal_reference(string))
return this:match_nth(parsed[2], olist, parsed[1]);
elseif (parsed = this:parse_possessive_reference(string))
{whostr, objstr} = parsed;
if (valid(whose = this:match(whostr, olist)))
return this:match(objstr, whose.contents);
else
return whose;
endif
else
return object;
endif
"Profane (#30788) - Sat Jan  3, 1998 - Changed so literals get returned ONLY if in the passed object list.";
"Profane (#30788) - Sat Jan  3, 1998 - OK, that broke lots of stuff, so changed it back.";
.
#51:1
":match_nth(string, objlist, n)";
"Find the nth object in 'objlist' that matches 'string'.";
{what, where, n} = args;
for v in (where)
z = 0;
for q in (v.aliases)
z = z || (index(q, what) == 1);
endfor
if (z && (!(n = n - 1)))
return v;
endif
endfor
return $failed_match;
.
#51:2
"$match_utils:match_verb(verbname, object) => Looks for a command-line style verb named <verbname> on <object> with current values of prepstr, dobjstr, dobj, iobjstr, and iobj.  If a match is made, the verb is called with @args[3] as arguments and 1 is returned.  Otherwise, 0 is returned.";
{vrb, what, rest} = args;
if (where = $object_utils:has_verb(what, vrb))
if ((vargs = verb_args(where[1], vrb)) != {"this", "none", "this"})
if (((((((vargs[2] == "any") || ((!prepstr) && (vargs[2] == "none"))) || index(("/" + vargs[2]) + "/", ("/" + prepstr) + "/")) && (((vargs[1] == "any") || ((!dobjstr) && (vargs[1] == "none"))) || ((dobj == what) && (vargs[1] == "this")))) && (((vargs[3] == "any") || ((!iobjstr) && (vargs[3] == "none"))) || ((iobj == what) && (vargs[3] == "this")))) && index(verb_info(where[1], vrb)[2], "x")) && verb_code(where[1], vrb))
set_task_perms(caller_perms());
what:(vrb)(@rest);
return 1;
endif
endif
endif
.
#51:3
":match_list(string, object_list) -> List of all matches.";
{what, where} = args;
if (!what)
return {};
endif
r = {};
for v in (where)
if (!(v in r))
z = 0;
for q in (v.aliases)
z = z || (q && (index(q, what) == 1));
endfor
if (z)
"r = listappend(r, v);";
r = {@r, v};
endif
endif
endfor
return r;
"Hydros (#106189) - Sun Jul 3, 2005 - Changed listappend to a splice to save ticks. Old code commented above.";
.
#51:4
":parse_ordref(string)";
"Parses strings referring to an 'nth' object.";
"=> {INT n, STR object} Where 'n' is the number the ordinal represents, and 'object' is the rest of the string.";
"=> 0 If the given string is not an ordinal reference.";
"  Example:";
":parse_ordref(\"second broadsword\") => {2, \"broadsword\"}";
":parse_ordref(\"second\") => 0";
"  Note that there must be more to the string than the ordinal alone.";
if (m = match(args[1], ("^" + this.ordinal_regexp) + " +%([^ ].+%)$"))
o = substitute("%1", m);
n = (o in this.ordn) || (o in this.ordw);
return n && {n, substitute("%2", m)};
else
return 0;
endif
.
#51:5
":parse_possessive_reference(string)";
"Parses strings in a possessive format.";
"=> {STR whose, STR object}  Where 'whose' is the possessor of 'object'.";
"If the string consists only of a possessive string (ie: \"my\", or \"yduJ's\"), then 'object' will be an empty string.";
"=> 0 If the given string is not a possessive reference.";
"  Example:";
":parse_possessive_reference(\"joe's cat\") => {\"joe\", \"cat\"}";
":parse_possessive_reference(\"sis' fish\") => {\"sis\", \"fish\"}";
"  Strings are returned as a value suitable for a :match routine, thus 'my' becoming 'me'.";
":parse_possessive_reference(\"my dog\") => {\"me\", \"dog\"}";
string = args[1];
if (m = match(string, "^my$%|^my +%(.+%)?"))
return {"me", substitute("%1", m)};
elseif (m = match(string, "^%(.+s?%)'s? *%(.+%)?"))
return {substitute("%1", m), substitute("%2", m)};
else
return 0;
endif
"Profane (#30788) - Sun Jun 21, 1998 - changed first parenthetical match bit from %([^ ]+s?%) to %(.+s?%)";
.
#51:6
"Usage: object_match_failed(object, string[, ambigs])";
"Prints a message if string does not match object.  Generally used after object is derived from a :match_object(string).";
"ambigs is an optional list of the objects that were matched upon.  If given, the message printed will list the ambiguous among them as choices.";
{match_result, string, ?ambigs = 0} = args;
tell = (0 && $perm_utils:controls(caller_perms(), player)) ? "notify" | "tell";
if ((index(string, "#") == 1) && ($code_utils:toobj(string) != E_TYPE))
"...avoid the `I don't know which `#-2' you mean' message...";
if (!valid(match_result))
player:(tell)(tostr("There is no \"", string, "\" that you can see."));
endif
return !valid(match_result);
elseif (match_result == $nothing)
player:(tell)("You must give the name of some object.");
elseif (match_result == $failed_match)
player:(tell)(tostr("There is no \"", string, "\" that you can see."));
elseif (match_result == $ambiguous_match)
if (typeof(ambigs) != LIST)
player:(tell)(tostr("I don't know which \"", string, "\" you mean."));
return 1;
endif
ambigs = $match_utils:match_list(string, ambigs);
ambigs = $list_utils:map_property(ambigs, "name");
if ((length($list_utils:remove_duplicates(ambigs)) == 1) && $object_utils:isa(player.location, this.matching_room))
player:(tell)(tostr("I don't know which \"", string, "\" you mean.  Try using \"first ", string, "\", \"second ", string, "\", etc."));
else
player:(tell)(tostr("I don't know which \"", string, "\" you mean: ", $string_utils:english_list(ambigs, "nothing", " or "), "."));
endif
return 1;
elseif (!valid(match_result))
player:(tell)(tostr("The object you specified does not exist.  Seeing ghosts?"));
else
return 0;
endif
return 1;
.
#51:7
if (caller_perms().wizard)
pass(@args);
this.matching_room = $nothing;
endif
.
#52:0
"Syntax:  has_property(OBJ, STR) => INT 0|1";
"";
"Does object have the specified property? Returns true if it is defined on the object or a parent.";
{object, prop} = args;
try
object.(prop);
return 1;
except (E_PROPNF, E_INVIND)
return 0;
endtry
"Old code...Ho_Yan 10/22/96";
if (prop in $code_utils.builtin_props)
return valid(object);
else
return !(!property_info(object, prop));
endif
.
#52:1
"Syntax:  all_properties (OBJ what)";
"         all_verbs      (OBJ what)";
"";
"Returns all properties or verbs defined on `what' and all of its ancestors. Uses wizperms to get properties or verbs if the caller of this verb owns what, otherwise, uses caller's perms.";
what = args[1];
if (what.owner != caller_perms())
set_task_perms(caller_perms());
endif
bif = (verb == "all_verbs") ? "verbs" | "properties";
res = `call_function(bif, what) ! E_PERM => {}';
while (valid(what = parent(what)))
res = {@`call_function(bif, what) ! E_PERM => {}', @res};
endwhile
return res;
.
#52:2
":has_verb(OBJ object, STR verbname)";
"Find out if an object has a verb matching the given verbname.";
"Returns {location} if so, 0 if not, where location is the object or the ancestor on which the verb is actually defined.";
{object, verbname} = args;
while (valid(object))
try
if (verb_info(object, verbname))
return {object};
endif
except (E_VERBNF)
object = parent(object);
endtry
endwhile
return 0;
"OLD CODE BELOW:";
while (E_VERBNF == (vi = `verb_info(object, verbname) ! E_VERBNF, E_INVARG'))
object = parent(object);
endwhile
return vi ? {object} | 0;
.
#52:3
"Usage:  has_callable_verb(object, verb)";
"See if an object has a verb that can be called by another verb (i.e., that has its x permission bit set).";
"Return {location}, where location is the object that defines the verb, or 0 if the object doesn't have the verb.";
{object, verbname} = args;
if (typeof(object) == WAIF)
object = object.class;
verbname = ":" + verbname;
endif
return `{respond_to(object, verbname)[1]} ! ANY => 0';
.
#52:4
":match_verb(OBJ object, STR verb)";
"Find out if an object has a given verb, and some information about it.";
"Returns {OBJ location, STR verb} if matched, 0 if not.";
"Location is the object on which it is actually defined, verb is a name";
"for the verb which can subsequently be used in verb_info (i.e., no";
"asterisks).";
verbname = strsub(args[2], "*", "");
object = args[1];
while (E_VERBNF == (info = `verb_info(object, verbname) ! E_VERBNF, E_INVARG'))
object = parent(object);
endwhile
return info ? {object, verbname} | 0;
.
#52:5
{what, targ, ?return_parent = 0} = args;
if ((typeof(what) == OBJ) && (typeof(targ) in {OBJ, LIST}))
return isa(@args);
elseif ((typeof(what) == WAIF) && (typeof(targ) in {OBJ, LIST}))
return isa(what.class, targ, return_parent);
elseif ((typeof(what) == WAIF) && (typeof(targ) == WAIF))
return isa(what.class, targ.class, return_parent);
elseif ((typeof(what) == OBJ) && (typeof(targ) == WAIF))
return isa(targ.class, what, return_parent);
else
raise(E_INVARG);
endif
.
#52:6
"Usage:  ancestors(object[, object...])";
"Return a list of all ancestors of the object(s) in args, with no duplicates.";
"If called with a single object, the result will be in order ascending up the inheritance hierarchy.  If called with multiple objects, it probably won't.";
return ancestors(@args);
.
#52:7
r = {what = args[1]};
for k in (children(what))
if (children(k))
r = {@r, @this:(verb)(k)};
else
r = {@r, k};
endif
endfor
return r;
.
#52:8
"$object_utils:contains(obj1, obj2) -- does obj1 contain obj2?";
"";
"Return true iff obj2 is under obj1 in the containment hierarchy; that is, if obj1 is obj2's location, or its location's location, or ...";
{loc, what} = args;
while (valid(what))
what = what.location;
if (what == loc)
return valid(loc);
endif
endwhile
return 0;
.
#52:9
"all_contents(object)";
"Return a list of all objects contained (at some level) by object.";
for y in (res = args[1].contents)
y.contents && (res = {@res, @this:all_contents(y)});
endfor
return res;
.
#52:10
"findable_properties(object)";
"Return a list of properties on those members of object's ancestor list that are readable or are owned by the caller (or all properties if the caller is a wizard).";
what = args[1];
props = {};
who = caller_perms();
while (what != $nothing)
if ((what.r || (who == what.owner)) || who.wizard)
props = {@properties(what), @props};
endif
what = parent(what);
endwhile
return props;
.
#52:11
"owned_properties(what[, who])";
"Return a list of all properties on WHAT owned by WHO.";
"Only wizardly verbs can specify WHO; mortal verbs can only search for properties owned by their own owners.  For more information, talk to Gary_Severn.";
what = anc = args[1];
who = ((c = caller_perms()).wizard && (length(args) > 1)) ? args[2] | c;
props = {};
while (anc != $nothing)
for k in (properties(anc))
if (property_info(what, k)[1] == who)
props = listappend(props, k);
endif
endfor
anc = parent(anc);
endwhile
return props;
.
#52:12
":property_conflicts(object,newparent)";
"Looks for propertyname conflicts that would keep chparent(object,newparent)";
"  from working.";
"Returns a list of elements of the form {<propname>, @<objectlist>}";
"where <objectlist> is list of descendents of object defining <propname>.";
if (!valid(object = args[1]))
return E_INVARG;
elseif (!valid(newparent = args[2]))
return (newparent == #-1) ? {} | E_INVARG;
elseif (!($perm_utils:controls(caller_perms(), object) && (newparent.f || $perm_utils:controls(caller_perms(), newparent))))
"... if you couldn't chparent anyway, you don't need to know...";
return E_PERM;
endif
"... properties existing on newparent";
"... cannot be present on object or any descendent...";
props = conflicts = {};
for o in ({object, @$object_utils:descendents_suspended(object)})
for p in (properties(o))
if (`property_info(newparent, p) ! E_PROPNF => 0')
if (i = p in props)
conflicts[i] = {@conflicts[i], o};
else
props = {@props, p};
conflicts = {@conflicts, {p, o}};
endif
endif
$command_utils:suspend_if_needed(0);
endfor
$command_utils:suspend_if_needed(0);
endfor
return conflicts;
.
#52:13
":descendants_with_property_suspended(object,property)";
" => list of descendants of object on which property is defined.";
"calls suspend(0) as needed";
{object, prop} = args;
if ((caller == this) || (object.w || $perm_utils:controls(caller_perms(), object)))
$command_utils:suspend_if_needed(0);
if (`property_info(object, prop) ! E_PROPNF => 0')
return {object};
endif
r = {};
for c in (children(object))
r = {@r, @this:descendants_with_property_suspended(c, prop)};
endfor
return r;
else
return E_PERM;
endif
.
#52:14
"Usage:  locations(object)";
"Return a listing of the location hierarchy above object.";
return locations(@args);
.
#52:15
"Syntax:  all_properties_suspended (OBJ what)";
"         all_verbs_suspended      (OBJ what)";
"";
"Returns all properties or verbs defined on `what' and all of its ancestors. Uses wizperms to get properties or verbs if the caller of this verb owns what, otherwise, uses caller's perms. Suspends as necessary";
what = args[1];
if (what.owner != caller_perms())
set_task_perms(caller_perms());
endif
bif = (verb == "all_verbs_suspended") ? "verbs" | "properties";
res = `call_function(bif, what) ! E_PERM => {}';
while (valid(what = parent(what)))
res = {@`call_function(bif, what) ! E_PERM => {}', @res};
$command_utils:suspend_if_needed(0);
endwhile
return res;
.
#52:16
":connected(object) => true if object is a connected player.";
"equivalent to (object in connected_players()) for valid players, perhaps with less server overhead.";
"use object:is_listening() if you want to allow for puppets and other non-player objects that still 'care' about what's said.";
return typeof(`connected_seconds(@args) ! E_INVARG') == INT;
.
#52:17
":isoneof(x,y) = x isa z, for some z in list y";
{what, targ} = args;
while (valid(what))
if (what in targ)
return 1;
endif
what = parent(what);
endwhile
return 0;
.
#52:18
"Returns 1 if the verb is actually *defined* on this object, 0 else.";
"Use this instead of :has_verb if your aim is to manipulate that verb code or whatever.";
return `verb_info(@args) ! ANY => 0' && 1;
"Old code below...Ho_Yan 10/22/96";
info = verb_info(@args);
return typeof(info) != ERR;
.
#52:19
":defines_property(OBJ object, STR property name) => Returns 1 if the property is actually *defined* on the object given";
if (!valid(o = args[1]))
return 0;
elseif (!valid(p = parent(o)))
return this:has_property(o, args[2]);
else
return (!this:has_property(p, args[2])) && this:has_property(o, args[2]);
endif
.
#52:20
":has_any_verb(object) / :has_any_property(object)";
" -- does `object' have any verbs/properties?";
return !(!`(verb == "has_any_verb") ? verbs(args[1]) | properties(args[1]) ! E_INVARG => 0');
.
#52:21
":has_readable_property(OBJ object, STR property name) => 1 if property exists and is publically readable (has the r flag set true).";
{object, prop} = args;
try
pinfo = property_info(object, prop);
return index(pinfo[2], "r") != 0;
except (E_PROPNF)
return (prop in $code_utils.builtin_props) > 0;
endtry
.
#52:22
":descendants (OBJ object) => {OBJs} all nested children of <object>";
return descendants(@args);
.
#52:23
":leaves (OBJ object) => {OBJs} descendants of <object> that have no children";
r = {args[1]};
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r[i..i] = kids;
else
i = i + 1;
endif
endwhile
return r;
.
#52:24
":branches (OBJ object) => {OBJs} descendants of <object> that have children";
r = args[1..1];
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r[i + 1..i] = kids;
i = i + 1;
else
r[i..i] = {};
endif
endwhile
return r;
.
#52:25
":descendants_suspended (OBJ object) => {OBJs} all nested children of <object>";
set_task_perms(caller_perms());
r = children(args[1]);
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r = {@r, @kids};
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endwhile
return r;
.
#52:26
":leaves_suspended (OBJ object) => {OBJs} descendants of <object> that have";
"                                         no children";
set_task_perms(caller_perms());
r = {args[1]};
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r[i..i] = kids;
else
i = i + 1;
endif
$command_utils:suspend_if_needed(0);
endwhile
return r;
.
#52:27
":branches_suspended (OBJ object) => {OBJs} all descendants of <object> that";
"                                           have children.";
set_task_perms(caller_perms());
r = args[1..1];
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r[i + 1..i] = kids;
i = i + 1;
else
r[i..i] = {};
endif
$command_utils:suspend_if_needed(0);
endwhile
return r;
.
#52:28
":disown(object) / :disinherit(object)";
" => 1 (for a successful disinheritance)";
" raises E_PERM, E_INVARG, E_ARGS";
cp = caller_perms();
"     no set_task_perms() because we need to be able to";
"     chparent() an object we don't own";
{victim} = args;
parent = parent(victim);
if ($perm_utils:controls(cp, victim))
raise(E_INVARG, tostr(victim.name, " (", victim, ") is yours.  Use @chparent."));
elseif (!valid(parent))
raise(E_INVARG, tostr(victim.name, " (", victim, ") is already an orphan."));
elseif (!$perm_utils:controls(cp, parent))
raise(E_PERM, tostr(parent.name, " (", parent, "), the parent of ", victim.name, " (", victim, "), is not yours."));
elseif (!valid(grandparent = parent(parent)))
"... still not sure about this... do we care?  --Rog...";
raise(E_INVARG, tostr(victim.name, " (", victim, ") has no grandparent to take custody."));
else
chparent(victim, grandparent);
return 1;
endif
.
#52:29
"  accessible_verbs(object)   => a list of verb names (or E_PERM) regardless of readability of object";
{thing} = args;
valid(thing) || raise(E_INVARG, "Invalid object argument");
{num_verbs, verbs} = {length(verbs(thing)), {}};
set_task_perms(caller_perms());
"... caching num of verbs before for loop saves us ticks ...";
for i in [1..num_verbs]
verbs = {@verbs, `verb_info(thing, i)[3] ! E_PERM'};
endfor
return verbs;
.
#52:30
" :accessible_props(object)   => a list of property names (or E_PERM), regardless of the readability of the object.";
thing = args[1];
all = properties(thing);
props = {};
set_task_perms(caller_perms());
for i in (all)
$command_utils:suspend_if_needed(0);
if ((info = `property_info(thing, i) ! ANY') != E_PROPNF)
props = {@props, info ? i | E_PERM};
endif
endfor
return props;
"Last modified Mon Nov 28 06:19:35 2005 PST, by Roebare (#109000).";
.
#53:0
this.input_string = args[1];
this.input_length = length(args[1]);
this.input_index = 1;
this.index_incremented = 0;
.
#53:1
string = this.input_string;
len = this.input_length;
i = this.input_index;
while ((i <= len) && (string[i] == " "))
i = i + 1;
endwhile
if (i > len)
this.index_incremented = 0;
return "";
elseif ((ch = string[i]) in {"(", ")", "!", "?"})
this.input_index = i + 1;
this.index_incremented = 1;
return ch;
elseif (ch in {"&", "|"})
this.input_index = i = i + 1;
this.index_incremented = 1;
if ((i <= len) && (string[i] == ch))
this.input_index = i + 1;
this.index_incremented = 2;
endif
return ch + ch;
else
start = i;
while ((i <= len) && (!((ch = string[i]) in {"(", ")", "!", "?", "&", "|"})))
i = i + 1;
endwhile
this.input_index = i;
i = i - 1;
while (string[i] == " ")
i = i - 1;
endwhile
this.index_incremented = (i - start) + 1;
return this:canonicalize_spaces(string[start..i]);
endif
.
#53:2
name = args[1];
while (index(name, "  "))
name = strsub(name, "  ", " ");
endwhile
return name;
.
#53:3
"parse_keyexp(STRING keyexpression, OBJ player) => returns a list containing the coded key, or a string containing an error message if the attempt failed.";
"";
"Grammar for key expressions:";
"";
"    E ::= A       ";
"       |  E || A  ";
"       |  E && A  ";
"    A ::= ( E )   ";
"       |  ! A     ";
"       |  object  ";
"       |  ? object  ";
this:init_scanner(args[1]);
this.player = args[2];
return this:parse_E();
.
#53:4
exp = this:parse_A();
if (typeof(exp) != STR)
while ((token = this:scan_token()) in {"&&", "||"})
rhs = this:parse_A();
if (typeof(rhs) == STR)
return rhs;
endif
exp = {token, exp, rhs};
endwhile
"The while loop above always eats a token. Reset it back so the iteration can find it again. Always losing `)'. Ho_Yan 3/9/95";
this.input_index = this.input_index - this.index_incremented;
endif
return exp;
.
#53:5
token = this:scan_token();
if (token == "(")
exp = this:parse_E();
if ((typeof(exp) != STR) && (this:scan_token() != ")"))
return "Missing ')'";
else
return exp;
endif
elseif (token == "!")
exp = this:parse_A();
if (typeof(exp) == STR)
return exp;
else
return {"!", exp};
endif
elseif (token == "?")
next = this:scan_token();
if (next in {"(", ")", "!", "&&", "||", "?"})
return ("Missing object-name before '" + token) + "'";
elseif (next == "")
return "Missing object-name at end of key expression";
else
what = this:match_object(next);
if (typeof(what) == OBJ)
return {"?", this:match_object(next)};
else
return what;
endif
endif
elseif (token in {"&&", "||"})
return ("Missing expression before '" + token) + "'";
elseif (token == "")
return "Missing expression at end of key expression";
else
return this:match_object(token);
endif
.
#53:6
"eval_key(LIST|OBJ coded key, OBJ testobject) => returns true if testobject will solve the provided key.";
{key, who} = args;
type = typeof(key);
if (!(type in {LIST, OBJ}))
return 1;
elseif (typeof(key) == OBJ)
return (who == key) || $object_utils:contains(who, key);
endif
op = key[1];
if (op == "!")
return !this:eval_key(key[2], who);
elseif (op == "?")
return key[2]:is_unlocked_for(who);
elseif (op == "&&")
return this:eval_key(key[2], who) && this:eval_key(key[3], who);
elseif (op == "||")
return this:eval_key(key[2], who) || this:eval_key(key[3], who);
else
raise(E_DIV);
endif
.
#53:7
"used by $lock_utils to unparse a key expression so one can use `here' and `me' as well as doing the regular object matching.";
token = args[1];
if (token == "me")
return this.player;
elseif (token == "here")
if (valid(this.player.location))
return this.player.location;
else
return ("'here' has no meaning where " + this.player.name) + " is";
endif
else
what = this.player.location:match_object(token);
if (what == $failed_match)
return ("Can't find an object named '" + token) + "'";
elseif (what == $ambiguous_match)
return ("Multiple objects named '" + token) + "'";
else
return what;
endif
endif
.
#53:8
":unparse_key(LIST|OBJ coded key) => returns a string describing the key in english/moo-code terms.";
"Example:";
"$lock_utils:unparse_key({\"||\", $hacker, $housekeeper}) => \"#18105[Hacker] || #36830[housekeeper]\"";
key = args[1];
type = typeof(key);
if (!(type in {LIST, OBJ}))
return "(None.)";
elseif (type == OBJ)
if (valid(key))
return tostr(key, "[", key.name, "]");
else
return tostr(key);
endif
else
op = key[1];
arg1 = this:unparse_key(key[2]);
if (op == "?")
return "?" + arg1;
elseif (op == "!")
if (typeof(key[2]) == LIST)
return ("!(" + arg1) + ")";
else
return "!" + arg1;
endif
elseif (op in {"&&", "||"})
other = (op == "&&") ? "||" | "&&";
lhs = arg1;
rhs = this:unparse_key(key[3]);
if ((typeof(key[2]) == OBJ) || (key[2][1] != other))
exp = lhs;
else
exp = ("(" + lhs) + ")";
endif
exp = ((exp + " ") + op) + " ";
if ((typeof(key[3]) == OBJ) || (key[3][1] != other))
exp = exp + rhs;
else
exp = ((exp + "(") + rhs) + ")";
endif
return exp;
else
raise(E_DIV);
endif
endif
.
#53:9
set_task_perms($no_one);
{key, who} = args;
type = typeof(key);
if (!(type in {LIST, OBJ}))
return 1;
elseif (typeof(key) == OBJ)
return (who == key) || $object_utils:contains(who, key);
endif
op = key[1];
if (op == "!")
return !this:eval_key(key[2], who);
elseif (op == "?")
return key[2]:is_unlocked_for(who);
elseif (op == "&&")
return this:eval_key(key[2], who) && this:eval_key(key[3], who);
elseif (op == "||")
return this:eval_key(key[2], who) || this:eval_key(key[3], who);
elseif (op == ".")
if ($object_utils:has_property(who, key[2]) && who.(key[2]))
return 1;
else
for thing in ($object_utils:all_contents(who))
if ($object_utils:has_property(thing, key[2]) && thing.(key[2]))
return 1;
endif
endfor
endif
return 0;
elseif (op == ":")
if ($object_utils:has_verb(who, key[2]) && who:(key[2])())
return 1;
else
for thing in ($object_utils:all_contents(who))
if ($object_utils:has_verb(thing, key[2]) && thing:(key[2])())
return 1;
endif
endfor
endif
return 0;
else
raise(E_DIV);
endif
.
#53:10
token = this:scan_token();
if (token == "(")
exp = this:parse_E();
if ((typeof(exp) != STR) && (this:scan_token() != ")"))
return "Missing ')'";
else
return exp;
endif
elseif (token == "!")
exp = this:parse_A();
if (typeof(exp) == STR)
return exp;
else
return {"!", exp};
endif
elseif (token == "?")
next = this:scan_token();
if (next in {":", ".", "(", ")", "!", "&&", "||", "?"})
return ("Missing object-name before '" + token) + "'";
elseif (next == "")
return "Missing object-name at end of key expression";
else
what = this:match_object(next);
if (typeof(what) == OBJ)
return {"?", this:match_object(next)};
else
return what;
endif
endif
elseif (token in {":", "."})
next = this:scan_token();
if (next in {":", ".", "(", ")", "!", "&&", "||", "?"})
return ("Missing verb-or-property-name before '" + token) + "'";
elseif (next == "")
return "Missing verb-or-property-name at end of key expression";
elseif (typeof(next) != STR)
return "Non-string verb-or-property-name at end of key expression";
else
return {token, next};
endif
elseif (token in {"&&", "||"})
return ("Missing expression before '" + token) + "'";
elseif (token == "")
return "Missing expression at end of key expression";
else
return this:match_object(token);
endif
.
#54:0
who = valid(caller_perms()) ? caller_perms() | player;
if ($perm_utils:controls(who, this) || this:is_readable_by(who))
result = this:do_burn();
else
result = 0;
endif
player:tell(result ? this:burn_succeeded_msg() | this:burn_failed_msg());
if (msg = result ? this:oburn_succeeded_msg() | this:oburn_failed_msg())
player.location:announce(player.name, " ", msg);
endif
.
#54:1
return (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "";
.
#54:2
if ((this != $letter) && ((caller == this) || $perm_utils:controls(caller_perms(), this)))
fork (0)
$recycler:_recycle(this);
endfork
return 1;
else
return E_PERM;
endif
.
#55:0
":make(n[,elt]) => a list of n elements, each of which == elt. elt defaults to 0.";
{n, ?elt = 0} = args;
if (n < 0)
return E_INVARG;
endif
ret = {};
build = {elt};
while (1)
if (n % 2)
ret = {@ret, @build};
endif
if (n = n / 2)
build = {@build, @build};
else
return ret;
endif
endwhile
.
#55:1
":range([m,]n) => {m,m+1,...,n}";
{?m = 1, n} = args;
ret = {};
for k in [m..n]
ret = {@ret, k};
endfor
return ret;
.
#55:2
set_task_perms(caller_perms());
{objs, prop} = args;
if (length(objs) > 50)
return {@this:map_prop(objs[1..$ / 2], prop), @this:map_prop(objs[($ / 2) + 1..$], prop)};
endif
strs = {};
for foo in (objs)
strs = {@strs, foo.(prop)};
endfor
return strs;
.
#55:3
set_task_perms(caller_perms());
{objs, vrb, @rest} = args;
if (length(objs) > 50)
return {@this:map_verb(@listset(args, objs[1..$ / 2], 1)), @this:map_verb(@listset(args, objs[($ / 2) + 1..$], 1))};
endif
strs = {};
for o in (objs)
strs = {@strs, o:(vrb)(@rest)};
endfor
return strs;
.
#55:4
"map_arg([n,]object,verb,@args) -- assumes the nth element of args is a list, calls object:verb(@args) with each element of the list substituted in turn, returns the list of results.  n defaults to 1.";
"map_verb_arg(o,v,{a...},a2,a3,a4,a5)={o:v(a,a2,a3,a4,a5),...}";
"map_verb_arg(4,o,v,a1,a2,a3,{a...},a5)={o:v(a1,a2,a3,a,a5),...}";
set_task_perms(caller_perms());
if (n = args[1])
{object, verb, @rest} = args[2..$];
else
object = n;
n = 1;
{verb, @rest} = args[2..$];
endif
results = {};
for a in (rest[n])
results = listappend(results, object:(verb)(@listset(rest, a, n)));
endfor
return results;
.
#55:5
":map_builtin(objectlist,func) applies func to each of the objects in turn and returns the corresponding list of results.  This function is mainly here for completeness -- in the vast majority of situations, a simple for loop is better.";
set_task_perms(caller_perms());
{objs, builtin} = args;
if (!`function_info(builtin) ! E_INVARG => 0')
return E_INVARG;
endif
if (length(objs) > 100)
return {@this:map_builtin(objs[1..$ / 2], builtin), @this:map_builtin(objs[($ / 2) + 1..$], builtin)};
endif
strs = {};
for foo in (objs)
strs = {@strs, call_function(builtin, foo)};
endfor
return strs;
.
#55:6
"find_insert(sortedlist,key) => index of first element in sortedlist > key";
"  sortedlist is assumed to be sorted in increasing order and the number returned is anywhere from 1 to length(sortedlist)+1, inclusive.";
{lst, key} = args;
if ((r = length(lst)) < 25)
for l in [1..r]
if (lst[l] > key)
return l;
endif
endfor
return r + 1;
else
l = 1;
while (r >= l)
if (key < lst[i = (r + l) / 2])
r = i - 1;
else
l = i + 1;
endif
endwhile
return l;
endif
.
#55:7
"remove_duplicates(list) => list as a set, i.e., all repeated elements removed.";
out = {};
for x in (args[1])
out = setadd(out, x);
endfor
return out;
.
#55:8
"arrayset(list,value,pos1,...,posn) -- returns list modified such that";
"  list[pos1][pos2][...][posn] == value";
if (length(args) > 3)
return listset(@listset(args[1..3], this:arrayset(@listset(listdelete(args, 3), args[1][args[3]], 1)), 2));
"... Rog's entry in the Obfuscated MOO-Code Contest...";
else
return listset(@args);
endif
.
#55:9
":setremove_all(set,elt) => set with *all* occurences of elt removed";
{set, what} = args;
while (w = what in set)
set[w..w] = {};
endwhile
return set;
.
#55:10
"append({a,b,c},{d,e},{},{f,g,h},...) =>  {a,b,c,d,e,f,g,h}";
if (length(args) > 50)
return {@this:append(@args[1..$ / 2]), @this:append(@args[($ / 2) + 1..$])};
endif
l = {};
for a in (args)
l = {@l, @a};
endfor
return l;
.
#55:11
"reverse(list) => reversed list";
return this:_reverse(@args[1]);
.
#55:12
":_reverse(@list) => reversed list";
if (length(args) > 50)
return {@this:_reverse(@args[($ / 2) + 1..$]), @this:_reverse(@args[1..$ / 2])};
endif
l = {};
for a in (args)
l = listinsert(l, a);
endfor
return l;
.
#55:13
"compress(list) => list with consecutive repeated elements removed, e.g.,";
"compress({a,b,b,c,b,b,b,d,d,e}) => {a,b,c,b,d,e}";
if (l = args[1])
out = {last = l[1]};
for x in (listdelete(l, 1))
if (x != last)
out = listappend(out, x);
last = x;
endif
endfor
return out;
else
return l;
endif
.
#55:14
"sort(list[,keys]) => sorts keys (assumed to be all numbers or strings) and returns list with the corresponding permutation applied to it.  keys defaults to the list itself.";
"sort({x1,x3,x2},{1,3,2}) => {x1,x2,x3}";
set_thread_mode(0);
return sort(@args);
.
#55:15
":sort_suspended(interval,list[,keys]) => sorts keys (assumed to be all numbers or strings) and returns list with the corresponding permutation applied to it.  keys defaults to the list itself.";
"Note: For compatibility with LambdaCore, the interval argument hasn't been removed. In ToastStunt, however, it's not used. Instead, the task will suspend until the sort thread has finished.";
set_task_perms(caller_perms());
return sort(@args[2..$]);
.
#55:16
"slice(alist[,index]) returns a list of the index-th elements of the elements of alist, e.g., ";
"    slice({{\"z\",1},{\"y\",2},{\"x\",5}},2) => {1,2,5}.";
"index defaults to 1 and may also be a nonempty list, e.g., ";
"    slice({{\"z\",1,3},{\"y\",2,4}},{2,1}) => {{1,\"z\"},{2,\"y\"}}";
"For compatibility with LambdaCore, threading is disabled by default.";
set_thread_mode(0);
return slice(@args);
.
#55:17
"assoc(target,list[,index]) returns the first element of `list' whose own index-th element is target.  Index defaults to 1.";
"returns {} if no such element is found";
{target, thelist, ?indx = 1} = args;
for t in (thelist)
if ((typeof(t) == LIST) && `t[indx] == target ! E_RANGE => 0')
return t;
endif
endfor
return {};
.
#55:18
"Copied from Moo_tilities (#332):iassoc by Mooshie (#106469) Wed Mar 18 19:27:51 1998 PST";
"Usage: iassoc(ANY target, LIST list [, INT index ]) => Returns the index of the first element of `list' whose own index-th element is target.  Index defaults to 1.";
"Returns 0 if no such element is found.";
{target, thelist, ?indx = 1} = args;
for element in (thelist)
if (`element[indx] == target ! E_RANGE, E_TYPE => 0')
if (typeof(element) == LIST)
return element in thelist;
endif
endif
endfor
return 0;
.
#55:19
"Copied from Moo_tilities (#332):iassoc_suspended by Mooshie (#106469) Wed Mar 18 19:27:53 1998 PST";
"Usage: iassoc_suspended(ANY target, LIST list [, INT index [, INT suspend-for ]]) => Returns the index of the first element of `list' whose own index-th element is target. Index defaults to 1.";
"Returns 0 if no such element is found.";
"Suspends as needed. Suspend length defaults to 0.";
set_task_perms(caller_perms());
{target, thelist, ?indx = 1, ?suspend_for = 0} = args;
cu = $command_utils;
for element in (thelist)
if (`element[indx] == target ! E_RANGE, E_TYPE => 0' && (typeof(element) == LIST))
return element in thelist;
endif
cu:suspend_if_needed(suspend_for);
endfor
return 0;
"Mooshie (#106469) - Tue Feb 10, PST - :assoc_suspended does a set_task_perms, why shouldn't this?";
.
#55:20
"assoc_prefix(target,list[,index]) returns the first element of `list' whose own index-th element has target as a prefix.  Index defaults to 1.";
{target, thelist, ?indx = 1} = args;
for t in (thelist)
if ((typeof(t) == LIST) && ((length(t) >= indx) && (index(t[indx], target) == 1)))
return t;
endif
endfor
return {};
.
#55:21
"iassoc_prefix(target,list[,index]) returns the index of the first element of `list' whose own index-th element has target as a prefix.  Index defaults to 1.";
{target, lst, ?indx = 1} = args;
for i in [1..length(lst)]
if ((typeof(lsti = lst[i]) == LIST) && ((length(lsti) >= indx) && (index(lsti[indx], target) == 1)))
return i;
endif
endfor
return 0;
.
#55:22
"iassoc_sorted(target,sortedlist[,i]) => index of last element in sortedlist whose own i-th element is <= target.  i defaults to 1.";
"  sortedlist is assumed to be sorted in increasing order and the number returned is anywhere from 0 to length(sortedlist), inclusive.";
{target, lst, ?indx = 1} = args;
if ((r = length(lst)) < 25)
for l in [1..r]
if (target < lst[l][indx])
return l - 1;
endif
endfor
return r;
else
l = 0;
r = r + 1;
while ((r - 1) > l)
if (target < lst[i = (r + l) / 2][indx])
r = i;
else
l = i;
endif
endwhile
return l;
endif
.
#55:23
":sort_alist(alist[,n]) sorts a list of tuples by n-th (1st) element.";
{alist, ?sort_on = 1} = args;
if ((alist_length = length(alist)) < 25)
"use insertion sort on short lists";
return this:sort(alist, this:slice(@args));
endif
left_index = alist_length / 2;
right_index = (alist_length + 1) / 2;
left_sublist = this:sort_alist(alist[1..left_index], sort_on);
right_sublist = this:sort_alist(alist[left_index + 1..alist_length], sort_on);
"...";
"... merge ...";
"...";
left_key = left_sublist[left_index][sort_on];
right_key = right_sublist[right_index][sort_on];
if (left_key > right_key)
merged_list = {};
else
"... alist_length >= 25 implies right_index >= 2...";
"... move right_index downward until left_key > right_key...";
r = right_index - 1;
while (left_key <= (right_key = right_sublist[r][sort_on]))
if (r = r - 1)
else
return {@left_sublist, @right_sublist};
endif
endwhile
merged_list = right_sublist[r + 1..right_index];
right_index = r;
endif
while (l = left_index - 1)
"... left_key > right_key ...";
"... move left_index downward until left_key <= right_key...";
while ((left_key = left_sublist[l][sort_on]) > right_key)
if (l = l - 1)
else
return {@right_sublist[1..right_index], @left_sublist[1..left_index], @merged_list};
endif
endwhile
merged_list[1..0] = left_sublist[l + 1..left_index];
left_index = l;
"... left_key <= right_key ...";
if (r = right_index - 1)
"... move right_index downward until left_key > right_key...";
while (left_key <= (right_key = right_sublist[r][sort_on]))
if (r = r - 1)
else
return {@left_sublist[1..left_index], @right_sublist[1..right_index], @merged_list};
endif
endwhile
merged_list[1..0] = right_sublist[r + 1..right_index];
right_index = r;
else
return {@left_sublist[1..left_index], right_sublist[1], @merged_list};
endif
endwhile
return {@right_sublist[1..right_index], left_sublist[1], @merged_list};
.
#55:24
"sort_alist_suspended(interval,alist[,n]) sorts a list of tuples by n-th element.  n defaults to 1.  Calls suspend(interval) as necessary.";
set_task_perms(caller_perms());
"... so it can be killed...";
{interval, alist, ?sort_on = 1} = args;
if ((alist_length = length(alist)) < 10)
"insertion sort on short lists";
$command_utils:suspend_if_needed(interval);
return this:sort(alist, this:slice(@listdelete(args, 1)));
endif
"variables specially expanded for the anal-retentive";
left_index = alist_length / 2;
right_index = (alist_length + 1) / 2;
left_sublist = this:sort_alist_suspended(interval, alist[1..left_index], sort_on);
right_sublist = this:sort_alist_suspended(interval, alist[left_index + 1..alist_length], sort_on);
left_element = left_sublist[left_index];
right_element = right_sublist[right_index];
merged_list = {};
while (1)
$command_utils:suspend_if_needed(interval);
if (left_element[sort_on] > right_element[sort_on])
merged_list = {left_element, @merged_list};
if (left_index = left_index - 1)
left_element = left_sublist[left_index];
else
return {@right_sublist[1..right_index], @merged_list};
endif
else
merged_list = {right_element, @merged_list};
if (right_index = right_index - 1)
right_element = right_sublist[right_index];
else
return {@left_sublist[1..left_index], @merged_list};
endif
endif
endwhile
.
#55:25
":randomly_permute(list) => list with its elements randomly permuted";
"  each of the length(list)! possible permutations is equally likely";
plist = {};
for i in [1..length(ulist = args[1])]
plist = listinsert(plist, ulist[i], random(i));
endfor
return plist;
.
#55:26
"$list_utils:count(item, list)";
"Returns the number of occurrences of item in list.";
{x, xlist} = args;
if (typeof(xlist) != LIST)
return E_INVARG;
endif
counter = 0;
while (loc = x in xlist)
counter = counter + 1;
xlist = xlist[loc + 1..$];
endwhile
return counter;
.
#55:27
"Copied from $quinn_utils (#34283):unroll by Quinn (#19845) Mon Mar  8 09:29:03 1993 PST";
":flatten(LIST list_of_lists) => LIST of all lists in given list `flattened'";
newlist = {};
for elm in (args[1])
if (typeof(elm) == LIST)
newlist = {@newlist, @this:flatten(elm)};
else
newlist = {@newlist, elm};
endif
endfor
return newlist;
.
#55:28
"Copied from APHiD (#33119):longest Sun May  9 21:00:18 1993 PDT";
"$list_utils:longest(<list>)";
"$list_utils:shortest(<list>)";
"             - Returns the shortest or longest element in the list.  Elements may be either strings or lists.  Returns E_TYPE if passed a non-list or a list containing non-string/list elements.  Returns E_RANGE if passed an empty list.";
if (typeof(all = args[1]) != LIST)
return E_TYPE;
elseif (all == {})
return E_RANGE;
else
result = all[1];
for things in (all)
if ((typeof(things) != LIST) && (typeof(things) != STR))
return E_TYPE;
else
result = (((verb == "longest") && (length(result) < length(things))) || ((verb == "shortest") && (length(result) > length(things)))) ? things | result;
endif
endfor
endif
return result;
.
#55:29
"reverse(list) => reversed list.  Does suspend(0) as necessary.";
set_task_perms(caller_perms());
"^^^For suspend task.";
return this:_reverse_suspended(@args[1]);
.
#55:30
":_reverse(@list) => reversed list";
set_task_perms(caller_perms());
$command_utils:suspend_if_needed(0);
if (length(args) > 50)
return {@this:_reverse_suspended(@args[($ / 2) + 1..$]), @this:_reverse_suspended(@args[1..$ / 2])};
endif
l = {};
for a in (args)
l = listinsert(l, a);
endfor
return l;
.
#55:31
":randomly_permute_suspended(list) => list with its elements randomly permuted";
"  each of the length(list)! possible permutations is equally likely";
set_task_perms(caller_perms());
plist = {};
for i in [1..length(ulist = args[1])]
plist = listinsert(plist, ulist[i], random(i));
$command_utils:suspend_if_needed(0);
endfor
return plist;
.
#55:32
"swap_elements -- exchange two elements in a list";
"Usage:  $list_utils:swap_elements(<list/LIST>,<index/INT>,<index/INT>)";
"        $list_utils:swap_elements({\"a\",\"b\"},1,2);";
{l, i, j} = args;
if (((typeof(l) == LIST) && (typeof(i) == INT)) && (typeof(j) == INT))
ll = length(l);
if (((i > 0) && (i <= ll)) && ((j > 0) && (j <= ll)))
t = l[i];
l[i] = l[j];
l[j] = t;
return l;
else
return E_RANGE;
endif
else
return E_TYPE;
endif
.
#55:33
"random_item -- returns a random element of the input list.";
if (length(args) == 1)
if (typeof(l = args[1]) == LIST)
if (length(l) > 0)
return l[random($)];
else
return E_RANGE;
endif
else
return E_TYPE;
endif
else
return E_ARGS;
endif
.
#55:34
"Copied from Moo_tilities (#332):assoc_suspended by Mooshie (#106469) Wed Mar 18 19:27:54 1998 PST";
"Usage: assoc_suspended(ANY target, LIST list [, INT index [, INT suspend-for ])) => Returns the first element of `list' whose own index-th element is target.  Index defaults to 1.";
"Returns {} if no such element is found.";
"Suspends as necessary. Suspend length defaults to 0.";
set_task_perms(caller_perms());
{target, thelist, ?indx = 1, ?suspend_for = 0} = args;
cu = $command_utils;
for t in (thelist)
if (`t[indx] == target ! E_TYPE => 0')
if ((typeof(t) == LIST) && (length(t) >= indx))
return t;
endif
endif
cu:suspend_if_needed(suspend_for);
endfor
return {};
.
#55:35
"Copied from Uther's_Ghost (#93141):amerge Tue May 27 20:28:18 1997 PDT";
"amerge(list[,tindex[,dindex]]) returns an associated list such that all the tuples in the original list with the same tindex-th element are merged. Useful for merging alists ( amerge({@alist1, @alist2, ...}) ) and for ensuring that each tuple has a unique index. Tindex defaults to 1. Dindex defaults to 1 and refers to the position in the tuple where the tindex-th element will land in the new tuple.";
{alist, ?tidx = 1, ?didx = 1} = args;
if (alist)
alist = this:sort_alist(alist, tidx);
i = 1;
res = {{cur = alist[1][tidx]}};
for tuple in (alist)
if (tuple[tidx] == cur)
res[i] = {@res[i], @listdelete(tuple, tidx)};
else
if (didx != 1)
res[i] = this:swap_elements(res[i], 1, min(didx, length(res[i])));
endif
i = i + 1;
res = {@res, {cur = tuple[tidx], @listdelete(tuple, tidx)}};
endif
endfor
return res;
endif
return alist;
.
#55:36
"passoc(key,list1,list2)";
"passoc() behaves rather similarly to assoc, with the exception that it's intended for";
"parallel lists.  given a key from list1, it returns a list containing the key and the";
"corresponding item from list2 (\"corresponding\", in the case of parallel lists, means";
"having the same index.)";
indx = args[1] in args[2];
if (indx)
return {args[1], args[3][indx]};
else
return {};
endif
.
#55:37
"Copied from Moo_tilities (#332):setmove by Mooshie (#106469) Mon Sep 22 21:07:25 1997 PDT";
"Usage: setmove(LIST elements, INT from, INT to)";
"Moves element in list from one position in list to another.";
"";
"Example: setmove({x, y, z}, 1, 3) => {y, z, x}";
"         setmove({x, y, z}, 2, 1} => {y, x, z}";
{start, from, to} = args;
what = start[from];
return listinsert(listdelete(start, from), what, to);
"  Written by Mooshie (#106469) @ Lambda - Mon Sep 22 21:03:26 1997 PDT -  ";
.
#55:38
"Copied from Moo_tilities (#332):iassoc_new by Mooshie (#106469) Wed Mar 18 19:27:52 1998 PST";
"Usage: iassoc_new(ANY target, LIST list [, INT index ]) => Returns the index of the first element of `list' whose own index-th element is target.  Index defaults to 1.";
"Returns 0 if no such element is found.";
"NOTE: expects that each index in the given list will be a list with at least as many elements as the indicated `index' argument. Otherwise will return E_RANGE";
{target, thelist, ?indx = 1} = args;
try
for element in (thelist)
if (element[indx] == target)
if (typeof(element) == LIST)
return element in thelist;
endif
endif
endfor
except e (ANY)
return e[1];
endtry
return 0;
.
#55:39
"Syntax:  build_alist(list, N) =>";
"{list[1..N], list[N+1..N*2], list[N*2+1..N*3], ..., list[N*(N-1)+1..N*N]}";
"";
"Creates an associated list from a flat list at every Nth interval. If the list doesn't have a multiple of N elements, E_RANGE is returned.";
"Example:  build_alist({a,b,c,d,e,f,g,h,i},3)=>{{a,b,c},{d,e,f},{g,h,i}}";
{olist, interval} = args;
if ((tot = length(olist)) % interval)
return E_RANGE;
endif
nlist = {};
d = 1;
while (d <= tot)
nlist = {@nlist, olist[1..interval]};
olist[1..interval] = {};
d = d + interval;
endwhile
return nlist;
.
#55:40
"Copied from list utilities (#372):flatten [verb author Hacker (#18105)] at Sun Jul  3 07:46:47 2011 PDT";
"Copied from $quinn_utils (#34283):unroll by Quinn (#19845) Mon Mar  8 09:29:03 1993 PST";
":flatten(LIST list_of_lists) => LIST of all lists in given list `flattened'";
newlist = {};
for elm in (args[1])
if (typeof(elm) == LIST)
$command_utils:suspend_if_needed(0);
newlist = {@newlist, @this:flatten_suspended(elm)};
else
$command_utils:suspend_if_needed(0);
newlist = {@newlist, elm};
endif
endfor
return newlist;
.
#55:41
":max_length(strings-or-lists[, default])";
"Return the maximum length of a set of strings or lists.";
"default is the minimum length that can be returned; 0 is a safe bet.";
max = args[2] || 0;
for item in (args[1])
max = max(max, length(item));
endfor
return max;
.
#55:42
":make_alist(lists[, pad])";
"Make an alist out of n parallel lists (basically a matrix transpose).";
"If the lists are of uneven length, fill the remaining tuples with pad (defaults to 0).";
alist = {};
pad = (length(args) > 1) ? args[2] | 0;
for i in [1..$list_utils:max_length(args[1])]
tuple = {};
for l in (args[1])
tuple = {@tuple, (i > length(l)) ? pad | l[i]};
endfor
alist = {@alist, tuple};
endfor
return alist;
.
#56:0
"Usage: object_match_failed(object, string, allow invalid)";
"Prints a message if string does not match object.  Generally used after object is derived from a :match_object(string).";
"If allow invalid is true, invalid objects > #0 are not considered a failure.";
{match_result, string, ?allow_invalid = 0} = args;
tell = $perm_utils:controls(caller_perms(), player) ? "notify" | "tell";
if ((index(string, "#") == 1) && ($code_utils:toobj(string) != E_TYPE))
"...avoid the `I don't know which `#-2' you mean' message...";
if ((allow_invalid && (match_result > #0)) && (!valid(match_result)))
return 0;
elseif (!valid(match_result))
player:(tell)(tostr(string, " does not exist."));
endif
return !valid(match_result);
elseif (match_result == $nothing)
player:(tell)("You must give the name of some object.");
elseif (match_result == $failed_match)
player:(tell)(tostr("I see no \"", string, "\" here."));
elseif (match_result == $ambiguous_match)
player:(tell)(tostr("I don't know which \"", string, "\" you mean."));
elseif ((!allow_invalid) && (!valid(match_result)))
player:(tell)(tostr(match_result, " does not exist."));
else
return 0;
endif
return 1;
.
#56:1
":player_match_failed(result,string)";
"  is exactly like :object_match_failed(result,string)";
"  except that its messages are more suitable for player searches.";
":player_match_result(results,strings)";
"  handles a list of results, also presumably from $string_utils:match_player(strings), printing messages to player for *each* of the nonmatching strings.  It returns a list, an overall result (true if some string didn't match --- just like player_match_failed), followed by the list players that matched.";
"";
"An optional 3rd arg gives an identifying string to prefix to each of the nasty messages.";
if (valid(player))
tell = $perm_utils:controls(caller_perms(), player) ? "notify" | "tell";
plyr = player;
else
tell = "notify";
plyr = $login;
endif
"...";
{match_results, strings, ?cmdid = ""} = args;
pmf = verb == "player_match_failed";
if (typeof(match_results) == OBJ)
match_results = {match_results};
strings = {strings};
endif
pset = {};
bombed = 0;
for i in [1..length(match_results)]
if (valid(result = match_results[i]))
pset = setadd(pset, match_results[i]);
elseif (result == $nothing)
"... player_match_result quietly skips over blank strings";
if (pmf)
plyr:(tell)("You must give the name of some player.");
bombed = 1;
endif
elseif (result == $failed_match)
plyr:(tell)(tostr(cmdid, "\"", strings[i], "\" is not the name of any player."));
bombed = 1;
elseif (result == $ambiguous_match)
lst = $player_db:find_all(strings[i]);
plyr:(tell)(tostr(cmdid, "\"", strings[i], "\" could refer to ", (length(lst) > 20) ? tostr("any of ", length(lst), " players") | $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", lst), "no one", " or "), "."));
bombed = 1;
else
plyr:(tell)(tostr(result, " does not exist."));
bombed = 1;
endif
endfor
if ((!bombed) && (!pset))
"If there were NO valid results, but not any actual 'error', fail anyway.";
plyr:(tell)("You must give the name of some player.");
bombed = 1;
endif
return pmf ? bombed | {bombed, @pset};
.
#56:2
"$command_utils:read() -- read a line of input from the player and return it";
"Optional argument is a prompt portion to replace `a line of input' in the prompt.";
"";
"Returns E_PERM if the current task is not the most recent task spawned by a command from player.";
{?prompt = "a line of input"} = args;
c = callers();
p = c[$][5];
p:notify(tostr("[Type ", prompt, " or `@abort' to abort the command.]"));
try
ans = read();
if ($string_utils:trim(ans) == "@abort")
p:notify(">> Command Aborted <<");
kill_task(task_id());
endif
return ans;
except error (ANY)
return error[1];
endtry
.
#56:3
"$command_utils:read_lines([max]) -- read zero or more lines of input";
"";
"Returns a list of strings, the (up to MAX, if given) lines typed by the player.  Returns E_PERM if the current task is not a command task that has never called suspend().";
"In order that one may enter arbitrary lines, including \"@abort\" or \".\", if the first character in an input line is `.' and there is some nonwhitespace afterwords, the `.' is dropped and the rest of the line is taken verbatim, so that, e.g., \".@abort\" enters as \"@abort\" and \"..\" enters as \".\".";
"--- Inline editor ---";
return $edit_utils:editor();
"--- Inline editor ---";
"(Remove the above line if you wish for normal read_lines prompts.)";
{?max = 0} = args;
c = callers();
p = c[$][5];
p:notify(tostr("[Type", max ? tostr(" up to ", max) | "", " lines of input; use `.' to end or `@abort' to abort the command.]"));
ans = {};
while (1)
try
line = read();
if ((line[1..min(6, $)] == "@abort") && ((tail = line[7..$]) == $string_utils:space(tail)))
p:notify(">> Command Aborted <<");
kill_task(task_id());
elseif ((!line) || (line[1] != "."))
ans = {@ans, line};
elseif ((tail = line[2..$]) == $string_utils:space(tail))
return ans;
else
ans = {@ans, tail};
endif
if (max && (length(ans) >= max))
return ans;
endif
except error (ANY)
return error[1];
endtry
endwhile
.
#56:4
":yes-or-no([prompt]) -- prompts the player for a yes or no answer and returns a true value iff the player enters a line of input that is some prefix of \"yes\"";
"";
"Returns E_NONE if the player enters a blank line, E_INVARG, if the player enters something that isn't a prefix of \"yes\" or \"no\", and E_PERM if the current task is not a command task that has never called suspend().";
c = callers();
p = c[$][5];
p:notify(tostr(args ? args[1] + " " | "", "[Enter `yes' or `no']"));
try
ans = read(@((caller == p) || $perm_utils:controls(caller_perms(), p)) ? {p} | {});
if (ans = $string_utils:trim(ans))
if (ans == "@abort")
p:notify(">> Command Aborted <<");
kill_task(task_id());
endif
return (index("yes", ans) == 1) || ((index("no", ans) != 1) && E_INVARG);
else
return E_NONE;
endif
except error (ANY)
return error[1];
endtry
.
#56:5
"$command_utils:read_lines_escape(escapes[,help]) -- read zero or more lines of input";
"";
"Similar to :read_lines() except that help is available and one may specify other escape sequences to terminate the read.";
"  escapes should be either a string or list of strings; this specifies which inputs other from `.' or `@abort' should terminate the read (... don't use anything beginning with a `.').";
"  help should be a string or list of strings to be printed in response to the player typing `?'; the first line of the help text should be a general comment about what the input text should be used for.  Successive lines should describe the effects of the alternative escapes.";
"Returns {end,list-of-strings-input} where end is the particular line that terminated this input or 0 if input terminated normally with `.'.  Returns E_PERM if the current task is not a command task that has never called suspend().  ";
"@abort and lines beginning with `.' are treated exactly as with :read_lines()";
{escapes, ?help = "You are currently in a read loop."} = args;
c = callers();
p = c[$][5];
escapes = {".", "@abort", @(typeof(escapes) == LIST) ? escapes | {escapes}};
p:notify(tostr("[Type lines of input; `?' for help; end with `", $string_utils:english_list(escapes, "", "' or `", "', `", ""), "'.]"));
ans = {};
escapes[1..0] = {"?"};
"... set up the help text...";
if (typeof(help) != LIST)
help = {help};
endif
help[2..1] = {"Type `.' on a line by itself to finish.", "Anything else with a leading period is entered with the period removed.", "Type `@abort' to abort the command completely."};
while (1)
try
line = read();
if ((trimline = $string_utils:trimr(line)) in escapes)
if (trimline == ".")
return {0, ans};
elseif (trimline == "@abort")
p:notify(">> Command Aborted <<");
kill_task(task_id());
elseif (trimline == "?")
p:notify_lines(help);
else
return {trimline, ans};
endif
else
if (line && (line[1] == "."))
line[1..1] = "";
endif
ans = {@ans, line};
endif
except error (ANY)
return error[1];
endtry
endwhile
.
#56:6
"Suspend, using output_delimiters() in case a client needs to keep track";
"of the output of the current command.";
"Args are TIME, amount of time to suspend, and optional (misnamed) OUTPUT.";
"If given no OUTPUT, just do a suspend.";
"If OUTPUT is neither list nor string, suspend and return output_delimiters";
"If OUTPUT is a list, it should be in the output_delimiters() format:";
"  {PREFIX, SUFFIX}.  Use these to handle that client stuff.";
"If OUTPUT is a string, it should be SUFFIX (output_delimiters[2])";
"";
"Proper usage:";
"The first time you want to suspend, use";
"  output_delimiters = $command_utils:suspend(time, x);";
"where x is some non-zero number.";
"Following, use";
"  $command_utils:suspend(time, output_delimiters);";
"To wrap things up, use";
"  $command_utils:suspend(time, output_delimiters[2]);";
"You'll probably want time == 0 most of the time.";
"Note: Using this from verbs called by other verbs could get pretty weird.";
{time, ?output = 0} = args;
set_task_perms(caller_perms());
value = 0;
if (!output)
suspend(time);
else
if (typeof(output) == LIST)
PREFIX = output[1];
SUFFIX = output[2];
if (PREFIX)
player:tell(output[2]);
endif
suspend(time);
if (SUFFIX)
player:tell(output[1]);
endif
elseif (typeof(output) == STR)
if (output)
player:tell(output);
endif
else
output = output_delimiters(player);
suspend(time);
if (output != {"", ""})
player:tell(output[1]);
endif
value = output;
endif
endif
return output;
.
#56:7
"Return true if we're running out of ticks or seconds.";
return (ticks_left() < 4000) || (seconds_left() < 2);
"If this verb is changed make sure to change :suspend_if_needed as well.";
.
#56:8
"Usage:  $command_utils:suspend_if_needed(<time>[, @<announcement>])";
"See if we're running out of ticks or seconds, and if so suspend(<time>) and return true.  If more than one arg is given, print the remainder with player:tell.";
if ((ticks_left() < 4000) || (seconds_left() < 2))
"Note: above computation should be the same as :running_out_of_time.";
{?time = 10, @ann} = args;
if (ann && valid(player))
player:tell(tostr(@ann));
endif
amount = max(time, min($login:current_lag(), 10));
set_task_perms(caller_perms());
"this is trying to back off according to lag...";
suspend(amount);
return 1;
endif
.
#56:9
":dump_lines(text) => text `.'-quoted for :read_lines()";
"  text is assumed to be a list of strings";
"Returns a corresponding list of strings which, when read via :read_lines, ";
"produces the original list of strings (essentially, any strings beginning ";
"with a period \".\" have the period doubled).";
"The list returned includes a final \".\"";
text = args[1];
newtext = {};
i = lasti = 0;
for line in (text)
if (match(line, "^%(%.%| *@abort *$%)"))
newtext = {@newtext, @(i > lasti) ? text[lasti + 1..i] | {}, "." + line};
lasti = i = i + 1;
else
i = i + 1;
endif
endfor
return {@newtext, @(i > lasti) ? text[lasti + 1..i] | {}, "."};
.
#56:10
":explain_syntax(here,verb,args)";
verb = args[2];
for x in ({player, args[1], @valid(dobj) ? {dobj} | {}, @valid(iobj) ? {iobj} | {}})
what = x;
while (hv = $object_utils:has_verb(what, verb))
what = hv[1];
i = 1;
while (i = $code_utils:find_verb_named(what, verb, i))
if (evs = $code_utils:explain_verb_syntax(x, verb, @verb_args(what, i)))
player:tell("Try this instead:  ", evs);
return 1;
endif
i = i + 1;
endwhile
what = parent(what);
endwhile
endfor
return 0;
.
#56:11
":do_huh(verb,args)  what :huh should do by default.";
{verb, args} = args;
if ($perm_utils:controls(caller_perms(), player) || (caller_perms() == player))
this.feature_task = {task_id(), verb, args, argstr, dobj, dobjstr, prepstr, iobj, iobjstr};
endif
set_task_perms(cp = caller_perms());
notify = $perm_utils:controls(cp, player) ? "notify" | "tell";
if (verb == "")
"should only happen if a player types backslash";
player:(notify)("I don't understand that.");
return;
endif
if (player:my_huh(verb, args))
"... the player found something funky to do ...";
elseif (caller:here_huh(verb, args))
"... the room found something funky to do ...";
elseif (player:last_huh(verb, args))
"... player's second round found something to do ...";
elseif (dobj == $ambiguous_match)
if (iobj == $ambiguous_match)
player:(notify)(tostr("I don't understand that (\"", dobjstr, "\" and \"", iobjstr, "\" are both ambiguous names)."));
else
player:(notify)(tostr("I don't understand that (\"", dobjstr, "\" is an ambiguous name)."));
endif
elseif (iobj == $ambiguous_match)
player:(notify)(tostr("I don't understand that (\"", iobjstr, "\" is an ambiguous name)."));
else
player:(notify)("I don't understand that.");
player:my_explain_syntax(caller, verb, args) || (caller:here_explain_syntax(caller, verb, args) || this:explain_syntax(caller, verb, args));
endif
.
#56:12
"task_info(task id)";
"Return info (the same info supplied by queued_tasks()) about a given task id, or E_INVARG if there's no such task queued.";
"WIZARDLY";
set_task_perms(caller_perms());
tasks = queued_tasks();
task_id = args[1];
for task in (tasks)
if (task[1] == task_id)
return task;
endif
endfor
return E_INVARG;
.
#56:13
if (caller_perms().wizard)
pass(@args);
this.lag_samples = {};
this.feature_task = "hey, neat, no feature verbs have been run yet!";
endif
.
#56:14
"Kills this task if the current lag is greater than args[1].  Args[2..n] will be passed to player:tell.";
cutoff = args[1];
if ($login:current_lag() > cutoff)
player:tell(@listdelete(args, 1));
kill_task(task_id());
endif
.
#56:15
":validate_feature(verb, args)";
"  (where `verb' and `args' are the arguments passed to :my_huh)";
"  returns true or false based on whether this is the same command typed by the user (comparing it against $command_utils.feature_task, set by $command_utils:do_huh).";
"  assumes that the :my_huh parsing has not suspended";
return {task_id(), @args, argstr, dobj, dobjstr, prepstr, iobj, iobjstr} == this.feature_task;
.
#56:16
"While input is being read() from a player, return 1. Otherwise return 0.";
{who} = args;
return `who.reading_input ! ANY => 0';
.
#57:0
if ((!player.wizard) || (player != this))
player:notify("Sorry.");
return;
endif
set_task_perms(player);
args = setremove(args, "to");
if ((length(args) != 2) || (!args[2]))
player:notify(tostr("Usage:  ", verb, " <object-or-property-or-verb> <owner>"));
return;
endif
what = args[1];
owner = $string_utils:match_player(args[2]);
bynumber = verb == "@chown#";
if ($command_utils:player_match_result(owner, args[2])[1])
elseif (spec = $code_utils:parse_verbref(what))
object = this:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
vname = spec[2];
if (bynumber)
vname = $code_utils:toint(vname);
if (vname == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || (vname > length(verbs(object))))
return player:notify("Verb number out of range.");
endif
endif
info = `verb_info(object, vname) ! ANY';
if (info == E_VERBNF)
player:notify("That object does not define that verb.");
elseif (typeof(info) == ERR)
player:notify(tostr(info));
else
try
result = set_verb_info(object, vname, listset(info, owner, 1));
player:notify("Verb owner set.");
except e (ANY)
player:notify(e[2]);
endtry
endif
endif
elseif (bynumber)
player:notify("@chown# can only be used with verbs.");
elseif (index(what, ".") && (spec = $code_utils:parse_propref(what)))
object = this:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
pname = spec[2];
e = $wiz_utils:set_property_owner(object, pname, owner);
if (e == E_NONE)
player:notify("+c Property owner set.  Did you really want to do that?");
else
player:notify(tostr(e && "Property owner set."));
endif
endif
else
object = this:my_match_object(what);
if (!$command_utils:object_match_failed(object, what))
player:notify(tostr($wiz_utils:set_owner(object, owner) && "Object ownership changed."));
endif
endif
.
#57:1
if (caller != this)
raise(E_PERM);
endif
set_task_perms(player);
if ((length(args) == 1) && (argstr[1] == "\""))
argstr = args[1];
endif
shout = $gender_utils:get_conj("shouts", player);
for person in (connected_players())
if (person != player)
person:notify(tostr(player.name, " ", shout, ", \"", argstr, "\""));
endif
endfor
player:notify(tostr("You shout, \"", argstr, "\""));
.
#57:2
"@grant <object> to <player>";
"@grants <object> to <player>   --- same as @grant but may suspend.";
"@transfer <expression> to <player> -- like 'grant', but evalutes a possible list of objects to transfer, and modifies quota.";
"Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).";
if ((!player.wizard) || (player != this))
player:notify("Sorry.");
return;
endif
set_task_perms(player);
if ((!iobjstr) || (!dobjstr))
return player:notify(tostr("Usage:  ", verb, " <object> to <player>"));
endif
if ($command_utils:player_match_failed(newowner = $string_utils:match_player(iobjstr), iobjstr))
"...newowner is bogus...";
return;
endif
if (verb == "@transfer")
objlist = player:eval_cmd_string(dobjstr, 0);
if (!objlist[1])
player:notify(tostr("Had trouble reading `", dobjstr, "': "));
player:notify_lines(@objlist[2]);
return;
elseif (typeof(objlist[2]) == OBJ)
objlist = objlist[2..2];
elseif (typeof(objlist[2]) != LIST)
player:notify(tostr("Value of `", dobjstr, "' is not an object or list:  ", toliteral(objlist[2])));
return;
else
objlist = objlist[2];
endif
elseif ($command_utils:object_match_failed(object = this:my_match_object(dobjstr), dobjstr))
"...object is bogus...";
return;
else
objlist = {object};
endif
"Used to check for quota of newowner, but doesn't anymore, cuz the quota check doesn't work";
suspendok = verb != "@grant";
player:tell("Transferring ", toliteral(objlist), " to ", $string_utils:nn(newowner));
for object in (objlist)
$command_utils:suspend_if_needed(0);
same = object.owner == newowner;
for vnum in [1..length(verbs(object))]
info = verb_info(object, vnum);
if (!((info[1] != object.owner) && (valid(info[1]) && is_player(info[1]))))
same = same && (info[1] == newowner);
set_verb_info(object, vnum, listset(info, newowner, 1));
endif
endfor
for prop in (properties(object))
if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))
suspend(0);
endif
info = property_info(object, prop);
if (!(index(info[2], "c") || (((info[1] != object.owner) && valid(info[1])) && is_player(info[1]))))
same = same && (info[1] == newowner);
$wiz_utils:set_property_owner(object, prop, newowner, suspendok);
endif
endfor
if (suspendok)
suspend(0);
endif
$wiz_utils:set_owner(object, newowner, suspendok);
if (same)
player:notify(tostr(newowner.name, " already owns everything ", newowner.ps, " is entitled to on ", object.name, "."));
else
player:notify(tostr("Ownership changed on ", $string_utils:nn(object), ", verb, properties and descendants' properties."));
endif
endfor
player:notify(tostr(verb, " complete."));
.
#57:3
set_task_perms(player);
dobj = $string_utils:match_player(dobjstr);
if (dobj == $nothing)
player:notify(tostr("Usage:  ", verb, " <playername>"));
elseif ($command_utils:player_match_result(dobj, dobjstr)[1])
elseif ($wiz_utils:check_prog_restricted(dobj))
return player:notify(tostr("Sorry, ", dobj.name, " is not allowed to be a programmer."));
elseif ((dobj.description == $player.description) && (!$command_utils:yes_or_no($string_utils:pronoun_sub("@Programmer %d despite %[dpp] lack of description?"))))
player:notify(tostr("Okay, leaving ", dobj.name, " !programmer."));
return;
elseif (result = $wiz_utils:set_programmer(dobj))
player:notify(tostr(dobj.name, " (", dobj, ") is now a programmer.  ", dobj.ppc, " quota is currently ", $quota_utils:get_quota(dobj), "."));
player:notify(tostr(dobj.name, " and the other wizards have been notified."));
if (msg = this:programmer_victim_msg())
dobj:notify(msg);
endif
if ($object_utils:isa(dobj.location, $room) && (msg = this:programmer_msg()))
dobj.location:announce_all_but({dobj}, msg);
endif
elseif (result == E_NONE)
player:notify(tostr(dobj.name, " (", dobj, ") is already a programmer..."));
else
player:notify(tostr(result));
endif
.
#57:4
{?core_variant_name = ""} = args;
if (!player.wizard)
player:notify("Nice try, but permission denied.");
return;
elseif (length(connected_players()) > 1)
player:notify("You need to @boot everybody else before I'll believe this isn't the real MOO.");
abort = 1;
elseif (`boot_player(open_network_connection("localhost", 666)) ! ANY' != E_PERM)
player:notify("Why are outbound connections enabled?  I bet this is the real MOO.");
abort = 1;
else
abort = (!$command_utils:yes_or_no("Continuing with this command will destroy all but the central core of the database.  Are you sure you want to do this?  ")) || (!$command_utils:yes_or_no("Really sure? "));
endif
if (abort)
player:notify("Core database extraction aborted.");
return;
endif
"----------------------------------------";
player:notify("Messing with server options...");
spi = {};
for p in ({"protect_recycle", "protect_set_property_info", "protect_add_property", "protect_chparent", "bg_ticks"})
spi = {@spi, {p, $server_options.(p)}};
$server_options.(p) = 0;
endfor
$server_options.bg_ticks = 1000000;
add_property($server_options, "bg_seconds", 7, {player, "r"});
`load_server_options() ! ANY';
add_property($server_options, "__mcd__savesopt", spi, {player, "r"});
"----------------------------------------";
player:notify("Killing all queued tasks ...");
for t in (queued_tasks())
kill_task(t[1]);
endfor
suspend(0);
"----------------------------------------";
player:notify(tostr("Identifying objects to be saved", @core_variant_name ? {" for core variant '", core_variant_name, "'"} | {}, " ..."));
"... TODO --- core variant name lookup?";
core_variant = {{"name", core_variant_name}};
{saved, saved_props, skipped_parents, proxy_original, proxy_incore, namespaces} = $core_object_info(core_variant, 1);
if (!(player in saved))
player:notify("Sorry, but this won't work unless you yourself are on the list of objects to be saved.");
player:notify("Core database extraction aborted.");
return;
endif
for ops in (saved_props)
{o, o_props} = ops;
for p in (o_props)
if (i = o.(p) in proxy_original)
o.(p) = proxy_incore[i];
endif
endfor
endfor
"... TODO --- why isn't this on #0:init_for_core ? --Rog";
$player_class = $mail_recipient_class;
"----------------------------------------";
player:notify("Stripping you of any personal verbs and/or properties ...");
for i in [1..length(verbs(player))]
delete_verb(player, 1);
endfor
for p in (properties(player))
delete_property(player, p);
endfor
chparent(player, $wiz);
for p in ($object_utils:all_properties(player))
clear_property(player, p);
endfor
player:set_name("Wizard");
player:set_aliases({"Wizard"});
player.description = "";
player.key = 0;
player.ownership_quota = 100;
player.password = 0;
player.last_password_time = 0;
$gender_utils:set(player, "neuter");
"----------------------------------------";
suspend(0);
owners_original = owners_incore = {};
for i in [1..length(proxy_original)]
o = proxy_original[i];
if (is_player(o) && (o != $no_one))
owners_original = {@owners_original, o};
owners_incore = {@owners_incore, proxy_incore[i]};
endif
endfor
for o in (saved)
if (is_player(o) && (o != $no_one))
owners_original = {@owners_original, o};
owners_incore = {@owners_incore, o};
endif
endfor
player:notify(tostr("Chowning every saved object, verb and property to one of ", $string_utils:nn(owners_incore), "..."));
for o in (saved)
$command_utils:suspend_if_needed(0, "... ", length(saved) - (o in saved), " to go");
if (i = o.owner in owners_original)
o.owner = owners_incore[i];
elseif (valid(o.owner) && o.owner.wizard)
o.owner = player;
else
o.owner = $hacker;
endif
old_verbs = {};
for j in [1..length(verbs(o))]
$command_utils:suspend_if_needed(0, "... ", length(saved) - (o in saved), " to go");
info = verb_info(o, j);
if (i = info[1] in owners_original)
info[1] = owners_incore[i];
elseif (valid(info[1]) && info[1].wizard)
info[1] = player;
else
info[1] = $hacker;
endif
set_verb_info(o, j, info);
if (index(info[3], "(old)"))
old_verbs = {j, @old_verbs};
endif
endfor
for vname in (old_verbs)
delete_verb(o, vname);
endfor
for p in ($object_utils:all_properties(o))
$command_utils:suspend_if_needed(0, "... ", length(saved) - (o in saved), " to go");
info = property_info(o, p);
if (i = info[1] in owners_original)
info[1] = owners_incore[i];
elseif (valid(info[1]) && info[1].wizard)
info[1] = player;
else
info[1] = $hacker;
endif
set_property_info(o, p, info);
endfor
endfor
"----------------------------------------";
player:notify("Removing all unsaved :recycle, :exitfunc, and :recycle verbs ...");
for o in [#0..max_object()]
$command_utils:suspend_if_needed(0, "... ", o);
if (valid(o) && (!(o in saved)))
for v in ({"recycle", "exitfunc", "recycle"})
while ($object_utils:defines_verb(o, v))
delete_verb(o, v);
endwhile
endfor
endif
endfor
"----------------------------------------";
player:notify("Recycling unsaved objects ...");
add_property(this, "__mcd__pos", toint(max_object()), {player, "r"});
add_property(this, "__mcd__save", {core_variant, saved, saved_props, skipped_parents, namespaces}, {player, "r"});
suspend(0);
try
this:mcd_2(core_variant, saved, saved_props, skipped_parents, namespaces);
finally
if ((!queued_tasks()) && `this.__mcd__save ! E_PROPNF => 0')
"...use raw notify since we have no idea what will be b0rken";
notify(player, "Core database extraction failed.");
endif
endtry
.
#57:5
if (!player.wizard)
player:notify("Sorry.");
return;
elseif ($code_utils:task_valid($wiz_utils.shutdown_task))
player:notify(tostr("Shutdown already in progress.  The MOO will be shut down in ", $time_utils:english_time($server["shutdown_time"] - time()), ", by ", $wiz_utils.shutdown_message));
return;
endif
if (s = match(argstr, "^in +%([0-9]+%)%( +%|$%)"))
bounds = s[3][1];
delay = toint(argstr[bounds[1]..bounds[2]]);
argstr = argstr[s[2] + 1..$];
else
delay = 2;
endif
if (!$command_utils:yes_or_no(tostr("Do you really want to shut down the server in ", delay, " minutes?")))
player:notify("Aborted.");
return;
endif
announce_times = {};
if (delay > 0)
while (delay > 0)
announce_times = {@announce_times, delay * 60};
delay = delay / 2;
endwhile
announce_times = {@announce_times, 30, 10};
$server["shutdown_time"] = time() + announce_times[1];
endif
$wiz_utils.shutdown_message = tostr(player.name, " (", player, "): ", argstr);
$wiz_utils.shutdown_task = task_id();
for i in [1..length(announce_times)]
base_msg = tostr("*** The server will be shut down by ", player.name, " (", player, ") in ", $time_utils:english_time(announce_times[i]), ":");
msg = {base_msg, @$generic_editor:fill_string("*** " + argstr, length(base_msg) - 4, "*** ")};
"...use raw notify() since :notify() verb could be broken...";
for p in (connected_players())
for line in (msg)
notify(p, line);
endfor
$command_utils:suspend_if_needed(0);
endfor
suspend(announce_times[i] - {@announce_times, 0}[i + 1]);
endfor
for p in (connected_players())
notify(p, tostr("*** Server shutdown by ", $wiz_utils.shutdown_message, " ***"));
boot_player(p);
endfor
suspend(0);
$wiz_utils.shutdown_task = E_NONE;
set_task_perms(player);
shutdown(argstr);
.
#57:6
set_task_perms(player);
dump_database();
player:notify("Dumping...");
.
#57:7
set_task_perms(player);
if (argstr[1] != ":")
argstr = ":" + argstr;
endif
player:notify(tostr("Searching for verbs that appear to call ", argstr, " ..."));
player:notify("");
$code_utils:find_verbs_containing(argstr + "(");
.
#57:8
if (!caller_perms().wizard)
return;
elseif (length(connected_players()) > 1)
return;
elseif (`boot_player(open_network_connection("localhost", 666)) ! ANY' != E_PERM)
return;
elseif (!("__mcd__pos" in properties(this)))
return;
endif
end = this.__mcd__pos;
{core_variant, saved, saved_props, skipped_parents, namespaces} = args;
player:notify(tostr("*** Recycling from #", end, " ..."));
suspend(0);
fork (0)
try
this:mcd_2(core_variant, saved, saved_props, skipped_parents, namespaces);
finally
if ((!queued_tasks()) && `this.__mcd__save ! E_PROPNF => 0')
"...use raw notify since we have no idea what will be b0rken";
notify(player, "Core database extraction failed.");
endif
endtry
endfork
for i in [0..end]
this.__mcd__pos = end - i;
o = toobj(end - i);
if ($command_utils:running_out_of_time())
return;
endif
if (valid(o) && (!(o in saved)))
for x in (o.contents)
move(x, #-1);
endfor
if (is_player(o))
"o.features = {}";
set_player_flag(o, 0);
endif
if (!(o in skipped_parents))
chparent(o, #-1);
endif
recycle(o);
endif
endfor
delete_property(this, "__mcd__pos");
spi = $server_options.__mcd__savesopt;
delete_property($server_options, "__mcd__savesopt");
delete_property($server_options, "bg_seconds");
for pv in (spi)
$server_options.(pv[1]) = pv[2];
endfor
load_server_options();
"----------------------------------------";
suspend(0);
player:notify("Killing queued tasks ...");
for t in (queued_tasks())
kill_task(t[1]);
endfor
"----------------------------------------";
player:notify("Compacting object numbers ...");
old_oids = new_oids = {player};
for o_ps in (saved_props)
$command_utils:suspend_if_needed(0);
{o, o_props} = o_ps;
"Oh geeze. 'o' could have already been renumbered!";
if (ind = o in old_oids)
o = new_oids[ind];
endif
for p in (o_props)
if ((p == "owner") || (p == "location"))
"...renumber() takes care of these";
elseif (i = (old = o.(p)) in old_oids)
o.(p) = new_oids[i];
elseif (valid(old))
new_oids[1..0] = {o.(p) = renumber(old)};
old_oids[1..0] = {old};
endif
endfor
endfor
for o in (saved)
if (valid(o) && (o != player))
renumber(o);
endif
endfor
player:notify("Compacting namespaces ...");
for ns in (namespaces)
{o, o_prop, o_map} = ns;
for value, key in (o_map)
if (index = value in old_oids)
o.(o_prop)[key] = new_oids[index];
elseif (valid(value))
new_oids[1..0] = {o.(o_prop)[key] = renumber(value)};
old_oids[1..0] = {value};
endif
endfor
endfor
reset_max_object();
"...rebuild saved list so that parents come before children...";
saved = {};
for o in [#0..max_object()]
os = {};
while (valid(o) && (!(o in saved)))
os = {o, @os};
o = parent(o);
endwhile
saved = {@saved, @os};
endfor
"----------------------------------------";
player:notify("Performing miscellaneous cleanups ...");
succeeded = 1;
for o in [#0..max_object()]
$command_utils:suspend_if_needed(0);
try
move(o, #-1);
except e (ANY)
player:notify(tostr("Couldn't move ", o, " => ", e[2]));
player:notify(toliteral(e[4]));
succeeded = 0;
endtry
endfor
for o in (saved)
$command_utils:suspend_if_needed(0);
if ($object_utils:has_callable_verb(o, "init_for_core"))
try
o:init_for_core(core_variant);
except e (ANY)
player:notify(tostr("Error from ", o, ":init_for_core => ", e[2]));
player:notify(toliteral(e[4]));
succeeded = 0;
endtry
endif
endfor
player:notify("Re-measuring everything ...");
for o in [#0..max_object()]
$command_utils:suspend_if_needed(0);
if (valid(o))
$byte_quota_utils:object_bytes(o);
endif
endfor
$wiz_utils:initialize_owned();
$byte_quota_utils:summarize_one_user(player);
delete_property(this, "__mcd__save");
player:notify("Core database extraction " + (succeeded ? "is complete." | "failed."));
if (succeeded)
boot_player(player);
shutdown();
endif
.
#57:9
"@toad[!][!] <player> [blacklist|redlist|graylist] [commentary]";
whostr = args[1];
comment = $string_utils:first_word(argstr)[2];
if (verb == "@toad!!")
listname = "redlist";
elseif (verb == "@toad!")
listname = "blacklist";
elseif ((ln = {@args, ""}[2]) && (index(listname = $login:listname(ln), ln) == 1))
"...first word of coment is one of the magic words...";
comment = $string_utils:first_word(comment)[2];
else
listname = "";
endif
if ((!player.wizard) || (player != this))
player:notify("Yeah, right... you wish.");
return;
elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))
return;
elseif (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))
player:notify(tostr("Must be a full name or an object number:  ", who.name, "(", who, ")"));
return;
elseif (who == player)
player:notify("If you want to toad yourself, you have to do it by hand.");
return;
endif
dobj = who;
if (msg = player:toad_victim_msg())
notify(who, msg);
endif
if ($wiz_utils:rename_all_instances(who, "disfunc", "toad_disfunc"))
player:notify(tostr(who, ":disfunc renamed."));
endif
if ($wiz_utils:rename_all_instances(who, "recycle", "toad_recycle"))
player:notify(tostr(who, ":recycle renamed."));
endif
"MOO-specific cleanup while still a player object.";
this:toad_cleanup(who);
e = $wiz_utils:unset_player(who, $hacker);
player:notify(e ? tostr(who.name, "(", who, ") is now a toad.") | tostr(e));
if (e && ($object_utils:isa(who.location, $room) && (msg = player:toad_msg())))
who.location:announce_all_but({who}, msg);
endif
if (listname && (!$login:(listname + "ed")(cname = $string_utils:connection_hostname(who.last_connect_place))))
$login:(listname + "_add")(cname);
player:notify(tostr("Site ", cname, " ", listname, "ed."));
else
cname = "";
endif
if (!comment)
player:notify("So why is this person being toaded?");
comment = $command_utils:read();
endif
$mail_agent:send_message(player, $toad_log, tostr("@toad ", who.name, " (", who, ")"), {$string_utils:from_list(who.all_connect_places, " "), @cname ? {$string_utils:capitalize(listname + "ed:  ") + cname} | {}, @comment ? {comment} | {}});
player:notify(tostr("Mail sent to ", $mail_agent:name($toad_log), "."));
`$local.waitlist:note_reapee(who, tostr("@toaded by ", player.name)) ! ANY';
.
#57:10
"@untoad <object> [as namespec]";
"Turns object into a player.  Anything that isn't a guest is chowned to itself.";
if (!player.wizard)
player:notify("Yeah, right... you wish.");
elseif (prepstr && (prepstr != "as"))
player:notify(tostr("Usage:  ", verb, " <object> [as name,alias,alias...]"));
elseif ($command_utils:object_match_failed(dobj, dobjstr))
elseif (prepstr && (!(e = $building_utils:set_names(dobj, iobjstr))))
player:notify(tostr("Initial rename failed:  ", e));
elseif (e = $wiz_utils:set_player(dobj, g = $object_utils:isa(dobj, $guest)))
player:notify(tostr(dobj.name, "(", dobj, ") is now a ", g ? "usable guest." | "player."));
elseif (e == E_INVARG)
player:notify(tostr(dobj.name, "(", dobj, ") is not of an appropriate player class."));
player:notify("@chparent it to $player or some descendant.");
elseif (e == E_NONE)
player:notify(tostr(dobj.name, "(", dobj, ") is already a player."));
elseif (e == E_NACC)
player:notify("Wait until $player_db is finished updating...");
elseif (e == E_RECMOVE)
player:notify(tostr("The name `", dobj.name, "' is currently unavailable."));
player:notify(tostr("Try again with   ", verb, " ", dobj, " as <newname>"));
else
player:notify(tostr(e));
endif
.
#57:11
"@quota <player> is [public] <number> [<reason>]";
"  changes a player's quota.  sends mail to the wizards.";
if (player != this)
return player:notify("Permission denied.");
endif
set_task_perms(player);
dobj = $string_utils:match_player(dobjstr);
if ($command_utils:player_match_result(dobj, dobjstr)[1])
return;
elseif (!valid(dobj))
player:notify("Set whose quota?");
return;
endif
if (iobjstr[1..min(7, $)] == "public ")
iobjstr[1..7] = "";
if ($object_utils:has_property($local, "public_quota_log"))
recipients = {$quota_log, $local.public_quota_log};
else
player:tell("No public quota log.");
return E_INVARG;
endif
else
recipients = {$quota_log};
endif
old = $quota_utils:get_quota(dobj);
qstr = iobjstr[1..(n = index(iobjstr + " ", " ")) - 1];
new = $code_utils:toint((qstr[1] == "+") ? qstr[2..$] | qstr);
reason = iobjstr[n + 1..$] || "(none)";
if (typeof(new) != INT)
player:notify(tostr("Set ", dobj.name, "'s quota to what?"));
return;
elseif (qstr[1] == "+")
new = old + new;
endif
result = $quota_utils:set_quota(dobj, new);
if (typeof(result) == ERR)
player:notify(tostr(result));
else
player:notify(tostr(dobj.name, "'s quota set to ", new, "."));
endif
$mail_agent:send_message(player, recipients, tostr("@quota ", dobj.name, " (", dobj, ") ", new, " (from ", old, ")"), tostr("Reason for quota ", ((new - old) < 0) ? "decrease: " | "increase: ", reason, index("?.!", reason[$]) ? "" | "."));
.
#57:12
set_task_perms(player);
"The time below is Oct. 1, 1990, roughly the birthdate of the LambdaMOO server.";
start = 654768000;
now = time();
day = (24 * 60) * 60;
week = 7 * day;
month = 30 * day;
days_objects = days_players = {0, 0, 0, 0, 0, 0, 0};
weeks_objects = weeks_players = {0, 0, 0, 0};
months_objects = months_players = {};
nonplayer_objects = invalid_objects = 0;
always_objects = always_players = 0;
never_objects = never_players = 0;
numo = 0;
if (argstr)
if (((!dobjstr) && (prepstr == "with")) && (index("objects", iobjstr) == 1))
with_objects = 1;
else
player:notify(tostr("Usage:  ", verb, " [with objects]"));
return;
endif
else
with_objects = 0;
players = players();
endif
for i in [1..with_objects ? toint(max_object()) + 1 | length(players)]
if (with_objects)
o = toobj(i - 1);
else
o = players[i];
endif
if ($command_utils:running_out_of_time())
player:notify(tostr("... ", o));
suspend(0);
endif
if (valid(o))
numo = numo + 1;
p = is_player(o) ? o | o.owner;
if (!valid(p))
invalid_objects = invalid_objects + 1;
elseif (!$object_utils:isa(p, $player))
nonplayer_objects = nonplayer_objects + 1;
else
seconds = now - p.last_connect_time;
days = seconds / day;
weeks = seconds / week;
months = seconds / month;
if (seconds < 0)
if (is_player(o))
always_players = always_players + 1;
else
always_objects = always_objects + 1;
endif
elseif (seconds > (now - start))
if (is_player(o))
never_players = never_players + 1;
else
never_objects = never_objects + 1;
endif
elseif (months > 0)
while (months > length(months_players))
months_players = {@months_players, 0};
months_objects = {@months_objects, 0};
endwhile
if (is_player(o))
months_players[months] = months_players[months] + 1;
endif
months_objects[months] = months_objects[months] + 1;
elseif (weeks > 0)
if (is_player(o))
weeks_players[weeks] = weeks_players[weeks] + 1;
endif
weeks_objects[weeks] = weeks_objects[weeks] + 1;
else
if (is_player(o))
days_players[days + 1] = days_players[days + 1] + 1;
endif
days_objects[days + 1] = days_objects[days + 1] + 1;
endif
endif
endif
endfor
player:notify("");
player:notify(tostr("Last connected"));
player:notify(tostr("at least this     Num.     Cumul.   Cumul. %", with_objects ? "     Num.     Cumul.   Cumul. %" | ""));
player:notify(tostr("long ago        players   players   players ", with_objects ? "   objects   objects   objects" | ""));
player:notify(tostr("---------------------------------------------", with_objects ? "--------------------------------" | ""));
su = $string_utils;
col1 = 14;
col2 = 7;
col3 = 10;
col4 = 9;
col5 = 11;
col6 = 11;
col7 = 10;
nump = length(players());
totalp = totalo = 0;
for x in ({{days_players, days_objects, "day", 1}, {weeks_players, weeks_objects, "week", 0}, {months_players, months_objects, "month", 0}})
pcounts = x[1];
ocounts = x[2];
unit = x[3];
offset = x[4];
for i in [1..length(pcounts)]
$command_utils:suspend_if_needed(0);
j = i - offset;
player:notify(tostr(su:left(tostr(j, " ", unit, (j == 1) ? ":" | "s:"), col1), su:right(pcounts[i], col2), su:right(totalp = totalp + pcounts[i], col3), su:right((totalp * 100) / nump, col4), "%", with_objects ? tostr(su:right(ocounts[i], col5), su:right(totalo = totalo + ocounts[i], col6), su:right((totalo * 100) / numo, col7), "%") | ""));
endfor
player:notify("");
endfor
player:notify(tostr(su:left("Never:", col1), su:right(never_players, col2), su:right(totalp = totalp + never_players, col3), su:right((totalp * 100) / nump, col4), "%", with_objects ? tostr(su:right(never_objects, col5), su:right(totalo = totalo + never_objects, col6), su:right((totalo * 100) / numo, col7), "%") | ""));
player:notify(tostr(su:left("Always:", col1), su:right(always_players, col2), su:right(totalp = totalp + always_players, col3), su:right((totalp * 100) / nump, col4), "%", with_objects ? tostr(su:right(always_objects, col5), su:right(totalo = totalo + always_objects, col6), su:right((totalo * 100) / numo, col7), "%") | ""));
with_objects && player:notify(tostr(su:left("Non-player owner:", (((col1 + col2) + col3) + col4) + 1), su:right(nonplayer_objects, col5), su:right(totalo = totalo + nonplayer_objects, col6), su:right((totalo * 100) / numo, col7), "%"));
with_objects && player:notify(tostr(su:left("Invalid owner:", (((col1 + col2) + col3) + col4) + 1), su:right(invalid_objects, col5), su:right(totalo = totalo + invalid_objects, col6), su:right((totalo * 100) / numo, col7), "%"));
player:notify("");
.
#57:13
"Auxiliary verb for parsing @kill soon [#-of-seconds] [player | everyone]";
"Args[1] is either # of seconds or player/everyone.";
"Args[2], if it exists, is player/everyone, and forces args[1] to have been # of seconds.";
"Return value: {# of seconds [default 60] , 1 for all, object for player.}";
set_task_perms(caller_perms());
nargs = length(args);
soon = toint(args[1]);
if (nargs > 1)
everyone = args[2];
elseif (soon <= 0)
everyone = args[1];
else
everyone = 0;
endif
if (everyone == "everyone")
everyone = 1;
elseif (typeof(everyone) == STR)
result = $string_utils:match_player(everyone);
if ($command_utils:player_match_failed(result, everyone))
player:notify(tostr("Usage:  ", callers()[1][2], " soon [number of seconds] [\"everyone\" | player name]"));
return {-1, -1};
else
return {soon ? soon | 60, result};
endif
endif
return {soon ? soon | 60, everyone ? everyone | player};
.
#57:14
set_task_perms(player);
if (!args)
player:notify(tostr("Usage:  ", verb, " <pattern>"));
return;
endif
pattern = argstr;
regexp = verb == "@egrepcore";
player:notify(tostr("Searching for core verbs ", regexp ? "matching the regular expression " | "containing the string ", toliteral(pattern), " ..."));
player:notify("");
$code_utils:(regexp ? "find_verbs_matching" | "find_verbs_containing")(pattern, $core_objects());
.
#57:15
"@net-who prints all connected users and hosts.";
"@net-who player player player prints specified users and current or most recent connected host.";
"@net-who from hoststring prints all players who have connected from that host or host substring.  Substring can include *'s, e.g. @net-who from *.foo.edu.";
set_task_perms(player);
su = $string_utils;
if ((prepstr == "from") && dobjstr)
player:notify(tostr("Usage:  ", verb, " from <host string>"));
elseif (((prepstr != "from") || dobjstr) || (!iobjstr))
"Not parsing 'from' here...  Instead printing connected/recent users.";
if (!(pstrs = args))
unsorted = connected_players();
else
unsorted = listdelete($command_utils:player_match_result(su:match_player(pstrs), pstrs), 1);
endif
if (!unsorted)
return;
endif
$wiz_utils:show_netwho_listing(player, unsorted);
else
$wiz_utils:show_netwho_from_listing(player, iobjstr);
endif
.
#57:16
"Creates a player.";
"Syntax:  @make-player name email-address comments....";
"Generates a random password for the player.";
if ((!player.wizard) || callers())
return E_PERM;
elseif (length(args) < 2)
player:tell("Syntax:  @make-player name email-address comments....");
return;
elseif (args[2] == "for")
"common mistake: @make-player <name> for <email-address> ...";
args = listdelete(args, 2);
endif
return $wiz_utils:do_make_player(@args);
.
#57:17
if (!player.wizard)
player:notify("Sorry.");
elseif (!$code_utils:task_valid($wiz_utils.shutdown_task))
player:notify("No server shutdown in progress.");
$wiz_utils.shutdown_task = E_NONE;
else
"... Reset time so that $login:check_for_shutdown shuts up...";
kill_task($wiz_utils.shutdown_task);
$wiz_utils.shutdown_task = E_NONE;
$server["shutdown_time"] = time() - 1;
for p in (connected_players())
notify(p, tostr("*** Server shutdown ABORTED by ", player.name, " (", player, ")", argstr && (":  " + argstr), " ***"));
endfor
endif
.
#57:18
"This is the canonical doing-something-to-somebody message.";
"The corresponding property can either be";
"   string             msg for all occasions";
"   list of 2 strings  {we-are-there-msg,we-are-elsewhere-msg}";
m = this.(verb);
if (typeof(m) != LIST)
return $string_utils:pronoun_sub(m);
elseif ((this.location == dobj.location) || (length(m) < 2))
return $string_utils:pronoun_sub(m[1]);
else
return $string_utils:pronoun_sub(m[2]);
endif
.
#57:19
set_task_perms((caller in {this, $generic_editor, $verb_editor, $mail_editor, $note_editor}) ? this.owner | caller_perms());
return `move(this, args[1]) ! ANY';
.
#57:20
"@newt <player> [commentary]";
"turns a player into a newt.  It can get better...";
"adds player to $login.newted, they will not be allowed to log in.";
"Sends mail to $newt_log giving .all_connect_places and commentary.";
whostr = args[1];
comment = $string_utils:first_word(argstr)[2];
if (!player.wizard)
player:notify("Yeah, right.");
elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))
return;
elseif (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))
player:notify(tostr("Must be a full name or an object number:  ", who.name, "(", who, ")"));
return;
elseif (who == player)
player:notify("If you want to newt yourself, you have to do it by hand.");
return;
elseif (who in $login.newted)
player:notify(tostr(who.name, " appears to already be a newt."));
return;
else
$wiz_utils:newt_player(who, comment);
endif
.
#57:21
"@denewt <player> [commentary]";
"Remove the player from $Login.newted";
"Sends mail to $newt_log with commentary.";
whostr = args[1];
comment = $string_utils:first_word(argstr)[2];
if (!player.wizard)
player:notify("Yeah, right.");
elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))
return;
else
"Should parse email address and register user in some clever way.  Ick.";
if (!(who in $login.newted))
player:notify(tostr(who.name, " does not appear to be a newt."));
else
$login.newted = setremove($login.newted, who);
if (entry = $list_utils:assoc(who, $login.temporary_newts))
$login.temporary_newts = setremove($login.temporary_newts, entry);
endif
player:notify(tostr(who.name, " (", who, ") got better."));
$mail_agent:send_message(player, $newt_log, tostr("@denewt ", who.name, " (", who, ")"), comment ? {comment} | {});
endif
endif
.
#57:22
"Registers a player.";
"Syntax:  @register name email-address [additional commentary]";
"Email-address is stored in $registration_db and on the player object.";
if (!player.wizard)
return player:tell(E_PERM);
endif
$wiz_utils:do_register(@args);
.
#57:23
"@newpassword player is [string]";
"Set's a player's password; omit string to have one randomly generated.";
"Offer to email the password.";
if (!player.wizard)
return E_PERM;
elseif ($command_utils:player_match_failed(dobj = $string_utils:match_player(dobjstr), dobjstr))
return;
elseif (!(dobjstr in {@dobj.aliases, tostr(dobj)}))
player:notify(tostr("Must be a full name or an object number: ", dobj.name, " (", dobj, ")"));
else
$wiz_utils:do_new_password(dobj, iobjstr);
endif
.
#57:24
"@log [<string>]    enters a comment in the server log.";
"If no string is given, you are prompted to enter one or more lines for an extended comment.";
set_task_perms(player);
whostr = tostr("from ", player.name, " (", player, ")");
if ((!player.wizard) || (player != caller))
player:notify("Yeah, right.");
elseif (argstr)
server_log(tostr("COMMENT: [", whostr, "]  ", argstr));
player:notify("One-line comment logged.");
elseif (lines = $command_utils:read_lines())
server_log(tostr("COMMENT: [", whostr, "]"));
for l in (lines)
server_log(l);
endfor
server_log(tostr("END_COMMENT."));
player:notify(tostr(length(lines), " lines logged as extended comment."));
endif
.
#57:25
set_task_perms(player);
n = (dobjstr == "all") ? 0 | $code_utils:toint(dobjstr || "20");
if (caller != this)
player:notify("You lose.");
elseif ((n == E_TYPE) && (index("now", dobjstr) != 1))
player:notify(tostr("Usage:  ", verb, " <number>  (where <number> indicates how many entries to look at in the guest log)"));
player:notify(tostr("Usage:  ", verb, " now (to see information about currently connected guests only)"));
elseif ((!dobjstr) || (index("now", dobjstr) != 1))
$guest_log:last(n);
else
"*way* too much copied code in here from @who...  Sorry.  --yduJ";
su = $string_utils;
conn = connected_players();
unsorted = {};
for g in ($object_utils:leaves($guest))
if (g in conn)
unsorted = {@unsorted, g};
endif
endfor
if (!unsorted)
player:tell("No guests found.");
return;
endif
footnotes = {};
alist = {};
nwidth = length("Player name");
for u in (unsorted)
pref = u.programmer ? "% " | "  ";
u.programmer && (footnotes = setadd(footnotes, "prog"));
u3 = {tostr(pref, u.name, " (", u, ")"), su:from_seconds(connected_seconds(u)), su:from_seconds(idle_seconds(u)), where = $string_utils:connection_hostname(u)};
nwidth = max(length(u3[1]), nwidth);
if ($login:blacklisted(where))
where = "(*) " + where;
footnotes = setadd(footnotes, "black");
elseif ($login:graylisted(where))
where = "(+) " + where;
footnotes = setadd(footnotes, "gray");
endif
alist = {@alist, u3};
$command_utils:suspend_if_needed(0);
endfor
alist = $list_utils:sort_alist_suspended(0, alist, 3);
$command_utils:suspend_if_needed(0);
headers = {"Player name", "Connected", "Idle Time", "From Where"};
time_width = length("59 minutes") + 2;
before = {0, w1 = nwidth + 3, w2 = w1 + time_width, w3 = w2 + time_width};
tell1 = "  " + headers[1];
tell2 = "  " + su:space(headers[1], "-");
for j in [2..4]
tell1 = su:left(tell1, before[j]) + headers[j];
tell2 = su:left(tell2, before[j]) + su:space(headers[j], "-");
endfor
player:notify(tell1);
player:notify(tell2);
active = 0;
for a in (alist)
$command_utils:suspend_if_needed(0);
tell1 = a[1];
for j in [2..4]
tell1 = su:left(tell1, before[j]) + tostr(a[j]);
endfor
player:notify(tell1[1..min($, 79)]);
endfor
if (footnotes)
player:notify("");
if ("prog" in footnotes)
player:notify(" %  == programmer.");
endif
if ("black" in footnotes)
player:notify("(*) == blacklisted site.");
endif
if ("gray" in footnotes)
player:notify("(+) == graylisted site.");
endif
endif
player:tell("@guests display complete.");
endif
.
#57:26
if (caller != this)
set_task_perms(valid(caller_perms()) ? caller_perms() | player);
endif
use = this.mail_identity;
if (valid(use) && (use != this))
return use:(verb)(@args);
else
return pass(@args);
endif
.
#57:27
"@[un]blacklist [<site or subnet>  [for <duration>] [commentary]]";
"@[un]graylist  [<site or subnet>  [for <duration>] [commentary]]";
"@[un]redlist   [<site or subnet>  [for <duration>] [commentary]]";
"@[un]spooflist [<site of subnet>  [for <duration>] [commentary]]";
"The `for <duration>' is for temporary colorlisting a site only. The duration should be in english time units:  for 1 hour, for 1 day 2 hours 15 minutes, etc. The commentary should be after all durations. Note, if you are -not- using a duration, do not start your commentary with the word `for'.";
set_task_perms(player);
if ((player != this) || (!player.wizard))
player:notify("Ummm.  no.");
return;
endif
undo = verb[2..3] == "un";
which = $login:listname(verb[undo ? 4 | 2]);
downgrade = {"", "graylist", "blacklist"}[1 + index("br", which[1])];
if (!(fw = $string_utils:first_word(argstr)))
"... Just print the list...";
this:display_list(which);
return;
endif
target = fw[1];
if (fw[2] && (parse = this:parse_templist_duration(fw[2]))[1])
if ((typeof(parse[3]) == ERR) || (!parse[3]))
player:notify(tostr("Could not parse the duration for @", which, "ing site \"", target, "\""));
return;
endif
start = parse[2];
duration = parse[3];
comment = parse[4] ? {parse[4]} | {};
comment = {tostr("for ", $time_utils:english_time(duration)), @comment};
elseif (fw[2])
comment = {fw[2]};
else
"Get the right vars set up as though parse had been called";
parse = {0, ""};
comment = {};
endif
player:tell("comment is currently ", toliteral(comment));
if (is_literal = $site_db:domain_literal(target))
if (target[$] == ".")
target = target[1..$ - 1];
endif
fullname = "subnet " + target;
else
if (target[1] == ".")
target[1..1] = "";
endif
fullname = ("domain `" + target) + "'";
endif
entrylist = $login.(which)[1 + (!is_literal)];
if ((!undo) && (target in entrylist))
player:notify(tostr(fullname, " is already ", which, "ed."));
return;
endif
entrylist = setremove(entrylist, target);
if (!(result = this:check_site_entries(undo, which, target, is_literal, entrylist))[1])
return;
endif
rm = result[2];
namelist = $string_utils:english_list(rm);
downgraded = {};
if (rm)
ntries = (length(rm) == 1) ? "ntry" | "ntries";
if ($command_utils:yes_or_no(tostr("Remove e", ntries, " for ", namelist, "?")))
dg = undo && (downgrade && $command_utils:yes_or_no(downgrade + " them?"));
for s in (rm)
$login:(which + "_remove")(s);
dg && ($login:(downgrade + "_add")(s) && (downgraded = {@downgraded, s}));
endfor
player:notify(tostr("E", ntries, " removed", @dg ? {" and ", downgrade, "ed."} | {"."}));
else
player:notify(tostr(namelist, " will continue to be ", which, "ed."));
rm = {};
endif
endif
if (downgraded)
comment[1..0] = {tostr(downgrade, "ed ", $string_utils:english_list(downgraded), ".")};
endif
tempentrylist = $login.("temporary_" + which)[1 + (!is_literal)];
if ((!undo) && (target in $list_utils:slice(tempentrylist)))
player:notify(tostr(fullname, " is already temporarily ", which, "ed."));
return;
endif
if (en = $list_utils:assoc(target, tempentrylist))
tempentrylist = setremove(tempentrylist, en);
endif
if (!(result = this:check_site_entries(undo, which, target, is_literal, $list_utils:slice(tempentrylist)))[1])
return;
endif
rmtemp = result[2];
tempnamelist = $string_utils:english_list(rmtemp);
tempdowngraded = {};
if (rmtemp)
ntries = (length(rmtemp) == 1) ? "ntry" | "ntries";
if ($command_utils:yes_or_no(tostr("Remove e", ntries, " for ", tempnamelist, "?")))
dg = undo && (downgrade && $command_utils:yes_or_no(downgrade + " them?"));
for s in (rmtemp)
old = $list_utils:assoc(s, tempentrylist);
$login:(which + "_remove_temp")(s);
dg && ($login:(downgrade + "_add_temp")(s, old[2], old[3]) && (tempdowngraded = {@tempdowngraded, s}));
endfor
player:notify(tostr("E", ntries, " removed", @dg ? {" and ", downgrade, "ed with durations transferred."} | {"."}));
else
player:notify(tostr(tempnamelist, " will continue to be temporarily ", which, "ed."));
rmtemp = {};
endif
endif
if (tempdowngraded)
comment[1..0] = {tostr(downgrade, "ed ", $string_utils:english_list(tempdowngraded), ".")};
endif
if (!undo)
if (parse[1])
$login:(which + "_add_temp")(target, start, duration);
player:notify(tostr(fullname, " ", which, "ed for ", $time_utils:english_time(duration)));
else
$login:(which + "_add")(target);
player:notify(tostr(fullname, " ", which, "ed."));
endif
if (rm)
comment[1..0] = {tostr("Subsumes ", which, "ing for ", namelist, ".")};
endif
if (rmtemp)
comment[1..0] = {tostr("Subsumes temporary ", which, "ing for ", tempnamelist, ".")};
endif
elseif ($login:(which + "_remove")(target))
player:notify(tostr(fullname, " un", which, "ed."));
if (!downgrade)
elseif ($command_utils:yes_or_no(downgrade + " it?"))
$login:(downgrade + "_add")(target) && (downgraded = {target, @downgraded});
player:notify(tostr(fullname, " ", downgrade, "ed."));
else
player:notify(tostr(fullname, " not ", downgrade, "ed."));
endif
if (downgraded)
player:tell("Comment currently: ", toliteral(comment), " ; downgrade = ", toliteral(downgrade), " ; downgraded = ", toliteral(downgraded));
comment[1..0] = {tostr(downgrade, "ed ", $string_utils:english_list(downgraded), ".")};
endif
if (rm)
comment[1..0] = {tostr("Also removed ", namelist, ".")};
endif
elseif ((old = $list_utils:assoc(target, $login.("temporary_" + which)[1 + (!is_literal)])) && $login:(which + "_remove_temp")(target))
player:notify(tostr(fullname, " un", which, "ed."));
if (!downgrade)
elseif ($command_utils:yes_or_no(downgrade + " it?"))
$login:(downgrade + "_add_temp")(target, old[2], old[3]) && (tempdowngraded = {target, @tempdowngraded});
player:notify(tostr(fullname, " ", downgrade, "ed, currently for ", $time_utils:english_time(old[3]), " from ", $time_utils:time_sub("$1/$3", old[2])));
else
player:notify(tostr(fullname, " not ", downgrade, "ed."));
endif
if (tempdowngraded)
comment[1..0] = {tostr(downgrade, "ed ", $string_utils:english_list(tempdowngraded), "with durations transferred.")};
endif
if (rmtemp)
comment[1..0] = {tostr("Also removed ", tempnamelist, ".")};
endif
elseif (rm || rmtemp)
player:notify(tostr(fullname, " itself was never actually ", which, "ed."));
comment[1..0] = {tostr("Removed ", namelist, " from regular and ", tempnamelist, " from temporary.")};
else
player:notify(tostr(fullname, " was not ", which, "ed before."));
return;
endif
subject = tostr(undo ? "@un" | "@", which, " ", fullname);
$mail_agent:send_message(player, $site_log, subject, comment);
"...";
"... make sure we haven't screwed ourselves...";
uhoh = {};
for site in (player.all_connect_places)
if (index(site, target) && $login:(which + "ed")(site))
uhoh = {@uhoh, site};
endif
endfor
if (uhoh)
player:notify(tostr("WARNING:  ", $string_utils:english_list(uhoh), " are now ", which, "ed!"));
endif
.
#57:28
"Usage:  @corify <object> as <propname>";
"Adds <object> to the core, as $<propname>";
"Reminds the wizard to write an :init_for_core verb, if there isn't one already.";
if (!player.wizard)
player:tell("Sorry, the core is wizardly territory.");
return;
endif
if (dobj == $failed_match)
dobj = player:my_match_object(dobjstr);
endif
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
if (!iobjstr)
player:tell("Usage:  @corify <object> as <propname>");
return;
elseif (iobjstr[1] == "$")
iobjstr = iobjstr[2..$];
endif
try
add_property(#0, iobjstr, dobj, {player, "r"});
except e (ANY)
return player:tell(e[1], ":", e[2]);
endtry
if (!("init_for_core" in verbs(dobj)))
player:tell(dobj:titlec(), " has no :init_for_core verb.  Strongly consider adding one before doing anything else.");
else
player:tell("Corified ", $string_utils:nn(dobj), " as $", iobjstr, ".");
endif
.
#57:29
"Usage:  @make-guest <guestname>";
"Creates a player called <guestname>_Guest owned by $hacker and a child of $guest. Or, if $local.guest exists, make a child of that, assuming that all other guests are children of it too.";
if (!player.wizard)
player:tell("If you think this MOO needs more guests, you should contact a wizard.");
return E_PERM;
endif
if (length(args) != 1)
player:tell("Usage: ", verb, " <guest name>");
return;
endif
guest_parent = (($object_utils:has_property($local, "guest") && valid($local.guest)) && $object_utils:isa($local.guest, $guest)) ? $local.guest | $guest;
i = length(children(guest_parent));
while (!$player_db:available(guestnum = tostr("Guest", i = i + 1)))
endwhile
guestname = args[1] + "_Guest";
guestaliases = {guestname, adj = args[1], guestnum};
if (!player.wizard)
return;
elseif ($player_db.frozen)
player:tell("Sorry, the player db is frozen, so no players can be made right now.  Please try again in a few minutes.");
return;
elseif (!$player_db:available(guestname))
player:tell("\"", guestname, "\" is not an available name.");
return;
elseif (!$player_db:available(adj))
player:Tell("\"", adj, "\" is not an available name.");
return;
else
new = $quota_utils:bi_create(guest_parent, $hacker);
new:set_name(guestname);
new:set_aliases(guestaliases);
if (!(e = $wiz_utils:set_player(new, 1)))
player:Tell("Unable to make ", new.name, " (", new, ") a player.");
player:Tell(tostr(e));
else
player:Tell("Guest: ", new.name, " (", new, ") made.");
new.default_description = {"By definition, guests appear nondescript."};
new.description = new.default_description;
new.last_connect_time = $maxint;
new.last_disconnect_time = time();
new.password = 0;
new.size_quota = new.size_quota;
new:set_gender(new.default_gender);
move(new, $player_start);
player:tell("Now don't forget to @describe ", new, " as something.");
endif
endif
.
#57:30
if (!player.wizard)
return player:tell("Permission denied.");
elseif (!valid(who = $string_utils:match_player(dobjstr)))
return $command_utils:player_match_failed(who, dobjstr);
elseif (((dobjstr != who.name) && (!(dobjstr in who.aliases))) && (dobjstr != tostr(who)))
return player:tell(tostr("Must be a full name or an object number:  ", who.name, "(", who, ")"));
elseif (who == player)
player:notify("If you want to newt yourself, you have to do it by hand.");
return;
elseif (!(howlong = $time_utils:parse_english_time_interval(iobjstr)))
return player:tell("Can't parse time: ", howlong);
else
if (who in $login.newted)
player:notify(tostr(who.name, " appears to already be a newt."));
else
$wiz_utils:newt_player(who, "", ("For " + iobjstr) + ".  ");
endif
if (index = $list_utils:iassoc(who, $login.temporary_newts))
$login.temporary_newts[index][2] = time();
$login.temporary_newts[index][3] = howlong;
else
$login.temporary_newts = {@$login.temporary_newts, {who, time(), howlong}};
endif
player:tell(who.name, " (", who, ") will be a newt until ", ctime(time() + howlong));
endif
.
#57:31
"@deprogrammer victim [for <duration>] [reason]";
"";
"Removes the prog-bit from victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. He will be automatically removed the first time he asks for a progbit after the duration expires.  Either with or without the duration you can specify a reason, or you will be prompted for one. However, if you don't have a duration, don't start the reason with the word `For'.";
set_task_perms(player);
if ((player != this) || (!player.wizard))
player:notify("No go.");
return;
endif
if (!args)
player:notify(tostr("Usage:  ", verb, " <playername> [for <duration>] [reason]"));
endif
fw = $string_utils:first_word(argstr);
if (fw[2] && (parse = this:parse_templist_duration(fw[2]))[1])
if ((typeof(parse[3]) == ERR) || (!parse[3]))
player:notify(tostr("Could not parse the duration for restricting programming for ", fw[1], "."));
return;
endif
start = parse[2];
duration = parse[3];
reason = parse[4] ? {parse[4]} | {};
else
start = duration = 0;
reason = fw[2] ? {fw[2]} | {};
endif
if (!reason)
reason = {$command_utils:read("reason for resetting programmer flag")};
endif
if (duration)
reason = {tostr("for ", $time_utils:english_time(duration)), @reason};
endif
if ($command_utils:player_match_failed(victim = $string_utils:match_player(fw[1]), fw[1]))
"...done...";
elseif (result = $wiz_utils:unset_programmer(victim, reason, @start ? {start, duration} | {}))
player:notify(tostr(victim.name, " (", victim, ") is no longer a programmer.", duration ? tostr("  This restriction will be lifted in ", $string_utils:from_seconds(duration), ".") | ""));
elseif (result == E_NONE)
player:notify(tostr(victim.name, " (", victim, ") was already a nonprogrammer..."));
else
player:notify(tostr(result));
endif
.
#57:32
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
endif
which = args[1];
slist = {};
if (s = $login.(which)[1])
slist = {@slist, "--- Subnets ---", @s};
endif
if (s = $login.(which)[2])
slist = {@slist, "--- Domains ---", @s};
endif
if (s = $login.("temporary_" + which)[1])
slist = {@slist, "--- Temporary Subnets ---"};
for d in (s)
slist = {@slist, tostr(d[1], " until ", $time_utils:time_sub("$1/$3 $H:$M", d[2] + d[3]))};
$command_utils:suspend_if_needed(2);
endfor
endif
if (s = $login.("temporary_" + which)[2])
slist = {@slist, "--- Temporary Domains ---"};
for d in (s)
slist = {@slist, tostr(d[1], " until ", $time_utils:time_sub("$1/$3 $H:$M", d[2] + d[3]))};
$command_utils:suspend_if_needed(2);
endfor
endif
if (slist)
player:notify_lines($string_utils:columnize(slist, 2));
else
player:notify(tostr("The ", which, " is empty."));
endif
.
#57:33
"parses out the time interval at the beginning of the args[1], assumes rest is commentary.";
if ((fw = $string_utils:first_word(args[1]))[1] == "for")
words = $string_utils:words(fw[2]);
try_ = {};
ind = cont = 1;
while (cont)
word = words[ind];
cont = ind;
if (toint(word))
try_ = {@try_, word};
ind = ind + 1;
else
for set in ($time_utils.time_units)
if (word in set)
try_ = {@try_, word};
ind = ind + 1;
endif
endfor
endif
if ((cont == ind) || (ind > length(words)))
cont = 0;
endif
endwhile
dur = $time_utils:parse_english_time_interval(@try_);
rest = $string_utils:from_list(words[ind..$], " ");
return {1, time(), dur, rest};
else
return {0, argstr};
endif
.
#57:34
"Called by @[un]<color>list to check existence of the target site.";
"=> {done okay, LIST of sites to remove}";
if (caller != this)
return E_PERM;
endif
{undo, which, target, is_literal, entrylist} = args;
rm = {};
confirm = 0;
if (is_literal)
for s in (entrylist)
if ((i = index(s, target + ".")) == 1)
"... target is a prefix of s, s should probably go...";
rm = {@rm, s};
elseif (index(target + ".", s + ".") != 1)
"... s is not a prefix of target...";
elseif (undo)
player:notify(tostr("You will need to un", which, " subnet ", s, " as well."));
elseif (confirm)
player:notify(tostr("...Subnet ", s, " already ", which, "ed..."));
else
player:notify(tostr("Subnet ", s, " already ", which, "ed."));
if (!(confirm = $command_utils:yes_or_no(tostr(which, " ", target, " anyway?"))))
return {0, {}};
endif
endif
endfor
else
for s in (entrylist)
if ((i = rindex(s, "." + target)) && (i == (length(s) - length(target))))
"... target is a suffix of s, s should probably go...";
rm = {@rm, s};
elseif ((!(i = rindex("." + target, "." + s))) || (i < ((length(target) - length(s)) + 1)))
"... s is not a suffix of target...";
elseif (undo)
player:notify(tostr("You will need to un", which, " domain `", s, "' as well."));
elseif (confirm)
player:notify(tostr("...Domain `", s, "' already ", which, "ed..."));
else
player:notify(tostr("Domain `", s, "' already ", which, "ed."));
if (!(confirm = $command_utils:yes_or_no(tostr(which, " ", target, " anyway?"))))
return {0, {}};
endif
endif
endfor
endif
return {1, rm};
.
#57:35
"Syntax:  @lock-login <message>";
"         @lock-login! <message>";
"         @unlock-login";
"";
"The @lock-login calls prevent all non-wizard users from logging in, displaying <message> to them when they try.  (The second syntax, with @lock-login!, additionally boots any nonwizards who are already connected.)  @unlock-login turns this off.";
if (caller != this)
raise(E_PERM);
elseif (verb[2] == "u")
$login.no_connect_message = 0;
player:notify("Login restrictions removed.");
elseif (!argstr)
player:notify("You must provide some message to display to users who attempt to login:  @lock-login <message>");
else
$login.no_connect_message = argstr;
player:notify(tostr("Logins are now blocked for non-wizard players.  Message displayed when attempted:  ", $login.no_connect_message));
if (verb == "@lock-login!")
wizards = $wiz_utils:all_wizards_unadvertised();
for x in (connected_players())
if (!(x in wizards))
boot_player(x);
endif
endfor
player:notify("All nonwizards have been booted.");
endif
endif
.
#57:36
"...was on $player, now archived here for posterity...";
"Runs the old->new format conversion on every message in this.messages.";
" => 1 if successful";
" => 0 if anything toward happened during a suspension";
"      (e.g., new message received, someone deleted stuff) ";
"      in which case this.messages is left as if this routine were never run.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
msgs = {};
i = 1;
for m in (oldmsgs = this.messages)
msgs = {@msgs, {m[1], $mail_agent:__convert_new(@m[2])}};
if ($command_utils:running_out_of_time())
player:notify(tostr("...", i, " ", this));
suspend(0);
if (oldmsgs != this.messages)
return 0;
endif
endif
i = i + 1;
endfor
this.messages = msgs;
return 1;
.
#57:37
if ((!player.wizard) || (caller != this))
raise(E_PERM);
endif
"Noop. Placeholder verb for MOO-specific cleanups.";
.
#57:38
if (!player.wizard)
return E_PERM;
endif
set_task_perms(player);
player:tell("What string are you replacing?");
old = $command_utils:read();
if (old == "")
return player:tell("You can't replace an empty string.");
endif
player:tell("What string are you replacing it with?");
new = $command_utils:read();
if (new == "")
return player:tell("You can't replace it with an empty string.");
endif
if ($command_utils:yes_or_no(tostr("You are about to replace ", old, " with ", new, " in all verbs. Are you sure you want to do this? Be very sure.")) == 1)
player:tell("Working...");
total = 0;
for o in [#0..max_object()]
yin();
if (!valid(o))
continue;
endif
verbs = verbs(o);
if (verbs == {})
continue;
endif
for v in (verbs)
code = verb_code(o, v);
replaced = 0;
old_line = new_line = {};
for l in [1..length(code)]
yin();
if (!index(code[l], old))
continue;
endif
old_line = {@old_line, code[l]};
code[l] = strsub(code[l], old, new);
new_line = {@new_line, code[l]};
replaced = replaced + 1;
endfor
"Try to compile the new code if it has any replaced lines.";
if (replaced)
result = set_verb_code(o, v, code);
if (typeof(result) == ERR)
player:tell("Could not compile code for ", $string_utils:nn(o), ":", v, ". ", toliteral(result));
else
player:tell("... replaced code in ", o, ":", v, ":");
for pew in [1..length(old_line)]
player:tell("   ", old_line[pew]);
player:tell("   ", new_line[pew]);
endfor
total = total + 1;
endif
endif
yin();
endfor
yin();
endfor
player:tell("Done. ", total, " verbs replaced.");
else
return player:tell("Aborted.");
endif
.
#57:39
if (player != this)
return E_PERM;
endif
"Check prerequisites:";
if (typeof(`function_info("curl") ! E_INVARG') == ERR)
return player:tell("This verb relies on the curl builtin function to retrieve up-to-date documentation. Please ensure that the server has been compiled with the function enabled. You may need to install a supporting library, such as libcurl. Further information may be available here: https://github.com/lisdude/toaststunt/blob/master/docs/README.md#build-instructions");
endif
required_verbs = {{$object_utils, "has_property"}, {$player, "my_match_object"}, {$command_utils, "object_match_failed"}, {$string_utils, "nn"}, {$command_utils, "yes_or_no"}, {$recycler, "_create"}, {$string_utils, "english_list"}, {$list_utils, "map_builtin"}};
required_props = {{$sysobj, "generic_help"}, {$sysobj, "prog"}};
for x in (required_verbs)
if (typeof(`verb_info(@x) ! E_VERBNF') == ERR)
return player:tell("This verb relies on several LambdaCore verbs being present. It seems your database is missing: ", x[1], ":", x[2]);
endif
endfor
for x in (required_props)
if (typeof(`property_info(@x) ! E_PROPNF') == ERR)
return player:tell("This verb relies on several LambdaCore properties being present. It seems your database is missing: ", x[1], ".", x[2]);
endif
endfor
"Now do a special test for builtin_function help. Standard LambdaCore stores this in a property on $sysobj. ToastCore stores it in a map on $sysobj.";
if ($object_utils:has_property($sysobj, "builtin_function_help"))
builtin_function_help = $builtin_function_help;
elseif ($object_utils:has_property($sysobj, "help_db") && maphaskey($help_db, "builtin_function"))
builtin_function_help = $help_db["builtin_function"];
else
"Not a fatal error, but we won't be able to check our priority";
builtin_function_help = $failed_match;
endif
"Check if the update verb itself needs updated. (This does its own prerequisite checking because these functions aren't, strictly speaking, required for the main help update to succeed.)";
if ((typeof(`verb_info($list_utils, "setremove_all") ! E_VERBNF') != ERR) && (typeof(`verb_info($object_utils, "has_verb") ! E_VERBNF') != ERR))
verb_loc = $object_utils:has_verb(this, verb)[1];
if (player.wizard || (verb_info(verb_loc, verb)[1] == player))
update_url = "https://raw.githubusercontent.com/lisdude/toaststunt-documentation/master/update_verb.moo";
new_verb = $list_utils:setremove_all(decode_binary(call_function("curl", update_url)), 10)[3..$ - 1];
if ((new_verb != verb_code(verb_loc, verb)) && ($command_utils:yes_or_no(tostr("There is an update available for this verb. Would you like to apply it? You can review the updated code here: ", update_url)) == 1))
set_verb_code(verb_loc, verb, new_verb);
return player:tell("This verb has been updated. Please run it again.");
endif
endif
endif
"Try to identify an existing help database either by name or by input from the wizard.";
db = 0;
if (!args)
for x in (children($generic_help))
if (x.name == "ToastStunt Help Database")
db = x;
break;
endif
endfor
else
match = player:my_match_object(argstr);
if ($command_utils:object_match_failed(match, argstr))
return;
elseif (isa(match, $generic_help))
db = match;
else
return player:tell($string_utils:nn(match), " doesn't appear to be a help database.");
endif
endif
"If we failed, create a new database and add it to $prog help.";
if (db == 0)
if ($command_utils:yes_or_no("No existing help database could be found. Would you like to create one?") == 1)
db = $recycler:_create($generic_help);
db:set_name("ToastStunt Help Database");
if (player.wizard && ($command_utils:yes_or_no("Would you like to add the new database to $prog.help?") == 1))
$prog.help = setadd($prog.help, db);
endif
else
return player:tell("Not creating a new database.");
endif
endif
"Test if our help database has a higher priority than the LambdaCore builtin function help database. If not, offer to make it so.";
if ((builtin_function_help != $failed_match) && ((db in $prog.help) > (builtin_function_help in $prog.help)))
if ($command_utils:yes_or_no("Would you like the ToastStunt help to take priority over LambdaCore help? This means that duplicate help files (such as move()) will prefer the ToastStunt version over the LambdaCore version.") == 1)
$prog.help = setremove($prog.help, db);
$prog.help = {db, @$prog.help};
endif
endif
"Finally, actually update the help files.";
if ($command_utils:yes_or_no(tostr("Do you want to update the help database ", $string_utils:nn(db), "?")) != 1)
return player:tell("Not updating.");
endif
if ((!player.wizard) && (db.owner != player))
return player:tell("You don't have permission to update ", $string_utils:nn(db), ".");
endif
url = "https://raw.githubusercontent.com/lisdude/toaststunt-documentation/master/function_help.moo";
data = call_function("curl", url);
if (typeof(data) == MAP)
return player:tell("Error retrieving help text: ", data["message"]);
else
regex = "^;;#123\\.\\(\"(?<property>.+)\"\\) = (?<value>.+)$";
data = decode_binary(data);
added = removed = updated = {};
properties = [];
for x in (data)
yin();
if (typeof(x) != STR)
continue;
endif
if (match = pcre_match(x, regex))
{property, value} = {match[1]["property"]["match"], $string_utils:to_value(match[1]["value"]["match"])};
if (value[1] != 1)
player:tell("Error parsing value for `", property, "'.");
continue;
else
value = value[2];
endif
properties[property] = value;
endif
endfor
"Check for properties that no longer exist in the remote.";
for local_prop in (properties(db))
yin();
if (!maphaskey(properties, local_prop))
if ($command_utils:yes_or_no(tostr("The property `", local_prop, "' no longer exists in the remote repository. Do you wish to delete the local version?")) == 1)
removed = setadd(removed, local_prop);
delete_property(db, local_prop);
endif
endif
endfor
for value, property in (properties)
if ($object_utils:has_property(db, property))
if (db.(property) != value)
updated = setadd(updated, property);
db.(property) = value;
endif
else
add_property(db, property, value, {db.owner, "rc"});
added = setadd(added, property);
endif
endfor
player:tell("Done! ", (((added == {}) && (updated == {})) && (removed == {})) ? "No changes found." | tostr("Added: ", $string_utils:english_list(added), ". Updated: ", $string_utils:english_list(updated), ".", (removed == {}) ? "" | tostr(" Removed: ", $string_utils:english_list(removed), ".")));
endif
.
#58:0
set_task_perms(player);
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
elseif (!$quota_utils:property_addition_permitted(player))
player:tell("Property addition not permitted because quota exceeded.");
return;
endif
nargs = length(args);
usage = tostr("Usage:  ", verb, " <object>.<prop-name> [<init_value> [<perms> [<owner>]]]");
if ((nargs < 1) || (!(spec = $code_utils:parse_propref(args[1]))))
player:notify(usage);
return;
endif
object = player:my_match_object(spec[1]);
name = spec[2];
if ($command_utils:object_match_failed(object, spec[1]))
return;
endif
if (nargs < 2)
value = 0;
else
q = $string_utils:prefix_to_value(argstr[$string_utils:word_start(argstr)[2][1]..$]);
if (q[1] == 0)
player:notify(tostr("Syntax error in initial value:  ", q[2]));
return;
endif
value = q[2];
args = {args[1], value, @$string_utils:words(q[1])};
nargs = length(args);
endif
default = player:prog_option("@prop_flags");
if (!default)
default = "rc";
endif
perms = (nargs < 3) ? default | $perm_utils:apply(default, args[3]);
if (nargs < 4)
owner = player;
else
owner = $string_utils:match_player(args[4]);
if ($command_utils:player_match_result(owner, args[4])[1])
return;
endif
endif
if (nargs > 4)
player:notify(usage);
return;
endif
try
add_property(object, name, value, {owner, perms});
player:notify(tostr("Property added with value ", toliteral(object.(name)), "."));
except (E_INVARG)
if ($object_utils:has_property(object, name))
player:notify(tostr("Property ", object, ".", name, " already exists."));
else
for i in [1..length(perms)]
if (!index("rcw", perms[i]))
player:notify(tostr("Unknown permission bit:  ", perms[i]));
return;
endif
endfor
"...the only other possibility...";
player:notify("Property is already defined on one or more descendents.");
player:notify(tostr("Try @check-prop ", args[1]));
endif
except e (ANY)
player:notify(e[2]);
endtry
.
#58:1
set_task_perms(player);
bynumber = verb == "@chmod#";
if (length(args) != 2)
player:notify(tostr("Usage:  ", verb, " <object-or-property-or-verb> <permissions>"));
return;
endif
{what, perms} = args;
if (spec = $code_utils:parse_verbref(what))
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
endif
if (valid(object = player:my_match_object(spec[1])))
vname = spec[2];
if (bynumber)
vname = $code_utils:toint(vname);
if (vname == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
endif
try
info = verb_info(object, vname);
if (!valid(owner = info[1]))
player:notify(tostr("That verb is owned by an invalid object (", owner, "); it needs to be @chowned."));
elseif (!is_player(owner))
player:notify(tostr("That verb is owned by a non-player object (", owner.name, ", ", owner, "); it needs to be @chowned."));
else
info[2] = perms = $perm_utils:apply(info[2], perms);
try
result = set_verb_info(object, vname, info);
player:notify(tostr("Verb permissions set to \"", perms, "\"."));
except (E_INVARG)
player:notify(tostr("\"", perms, "\" is not a valid permissions string for a verb."));
except e (ANY)
player:notify(e[2]);
endtry
endif
except (E_VERBNF)
player:notify("That object does not define that verb.");
except error (ANY)
player:notify(error[2]);
endtry
return;
endif
elseif (bynumber)
return player:notify("@chmod# can only be used for verbs.");
elseif (index(what, ".") && (spec = $code_utils:parse_propref(what)))
if (valid(object = player:my_match_object(spec[1])))
pname = spec[2];
try
info = property_info(object, pname);
info[2] = perms = $perm_utils:apply(info[2], perms);
try
result = set_property_info(object, pname, info);
player:notify(tostr("Property permissions set to \"", perms, "\"."));
except (E_INVARG)
player:notify(tostr("\"", perms, "\" is not a valid permissions string for a property."));
except error (ANY)
player:notify(error[2]);
endtry
except (E_PROPNF)
player:notify("That object does not have that property.");
except error (ANY)
player:notify(error[2]);
endtry
return;
endif
elseif (valid(object = player:my_match_object(what)))
perms = $perm_utils:apply(((object.r ? "r" | "") + (object.w ? "w" | "")) + (object.f ? "f" | ""), perms);
r = w = f = 0;
for i in [1..length(perms)]
if (perms[i] == "r")
r = 1;
elseif (perms[i] == "w")
w = 1;
elseif (perms[i] == "f")
f = 1;
else
player:notify(tostr("\"", perms, "\" is not a valid permissions string for an object."));
return;
endif
endfor
try
object.r = r;
object.w = w;
object.f = f;
player:notify(tostr("Object permissions set to \"", perms, "\"."));
except (E_PERM)
player:notify("Permission denied.");
endtry
return;
endif
$command_utils:object_match_failed(object, what);
.
#58:2
if (player != caller)
return;
endif
set_task_perms(player);
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
endif
if (!(args && (spec = $code_utils:parse_verbref(args[1]))))
player:notify(tostr(args ? ("\"" + args[1]) + "\"?  " | "", "<object>:<verb>  expected."));
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
"...can't find object...";
else
if (verb == "@args#")
name = $code_utils:toint(spec[2]);
if (name == E_TYPE)
return player:notify("Verb number expected.");
elseif ((name < 1) || `name > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
else
name = spec[2];
endif
try
info = verb_args(object, name);
if (typeof(pas = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)
"...arg spec is bogus...";
player:notify(tostr(pas));
elseif (!(newargs = pas[1]))
player:notify($string_utils:from_list(info, " "));
elseif (pas[2])
player:notify(tostr("\"", pas[2][1], "\" unexpected."));
else
info[2] = info[2][1..index(info[2] + "/", "/") - 1];
info = {@newargs, @info[length(newargs) + 1..$]};
try
result = set_verb_args(object, name, info);
player:notify("Verb arguments changed.");
except (E_INVARG)
player:notify(tostr("\"", info[2], "\" is not a valid preposition (?)"));
except error (ANY)
player:notify(error[2]);
endtry
endif
except (E_VERBNF)
player:notify("That object does not have a verb with that name.");
except error (ANY)
player:notify(error[2]);
endtry
endif
.
#58:3
"A MOO-code evaluator.  Type `;CODE' or `eval CODE'.";
"Calls player:eval_cmd_string to first transform CODE in any way appropriate (e.g., prefixing .eval_env) and then do the actual evaluation.  See documentation for this:eval_cmd_string";
"If you set your .eval_time property to 1, you find out how many ticks and seconds you used.";
"If eval-d is used, the evaluation is performed as if the debug flag were unset.";
if (player != this)
player:tell("I don't understand that.");
return;
elseif (!player.programmer)
player:tell("You need to be a programmer to eval code.");
return;
endif
set_task_perms(player);
result = player:eval_cmd_string(argstr, verb != "eval-d");
if (result[1])
player:notify(this:eval_value_to_string(result[2]));
if (player:prog_option("eval_time") && (!`output_delimiters(player)[2] ! ANY'))
player:notify(tostr("[used ", result[3], " tick", (result[3] != 1) ? "s, " | ", ", result[4], " second", (result[4] != 1) ? "s" | "", ".]"));
endif
else
player:notify_lines(result[2]);
nerrors = length(result[2]);
player:notify(tostr(nerrors, " error", (nerrors == 1) ? "." | "s."));
endif
.
#58:4
set_task_perms(player);
if ((length(args) != 1) || (!(spec = $code_utils:parse_propref(args[1]))))
player:notify(tostr("Usage:  ", verb, " <object>.<property>"));
return;
endif
object = player:my_match_object(spec[1]);
pname = spec[2];
if ($command_utils:object_match_failed(object, spec[1]))
return;
endif
try
result = delete_property(object, pname);
player:notify("Property removed.");
except (E_PROPNF)
player:notify("That object does not define that property.");
except res (ANY)
player:notify(res[2]);
endtry
.
#58:5
set_task_perms(player);
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
elseif (!$quota_utils:verb_addition_permitted(player))
player:tell("Verb addition not permitted because quota exceeded.");
return;
endif
if (!(args && (spec = $code_utils:parse_verbref(args[1]))))
player:notify(tostr("Usage:  ", verb, " <object>:<verb-name(s)> [<dobj> [<prep> [<iobj> [<permissions> [<owner>]]]]]"));
return;
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
return;
endif
name = spec[2];
"...Adding another verb of the same name is often a mistake...";
namelist = $string_utils:explode(name);
for n in (namelist)
if (i = index(n, "*"))
n = n[1..i - 1] + n[i + 1..$];
endif
if ((hv = $object_utils:has_verb(object, n)) && (hv[1] == object))
player:notify(tostr("Warning:  Verb `", n, "' already defined on that object."));
endif
endfor
if (typeof(pas = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)
player:notify(tostr(pas));
return;
endif
verbargs = pas[1] || (player:prog_option("verb_args") || {});
verbargs = {@verbargs, "none", "none", "none"}[1..3];
rest = pas[2];
if (verbargs == {"this", "none", "this"})
perms = player:prog_option("verb_perms") || "rxd";
if (!index(perms, "x"))
perms = perms + "x";
endif
else
perms = player:prog_option("verb_perms") || "rd";
endif
if (rest)
perms = $perm_utils:apply(perms, rest[1]);
endif
if (length(rest) < 2)
owner = player;
elseif (length(rest) > 2)
player:notify(tostr("\"", rest[3], "\" unexpected."));
return;
elseif ($command_utils:player_match_result(owner = $string_utils:match_player(rest[2]), rest[2])[1])
return;
elseif (owner == $nothing)
player:notify("Verb can't be owned by no one!");
return;
endif
try
x = add_verb(object, {owner, perms, name}, verbargs);
player:notify(tostr("Verb added (", (x > 0) ? x | length($object_utils:accessible_verbs(object)), ")."));
except (E_INVARG)
player:notify(tostr(rest ? tostr("\"", perms, "\" is not a valid set of permissions.") | tostr("\"", verbargs[2], "\" is not a valid preposition (?)")));
except e (ANY)
player:notify(e[2]);
endtry
.
#58:6
set_task_perms(player);
if (!(args && (spec = $code_utils:parse_verbref(args[1]))))
player:notify(tostr("Usage:  ", verb, " <object>:<verb>"));
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
"...bogus object...";
elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)
player:notify(tostr(argspec));
elseif (argspec[2])
player:notify($string_utils:from_list(argspec[2], " ") + "??");
elseif (length(argspec = argspec[1]) in {1, 2})
player:notify({"Missing preposition", "Missing iobj specification"}[length(argspec)]);
else
verbname = spec[2];
if (verb == "@rmverb#")
loc = $code_utils:toint(verbname);
if (loc == E_TYPE)
return player:notify("Verb number expected.");
elseif ((loc < 1) || (loc > `length(verbs(object)) ! E_PERM => 0'))
return player:notify("Verb number out of range.");
endif
else
if (index(verbname, "*") > 1)
verbname = strsub(verbname, "*", "");
endif
loc = $code_utils:find_last_verb_named(object, verbname);
if (argspec)
argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];
while ((loc != -1) && (`verb_args(object, loc) ! ANY' != argspec))
loc = $code_utils:find_last_verb_named(object, verbname, loc - 1);
endwhile
endif
if (loc < 0)
player:notify(tostr("That object does not define that verb", argspec ? " with those args." | "."));
return;
endif
endif
info = `verb_info(object, loc) ! ANY';
vargs = `verb_args(object, loc) ! ANY';
vcode = `verb_code(object, loc, 1, 1) ! ANY';
try
delete_verb(object, loc);
if (info)
player:notify(tostr("Verb ", object, ":", info[3], " (", loc, ") {", $string_utils:from_list(vargs, " "), "} removed."));
if (player:prog_option("rmverb_mail_backup"))
$mail_agent:send_message(player, player, tostr(object, ":", info[3], " (", loc, ") {", $string_utils:from_list(vargs, " "), "}"), vcode);
endif
else
player:notify(tostr("Unreadable verb ", object, ":", loc, " removed."));
endif
except e (ANY)
player:notify(e[2]);
endtry
endif
.
#58:7
"Syntax:  @forked [player]";
"         @forked all wizards";
"";
"For a normal player, shows all the tasks you have waiting in your queue, especially those forked or suspended. A wizard will see all the tasks of all the players unless the optional argument is provided. @forked-v*erbose will show the full callers() stack for each task that has suspended (not a fresh fork).";
"The second form is only usable by wizards and provides an output of all tasks owned by characters who are .wizard=1. Useful to find a task that may get put in a random queue due to $wiz_utils:random_wizard. Or even finding verbs that run with wizard permissions that shouldn't be.";
set_task_perms(player);
verbose = $code_utils:verbname_match("@forked-v*erbose", verb);
if (!dobjstr)
tasks = queued_tasks();
elseif ((dobjstr == "all wizards") && player.wizard)
tasks = {};
for t in (queued_tasks())
if (valid(t[5]) && t[5].wizard)
tasks = {@tasks, t};
endif
$command_utils:suspend_if_needed(1);
endfor
elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
elseif (typeof(tasks = $wiz_utils:queued_tasks(dobj)) != LIST)
player:notify(tostr(verb, " ", dobj.name, "(", dobj, "):  ", tasks));
return;
endif
if (tasks)
su = $string_utils;
player:notify("Queue ID    Start Time            Owner         {Size} Verb (Line) [This]");
player:notify("--------    ----------            -----         -----------------");
now = time();
for task in (tasks)
$command_utils:suspend_if_needed(0);
{q_id, start, nu, nu2, owner, vloc, vname, lineno, this, ?size = 0} = task;
if (typeof(start) == STR)
time = start;
else
time = (start >= now) ? ctime(start)[5..24] | su:left((start == -1) ? "Reading input ..." | tostr(now - start, " seconds ago..."), 20);
endif
owner_name = valid(owner) ? owner.name | tostr("Dead ", owner);
player:notify(tostr(su:left(tostr(q_id), 10), "  ", time, "  ", su:left(owner_name, 12), "  {", $building_utils:size_string(size), "} ", vloc, ":", vname, " (", lineno, ")", (this != vloc) ? tostr(" [", this, "]") | ""));
if (verbose || (index(vname, "suspend") && (vloc == $command_utils)))
"Display the first (or, if verbose, every) line of the callers() list, which is gotten by taking the second through last elements of task_stack().";
stack = `task_stack(q_id, 1) ! E_INVARG => {}';
for frame in (stack[2..verbose ? $ | 2])
{sthis, svname, sprogger, svloc, splayer, slineno} = frame;
player:notify(tostr("                    Called By...  ", su:left(valid(sprogger) ? sprogger.name | tostr("Dead ", sprogger), 19), "  ", svloc, ":", svname, (sthis != svloc) ? tostr(" [", sthis, "]") | "", " (", slineno, ")"));
endfor
endif
endfor
player:notify("-----------------------------------------------------------------");
else
player:notify("No tasks.");
endif
.
#58:8
"Kills one or more tasks.";
"Arguments:";
"   object:verb -- kills all tasks which were started from that object and verb.";
"   all -- kills all tasks owned by invoker";
"   all player-name -- wizard variant:  kills all tasks owned by player.";
"   all everyone -- wizard variant:  really kills all tasks.";
"   Integer taskid -- kills the specifically named task.";
"   soon [integer] -- kills all tasks scheduled to run in the next [integer] seconds, which defaults to 60.";
"   %integer -- kills all tasks which end in the digits contained in integer.";
"   The @killquiet alias kills tasks without the pretty printout if more than one task is being killed.";
set_task_perms(player);
quiet = index(verb, "q");
if (length(args) == 0)
player:notify_lines({tostr("Usage:  ", verb, " [object]:[verb]"), tostr("        ", verb, " task_id"), tostr("        ", verb, " soon [number-of-seconds]", player.wizard ? " [everyone|<player name>]" | ""), tostr("        ", verb, " all", player.wizard ? " [everyone|<player name>]" | "")});
return;
elseif (taskid = toint(args[1]))
elseif (all = args[1] == "all")
everyone = 0;
realplayer = player;
if (player.wizard && (length(args) > 1))
realplayer = $string_utils:match_player(args[2]);
everyone = args[2] == "everyone";
if ((!valid(realplayer)) && (!everyone))
$command_utils:player_match_result(realplayer, args[2]);
return;
elseif (!everyone)
set_task_perms(realplayer);
endif
endif
elseif (soon = args[1] == "soon")
realplayer = player;
if (length(args) > 1)
soon = toint(args[2]);
if ((soon <= 0) && (!player.wizard))
player:notify(tostr("Usage:  ", verb, " soon [positive-number-of-seconds]"));
return;
elseif (player.wizard)
result = this:kill_aux_wizard_parse(@args[2..$]);
soon = result[1];
if (result[1] < 0)
"already gave them an error message";
return;
elseif (result[2] == 1)
everyone = 1;
else
everyone = 0;
set_task_perms(result[2]);
realplayer = result[2];
endif
endif
else
soon = 60;
everyone = 0;
endif
elseif (percent = args[1][1] == "%")
l = length(args[1]);
digits = toint(args[1][2..l]);
percent = toint("1" + "0000000000"[1..l - 1]);
elseif (colon = index(argstr, ":"))
whatstr = argstr[1..colon - 1];
vrb = argstr[colon + 1..$];
if (whatstr)
what = player:my_match_object(whatstr);
endif
else
player:notify_lines({tostr("Usage:  ", verb, " [object]:[verb]"), tostr("        ", verb, " task_id"), tostr("        ", verb, " soon [number-of-seconds]", player.wizard ? " [everyone|<player name>]" | ""), tostr("        ", verb, " all", player.wizard ? " [\"everyone\"|<player name>]" | "")});
return;
endif
"OK, parsed the line, and punted them if it was bogus.  This verb could have been a bit shorter at the expense of readability.  I think it's getting towards unreadable as is.  At this point we've set_task_perms'd, and set up an enormous number of local variables.  Evaluate them in the order we set them, and we should never get var not found.";
queued_tasks = queued_tasks();
killed = 0;
if (taskid)
try
kill_task(taskid);
player:notify(tostr("Killed task ", taskid, "."));
killed = 1;
except error (ANY)
player:notify(tostr("Can't kill task ", taskid, ": ", error[2]));
endtry
elseif (all)
for task in (queued_tasks)
if (everyone || (realplayer == task[5]))
`kill_task(task[1]) ! ANY';
killed = killed + 1;
if (!quiet)
this:_kill_task_message(task);
endif
endif
$command_utils:suspend_if_needed(3, "... killing tasks");
endfor
elseif (soon)
now = time();
for task in (queued_tasks)
if (((task[2] - now) < soon) && ((!player.wizard) || (everyone || (realplayer == task[5]))))
`kill_task(task[1]) ! ANY';
killed = killed + 1;
if (!quiet)
this:_kill_task_message(task);
endif
endif
$command_utils:suspend_if_needed(3, "... killing tasks");
endfor
elseif (percent)
for task in (queued_tasks)
if (digits == (task[1] % percent))
`kill_task(task[1]) ! ANY';
killed = killed + 1;
if (!quiet)
this:_kill_task_message(task);
endif
endif
$command_utils:suspend_if_needed(3, "... killing tasks");
endfor
elseif ((colon || vrb) || whatstr)
for task in (queued_tasks)
if ((((((whatstr == "") || (valid(task[6]) && (index(task[6].name, whatstr) == 1))) || (valid(task[9]) && (index(task[9].name, whatstr) == 1))) || (task[9] == what)) || (task[6] == what)) && ((vrb == "") || (index(" " + strsub(task[7], "*", ""), " " + vrb) == 1)))
`kill_task(task[1]) ! ANY';
killed = killed + 1;
if (!quiet)
this:_kill_task_message(task);
endif
endif
$command_utils:suspend_if_needed(3, "... killing tasks");
endfor
else
player:notify("Something is funny; I didn't understand your @kill command.  You shouldn't have gotten here.  Please send yduJ mail saying you got this message from @kill, and what you had typed to @kill.");
endif
if (!killed)
player:notify("No tasks killed.");
elseif (quiet)
player:notify(tostr("Killed ", killed, " tasks."));
endif
.
#58:9
"Usage:  @copy source:verbname to target[:verbname]";
"  the target verbname, if not given, defaults to that of the source.  If the target verb doesn't already exist, a new verb is installed with the same args, names, code, and permission flags as the source.  Otherwise, the existing target's verb code is overwritten and no other changes are made.";
"This the poor man's version of multiple inheritance... the main problem is that someone may update the verb you're copying and you'd never know.";
"  if @copy-x is used, makes an unusable copy (!x, this none this).  If @copy-move is used, deletes the source verb as well.";
set_task_perms(player);
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
elseif ((verb != "@copy-move") && (!$quota_utils:verb_addition_permitted(player)))
player:notify("Verb addition not permitted because quota exceeded.");
return;
elseif ((!(from = $code_utils:parse_verbref(dobjstr))) || (!iobjstr))
player:notify(tostr("Usage:  ", verb, " obj:verb to obj:verb"));
player:notify(tostr("        ", verb, " obj:verb to obj"));
player:notify(tostr("        ", verb, " obj:verb to :verb"));
return;
elseif ($command_utils:object_match_failed(fobj = player:my_match_object(from[1]), from[1]))
return;
elseif (iobjstr[1] == ":")
to = {fobj, iobjstr[2..$]};
elseif ((!index(iobjstr, ":")) || (!(to = $code_utils:parse_verbref(iobjstr))))
iobj = player:my_match_object(iobjstr);
if ($command_utils:object_match_failed(iobj, iobjstr))
return;
endif
to = {iobj, from[2]};
elseif ($command_utils:object_match_failed(tobj = player:my_match_object(to[1]), to[1]))
return;
else
to[1] = tobj;
endif
from[1] = fobj;
if (verb == "@copy-move")
if ((!$perm_utils:controls(player, fobj)) && (!$quota_utils:verb_addition_permitted(player)))
player:notify("Won't be able to delete old verb.  Quota exceeded, so unable to continue.  Aborted.");
return;
elseif ($perm_utils:controls(player, fobj))
"only try to move if the player controls the verb. Otherwise, skip and treat as regular @copy";
if (typeof(result = $code_utils:move_verb(@from, @to)) == ERR)
player:notify(tostr("Unable to move verb from ", from[1], ":", from[2], " to ", to[1], ":", to[2], " --> ", result));
else
player:notify(tostr("Moved verb from ", from[1], ":", from[2], " to ", result[1], ":", result[2]));
endif
return;
else
player:notify("Won't be able to delete old verb.  Treating this as regular @copy.");
endif
endif
to_firstname = strsub(to[2][1..index(to[2] + " ", " ") - 1], "*", "") || "*";
if ((!(hv = $object_utils:has_verb(to[1], to_firstname))) || (hv[1] != to[1]))
if ((!(info = `verb_info(@from) ! ANY')) || (!(vargs = `verb_args(@from) ! ANY')))
player:notify(tostr("Retrieving ", from[1], ":", from[2], " --> ", info && vargs));
return;
endif
if (!player.wizard)
info[1] = player;
endif
if (verb == "@copy-x")
"... make sure this is an unusable copy...";
info[2] = strsub(info[2], "x", "");
vargs = {"this", "none", "this"};
endif
if (from[2] != to[2])
info[3] = to[2];
endif
if (ERR == typeof(e = `add_verb(to[1], info, vargs) ! ANY'))
player:notify(tostr("Adding ", to[1], ":", to[2], " --> ", e));
return;
endif
endif
code = `verb_code(@from) ! ANY';
owner = `verb_info(@from)[1] ! ANY';
if (typeof(code) == ERR)
player:notify(tostr("Couldn't retrieve code from ", from[1].name, " (", from[1], "):", from[2], " => ", code));
return;
endif
if (owner != player)
comment = tostr("Copied from ", $string_utils:nn(from[1]), ":", from[2], (from[1] == owner) ? "" | tostr(" [verb author ", $string_utils:nn(owner), "]"), " at ", ctime());
code = {$string_utils:print(comment) + ";", @code};
if (!player:prog_option("copy_expert"))
player:notify("Use of @copy is discouraged.  Please do not use @copy if you can use inheritance or features instead.  Use @copy carefully, and only when absolutely necessary, as it is wasteful of database space.");
endif
endif
e = `set_verb_code(to[1], to_firstname, code) ! ANY';
if (ERR == typeof(e))
player:notify(tostr("Copying ", from[1], ":", from[2], " to ", to[1], ":", to[2], " --> ", e));
elseif ((typeof(e) == LIST) && e)
player:notify(tostr("Copying ", from[1], ":", from[2], " to ", to[1], ":", to[2], " -->"));
player:notify_lines(e);
else
player:notify(tostr(to[1], ":", to[2], " code set."));
endif
.
#58:10
set_task_perms(caller_perms());
task = args[1];
player:notify(tostr("Killed: ", $string_utils:right(tostr("task ", task[1]), 17), ", verb ", task[6], ":", task[7], ", line ", task[8], (task[9] != task[6]) ? ", this==" + tostr(task[9]) | ""));
.
#58:11
"This version of @program deals with multiple verbs having the same name.";
"... @program <object>:<verbname> <dobj> <prep> <iobj>  picks the right one.";
if (player != caller)
return;
endif
set_task_perms(player);
"...";
"...catch usage errors first...";
"...";
punt = "...set punt to 0 only if everything works out...";
if (!(args && (spec = $code_utils:parse_verbref(args[1]))))
player:notify(tostr("Usage: ", verb, " <object>:<verb> [<dobj> <prep> <iobj>]"));
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
"...bogus object...";
elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)
player:notify(tostr(argspec));
elseif (verb == "@program#")
verbname = $code_utils:toint(spec[2]);
if (verbname == E_TYPE)
player:notify("Verb number expected.");
elseif (length(args) > 1)
player:notify("Don't give args for @program#.");
elseif ((verbname < 1) || `verbname > length(verbs(object)) ! E_PERM')
player:notify("Verb number out of range.");
else
argspec = 0;
punt = 0;
endif
elseif (argspec[2])
player:notify($string_utils:from_list(argspec[2], " ") + "??");
elseif (length(argspec = argspec[1]) in {1, 2})
player:notify({"Missing preposition", "Missing iobj specification"}[length(argspec)]);
else
punt = 0;
verbname = spec[2];
if (index(verbname, "*") > 1)
verbname = strsub(verbname, "*", "");
endif
endif
"...";
"...if we have an argspec, we'll need to reset verbname...";
"...";
if (punt)
elseif (argspec)
if (!(argspec[2] in {"none", "any"}))
argspec[2] = $code_utils:full_prep(argspec[2]);
endif
loc = $code_utils:find_verb_named(object, verbname);
while ((loc > 0) && (`verb_args(object, loc) ! ANY' != argspec))
loc = $code_utils:find_verb_named(object, verbname, loc + 1);
endwhile
if (!loc)
punt = "...can't find it....";
player:notify("That object has no verb matching that name + args.");
else
verbname = loc;
endif
else
loc = 0;
endif
"...";
"...get verb info...";
"...";
if (punt || (!(punt = "...reset punt to TRUE...")))
else
try
info = verb_info(object, verbname);
punt = 0;
aliases = info[3];
if (!loc)
loc = aliases in (verbs(object) || {});
endif
except (E_VERBNF)
player:notify("That object does not have that verb definition.");
except error (ANY)
player:notify(error[2]);
endtry
endif
"...";
"...read the code...";
"...";
if (punt)
player:notify(tostr("Now ignoring code for ", args ? args[1] | "nothing in particular", "."));
$command_utils:read_lines();
player:notify("Verb code ignored.");
else
player:notify(tostr("Now programming ", object.name, ":", aliases, "(", (!loc) ? "??" | loc, ")."));
lines = $command_utils:read_lines_escape((active = player in $verb_editor.active) ? {} | {"@edit"}, {tostr("You are editing ", $string_utils:nn(object), ":", verbname, "."), @active ? {} | {"Type `@edit' to take this into the verb editor."}});
if (lines[1] == "@edit")
$verb_editor:invoke(args[1], "@program", lines[2]);
return;
endif
simpleedit = $mcp.registry:match_package("dns-org-mud-moo-simpleedit");
if ((simpleedit != $failed_match) && simpleedit.v_filter_in)
lines[2] = simpleedit.v_filter_in[1]:(simpleedit.v_filter_in[2])(lines[2]);
endif
try
if (result = set_verb_code(object, verbname, lines[2]))
player:notify_lines(result);
player:notify(tostr(length(result), " error(s)."));
player:notify("Verb not programmed.");
else
player:notify("0 errors.");
player:notify("Verb programmed.");
endif
except error (ANY)
player:notify(error[2]);
player:notify("Verb not programmed.");
endtry
endif
.
#58:12
"Usage: @setenv <environment string>";
"Set your .eval_env property.";
set_task_perms(player);
if (!argstr)
player:notify(tostr("Usage:  ", verb, " <environment string>"));
return;
endif
player:notify(tostr("Current eval environment is: ", player.eval_env));
result = player:set_eval_env(argstr);
if (typeof(result) == ERR)
player:notify(tostr(result));
return;
endif
player:notify(tostr(".eval_env set to \"", player.eval_env, "\" (", player.eval_ticks, " ticks)."));
.
#58:13
"Usage: @prospectus <player> [from <start>] [to <end>]";
set_task_perms((caller_perms() == $nothing) ? player | caller_perms());
dobj = dobjstr ? $string_utils:match_player(dobjstr) | player;
if ($command_utils:player_match_result(dobj, dobjstr)[1])
return;
endif
dobjwords = $string_utils:words(dobjstr);
if (args[1..length(dobjwords)] == dobjwords)
args = args[length(dobjwords) + 1..$];
endif
if (!(parse_result = $code_utils:_parse_audit_args(@args)))
player:notify(tostr("Usage:  ", verb, " player [from <start>] [to <end>]"));
return;
endif
return $building_utils:do_prospectus(dobj, @parse_result);
.
#58:14
"@display <object>[.[property]]*[,[inherited_property]]*[:[verb]]*[;[inherited_verb]]*";
if (player != this)
player:notify(tostr("Sorry, you can't use ", this:title(), "'s `", verb, "' command."));
return E_PERM;
endif
"null names for properties and verbs are interpreted as meaning all of them.";
opivu = {{}, {}, {}, {}, {}};
string = "";
punc = 1;
literal = 0;
set_task_perms(player);
for jj in [1..length(argstr)]
j = argstr[jj];
if (literal)
string = string + j;
literal = 0;
elseif (j == "\\")
literal = 1;
elseif (y = index(".,:;", j))
opivu[punc] = {@opivu[punc], string};
punc = 1 + y;
string = "";
else
string = string + j;
endif
endfor
opivu[punc] = {@opivu[punc], string};
objname = opivu[1][1];
it = this:my_match_object(objname);
if ($command_utils:object_match_failed(it, objname))
return;
endif
readable = (it.owner == this) || (it.r || this.wizard);
cant = {};
if ("" in opivu[2])
if (readable)
prop = properties(it);
else
prop = {};
cant = setadd(cant, it);
endif
if (!this:display_option("thisonly"))
what = it;
while ((!prop) && valid(what = parent(what)))
if ((what.owner == this) || (what.r || this.wizard))
prop = properties(what);
else
cant = setadd(cant, what);
endif
endwhile
endif
else
prop = opivu[2];
endif
if ("" in opivu[3])
inh = {};
for what in ({it, @$object_utils:ancestors(it)})
if (((what.owner == this) || what.r) || this.wizard)
inh = {@inh, @properties(what)};
else
cant = setadd(cant, what);
endif
endfor
else
inh = opivu[3];
endif
for q in (inh)
if (q in `properties(it) ! ANY => {}')
prop = setadd(prop, q);
inh = setremove(inh, q);
endif
endfor
vrb = {};
if ("" in opivu[4])
if (readable)
vrbs = verbs(it);
else
vrbs = $object_utils:accessible_verbs(it);
cant = setadd(cant, it);
endif
what = it;
if (!this:display_option("thisonly"))
while ((!vrbs) && valid(what = parent(what)))
if ((what.owner == this) || (what.r || this.wizard))
vrbs = verbs(what);
else
cant = setadd(cant, what);
endif
endwhile
endif
for n in [1..length(vrbs)]
vrb = setadd(vrb, {what, n});
endfor
else
for w in (opivu[4])
if (y = $object_utils:has_verb(it, w))
vrb = setadd(vrb, {y[1], w});
else
this:notify(tostr("No such verb, \"", w, "\""));
endif
endfor
endif
if ("" in opivu[5])
for z in ({it, @$object_utils:ancestors(it)})
if (((this == z.owner) || z.r) || this.wizard)
for n in [1..length(verbs(z))]
vrb = setadd(vrb, {z, n});
endfor
else
cant = setadd(cant, z);
endif
endfor
else
for w in (opivu[5])
if (typeof(y = $object_utils:has_verb(it, w)) == LIST)
vrb = setadd(vrb, {y[1], w});
else
this:notify(tostr("No such verb, \"", w, "\""));
endif
endfor
endif
if (({""} in opivu) || (opivu[2..5] == {{}, {}, {}, {}}))
this:notify(tostr(it.name, " (", it, ") [ ", it.r ? "readable " | "", it.w ? "writeable " | "", it.f ? "fertile " | "", is_player(it) ? "(player) " | "", it.programmer ? "programmer " | "", it.wizard ? "wizard " | "", "]"));
if (it.owner != (is_player(it) ? it | this))
this:notify(tostr("  Owned by ", valid(p = it.owner) ? p.name | "** extinct **", " (", p, ")."));
endif
this:notify(tostr("  Child of ", valid(p = parent(it)) ? p.name | "** none **", " (", p, ")."));
if (it.location != $nothing)
this:notify(tostr("  Location ", valid(p = it.location) ? p.name | "** unplace (tell a wizard, fast!) **", " (", p, ")."));
endif
if ($quota_utils.byte_based && $object_utils:has_property(it, "object_size"))
this:notify(tostr("  Size: ", $string_utils:group_number(it.object_size[1]), " bytes at ", this:ctime(it.object_size[2])));
endif
endif
blankargs = this:display_option("blank_tnt") ? {"this", "none", "this"} | #-1;
for b in (vrb)
$command_utils:suspend_if_needed(0);
where = b[1];
q = b[2];
short = (typeof(q) == INT) ? q | strsub(y = index(q, " ") ? q[1..y - 1] | q, "*", "");
inf = `verb_info(where, short) ! ANY';
if ((typeof(inf) == LIST) || (inf == E_PERM))
name = (typeof(inf) == LIST) ? index(inf[3], " ") ? ("\"" + inf[3]) + "\"" | inf[3] | q;
line = $string_utils:left(tostr($string_utils:right(tostr(where), 6), ":", name, " "), 32);
if (inf == E_PERM)
line = line + "   ** unreadable **";
else
line = $string_utils:left(tostr(line, inf[1].name, " (", inf[1], ") "), 53) + ((i = inf[2] in {"x", "xd", "d", "rd"}) ? {" x", " xd", "  d", "r d"}[i] | inf[2]);
vargs = `verb_args(where, short) ! ANY';
if (vargs != blankargs)
if (this:display_option("shortprep") && (!(vargs[2] in {"any", "none"})))
vargs[2] = $code_utils:short_prep(vargs[2]);
endif
line = $string_utils:left(line + " ", 60) + $string_utils:from_list(vargs, " ");
endif
endif
this:notify(line);
elseif (inf == E_VERBNF)
this:notify(tostr(inf));
this:notify(tostr("  ** no such verb, \"", short, "\" **"));
else
this:notify("This shouldn't ever happen. @display is buggy.");
endif
endfor
all = {@prop, @inh};
max = (length(all) < 4) ? 999 | (this:linelen() - 56);
depth = (length(all) < 4) ? -1 | 1;
truncate_owner_names = length(all) > 1;
for q in (all)
$command_utils:suspend_if_needed(0);
inf = `property_info(it, q) ! ANY';
if (inf == E_PROPNF)
if (q in $code_utils.builtin_props)
this:notify(tostr($string_utils:left("," + q, 25), "Built in property            ", $string_utils:abbreviated_value(it.(q), max, depth)));
else
this:notify(tostr("  ** property not found, \"", q, "\" **"));
endif
else
pname = $string_utils:left(tostr((q in `properties(it) ! ANY => {}') ? "." | (`is_clear_property(it, q) ! ANY' ? " " | ","), q, " "), 25);
if (inf == E_PERM)
this:notify(pname + "   ** unreadable **");
else
oname = inf[1].name;
truncate_owner_names && ((length(oname) > 12) && (oname = oname[1..12]));
`inf[2][1] != "r" ! E_RANGE => 1' && (inf[2][1..0] = " ");
`inf[2][2] != "w" ! E_RANGE => 1' && (inf[2][2..1] = " ");
this:notify($string_utils:left(tostr($string_utils:left(tostr(pname, oname, " (", inf[1], ") "), 47), inf[2], " "), 54) + $string_utils:abbreviated_value(it.(q), max, depth));
endif
endif
endfor
if (cant)
failed = {};
for k in (cant)
failed = listappend(failed, tostr(k.name, " (", k, ")"));
endfor
this:notify($string_utils:centre(tostr(" no permission to read ", $string_utils:english_list(failed, ", ", " or ", " or "), ". "), 75, "-"));
else
this:notify($string_utils:centre(" finished ", 75, "-"));
endif
.
#58:15
set_task_perms(player);
"Let 'em @kill it.";
count = (maxobj = toint(max_object()) + 1) - length(recycled_objects());
player:notify(tostr("There are ", count, " valid objects out of ", maxobj, " allocated object numbers."));
.
#58:16
"@gethelp [<topic>] [from <db or dblist>]";
"  Prints the raw text of topic from the appropriate help db.";
"  With no argument, gets the blank (\"\") topic from wherever it lives";
"  Text is printed as a script for changing this help topic ";
"  (somewhat like @dump...)";
if (!prepstr)
topic = argstr;
dblist = $code_utils:help_db_list();
elseif (prepstr != "from")
player:notify("Usage:  ", verb, " [<topic>] [from <db>]");
return;
elseif (!(e = $no_one:eval_d(iobjstr = argstr[$string_utils:word_start(argstr)[(prepstr in args) + 1][1]..$])))
player:notify(tostr(e));
return;
elseif (!e[1])
player:notify_lines(e[2]);
return;
elseif (!(typeof(dblist = e[2]) in {OBJ, LIST}))
player:notify(tostr(iobjstr, " => ", dblist, " -- not an object or a list"));
return;
else
topic = dobjstr;
if (typeof(dblist) == OBJ)
dblist = {dblist};
endif
endif
search = $code_utils:help_db_search(topic, dblist);
if (!search)
player:notify("Topic not found.");
elseif (search[1] == $ambiguous_match)
player:notify(tostr("Topic `", topic, "' ambiguous:  ", $string_utils:english_list(search[2], "none", " or ")));
elseif (typeof(text = (db = search[1]):dump_topic(fulltopic = search[2])) == ERR)
"...ok...shoot me.  This is a -d verb...";
player:notify(tostr("Cannot retrieve `", fulltopic, "' on ", $code_utils:corify_object(db), ":  ", text));
else
player:notify_lines(text);
endif
.
#58:17
set_task_perms(player);
if (prepstr == "in")
pattern = dobjstr;
objlist = player:eval_cmd_string(iobjstr, 0);
if (!objlist[1])
player:notify(tostr("Had trouble reading `", iobjstr, "':  "));
player:notify_lines(@objlist[2]);
return;
elseif (typeof(objlist[2]) == OBJ)
objlist = {objlist[2..2]};
elseif (typeof(objlist[2]) != LIST)
player:notify(tostr("Value of `", iobjstr, "' is not an object or list:  ", toliteral(objlist[2])));
return;
else
objlist = objlist[2..2];
endif
elseif ((prepstr == "from") && (player.wizard && (n = toint(toobj(iobjstr)))))
pattern = dobjstr;
objlist = {n};
elseif (args && player.wizard)
pattern = argstr;
objlist = {};
else
player:notify(tostr("Usage:  ", verb, " <pattern> ", player.wizard ? "[in {<objectlist>} | from <number>]" | "in {<objectlist>}"));
return;
endif
player:notify(tostr("Searching for verbs ", @prepstr ? {prepstr, " ", iobjstr, " "} | {}, (verb == "@egrep") ? "matching the pattern " | "containing the string ", toliteral(pattern), " ..."));
player:notify("");
egrep = verb[2] == "e";
all = index(verb, "a");
$code_utils:(all ? egrep ? "find_verb_lines_matching" | "find_verb_lines_containing" | (egrep ? "find_verbs_matching" | "find_verbs_containing"))(pattern, @objlist);
.
#58:18
set_task_perms(player);
if (dobjstr == "")
player:notify(tostr("Usage:  ", verb, " <object-or-property-or-verb>"));
return;
endif
if (index(dobjstr, ".") && (spec = $code_utils:parse_propref(dobjstr)))
if (valid(object = player:my_match_object(spec[1])))
return $code_utils:show_property(object, spec[2]);
endif
elseif (index(dobjstr, ":") && (spec = $code_utils:parse_verbref(dobjstr)))
if (valid(object = player:my_match_object(spec[1])) && player.programmer)
return $code_utils:show_verbdef(object, spec[2]);
else
player:tell("You must be a programmer to show verbs.");
return;
endif
elseif (((dobjstr[1] == "$") && ((pname = dobjstr[2..$]) in properties(#0))) && (typeof(#0.(pname)) == OBJ))
if (valid(object = #0.(pname)))
return $code_utils:show_object(object);
endif
elseif ((dobjstr[1] == "$") && (spec = $code_utils:parse_propref(dobjstr)))
return $code_utils:show_property(#0, spec[2]);
else
if (valid(object = player:my_match_object(dobjstr)))
return $code_utils:show_object(object);
endif
endif
$command_utils:object_match_failed(object, dobjstr);
.
#58:19
"@check-prop object.property";
"  checks for descendents defining the given property.";
set_task_perms(player);
if (!(spec = $code_utils:parse_propref(dobjstr)))
player:notify(tostr("Usage:  ", verb, " <object>.<prop-name>"));
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
"...bogus object...";
elseif (!($perm_utils:controls(player, object) || object.w))
player:notify("You can't create a property on that object anyway.");
elseif ($object_utils:has_property(object, prop = spec[2]))
player:notify("That object already has that property.");
elseif (olist = $object_utils:descendants_with_property_suspended(object, prop))
player:notify("The following descendents have this property defined:");
player:notify("  " + $string_utils:from_list(olist, " "));
else
player:notify("No property name conflicts found.");
endif
.
#58:20
"set_eval_env(string);";
"Run <string> through eval.  If it doesn't compile, return E_INVARG.  If it crashes, well, it crashes.  If it works okay, set .eval_env to it and set .eval_ticks to the amount of time it took.";
if (is_player(this) && $perm_utils:controls(caller_perms(), this))
program = args[1];
value = $no_one:eval_d((";ticks = ticks_left();" + program) + ";return ticks - ticks_left() - 2;");
if (!value[1])
return E_INVARG;
elseif (typeof(value[2]) == ERR)
return value[2];
endif
try
ok = this.eval_env = program;
this.eval_ticks = value[2];
return 1;
except error (ANY)
return error[1];
endtry
endif
.
#58:21
"@clearproperty <obj>.<prop>";
"Set the value of <obj>.<prop> to `clear', making it appear to be the same as the property on its parent.";
set_task_perms(player);
if (!(l = $code_utils:parse_propref(dobjstr)))
player:notify(tostr("Usage:  ", verb, " <object>.<property>"));
elseif ($command_utils:object_match_failed(dobj = player:my_match_object(l[1]), l[1]))
"... bogus object...";
endif
try
if (is_clear_property(dobj, prop = l[2]))
player:notify(tostr("Property ", dobj, ".", prop, " is already clear!"));
return;
endif
clear_property(dobj, prop);
player:notify(tostr("Property ", dobj, ".", prop, " cleared; value is now ", toliteral(dobj.(prop)), "."));
except (E_INVARG)
player:notify(tostr("You can't clear ", dobj, ".", prop, "; none of the ancestors define that property."));
except error (ANY)
player:notify(error[2]);
endtry
.
#58:22
"Syntax: @disown <object> [from <object>]";
"This command is used to remove unwanted children of objects you control. If you control an object, and there is a child of that object you do not want, this command will chparent() the object to its grandparent.";
set_task_perms(player);
if (prepstr)
if (prepstr != "from")
player:notify("Usage:  ", verb, " <object> [from <object>]");
return;
elseif ($command_utils:object_match_failed(iobj = player:my_match_object(iobjstr), iobjstr))
"... from WHAT?..";
return;
elseif (valid(dobj = $string_utils:literal_object(dobjstr)))
"... literal object number...";
if (parent(dobj) != iobj)
player:notify(tostr(dobj, " is not a child of ", iobj.name, " (", iobj, ")"));
return;
endif
elseif ($command_utils:object_match_failed(dobj = $string_utils:match(dobjstr, children(iobj), "name", children(iobj), "aliases"), dobjstr))
"... can't match dobjstr against any children of iobj";
return;
endif
elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))
"... can't match dobjstr...";
return;
endif
try
if ($object_utils:disown(dobj))
player:notify(tostr(dobj.name, " (", dobj, ")'s parent is now ", (grandparent = parent(dobj)).name, " (", grandparent, ")."));
else
"this should never happen";
endif
except e (E_PERM, E_INVARG)
{code, message, value, traceback} = e;
player:notify(message);
endtry
.
#58:23
":eval_cmd_string(string[,debug])";
"Evaluates the string the way this player would normally expect to see it evaluated if it were typed on the command line.  debug (defaults to 1) indicates how the debug flag should be set during the evaluation.";
" => {@eval_result, ticks, seconds}";
"where eval_result is the result of the actual eval() call.";
"";
"For the case where string is an expression, we need to prefix `return ' and append `;' to string before passing it to eval().  However this is not appropriate for statements, where it is assumed an explicit return will be provided somewhere or that the return value is irrelevant.  The code below assumes that string is an expression unless it either begins with a semicolon `;' or one of the MOO language statement keywords.";
"Next, the substitutions described by this.eval_subs, which should be a list of pairs {string, sub}, are performed on string";
"Finally, this.eval_env is prefixed to the beginning while this.eval_ticks is subtracted from the eventual tick count.  This allows string to refer to predefined variables like `here' and `me'.";
set_task_perms(caller_perms());
{program, ?debug = 1} = args;
program = program + ";";
debug = debug ? 38 | 0;
if (!match(program, "^ *%(;%|%(if%|fork?%|return%|while%|try%)[^a-z0-9A-Z_]%)"))
program = "return " + program;
endif
program = tostr(this.eval_env, ";", $code_utils:substitute(program, this.eval_subs));
ticks = ((ticks_left() - 53) - this.eval_ticks) + debug;
seconds = seconds_left();
value = debug ? eval(program) | $code_utils:eval_d(program);
seconds = seconds - seconds_left();
ticks = ticks - ticks_left();
return {@value, ticks, seconds};
.
#58:24
"@dump something [with [id=...] [noprops] [noverbs] [create]]";
"This spills out all properties and verbs on an object, calling suspend at appropriate intervals.";
"   id=#nnn -- specifies an idnumber to use in place of the object's actual id (for porting to another MOO)";
"   noprops -- don't show properties.";
"   noverbs -- don't show verbs.";
"   create  -- indicates that a @create command should be generated and all of the verbs be introduced with @verb rather than @args; the default assumption is that the object already exists and you're just doing this to have a look at it.";
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
if (prepstr && (prepstr != "with"))
player:notify(tostr("Usage:  ", verb, " something [with [id=...] [noprops] [noverbs] [create]]"));
return;
endif
targname = tostr(dobj);
options = {"props", "verbs"};
create = 0;
if (iobjstr)
for o in ($string_utils:explode(iobjstr))
if (index(o, "id=") == 1)
targname = o[4..$];
elseif (o in {"noprops", "noverbs"})
options = setremove(options, o[3..$]);
elseif (o in {"create"})
create = 1;
else
player:notify(tostr("`", o, "' not understood as valid option."));
player:notify(tostr("Usage:  ", verb, " something [with [id=...] [noprops] [noverbs] [create]]"));
return;
endif
endfor
endif
$ansi_utils:add_noansi();
if (create)
player:notify($code_utils:dump_preamble(dobj));
endif
if ("props" in options)
player:notify_lines_suspended($code_utils:dump_properties(dobj, create, targname));
endif
if (!("verbs" in options))
player:notify("\"***finished***");
return;
endif
player:notify("");
player:notify_lines_suspended($code_utils:dump_verbs(dobj, create, targname));
player:notify("\"***finished***");
$ansi_utils:remove_noansi();
.
#58:25
"Copied from Player Class hacked with eval that does substitutions and assorted stuff (#8855):# by Geust (#24442) Sun May  9 20:19:05 1993 PDT";
"#<string>[.<property>|.parent] [exit|player|inventory] [for <code>] returns information about the object (we'll call it <thing>) named by string.  String is matched in the current room unless one of exit|player|inventory is given.";
"If neither .<property>|.parent nor <code> is specified, just return <thing>.";
"If .<property> is named, return <thing>.<property>.  .parent returns parent(<thing>).";
"If <code> is given, it is evaluated, with the value returned by the first part being substituted for %# in <code>.";
"For example, the command";
"  #JoeFeedback.parent player for toint(%#)";
"will return 26026 (unless Joe has chparented since writing this).";
set_task_perms(player);
if (!(whatstr = verb[2..dot = min(index(verb + ".", "."), index(verb + ":", ":")) - 1]))
player:notify("Usage:  #string [exit|player|inventory]");
return;
elseif (!args)
what = player:my_match_object(whatstr);
elseif (index("exits", args[1]) == 1)
what = player.location:match_exit(whatstr);
elseif (index("inventory", args[1]) == 1)
what = player:match(whatstr);
elseif (index("players", args[1]) == 1)
what = $string_utils:match_player(whatstr);
if ($command_utils:player_match_failed(what, whatstr))
return;
endif
else
what = player:my_match_object(whatstr);
endif
if ((!valid(what)) && match(whatstr, "^[0-9]+$"))
what = toobj(whatstr);
endif
if ($command_utils:object_match_failed(what, whatstr))
return;
endif
while (index(verb, ".parent") == (dot + 1))
what = parent(what);
dot = dot + 7;
endwhile
if (dot >= length(verb))
val = what;
elseif ((value = $code_utils:eval_d(tostr("return ", what, verb[dot + 1..$], ";")))[1])
val = value[2];
else
player:notify_lines(value[2]);
return;
endif
if (prepstr)
program = strsub(iobjstr + ";", "%#", toliteral(val));
end = 1;
"while (\"A\" <= (l = argstr[end]) && l <= \"Z\")";
while (("A" <= (l = program[end])) && (l <= "Z"))
end = end + 1;
endwhile
if ((program[1] == ";") || (program[1..end - 1] in {"if", "for", "fork", "return", "while", "try"}))
program = $code_utils:substitute(program, this.eval_subs);
else
program = $code_utils:substitute("return " + program, this.eval_subs);
endif
if ((value = eval(program))[1])
player:notify(this:eval_value_to_string(value[2]));
else
player:notify_lines(value[2]);
nerrors = length(value[2]);
player:notify(tostr(nerrors, " error", (nerrors == 1) ? "." | "s."));
endif
else
player:notify(this:eval_value_to_string(val));
endif
.
#58:26
set_task_perms(caller_perms());
if (typeof(val = args[1]) == OBJ)
return tostr("=> ", val, "  ", valid(val) ? ("(" + val.name) + ")" | ((a = $list_utils:assoc(val, {{#-1, "<$nothing>"}, {#-2, "<$ambiguous_match>"}, {#-3, "<$failed_match>"}})) ? a[2] | "<invalid>"));
elseif (typeof(val) == ERR)
return tostr("=> ", toliteral(val), "  (", val, ")");
else
return tostr("=> ", toliteral(val));
endif
.
#58:27
"@<what>-option <option> [is] <value>   sets <option> to <value>";
"@<what>-option <option>=<value>        sets <option> to <value>";
"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1";
"@<what>-option -<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option !<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option <option>      displays value of <option>";
set_task_perms(player);
what = "prog";
options = what + "_options";
option_pkg = $options[what];
set_option = ("set_" + what) + "_option";
if (!args)
player:notify_lines({("Current " + what) + " options:", "", @option_pkg:show(this.(options), option_pkg.names)});
return;
elseif (typeof(presult = option_pkg:parse(args)) == STR)
player:notify(presult);
return;
else
if (length(presult) > 1)
if (typeof(sresult = this:(set_option)(@presult)) == STR)
player:notify(sresult);
return;
elseif (!sresult)
player:notify("No change.");
return;
endif
endif
player:notify_lines(option_pkg:show(this.(options), presult[1]));
endif
.
#58:28
":prog_option(name)";
"Returns the value of the specified prog option";
if ((caller in {this, $mcp.simpleedit}) || $perm_utils:controls(caller_perms(), this))
return $options["prog"]:get(this.prog_options, args[1]);
else
return E_PERM;
endif
.
#58:29
":set_prog_option(oname,value)";
"Changes the value of the named option.";
"Returns a string error if something goes wrong.";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return tostr(E_PERM);
endif
"...this is kludgy, but it saves me from writing the same verb 3 times.";
"...there's got to be a better way to do this...";
verb[1..4] = "";
foo_options = verb + "s";
prop = verb[1..index(verb, "_") - 1];
"...";
if (typeof(s = $options[prop]:set(this.(foo_options), @args)) == STR)
return s;
elseif (s == this.(foo_options))
return 0;
else
this.(foo_options) = s;
return 1;
endif
.
#58:30
"@list <obj>:<verb> [<dobj> <prep> <iobj>] [with[out] paren|num] [all] [ranges]";
set_task_perms(player);
bynumber = verb == "@list#";
pflag = player:prog_option("list_all_parens");
nflag = !player:prog_option("list_no_numbers");
permflag = player:prog_option("list_show_permissions");
aflag = 0;
argspec = {};
range = {};
spec = args ? $code_utils:parse_verbref(args[1]) | E_INVARG;
args = spec ? listdelete(args, 1) | E_INVARG;
while (args)
if (args[1] && ((index("without", args[1]) == 1) || (args[1] == "wo")))
"...w,wi,wit,with => 1; wo,witho,withou,without => 0...";
fval = !index(args[1], "o");
if (`index("parentheses", args[2]) ! ANY' == 1)
pflag = fval;
args[1..2] = {};
elseif (`index("numbers", args[2]) ! ANY' == 1)
nflag = fval;
args[1..2] = {};
else
player:notify(tostr(args[1], " WHAT?"));
args = E_INVARG;
endif
elseif (index("all", args[1]) == 1)
if (bynumber)
player:notify("Don't use `all' with @list#.");
args = E_INVARG;
else
aflag = 1;
args[1..1] = {};
endif
elseif (index("0123456789", args[1][1]) || (index(args[1], "..") == 1))
if (E_INVARG == (s = $seq_utils:from_string(args[1])))
player:notify(tostr("Garbled range:  ", args[1]));
args = E_INVARG;
else
range = $seq_utils:union(range, s);
args = listdelete(args, 1);
endif
elseif (bynumber)
player:notify("Don't give args with @list#.");
args = E_INVARG;
elseif (argspec)
"... second argspec?  Not likely ...";
player:notify(tostr(args[1], " unexpected."));
args = E_INVARG;
elseif (typeof(pas = $code_utils:parse_argspec(@args)) == LIST)
argspec = pas[1];
if (length(argspec) < 2)
player:notify(tostr("Argument `", @argspec, "' malformed."));
args = E_INVARG;
else
argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];
args = pas[2];
endif
else
"... argspec is bogus ...";
player:notify(tostr(pas));
args = E_INVARG;
endif
endwhile
if (args == E_INVARG)
if (bynumber)
player:notify(tostr("Usage:  ", verb, " <object>:<verbnumber> [with|without parentheses|numbers] [ranges]"));
else
player:notify(tostr("Usage:  ", verb, " <object>:<verb> [<dobj> <prep> <iobj>] [with|without parentheses|numbers] [all] [ranges]"));
endif
return;
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
return;
endif
shown_one = 0;
for what in ({object, @$object_utils:ancestors(object)})
if (bynumber)
vname = $code_utils:toint(spec[2]);
if (vname == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(what)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
code = `verb_code(what, vname, pflag) ! ANY';
elseif (argspec)
vnum = $code_utils:find_verb_named(what, spec[2]);
while (vnum && (`verb_args(what, vnum) ! ANY' != argspec))
vnum = $code_utils:find_verb_named(what, spec[2], vnum + 1);
endwhile
vname = vnum;
code = (!vnum) ? E_VERBNF | `verb_code(what, vnum, pflag) ! ANY';
else
vname = spec[2];
code = `verb_code(what, vname, pflag) ! ANY';
endif
if (code != E_VERBNF)
if (shown_one)
player:notify("");
elseif (what != object)
player:notify(tostr("Object ", object, " does not define that verb", argspec ? " with those args" | "", ", but its ancestor ", what, " does."));
endif
if (typeof(code) == ERR)
player:notify(tostr(what, ":", vname, " -- ", code));
else
info = verb_info(what, vname);
vargs = verb_args(what, vname);
fullname = info[3];
if (index(fullname, " "))
fullname = toliteral(fullname);
endif
if (index(vargs[2], "/"))
vargs[2] = tostr("(", vargs[2], ")");
endif
$ansi_utils:add_noansi();
player:notify(tostr(what, ":", fullname, "   ", $string_utils:from_list(vargs, " "), permflag ? " " + info[2] | ""));
if (code == {})
player:notify("(That verb has not been programmed.)");
else
lineseq = {1, length(code) + 1};
range && (lineseq = $seq_utils:intersection(range, lineseq));
if (!lineseq)
player:notify("(No lines in that range.)");
endif
for k in [1..length(lineseq) / 2]
for i in [lineseq[(2 * k) - 1]..lineseq[2 * k] - 1]
if (nflag)
player:notify(tostr(" "[1..i < 10], i, ":  ", code[i]));
else
player:notify(code[i]);
endif
$command_utils:suspend_if_needed(0);
endfor
endfor
endif
$ansi_utils:remove_noansi();
endif
shown_one = 1;
endif
if (shown_one && (!aflag))
return;
endif
endfor
if (!shown_one)
player:notify(tostr("That object does not define that verb", argspec ? " with those args." | "."));
endif
.
#58:31
"Copied from Player Class hacked with eval that does substitutions and assorted stuff (#8855):set_eval_subs by Geust (#24442) Fri Aug  5 13:18:59 1994 PDT";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif (typeof(subs = args[1]) != LIST)
return E_TYPE;
else
for pair in (subs)
if (((length(pair) != 2) || typeof(pair[1] != STR)) || typeof(pair[2] != STR))
return E_INVARG;
endif
endfor
endif
return `this.eval_subs = subs ! ANY';
.
#58:32
set_task_perms(player);
if (!dobjstr)
try
if ((verb[7] != "(") && (verb[$] != ")"))
player:tell("Usage:  @verbs <object>");
return;
else
dobjstr = verb[8..$ - 1];
endif
except (E_RANGE)
return player:tell("Usage:  @verbs <object>");
endtry
endif
thing = player:my_match_object(dobjstr);
if (!$command_utils:object_match_failed(thing, dobjstr))
verbs = $object_utils:accessible_verbs(thing);
player:tell(";verbs(", thing, ") => ", toliteral(verbs));
endif
.
#58:33
"Syntax:  @forked-v*erbose [player]";
"         @forked-v*erbose all wizards";
"";
"For a normal player, shows all the tasks you have waiting in your queue, especially those forked or suspended. A wizard will see all the tasks of all the players unless the optional argument is provided. For a task which has suspended, and not a fresh fork, shows the full callers() stack.";
"The second form is only usable by wizards and provides an output of all tasks owned by characters who are .wizard=1. Useful to find a task that may get put in a random queue due to $wiz_utils:random_wizard. Or even finding verbs that run with wizard permissions that shouldn't be.";
set_task_perms(player);
if (!dobjstr)
tasks = queued_tasks();
elseif ((dobjstr == "all wizards") && player.wizard)
tasks = {};
for t in (queued_tasks())
if (valid(t[5]) && t[5].wizard)
tasks = {@tasks, t};
endif
$command_utils:suspend_if_needed(1);
endfor
elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
elseif (typeof(tasks = $wiz_utils:queued_tasks(dobj)) != LIST)
player:notify(tostr(verb, " ", dobj.name, "(", dobj, "):  ", tasks));
return;
endif
if (tasks)
su = $string_utils;
player:notify("Queue ID    Start Time            Owner         Verb (Line) [This]");
player:notify("--------    ----------            -----         -----------------");
now = time();
for task in (tasks)
$command_utils:suspend_if_needed(0);
{q_id, start, nu, nu2, owner, vloc, vname, lineno, this, ?size = 0} = task;
time = (start >= now) ? ctime(start)[5..24] | su:left((start == -1) ? "Reading input ..." | tostr(now - start, " seconds ago..."), 20);
owner_name = valid(owner) ? owner.name | tostr("Dead ", owner);
player:notify(tostr(su:left(tostr(q_id), 10), "  ", time, "  ", su:left(owner_name, 12), "  ", vloc, ":", vname, " (", lineno, ")", (this != vloc) ? tostr(" [", this, "]") | ""));
if (stack = `task_stack(q_id, 1) ! E_INVARG => 0')
for frame in (listdelete(stack, 1))
{sthis, svname, sprogger, svloc, splayer, slineno} = frame;
player:notify(tostr("                    Called By...  ", su:left(valid(sprogger) ? sprogger.name | tostr("Dead ", sprogger), 12), "  ", svloc, ":", svname, (sthis != svloc) ? tostr(" [", sthis, "]") | "", " (", slineno, ")"));
endfor
endif
endfor
player:notify("-----------------------------------------------------------------");
else
player:notify("No tasks.");
endif
.
#58:34
"Usage: @properties <object>";
"Alias: @props";
"Displays all properties defined on <object>. Properties unreadable by you display as `E_PERM'.";
if (player != this)
return player:tell(E_PERM);
endif
set_task_perms(player);
ob = this:my_match_object(argstr);
if (!$command_utils:object_match_failed(ob, argstr))
this:notify(tostr(";properties(", $code_utils:corify_object(ob), ") => ", toliteral($object_utils:accessible_props(ob))));
endif
"Last modified Mon Nov 28 06:21:21 2005 PST, by Roebare (#109000).";
.
#58:35
"I never, ever remember how to add to option packages. So here we are.";
if (!player.programmer)
return E_PERM;
endif
set_task_perms(player);
package = player:my_match_object(iobjstr);
if ((package == $failed_match) || (isa(package, $generic_options) == 0))
return player:tell("You need to specify an option package.");
elseif (dobjstr in package.names)
return player:tell("That option already exists.");
elseif ((!player.wizard) && (package.owner != player))
return player:tell("You don't own that option package.");
else
dobjstr = strsub(dobjstr, " ", "_");
player:tell("What text is displayed when the option is DISABLED?");
text = {$command_utils:read()};
player:tell("What text is displayed when the option is ENABLED?");
text = {@text, $command_utils:read()};
package:add_name(dobjstr);
add_property(package, tostr("show_", dobjstr), text, {player, "rc"});
player:tell("Option added!");
endif
.
#58:36
if (player != this)
return E_PERM;
endif
set_task_perms(player);
OBJ = player:my_match_object(argstr);
return player:tell($string_utils:nn(OBJ), " => ", $code_utils:corify_object(OBJ));
.
#58:37
if (!player.programmer)
return E_PERM;
endif
set_task_perms(player);
package = player:my_match_object(iobjstr);
dobjstr = strsub(dobjstr, " ", "_");
if ((package == $failed_match) || (isa(package, $generic_options) == 0))
return player:tell("You need to specify an option package.");
elseif ((dobjstr in package.names) == 0)
return player:tell("'", dobjstr, " isn't an option on ", $su:nn(package), ".");
elseif ((!player.wizard) && (package.owner != player))
return player:tell("You don't own that option package.");
else
if ($cu:yes_or_no(tostr("Really delete option '", dobjstr, " from ", $su:nn(package), "?")) == 1)
package:remove_name(dobjstr);
delete_property(package, tostr("show_", dobjstr));
player:tell("Option removed.");
else
player:tell("Aborted.");
endif
endif
.
#58:38
"Display ToastStunt commits.";
sourcedata = server_version("source");
current_commit = sourcedata["commit" in slice(sourcedata)][2];
last_commits = parse_json($string_utils:strip_binary(curl("https://api.github.com/repos/lisdude/toaststunt/commits")));
commit_lst = {{"Author", "SHA", "Date", "Message"}};
for commit in (last_commits)
is_current_commit = commit["sha"] == current_commit[1..$ - 1];
author = ((commit["commit"]["author"]["name"] + " (") + commit["commit"]["author"]["email"]) + ")";
message = commit["commit"]["message"];
if (line_End = index(message, "~0a"))
message = message[1..line_End - 1];
endif
sha = commit["sha"];
date = commit["commit"]["author"]["date"];
commit_lst = {@commit_lst, {(is_current_commit ? "[green]*[normal]" | "") + author, sha[1..6], date, message}};
endfor
player:tell_lines($string_utils:fit_to_screen(commit_lst, 2, 1));
player:tell();
player:tell("[green]*[normal] == The server is presently compiled from this commit.");
.
#59:0
":eval_d(code...) => {compiled?,result}";
"This works exactly like the builtin eval() except that the code is evaluated ";
"as if the d flag were unset.";
code = {"set_verb_code(this,\"eval_d_util\",{\"\\\"Do not remove this verb!  This is an auxiliary verb for :eval_d().\\\";\"});", "dobj=iobj=this=#-1;", "dobjstr=iobjstr=prepstr=argstr=verb=\"\";", tostr("caller=", caller, ";"), "set_task_perms(caller_perms());", @args};
if (!caller_perms().programmer)
return E_PERM;
elseif ((caller_perms() == $no_one) && $no_one:bad_eval(tostr(@args)))
return E_PERM;
elseif (svc = set_verb_code(this, "eval_d_util", code))
lines = {};
for line in (svc)
if ((index(line, "Line ") == 1) && (n = toint(line[6..(colon = index(line + ":", ":")) - 1])))
lines = {@lines, tostr("Line ", n - 5, line[colon..$])};
else
lines = {@lines, line};
endif
endfor
return {0, lines};
else
set_task_perms(caller_perms());
return {1, this:eval_d_util()};
endif
.
#59:1
":toint(STR)";
"=> toint(s) if STR is numeric";
"=> E_TYPE if it isn't";
return match(s = args[1], "^ *[-+]?[0-9]+ *$") ? toint(s) | E_TYPE;
.
#59:2
":toobj(objectid as string) => objectid";
return match(s = args[1], "^ *#[-+]?[0-9]+ *$") ? toobj(s) | E_TYPE;
.
#59:3
"toerr(n), toerr(\"E_FOO\"), toerr(\"FOO\") => E_FOO.";
if (typeof(s = args[1]) != STR)
n = toint(s) + 1;
if (n > length(this.error_list))
return 1;
endif
elseif (!(n = (s in this.error_names) || (("E_" + s) in this.error_names)))
return 1;
endif
return this.error_list[n];
.
#59:4
"error_name(E_FOO) => \"E_FOO\"";
return toliteral(@args);
return this.error_names[toint(args[1]) + 1];
.
#59:5
set_task_perms(caller_perms());
{object, ?what = {"props", "verbs"}} = args;
player:notify(tostr("Object ID:  ", object));
player:notify(tostr("Name:       ", object.name));
names = {"Parent", "Location", "Owner"};
vals = {parent(object), object.location, object.owner};
for i in [1..length(vals)]
if (!valid(vals[i]))
val = "*** NONE ***";
else
val = ((vals[i].name + " (") + tostr(vals[i])) + ")";
endif
player:notify(tostr(names[i], ":      "[1..12 - length(names[i])], val));
endfor
line = "Flags:     ";
if (is_player(object))
line = line + " player";
endif
for flag in ({"programmer", "wizard", "r", "w", "f"})
if (object.(flag))
line = (line + " ") + flag;
endif
endfor
player:notify(line);
if (player.programmer && ((player.wizard || (player == object.owner)) || object.r))
if (("verbs" in what) && (vs = verbs(object)))
player:notify("Verb definitions:");
for v in (vs)
$command_utils:suspend_if_needed(0);
player:notify(tostr("    ", v));
endfor
endif
if ("props" in what)
if (ps = properties(object))
player:notify("Property definitions:");
for p in (ps)
$command_utils:suspend_if_needed(0);
player:notify(tostr("    ", p));
endfor
endif
all_props = $object_utils:all_properties(object);
if (all_props != {})
player:notify("Properties:");
for p in (all_props)
$command_utils:suspend_if_needed(0);
strng = `toliteral(object.(p)) ! E_PERM => "(Permission denied.)"';
player:notify(tostr("    ", p, ": ", strng));
endfor
endif
endif
elseif (player.programmer)
player:notify("** Can't list properties or verbs: permission denied.");
endif
if (object.contents)
player:notify("Contents:");
for o in (object.contents)
$command_utils:suspend_if_needed(0);
player:notify(tostr("    ", o.name, " (", o, ")"));
endfor
endif
.
#59:6
set_task_perms(caller_perms());
{object, pname} = args;
if (pname in this.builtin_props)
player:notify(tostr(object, ".", pname));
player:notify("Built-in property.");
else
try
{owner, perms} = property_info(object, pname);
except error (ANY)
player:notify(error[2]);
return;
endtry
player:notify(tostr(object, ".", pname));
player:notify(tostr("Owner:        ", valid(owner) ? tostr(owner.name, " (", owner, ")") | "*** NONE ***"));
player:notify(tostr("Permissions:  ", perms));
endif
player:notify(tostr("Value:        ", $string_utils:print(object.(pname))));
.
#59:7
set_task_perms(caller_perms());
{object, vname} = args;
if (!(hv = $object_utils:has_verb(object, vname)))
player:notify("That object does not define that verb.");
return;
elseif (hv[1] != object)
player:notify(tostr("Object ", object, " does not define that verb, but its ancestor ", hv[1], " does."));
object = hv[1];
endif
try
{owner, perms, names} = verb_info(object, vname);
except error (ANY)
player:notify(error[2]);
return;
endtry
arg_specs = verb_args(object, vname);
player:notify(tostr(object, ":", names));
player:notify(tostr("Owner:            ", valid(owner) ? tostr(owner.name, " (", owner, ")") | "*** NONE ***"));
player:notify(tostr("Permissions:      ", perms));
player:notify(tostr("Direct Object:    ", arg_specs[1]));
player:notify(tostr("Preposition:      ", arg_specs[2]));
player:notify(tostr("Indirect Object:  ", arg_specs[3]));
.
#59:8
if (args[4..5] == {"none", "this"})
return 0;
endif
{thisobj, verb, adobj, aprep, aiobj} = args;
prep_part = (aprep == "any") ? "to" | this:short_prep(aprep);
".........`any' => `to' (arbitrary),... `none' => empty string...";
if ((adobj == "this") && (dobj == thisobj))
dobj_part = dobjstr;
iobj_part = ((!prep_part) || (aiobj == "none")) ? "" | ((aiobj == "this") ? dobjstr | iobjstr);
elseif ((aiobj == "this") && (iobj == thisobj))
dobj_part = (adobj == "any") ? dobjstr | ((adobj == "this") ? iobjstr | "");
iobj_part = iobjstr;
elseif (!("this" in args[3..5]))
dobj_part = (adobj == "any") ? dobjstr | "";
iobj_part = (prep_part && (aiobj == "any")) ? iobjstr | "";
else
return 0;
endif
return tostr(verb, dobj_part ? " " + dobj_part | "", prep_part ? " " + prep_part | "", iobj_part ? " " + iobj_part | "");
.
#59:9
"returns the permissions of the current verb (either the owner or the result of the most recent set_task_perms()).";
return caller_perms();
.
#59:10
"returns the object where the current verb is defined.";
return callers()[1][4];
.
#59:11
":verb_documentation([object,verbname]) => documentation at beginning of verb code, if any";
"default is the calling verb";
set_task_perms(caller_perms());
c = callers()[1];
{?object = c[4], ?vname = c[2]} = args;
try
code = verb_code(object, vname);
except error (ANY)
return error[2];
endtry
doc = {};
for line in (code)
if (match(line, "^\"%([^\\\"]%|\\.%)*\";$"))
"... now that we're sure `line' is just a string, eval() is safe...";
doc = {@doc, $no_one:eval("; return " + line)[2]};
else
return doc;
endif
endfor
return doc;
.
#59:12
":set_verb_documentation(object,verbname,text)";
"  changes documentation at beginning of verb code";
"  text is either a string or a list of strings";
"  returns a non-1 value if anything bad happens...";
set_task_perms(caller_perms());
{object, vname, text} = args;
if (typeof(code = `verb_code(object, vname) ! ANY') == ERR)
return code;
elseif (typeof(vd = $code_utils:verb_documentation(object, vname)) == ERR)
return vd;
elseif (!(typeof(text) in {LIST, STR}))
return E_INVARG;
else
newdoc = {};
for l in ((typeof(text) == LIST) ? text | {text})
if (typeof(l) != STR)
return E_INVARG;
endif
newdoc = {@newdoc, $string_utils:print(l) + ";"};
endfor
if (ERR == typeof(svc = `set_verb_code(object, vname, {@newdoc, @code[length(vd) + 1..$]}) ! ANY'))
"... this shouldn't happen.  I'm not setting this code -d just yet...";
return svc;
else
return 1;
endif
endif
.
#59:13
"$code_utils:parse_propref(string)";
"Parses string as a MOO-code property reference, returning {object-string, prop-name-string} for a successful parse and false otherwise.  It always returns the right object-string to pass to, for example, this-room:match_object.";
s = args[1];
if (dot = index(s, "."))
object = s[1..dot - 1];
prop = s[dot + 1..$];
if ((object == "") || (prop == ""))
return 0;
elseif (object[1] == "$")
ob = `#0.(object[2..$]) ! ANY';
if (typeof(ob) != OBJ)
"Try a map...";
ob = $code_utils:parse_sysobj_map(object);
endif
if (typeof(ob) != OBJ)
return 0;
endif
object = tostr(ob);
endif
elseif (index(s, "$") == 1)
object = "#0";
prop = s[2..$];
else
return 0;
endif
return {object, prop};
.
#59:14
"$code_utils:parse_verbref(string)";
"Parses string as a MOO-code verb reference, returning {object-string, verb-name-string} for a successful parse and false otherwise.  It always returns the right object-string to pass to, for example, this-room:match_object().";
s = args[1];
if (colon = index(s, ":"))
object = s[1..colon - 1];
verbname = s[colon + 1..$];
if (!(object && verbname))
return 0;
elseif (object[1] == "$")
pname = object[2..$];
if ((!(pname in properties(#0))) || (typeof(ob = #0.(pname)) != OBJ))
"Try a map...";
ob = $code_utils:parse_sysobj_map(object);
endif
if (typeof(ob) != OBJ)
return 0;
endif
object = tostr(ob);
endif
return {object, verbname};
elseif ((index(s, "$") == 1) && (!index(s, ".")))
return {"#0", s[2..$]};
else
return 0;
endif
.
#59:15
":parse_arg_spec(@args)";
"  attempts to parse the given sequence of args into a verb_arg specification";
"returns {verb_args,remaining_args} if successful.";
"  e.g., :parse_arg_spec(\"this\",\"in\",\"front\",\"of\",\"any\",\"foo\"..)";
"           => {{\"this\",\"in front of\",\"any\"},{\"foo\"..}}";
"returns a string error message if parsing fails.";
nargs = length(args);
if (nargs < 1)
return {{}, {}};
elseif ((ds = args[1]) == "tnt")
return {{"this", "none", "this"}, listdelete(args, 1)};
elseif (!(ds in {"this", "any", "none"}))
return tostr("\"", ds, "\" is not a valid direct object specifier.");
elseif ((nargs < 2) || (args[2] in {"none", "any"}))
verbargs = args[1..min(3, nargs)];
rest = args[4..nargs];
elseif (!(gp = $code_utils:get_prep(@args[2..nargs]))[1])
return tostr("\"", args[2], "\" is not a valid preposition.");
else
verbargs = {ds, @gp[1..min(2, nargs = length(gp))]};
rest = gp[3..nargs];
endif
if ((length(verbargs) >= 3) && (!(verbargs[3] in {"this", "any", "none"})))
return tostr("\"", verbargs[3], "\" is not a valid indirect object specifier.");
endif
return {verbargs, rest};
.
#59:16
if (server_version() != this._version)
this:_fix_preps();
endif
return this.prepositions;
.
#59:17
":short_prep(p) => shortest preposition equivalent to p";
"p may be a single word or one of the strings returned by verb_args().";
if (server_version() != this._version)
this:_fix_preps();
endif
word = args[1];
word = word[1..index(word + "/", "/") - 1];
if (p = word in this._other_preps)
return this._short_preps[this._other_preps_n[p]];
elseif (word in this._short_preps)
return word;
else
return "";
endif
.
#59:18
if (server_version() != this._version)
this:_fix_preps();
endif
prep = args[1];
if (p = prep in this._short_preps)
return this.prepositions[p];
elseif (p = prep in this._other_preps)
return this.prepositions[this._other_preps_n[p]];
else
return "";
endif
.
#59:19
":get_prep(@args) extracts the prepositional phrase from the front of args, returning a list consisting of the preposition (or \"\", if none) followed by the unused args.";
":get_prep(\"in\",\"front\",\"of\",...) => {\"in front of\",...}";
":get_prep(\"inside\",...)          => {\"inside\",...}";
":get_prep(\"frabulous\",...}       => {\"\", \"frabulous\",...}";
prep = "";
allpreps = {@this._short_preps, @this._other_preps};
rest = 1;
for i in [1..length(args)]
accum = (i == 1) ? args[1] | tostr(accum, " ", args[i]);
if (accum in allpreps)
prep = accum;
rest = i + 1;
endif
if (!(accum in this._multi_preps))
return {prep, @args[rest..$]};
endif
endfor
return {prep, @args[rest..$]};
.
#59:20
":_fix_preps() updates the properties on this having to do with prepositions.";
"_fix_preps should be called whenever we detect that a new server version has been installed.";
orig_args = verb_args(this, verb);
multis = nothers = others = shorts = longs = {};
i = 0;
while (typeof(`set_verb_args(this, verb, {"this", tostr(i), "this"}) ! ANY') != ERR)
l = verb_args(this, verb)[2];
all = $string_utils:explode(l, "/");
s = all[1];
for p in (listdelete(all, 1))
if (length(p) <= length(s))
s = p;
endif
endfor
for p in (all)
while (j = rindex(p, " "))
multis = {p = p[1..j - 1], @multis};
endwhile
endfor
longs = {@longs, l};
shorts = {@shorts, s};
others = {@others, @setremove(all, s)};
nothers = {@nothers, @$list_utils:make(length(all) - 1, length(shorts))};
i = i + 1;
endwhile
set_verb_args(this, verb, orig_args);
this.prepositions = longs;
this._short_preps = shorts;
this._other_preps = others;
this._other_preps_n = nothers;
this._multi_preps = multis;
this._version = server_version();
return;
.
#59:21
":find_verb_named(object,name[,n])";
"  returns the *number* of the first verb on object matching the given name.";
"  optional argument n, if given, starts the search with verb n,";
"  causing the first n verbs (1..n-1) to be ignored.";
"  0 is returned if no verb is found.";
"  This routine does not find inherited verbs.";
{object, name, ?start = 1} = args;
for i in [start..length(verbs(object))]
verbinfo = verb_info(object, i);
if (this:verbname_match(verbinfo[3], name))
return i;
endif
endfor
return 0;
.
#59:22
":find_last_verb_named(object,name[,n])";
"  returns the *number* of the last verb on object matching the given name.";
"  optional argument n, if given, starts the search with verb n-1,";
"  causing verbs (n..length(verbs(object))) to be ignored.";
"  -1 is returned if no verb is found.";
"  This routine does not find inherited verbs.";
{object, name, ?last = -1} = args;
if (last < 0)
last = length(verbs(object));
endif
for i in [0..last - 1]
verbinfo = verb_info(object, last - i);
if (this:verbname_match(verbinfo[3], name))
return last - i;
endif
endfor
return -1;
.
#59:23
":find_callable_verb_named(object,name[,n])";
"  returns the *number* of the first verb on object that matches the given";
"  name and has the x flag set.";
"  optional argument n, if given, starts the search with verb n,";
"  causing the first n verbs (0..n-1) to be ignored.";
"  0 is returned if no verb is found.";
"  This routine does not find inherited verbs.";
{object, name, ?start = 1} = args;
for i in [start..length(verbs(object))]
verbinfo = verb_info(object, i);
if (index(verbinfo[2], "x") && this:verbname_match(verbinfo[3], name))
return i;
endif
endfor
return 0;
.
#59:24
"$code_utils:find_verbs_containing(pattern[,object|object-list[,casematters]])";
"$code_utils:find_verbs_matching(pattern[,object|object-list[,casematters]])";
"$code_utils:find_verb_lines_containing(pattern[,object|object-list[,casematters]])";
"$code_utils:find_verb_lines_matching(pattern[,object|object-list[,casematters]])";
"";
"Print (to player) the name and owner of every verb in the database whose code";
"  (find_verbs_containing) contains PATTERN as a substring ";
"  (find_verbs_matching)   has a substring matches the regular expression PATTERN .";
"Optional second argument limits the search to the specified object or objects.";
"Optional third argument if true specifies case-sensitive matching.";
":find_verbs_*() prints the first matching line in a verb while";
":find_verb_lines_*() prints all matching lines";
"";
"Because it searches the entire database, this function may suspend the task several times before returning.";
"";
set_task_perms(caller_perms());
"... puts the task in a player's own job queue and prevents someone from learning about verbs that are otherwise unreadable to him/her.";
{pattern, ?where = 0, ?casematters = 0} = args;
count = 0;
_find_verbs = "_" + verb;
if (typeof(where) == INT)
for o in [toobj(where)..max_object()]
count = count + this:(_find_verbs)(pattern, o, casematters);
endfor
elseif (typeof(where) == LIST)
for o in (where)
count = count + this:(_find_verbs)(pattern, o, casematters);
endfor
else
"...typeof(where) == OBJ...";
count = this:(_find_verbs)(pattern, where, casematters);
endif
player:notify("");
player:notify(tostr("Total: ", count, " verb", (count != 1) ? "s." | "."));
.
#59:25
":_find_verbs_containing(pattern,object[,casematters])";
":_find_verbs_matching(regexp,object[,casematters])";
"number of verbs in object with code having a line containing pattern or matching regexp";
"prints verbname and offending line to player";
set_task_perms(caller_perms());
{pattern, o, ?casematters = 0} = args;
if ($command_utils:running_out_of_time())
player:notify(tostr("...", o));
suspend(0);
endif
if (!valid(o))
return 0;
endif
count = 0;
verbs = $object_utils:accessible_verbs(o);
_grep_verb_code = (verb == "_find_verbs_matching") ? "_egrep_verb_code" | "_grep_verb_code";
if (typeof(verbs) != LIST)
return player:notify(tostr("verbs(", o, ") => ", tostr(verbs)));
endif
for vnum in [1..length(verbs)]
if (l = this:(_grep_verb_code)(pattern, o, vnum, casematters))
owner = verb_info(o, vnum)[1];
player:notify(tostr(o, ":", verbs[vnum], " [", valid(owner) ? owner.name | "Recycled Player", " (", owner, ")]:  ", l));
count = count + 1;
endif
if ($command_utils:running_out_of_time())
player:notify(tostr("...", o));
suspend(0);
endif
endfor
return count;
.
#59:26
":_grep_verb_code(pattern,object,verbname[,casematters]) => line number or 0";
"  returns line number on which pattern occurs in code for object:verbname";
set_task_perms(caller_perms());
{pattern, object, vname, ?casematters = 0} = args;
"The following gross kluge is due to Quade (#82589).  tostr is fast, and so we can check for nonexistence of a pattern very quickly this way rather than checking line by line.  MOO needs a compiler.  --Nosredna";
vc = `verb_code(object, vname) ! ANY';
if ((typeof(vc) == ERR) || (!index(tostr(@vc), pattern, casematters)))
return 0;
else
for line in (vc)
if (index(line, pattern, casematters))
return line;
endif
endfor
return 0;
endif
.
#59:27
":_egrep_verb_code(regexp,object,verbname[,casematters]) => 0 or line number";
"  returns line number of first line matching regexp in object:verbname code";
set_task_perms(caller_perms());
{pattern, object, vname, ?casematters = 0} = args;
try
for line in (vc = `verb_code(object, vname) ! ANY => {}')
if (match(line, pattern, casematters))
return line;
endif
endfor
except (E_INVARG)
raise(E_INVARG, "Malformed regular expression.");
endtry
return 0;
.
#59:28
"Parse [from <start>] [to <end>] [for <name>].";
"Takes a series of strings, most likely @args with dobjstr removed.";
"Returns a list {INT start, INT end, STR name}, or {} if there is an error.";
fail = length(args) % 2;
start = 0;
end = toint(max_object());
match = "";
while (args && (!fail))
prep = args[1];
if (prep == "from")
if ((start = player.location:match_object(args[2])) >= #0)
start = toint(start);
else
start = toint(args[2]);
endif
elseif (prep == "to")
if ((end = player.location:match_object(args[2])) >= #0)
end = toint(end);
else
end = toint(args[2]);
endif
elseif (prep == "for")
match = args[2];
else
fail = 1;
endif
args = args[3..length(args)];
endwhile
return fail ? {} | {start, end, match};
.
#59:29
":help_db_list([player]) => list of help dbs";
"in the order that they are consulted by player";
{?who = player} = args;
olist = {who, @$object_utils:ancestors(who)};
if (valid(who.location))
olist = {@olist, who.location, @$object_utils:ancestors(who.location)};
endif
dbs = {};
for o in (olist)
h = `o.help ! ANY => 0';
if (typeof(h) == OBJ)
h = {h};
endif
if (typeof(h) == LIST)
for db in (h)
if ((typeof(db) == OBJ) && (valid(db) && (!(db in dbs))))
dbs = {@dbs, db};
endif
endfor
endif
endfor
return setadd(dbs, $help);
.
#59:30
":help_db_search(string,dblist)";
"  searches each of the help db's in dblist for a topic matching string.";
"  Returns  {db,topic}  or  {$ambiguous_match,{topic...}}  or {}";
{what, dblist} = args;
topics = {};
help = 1;
verb_help_match = 0;
for db in (dblist)
$command_utils:suspend_if_needed(0);
if ({what} == (ts = `db:find_topics(what) ! ANY => 0'))
if (db == $help_db["verb"])
"Verb help is considered a last resort. It's possible help files contain more relevant information (e.g. $login).";
verb_help_match = {db, ts[1]};
else
return {db, ts[1]};
endif
elseif (ts && (typeof(ts) == LIST))
if (help)
help = db;
endif
for t in (ts)
topics = setadd(topics, t);
endfor
endif
endfor
if (length(topics) > 1)
return {$ambiguous_match, topics};
elseif (topics)
return {help, topics[1]};
elseif (verb_help_match)
return verb_help_match;
else
return {};
endif
.
#59:31
":corify_object(object)  => string representing object";
"  usually just returns tostr(object), but in the case of objects that have";
"  corresponding #0 properties, return the appropriate $-string.";
object = args[1];
"Just in case #0 is !r on some idiot core.";
for p in (`properties(#0) ! ANY => {}')
"And if for some reason, some #0 prop is !r.";
if (`#0.(p) ! ANY' == object)
return "$" + p;
elseif (typeof(`#0.(p) ! ANY') == MAP)
for value, key in (#0.(p))
if (value == object)
return tostr("$", p, "[\"", key, "\"]");
endif
endfor
endif
endfor
return tostr(object);
.
#59:32
"See if the end of the string passed as args[1] ends 'inside' a doublequote.  Used by $code_utils:substitute.";
{string} = args;
quoted = 0;
while (i = index(string, "\""))
if ((!quoted) || ((i == 1) || (string[i - 1] != "\\")))
quoted = !quoted;
endif
string = string[i + 1..$];
endwhile
return quoted;
.
#59:33
"verb_or_property(<obj>, <name> [, @<args>])";
"Looks for a callable verb or property named <name> on <obj>.";
"If <obj> has a callable verb named <name> then return <obj>:(<name>)(@<args>).";
"If <obj> has a property named <name> then return <obj>.(<name>).";
"Otherwise return E_PROPNF, or E_PERM if you don't have permission to read the property.";
set_task_perms(caller_perms());
{object, name, @rest} = args;
return `object:(name)(@rest) ! E_VERBNF, E_INVIND => `object.(name) ! ANY'';
.
#59:34
"task_valid(INT id)";
"Return true iff there is currently a valid task with the given id.";
set_task_perms($no_one);
{id} = args;
t = $list_utils:slice(queued_tasks(), 1);
return ((id == task_id()) || (id in t)) || (E_PERM == `kill_task(id) ! ANY');
.
#59:35
":task_owner(INT task_id) => returns the owner of the task belonging to the id.";
if (a = $list_utils:assoc(args[1], queued_tasks()))
return a[5];
else
return E_INVARG;
endif
.
#59:36
":argstr(verb,args[,argstr]) => what argstr should have been.  ";
"Recall that the command line is parsed into a sequence of words; `verb' is";
"assigned the first word, `args' is assigned the remaining words, and argstr";
"is assigned a substring of the command line, which *should* be the one";
"starting first nonblank character after the verb, but is instead (because";
"the parser is BROKEN!) the one starting with the first nonblank character";
"after the first space in the line, which is not necessarily after the verb.";
"Clearly, if the verb contains spaces --- which can happen if you use";
"backslashes and quotes --- this loses, and argstr will then erroneously";
"have extra junk at the beginning.  This verb, given verb, args, and the";
"actual argstr, returns what argstr should have been.";
verb = args[1];
argstr = {@args, argstr}[3];
n = length(args = args[2]);
if (!index(verb, " "))
return argstr;
elseif (!args)
return "";
endif
"space in verb => two possible cases:";
"(1) first space was not in a quoted string.";
"    first word of argstr == rest of verb unless verb ended on this space.";
if ((nqargs = $string_utils:words(argstr)) == args)
return argstr;
elseif (((nqn = length(nqargs)) == (n + 1)) && (nqargs[2..nqn] == args))
return argstr[$string_utils:word_start(argstr)[2][1]..length(argstr)];
else
"(2) first space was in a quoted string.";
"    argstr starts with rest of string";
qs = $string_utils:word_start("\"" + argstr);
return argstr[qs[(length(qs) - length(args)) + 1][1] - 1..length(argstr)];
endif
.
#59:37
":verbname_match(fullverbname,name) => TRUE iff `name' is a valid name for a verb with the given `fullname'";
verblist = (" " + args[1]) + " ";
if (index(verblist, (" " + (name = args[2])) + " ") && (!(index(name, "*") || index(name, " "))))
"Note that if name has a * or a space in it, then it can only match one of the * verbnames";
return 1;
else
namelen = length(name);
while (star = index(verblist, "*"))
vstart = rindex(verblist[1..star], " ") + 1;
vlast = (vstart + index(verblist[vstart..$], " ")) - 2;
if ((namelen >= (star - vstart)) && ((!(v = strsub(verblist[vstart..vlast], "*", ""))) || (index(v, (verblist[vlast] == "*") ? name[1..min(namelen, length(v))] | name) == 1)))
return 1;
endif
verblist = verblist[vlast + 1..$];
endwhile
endif
return 0;
.
#59:38
"$code_utils:substitute(string,subs) => new line";
"Subs are a list of lists, {{\"target\",\"sub\"},{...}...}";
"Substitutes targets for subs in a delimited string fashion, avoiding substituting anything inside quotes, e.g. player:tell(\"don't sub here!\")";
{s, subs} = args;
lets = "abcdefghijklmnopqrstuvwxyz0123456789";
for x in (subs)
len = length(sub = x[1]);
delimited = index(lets, sub[1]) && index(lets, sub[len]);
prefix = "";
while (i = index(s, sub))
prefix = prefix + s[1..i - 1];
if ((((prefix == "") || ((!delimited) || (!index(lets, prefix[$])))) && ((!delimited) || (((i + len) > length(s)) || (!index(lets, s[i + len]))))) && (!this:inside_quotes(prefix)))
prefix = prefix + x[2];
else
prefix = prefix + s[i..(i + len) - 1];
endif
s = s[i + len..length(s)];
endwhile
s = prefix + s;
endfor
return s;
.
#59:39
":show_who_listing(players[,more_players])";
" prints a listing of the indicated players.";
" For players in the first list, idle/connected times are shown if the player is logged in, otherwise the last_disconnect_time is shown.  For players in the second list, last_disconnect_time is shown, no matter whether the player is logged in.";
{plist, ?more_plist = {}} = args;
idles = itimes = offs = otimes = {};
argstr = dobjstr = iobjstr = prepstr = "";
for p in (more_plist)
if (!valid(p))
caller:notify(tostr(p, " <invalid>"));
elseif (typeof(t = `p.last_disconnect_time ! E_PROPNF') == INT)
if (!(p in offs))
offs = {@offs, p};
otimes = {@otimes, {-t, -t, p}};
endif
elseif (is_player(p))
caller:notify(tostr(p.name, " (", p, ") ", (t == E_PROPNF) ? "is not a $player." | "has a garbled .last_disconnect_time."));
else
caller:notify(tostr(p.name, " (", p, ") is not a player."));
endif
endfor
for p in (plist)
if (p in offs)
elseif (!valid(p))
caller:notify(tostr(p, " <invalid>"));
elseif (typeof(i = `idle_seconds(p) ! ANY') != ERR)
if (!(p in idles))
idles = {@idles, p};
itimes = {@itimes, {i, connected_seconds(p), p}};
endif
elseif (typeof(t = `p.last_disconnect_time ! E_PROPNF') == INT)
offs = {@offs, p};
otimes = {@otimes, {-t, -t, p}};
elseif (is_player(p))
caller:notify(tostr(p.name, " (", p, ") not logged in.", (t == E_PROPNF) ? "  Not a $player." | "  Garbled .last_disconnect_time."));
else
caller:notify(tostr(p.name, " (", p, ") is not a player."));
endif
endfor
if (!(idles || offs))
return 0;
endif
idles = $list_utils:sort_alist(itimes);
offs = $list_utils:sort_alist(otimes);
"...";
"... calculate widths...";
"...";
headers = {"Player name", @idles ? {"Connected", "Idle time"} | {"Last disconnect time", ""}, "Location"};
total_width = `caller:linelen() ! ANY => 0' || 79;
max_name = total_width / 4;
name_width = length(headers[1]);
names = locations = {};
for lst in ({@idles, @offs})
$command_utils:suspend_if_needed(0);
p = lst[3];
namestr = tostr(p.name[1..min(max_name, $)], " (", p, ")");
name_width = max(length(namestr), name_width);
names = {@names, namestr};
if (typeof(wlm = `p.location:who_location_msg(p) ! ANY') != STR)
wlm = valid(p.location) ? p.location.name | tostr("** Nowhere ** (", p.location, ")");
endif
locations = {@locations, wlm};
endfor
time_width = 3 + (offs ? 12 | length("59 minutes"));
before = {0, w1 = 3 + name_width, w2 = w1 + time_width, w2 + time_width};
"...";
"...print headers...";
"...";
su = $string_utils;
tell1 = headers[1];
tell2 = su:space(tell1, "-");
for j in [2..4]
tell1 = su:left(tell1, before[j]) + headers[j];
tell2 = su:left(tell2, before[j]) + su:space(headers[j], "-");
endfor
caller:notify(tell1[1..min($, total_width)]);
caller:notify(tell2[1..min($, total_width)]);
"...";
"...print lines...";
"...";
active = 0;
for i in [1..total = (ilen = length(idles)) + length(offs)]
if (i <= ilen)
lst = idles[i];
if (lst[1] < (5 * 60))
active = active + 1;
endif
l = {names[i], su:from_seconds(lst[2]), su:from_seconds(lst[1]), locations[i]};
else
lct = offs[i - ilen][3].last_connect_time;
ldt = offs[i - ilen][3].last_disconnect_time;
ctime = `caller:ctime(ldt) ! ANY => 0' || ctime(ldt);
l = {names[i], (lct <= time()) ? ctime | "Never", "", locations[i]};
if ((i == (ilen + 1)) && idles)
caller:notify(su:space(before[2]) + "------- Disconnected -------");
endif
endif
tell1 = l[1];
for j in [2..4]
tell1 = su:left(tell1, before[j]) + l[j];
endfor
caller:notify(tell1[1..min($, total_width)]);
if ($command_utils:running_out_of_time())
if ($login:is_lagging())
"Check lag two ways---global lag, but we might still fail due to individual lag of the queue this runs in, so check again later.";
caller:notify(tostr("Plus ", total - i, " other players (", total, " total; out of time and lag is high)."));
return;
endif
now = time();
suspend(0);
if ((time() - now) > 10)
caller:notify(tostr("Plus ", total - i, " other players (", total, " total; out of time and lag is high)."));
return;
endif
endif
endfor
"...";
"...epilogue...";
"...";
caller:notify("");
if (total == 1)
active_str = ", who has" + ((active == 1) ? "" | " not");
else
if (active == total)
active_str = (active == 2) ? "s, both" | "s, all";
elseif (active == 0)
active_str = "s, none";
else
active_str = tostr("s, ", active);
endif
active_str = tostr(active_str, " of whom ha", (active == 1) ? "s" | "ve");
endif
caller:notify(tostr("Total: ", total, " player", active_str, " been active recently."));
return total;
.
#59:40
":_egrep_verb_code_all(regexp,object,verbname[,casematters]) => list of lines number";
"  returns list of all lines matching regexp in object:verbname code";
set_task_perms(caller_perms());
{pattern, object, vname, ?casematters = 0} = args;
lines = {};
for line in (vc = `verb_code(object, vname, 1, 0) ! ANY => {}')
if (match(line, pattern, casematters))
lines = {@lines, line};
endif
endfor
return lines;
.
#59:41
":_grep_verb_code_all(pattern,object,verbname[,casematters]) => list of lines";
"  returns list of lines on which pattern occurs in code for object:verbname";
set_task_perms(caller_perms());
{pattern, object, vname, ?casematters = 0} = args;
lines = {};
for line in (vc = `verb_code(object, vname) ! ANY => {}')
if (index(line, pattern, casematters))
lines = {@lines, line};
endif
endfor
return lines;
.
#59:42
":verb_usage([object,verbname]) => usage string at beginning of verb code, if any";
"default is the calling verb";
set_task_perms(caller_perms());
c = callers()[1];
{?object = c[4], ?vname = c[2]} = args;
if (typeof(code = `verb_code(object, vname) ! ANY') == ERR)
return code;
else
doc = {};
indent = "^$";
for line in (code)
if (match(line, "^\"%([^\\\"]%|\\.%)*\";$"))
"... now that we're sure `line' is just a string, eval() is safe...";
e = $no_one:eval(line)[2];
if (subs = match(e, "^%(%(Usage%|Syntax%): +%)%([^ ]+%)%(.*$%)"))
"Server is broken, hence the next three lines:";
if (subs[3][4][1] > subs[3][4][2])
subs[3][4] = {0, -1};
endif
indent = ("^%(" + $string_utils:space(length(substitute("%1", subs)))) + " *%)%([^ ]+%)%(.*$%)";
docverb = substitute("%3", subs);
if (match(vname, "^[0-9]+$"))
vname = docverb;
endif
doc = {@doc, (substitute("%1", subs) + vname) + substitute("%4", subs)};
elseif (subs = match(e, indent))
if (substitute("%3", subs) == docverb)
doc = {@doc, (substitute("%1", subs) + vname) + substitute("%4", subs)};
else
doc = {@doc, e};
endif
elseif (indent)
return doc;
endif
else
return doc;
endif
endfor
return doc;
endif
.
#59:43
"returns the callers() frame for the current verb.";
return callers()[1];
.
#59:44
"returns {this:verb_frame(), @callers()}.";
return callers();
.
#59:45
":move_verb(OBJ from, STR verb name, OBJ to, [STR new verb name]) -> Moves the specified verb from one object to another. Returns {OBJ, Full verb name} where the verb now resides if successful, error if not. To succeed, caller_perms() must control both objects and own the verb, unless called with wizard perms. Supplying a fourth argument moves the verb to a new name.";
"Should handle verbnames with aliases and wildcards correctly.";
who = caller_perms();
{from, origverb, to, ?destverb = origverb} = args;
if ((((typeof(from) != OBJ) || (typeof(to) != OBJ)) || (typeof(origverb) != STR)) || (typeof(destverb) != STR))
"check this first so we can parse out long verb names next";
return E_TYPE;
endif
origverb_first = strsub(origverb[1..index(origverb + " ", " ") - 1], "*", "") || "*";
destverb_first = strsub(destverb[1..index(destverb + " ", " ") - 1], "*", "") || "*";
if ((!valid(from)) || (!valid(to)))
return E_INVARG;
elseif ((from == to) && (destverb == origverb))
"Moving same origverb onto the same object puts the verbcode in the wrong one. Just not allow";
return E_NACC;
elseif (((!$perm_utils:controls(who, from)) && (!from.w)) || ((!$perm_utils:controls(who, to)) && (!to.w)))
"caller_perms() is not allowed to hack on either object in question";
return E_PERM;
elseif (!$object_utils:defines_verb(from, origverb_first))
"verb is not defined on the from object";
return E_VERBNF;
elseif ((vinfo = verb_info(from, origverb_first)) && (!$perm_utils:controls(who, vinfo[1])))
"caller_perms() is not permitted to add a verb with the existing verb owner";
return E_PERM;
elseif (!who.programmer)
return E_PERM;
else
"we now know that the caller's perms control the objects or the objects are writable, and we know that the caller's perms control the prospective verb owner (by more traditional means)";
vcode = verb_code(from, origverb_first);
vargs = verb_args(from, origverb_first);
vinfo[3] = (destverb == origverb) ? vinfo[3] | destverb;
if (typeof(res = `add_verb(to, vinfo, vargs) ! ANY') == ERR)
return res;
else
set_verb_code(to, destverb_first, vcode);
delete_verb(from, origverb_first);
return {to, vinfo[3]};
endif
endif
.
#59:46
":move_prop(OBJ from, STR prop name, OBJ to, [STR new prop name]) -> Moves the specified property and its contents from one object to another. Returns {OBJ, property name} where the property now resides if successful, error if not. To succeed, caller_perms() must control both objects and own the property, unless called with wizard perms. Supplying a fourth argument gives the property a new name on the new object.";
who = caller_perms();
{from, origprop, to, ?destprop = origprop} = args;
if ((((typeof(from) != OBJ) || (typeof(to) != OBJ)) || (typeof(origprop) != STR)) || (typeof(destprop) != STR))
return E_TYPE;
elseif ((!valid(from)) || (!valid(to)))
return E_INVARG;
elseif ((from == to) && (destprop == origprop))
"Moving same prop onto the same object puts the contents in the wrong one. Just not allow";
return E_NACC;
elseif (((!$perm_utils:controls(who, from)) && (!from.w)) || ((!$perm_utils:controls(who, to)) && (!to.w)))
"caller_perms() is not allowed to hack on either object in question";
return E_PERM;
elseif (!$object_utils:defines_property(from, origprop))
"property is not defined on the from object";
return E_PROPNF;
elseif ((pinfo = property_info(from, origprop)) && (!$perm_utils:controls(who, pinfo[1])))
"caller_perms() is not permitted to add a property with the existing property owner";
return E_PERM;
elseif (!who.programmer)
return E_PERM;
else
"we now know that the caller's perms control the objects or the objects are writable, and we know that the caller's perms control the prospective property owner (by more traditional means)";
pdata = from.(origprop);
pname = (destprop == origprop) ? origprop | destprop;
if (typeof(res = `add_property(to, pname, pdata, pinfo) ! ANY') == ERR)
return res;
else
delete_property(from, origprop);
return {to, pname};
endif
endif
.
#59:47
"Do not remove this verb!  This is an auxiliary verb for :eval_d().";
.
#59:48
":display_callers([callers() style list]) - displays the output of the given argument, assumed to be a callers() output. See `help callers()' for details. Will use callers() explicitly if no argument is passed.";
call = (caller_perms() == player) ? "notify_lines" | "tell_lines";
player:(call)(this:callers_text(@args));
.
#59:49
":callers_text([callers() style list]) - returns the output of the given argument, assumed to be a callers() output. See `help callers()' for details. Will use callers() explicitly if no argument is passed.";
linelen = min(player:linelen(), 200);
text = {};
su = $string_utils;
lu = $list_utils;
verbwidth = 0;
{?match = callers(1)} = args;
for verbitem in (lu:slice(match, 2))
verbwidth = max(verbwidth, length(verbitem));
endfor
verbwidth = 3 + verbwidth;
numwidth = ((linelen - verbwidth) / 4) - 1;
widths = {numwidth, verbwidth, numwidth, numwidth, numwidth};
top = l = between = "";
for x in [1..5]
top = (top + between) + su:left({"This", "Verb", "Permissions", "VerbLocation", "Player"}[x], -widths[x]);
l = (l + between) + su:space(widths[x], "-");
between = " ";
endfor
text = listappend(text, top);
text = listappend(text, l);
for line in (match)
output = {};
for bit in [1..5]
$command_utils:suspend_if_needed(3);
"bit == 2 below for verb: append line number.";
output = {@output, su:left((typeof(word = line[bit]) == STR) ? (bit == 2) ? tostr(word, "(", `line[6] ! ANY => 0', ")") | word | tostr(word, "(", valid(word) ? lu:shortest({word.name, @word.aliases}) | ((word == $nothing) ? "invalid" | ((word == $ambiguous_match) ? "ambiguous match" | "Error")), ")"), -widths[bit]), " "};
endfor
text = listappend(text, su:trimr(tostr(@output)));
endfor
text = listappend(text, l);
return text;
.
#59:50
":set_property_value(object, property, value)";
" set_verb_or_property(same) -- similar to `verb_or_property'";
"  -- attempts to set <object>.<property> to <value>.  If there exists <object>:set_<property>, then it is called and its returned value is returned.  If not, we try to set the property directly; the result of this is returned.";
set_task_perms(caller_perms());
if (length(args) != 3)
return E_ARGS;
elseif (typeof(o = args[1]) != OBJ)
return E_INVARG;
elseif (!$recycler:valid(o))
return E_INVIND;
elseif (typeof(p = args[2]) != STR)
return E_INVARG;
elseif ($object_utils:has_callable_verb(o, v = "set_" + p))
return o:(v)(args[3]);
else
return o.(p) = args[3];
endif
.
#59:51
"$code_utils:owns_task(task_id, who)";
"The purpose of this is to be faster than $code_utils:task_owner(task_id) in those cases where you are interested in whether a certain person owns the task rather than in determining the owner of a task where you have no preconceived notion of the owner.";
return $list_utils:assoc(args[1], $wiz_utils:queued_tasks(args[2]));
.
#59:52
"Syntax:  $code_utils:dflag_on()   => 0|1";
"";
"Returns true if the verb calling the verb that called this verb has the `d' flag set true. Returns false if it is !d. If there aren't that many callers, or the calling verb was a builtin such as eval, assume the debug flag is on for traceback purposes and return true.";
"This is useful for determining whether the calling verb should return or raise an error to the verb that called it.";
return (length(c = callers()) >= 2) ? `index(verb_info(c[2][4], c[2][2])[2], "d") && 1 ! E_INVARG => 1' | 1;
.
#59:53
"type_str -- returns a string describing the type of args[1]";
x = args[1];
type_data = {1, 3.14, "", #0, E_NONE, {}};
type_strs = {"INT", "FLOAT", "STR", "OBJ", "ERR", "LIST"};
for i in [1..length(type_data)]
if (typeof(type_data[i]) == typeof(x))
return type_strs[i];
endif
endfor
return "NONE";
.
#59:54
":dump_properties (object, create_flag): returns the list of strings representing the property information for this object and its ancestor objects in @dump format.";
set_task_perms(caller_perms());
{dobj, create, ?targname = tostr(dobj)} = args;
result = {};
for p in (`properties(dobj) ! ANY => {}')
pquoted = toliteral(p);
try
info = property_info(dobj, p);
value = dobj.(p);
except error (ANY)
result = {@result, tostr("\"", targname, ".(", pquoted, ") => ", toliteral(error[1]), " (", error[2], ")")};
continue p;
endtry
if (create)
uvalue = (typeof(value) == LIST) ? "{}" | 0;
result = {@result, tostr("@prop ", targname, ".", pquoted, " ", uvalue || toliteral(value), " ", info[2] || "\"\"", (info[1] == dobj.owner) ? "" | tostr(" ", info[1]))};
if (uvalue && value)
result = {@result, tostr(";;", targname, ".(", pquoted, ") = ", toliteral(value))};
endif
else
if (info[2] != "rc")
result = {@result, tostr("@chmod ", targname, ".", pquoted, " ", info[2])};
endif
if (info[1] != dobj.owner)
result = {@result, tostr("@chown ", targname, ".", pquoted, " ", info[1])};
endif
result = {@result, tostr(";;", targname, ".(", pquoted, ") = ", toliteral(value))};
endif
$command_utils:suspend_if_needed(0);
endfor
for a in ($object_utils:ancestors(dobj))
for p in (`properties(a) ! ANY => {}')
$command_utils:suspend_if_needed(1);
pquoted = toliteral(p);
try
value = dobj.(p);
except error (ANY)
result = {@result, tostr("\"", targname, ".(", pquoted, ") => ", toliteral(error[1]), " (", error[2], ")")};
continue p;
endtry
avalue = `a.(p) ! ANY';
if ((typeof(avalue) == ERR) || (value != avalue))
result = {@result, tostr(";;", targname, ".(", pquoted, ") = ", toliteral(value))};
endif
endfor
$command_utils:suspend_if_needed(1);
endfor
return result;
.
#59:55
":dump_preamble(object): produces the @create command necessary to dump this object.";
dobj = args[1];
parent = parent(dobj);
pstring = tostr(parent);
for p in (properties(#0))
if (#0.(p) == parent)
pstring = "$" + p;
endif
endfor
return tostr("@create ", pstring, " named ", dobj.name, ":", $string_utils:from_list(dobj.aliases, ","));
.
#59:56
":dump_verbs (object, create_flag): returns the list of strings representing the verb information for this object in @dump format.";
set_task_perms(caller_perms());
{dobj, create, ?targname = tostr(dobj)} = args;
result = {};
v = 1;
while ((info = `verb_info(dobj, v) ! ANY') || (info == E_PERM))
if (`index(info[3], "(old)") ! ANY' && 0)
"Thought about skipping (old) verbs...";
player:tell("Skipping ", dobj, ":\"", info[3], "\"...");
else
if (typeof(info) == ERR)
result = {@result, tostr("\"", dobj, ":", v, " --- ", info, "\";")};
else
if (i = index(vname = info[3], " "))
vname = vname[1..i - 1];
endif
if (vname[1] != "*")
vname = strsub(vname, "*", "");
endif
args = verb_args(dobj, v);
prep = (args[2] in {"any", "none"}) ? args[2] | $code_utils:short_prep(args[2]);
perms = (info[2] != ((args == {"this", "none", "this"}) ? "rxd" | "rd")) ? info[2] || "\"\"" | "";
if (create)
if (info[1] == dobj.owner)
tail = perms ? tostr(" ", perms) | "";
else
tail = tostr(" ", perms || info[2], " ", info[1]);
endif
result = {@result, tostr("@verb ", targname, ":\"", info[3], "\" ", args[1], " ", prep, " ", args[3], tail)};
else
result = {@result, tostr("@args ", targname, ":\"", info[3], "\" ", args[1], " ", prep, " ", args[3])};
if (info[1] != dobj.owner)
result = {@result, tostr("@chown ", targname, ":", vname, " ", info[1])};
endif
if (perms)
result = {@result, tostr("@chmod ", targname, ":", vname, " ", perms)};
endif
endif
if (code = verb_code(dobj, v, 1, 1))
result = {@result, tostr("@program ", targname, ":", vname), @code, ".", ""};
endif
endif
endif
if (`index(tostr(" ", info[3], " "), " * ") ! ANY')
"... we have a * verb.  may as well forget trying to list...";
"... the rest; they're invisible.  set v to something nonstring.";
v = E_TYPE;
else
v = v + 1;
endif
$command_utils:suspend_if_needed(0);
endwhile
return result;
.
#59:57
":_find_verb_lines_containing(pattern,object[,casematters])";
":_find_verb_lines_matching(regexp,object[,casematters])";
"number of verbs in object with code having a line containing pattern or matching regexp";
"prints verbname and all offending lines to player";
set_task_perms(caller_perms());
{pattern, o, ?casematters = 0} = args;
if ($command_utils:running_out_of_time())
player:notify(tostr("...", o));
suspend(0);
endif
if (!valid(o))
return 0;
endif
count = 0;
verbs = $object_utils:accessible_verbs(o);
if (typeof(verbs) != LIST)
return player:notify(tostr("verbs(", o, ") => ", tostr(verbs)));
endif
_grep_verb_code_all = (verb == "_find_verb_lines_matching") ? "_egrep_verb_code_all" | "_grep_verb_code_all";
for vnum in [1..length(verbs)]
found = 0;
for l in (this:(_grep_verb_code_all)(pattern, o, vnum, casematters))
owner = verb_info(o, vnum)[1];
player:notify(tostr(o, ":", verbs[vnum], " [", valid(owner) ? owner.name | "Recycled Player", " (", owner, ")]:  ", l));
found = 1;
$command_utils:suspend_if_needed(0);
endfor
if (found)
count = count + 1;
endif
if ($command_utils:running_out_of_time())
player:notify(tostr("...", o));
suspend(0);
endif
endfor
return count;
.
#59:58
"Usage:  commentify(lines)";
"";
"Given lines of text, translate them into comment strings and return the list.";
{lines} = args;
out = {};
for line in (lines)
out = {@out, $string_utils:print(line) + ";"};
endfor
return out;
.
#59:59
"$code_utils:parse_sysobj_map(string)";
"Attempt to parse a string into a map on $sysobj, allowing it to function as a poor man's namespace.";
"Returns E_PROPNF if no map could be matched or the value of the given key's value if successful.";
{string} = args;
set_task_perms(caller_perms());
if (string[1] == "$")
string = string[2..$];
endif
if ((ind = index(string, "[")) && (string[$] == "]"))
key = strsub(string[ind + 1..$ - 1], "\"", "");
"Let it work with \"key\" or key";
ob = `#0.(string[1..ind - 1])[key] ! ANY';
if (typeof(ob) != ERR)
return ob;
endif
endif
return E_PROPNF;
.
#59:60
" Usage:  uncommentify(lines)";
"";
" Given lines of comment code, translate them into text and return the list.";
set_task_perms($no_one);
{lines} = args;
out = {};
for line in (lines)
if (match(line, "^\"%([^\\\"]%|\\.%)*\";$"))
out = {@out, eval("return " + line)[2]};
else
return E_INVARG;
endif
endfor
return out;
.
#60:0
return $player.ownership_quota;
.
#60:1
return $prog.ownership_quota;
.
#60:2
text = pass(@args);
object = $string_utils:match_object(what = args[1], player.location);
if ((text != E_PROPNF) || (!valid(object)))
return text;
elseif (ohelp = `object:help_msg() ! ANY' || `object.help_msg ! ANY')
return {tostr(object.name, " (", object, "):"), "----", @(typeof(ohelp) == LIST) ? ohelp | {ohelp}};
else
about = $object_utils:has_verb(object, "about");
return {tostr("Sorry, but no help is available on ", object.name, " (", object, ")."), tostr("Try `examine ", what, "'", @about ? {" or `about ", what, "'"} | {}, ".")};
endif
.
#60:3
topiclist = pass(@args);
if (topiclist || (!args))
return topiclist;
elseif (valid(o = $string_utils:match_object(what = args[1], player.location)))
return {what};
else
return {};
endif
.
#60:4
text = {};
for db in ($code_utils:help_db_list())
if ($object_utils:has_callable_verb(db, "index"))
text = {@text, @db:index({tostr(db.name, " (", db, ")")})};
endif
endfor
return text;
.
#60:5
hdr = "Available Help Indices";
text = {"", hdr, $string_utils:space(hdr, "-")};
for db in ($code_utils:help_db_list())
try
for p in (db:find_index_topics())
text = {@text, tostr($string_utils:left(p, 14), " -- ", `db.(p)[2] ! ANY' || db.name, " (", db, ")")};
endfor
except (ANY)
"generally it will be E_TYPE when :find_index_topics returns an ERR. Just skip";
continue db;
endtry
endfor
if (full = this:find_full_index_topic())
text = {@text, "", tostr($string_utils:left(full, 14), " -- ", "EVERYTHING")};
endif
return text;
.
#60:6
wizzes = {};
for w in ($object_utils:leaves($wiz))
if (w.wizard && (w.advertised && is_player(w)))
wizzes = {@wizzes, w};
endif
endfor
wizzes = {#2, @$list_utils:randomly_permute(setremove(wizzes, #2))};
numwiz = length(wizzes);
hlist = {"ArchWizard:", "Wizard" + ((numwiz == 2) ? ":" | "s:"), @$list_utils:make(max(0, numwiz - 2), "")};
slist = {};
su = $string_utils;
for i in [1..numwiz]
wiz = wizzes[i];
slist = {@slist, tostr(su:left(hlist[i], 13), su:left(wiz.name, 16), (wpi = `wiz.public_identity.name ! ANY') ? (" (a.k.a. " + wpi) + ")" | "")};
endfor
return slist;
.
#60:7
if (((text = pass(@args)) != E_PROPNF) || ((!valid(object = $string_utils:match_object(what = args[1], player.location))) || (!$object_utils:has_property(object, "help_msg"))))
return text;
else
return {tostr(";;", $code_utils:corify_object(object), ".help_msg = $command_utils:read_lines()"), @$command_utils:dump_lines((typeof(text = object.help_msg) == LIST) ? text | {text})};
endif
.
#60:8
":find_full_index_topic([search])";
"Return the *full_index* topic or 0";
"If search argument is given and true, we don't depend on cached info.";
{?search = 0} = args;
"... N.B.  There is no cached info; it turns out that";
"... full-index is near enough to the beginning of $help's property list";
"... that there's no point to doing this.  --Rog";
for p in (`properties(this) ! E_PERM => {}')
if (`this.(p)[1] ! ANY' == "*full_index*")
return p;
endif
endfor
return 0;
.
#61:0
raw = ctime(this.last_news_time);
"         111111111122222";
"123456789012345678901234";
"Fri Nov 30 14:31:21 1990";
date = (raw[1..10] + ",") + raw[20..24];
return strsub(this.description, "%d", date);
.
#61:1
return pass(@args) || (args[1] in $list_utils:map_prop($object_utils:descendants($wiz), "mail_identity"));
.
#61:2
if (this:ok_write(caller, caller_perms()))
seq = args[1];
this.current_news_going = $seq_utils:intersection(this.current_news, seq);
this.current_news = $seq_utils:contract(this.current_news, seq);
return $mail_agent:(verb)(@args);
else
return E_PERM;
endif
.
#61:3
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
seq = $mail_agent:(verb)(@args);
this.current_news = $seq_utils:union(this.current_news_going, $seq_utils:expand(this.current_news, seq));
this.current_news_going = {};
return seq;
.
#61:4
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
this.current_news_going = {};
return $mail_agent:(verb)(@args);
.
#61:5
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
else
this.current_news = new = args[1];
if (new)
newlast = $seq_utils:last(new);
newlasttime = this:messages_in_seq(newlast)[2][1];
if (newlasttime > this.last_news_time)
"... only notify people if there exists a genuinely new item...";
this.last_news_time = newlasttime;
this:touch();
endif
else
"...flush everything...";
this.last_news_time = 0;
endif
endif
.
#61:6
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
else
return this:set_current_news($seq_utils:union(this.current_news, args[1]));
endif
.
#61:7
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
else
return this:set_current_news($seq_utils:intersection(this.current_news, $seq_utils:complement(args[1])));
endif
.
#61:8
":news_display_seq_full(msg_seq) => {cur, last-read-date}";
"Display the given msg_seq as a collection of news items";
set_task_perms(caller_perms());
desc = this:description();
player:notify((typeof(desc) == LIST) ? desc[1] | desc);
player:notify("");
msgs = this:messages_in_seq(args[1]);
for i in [-(n = length(msgs))..-1]
x = msgs[-i];
player:notify_lines(this:to_text(@x[2]));
player:notify("");
$command_utils:suspend_if_needed(0);
endfor
player:notify("(end)");
return {msgs[n][1], msgs[n][2][1]};
.
#61:9
":to_text(@msg) => message in text form -- formatted like a $news entry circa October, 1993";
date = args[1];
by = args[2];
"by = by[1..index(by, \"(\") - 2]";
subject = (args[4] == " ") ? "-*-NEWS FLASH-*-" | $string_utils:uppercase(args[4]);
text = args[("" in {@args, ""}) + 1..$];
ctime = $time_utils:time_sub("$D, $N $3, $Y", date);
return {ctime, subject, @text};
return {subject, tostr("  by ", by, " on ", ctime), "", @text};
.
#61:10
set_task_perms(caller_perms());
if ((player:get_current_message(this) || {0, 0})[2] < this.last_news_time)
if ((n = player:mail_option("news")) in {0, "all"})
player:tell("There is new news.  Type `news' to read all news or `news new' to read just new news.");
elseif (n == "contents")
player:tell("There is new news.  Type `news all' to read all news or `news new' to read just new news.");
elseif (n == "new")
player:tell("There is new news.  Type `news' to read new news, or `news all' to read all news.");
endif
endif
.
#61:11
if (!this:ok_write(caller, valid(who = caller_perms()) ? who | player))
player:notify("Permission denied.");
return;
endif
fork (0)
for p in (connected_players())
$command_utils:suspend_if_needed(0);
if ((p:get_current_message(this) || {0, 0})[2] < this.last_news_time)
p:notify("There's a new edition of the newspaper.  Type 'news new' to see the new article(s).");
endif
endfor
endfork
.
#61:12
if ((caller_perms() != #-1) && (caller_perms() != player))
raise(E_PERM);
endif
set_task_perms(player);
if (!this:is_writable_by(player))
player:notify("You can't write the news.");
elseif (typeof(result = this:add_news(args[1..(prepstr in args) - 1], player:get_current_message(this) || {0, 0})) == STR)
player:notify(result);
else
new = this.current_news;
if (new)
player:notify("Current newspaper set.");
this:display_seq_headers(new);
else
player:notify("Current newspaper is now empty.");
endif
endif
.
#61:13
if ((caller_perms() != #-1) && (caller_perms() != player))
raise(E_PERM);
endif
set_task_perms(player);
if (!this:is_writable_by(player))
player:notify("You can't write the news.");
elseif (typeof(result = this:rm_news(args[1..(prepstr in args) - 1], player:get_current_message(this) || {0, 0})) == STR)
player:notify(result);
else
new = this.current_news;
if (new)
player:notify("Current newspaper set.");
this:display_seq_headers(new);
else
player:notify("Current newspaper is now empty.");
endif
endif
.
#61:14
set_task_perms(player);
if (!this:is_writable_by(player))
player:notify("You can't write the news.");
elseif (typeof(seq = this:_parse(strings = args[(prepstr in args) + 1..$], @player:get_current_message(this) || {0, 0})) == STR)
player:notify(seq);
else
old = this.current_news;
if (old == seq)
player:notify("No change.");
else
this:set_current_news(seq);
if (seq)
player:notify("Current newspaper set.");
this:display_seq_headers(seq);
else
player:notify("Current newspaper is now empty.");
endif
endif
endif
.
#61:15
if (!(strings = args[1]))
return "You need to specify a message sequence";
elseif (typeof(pms = this:parse_message_seq(@args)) == STR)
return $string_utils:substitute(pms, {{"%f", "The news"}, {"%<has>", "has"}, {"%%", "%"}});
elseif (typeof(pms) != LIST)
return tostr(pms);
elseif (length(pms) > 1)
return tostr("I don't understand `", pms[2], "'.");
elseif (!(seq = pms[1]))
return tostr("The News (", this, ") has no `", $string_utils:from_list(strings, " "), "' messages.");
else
return seq;
endif
.
#61:16
if (caller_perms().wizard)
pass(@args);
this.description = "It's the current issue of the News, dated %d.";
this.moderated = 1;
this.last_news_time = 0;
this.readers = 1;
this.expire_period = 0;
this.archive_news = {};
$mail_agent:send_message(#2, this, "Welcome to LambdaCore", $wiz_utils.new_core_message);
this:add_news("$");
else
return E_PERM;
endif
.
#61:17
if (!this:ok_write(caller, caller_perms()))
$error:raise(E_PERM);
endif
{specs, ?cur = {0, 0}} = args;
seq = this:_parse(specs, @cur);
if (typeof(seq) == STR)
return seq;
endif
old = this.current_news;
new = $seq_utils:union(old, seq);
if (old == new)
return "Those messages are already in the news.";
endif
this:set_current_news(new);
return 1;
.
#61:18
if (!this:ok_write(caller, caller_perms()))
raise(E_PERM);
endif
{specs, ?cur = {0, 0}} = args;
seq = this:_parse(specs, @cur);
if (typeof(seq) == STR)
return seq;
endif
old = this.current_news;
new = $seq_utils:intersection(old, $seq_utils:complement(seq));
if (old == new)
return "Those messages were not in the news.";
endif
this:set_current_news(new);
return 1;
.
#61:19
player:notify("The following articles are currently in the newspaper:");
this:display_seq_headers(this.current_news);
.
#61:20
set_task_perms(player);
if (this:is_writable_by(player))
this:set_current_news({});
player:notify("Current newspaper is now empty.");
else
player:notify("You can't write the news.");
endif
.
#62:0
"Copied from The Coat Closet (#11):disfunc by Haakon (#2) Mon May  8 10:41:04 1995 PDT";
if ((((cp = caller_perms()) == (who = args[1])) || $perm_utils:controls(cp, who)) || (caller == this))
"need the first check since guests don't control themselves";
if (who.home == this)
move(who, $limbo);
this:announce("You hear a quiet popping sound; ", who.name, " has disconnected.");
else
pass(who);
endif
endif
.
#62:1
"Copied from The Coat Closet (#11):enterfunc by Haakon (#2) Mon May  8 10:41:38 1995 PDT";
who = args[1];
if ($limbo:acceptable(who))
move(who, $limbo);
else
pass(who);
endif
.
#62:2
"Copied from The Coat Closet (#11):match by Lambda (#50) Mon May  8 10:42:01 1995 PDT";
m = pass(@args);
if (m == $failed_match)
"... it might be a player off in the body bag...";
m = $string_utils:match_player(args[1]);
if (valid(m) && (!(m.location in {this, $limbo})))
return $failed_match;
endif
endif
return m;
.
#62:3
"Copied from The Coat Closet (#11):init_for_core by Nosredna (#2487) Mon May  8 10:42:52 1995 PDT";
if (!caller_perms().wizard)
return E_PERM;
endif
for v in ({"announce*", "emote", "button", "knob"})
if (`verb_info($player_start, v) ! E_VERBNF => 0')
delete_verb($player_start, v);
endif
endfor
for p in ({"out", "quiet", "button"})
if (p in properties($player_start))
delete_property($player_start, p);
endif
endfor
for p in ($object_utils:all_properties($room))
clear_property($player_start, p);
endfor
$player_start.name = "The First Room";
$player_start.aliases = {};
$player_start.description = "This is all there is right now.";
$player_start.exits = $player_start.entrances = {};
"... at the end since $room:init_for_core moves stuff in";
pass(@args);
.
#62:4
"Copied from The Coat Closet (#11):keep_clean by Haakon (#2) Mon May  8 10:47:08 1995 PDT";
if ($perm_utils:controls(caller_perms(), this))
junk = {};
while (1)
for x in (junk)
$command_utils:suspend_if_needed(0);
if (x in this.contents)
"This is old junk that's still around five minutes later.  Clean it up.";
if (!valid(x.owner))
move(x, $nothing);
#2:tell(">**> Cleaned up orphan object `", x.name, "' (", x, "), owned by ", x.owner, ", to #-1.");
elseif (!$object_utils:contains(x, x.owner))
move(x, x.owner);
x.owner:tell("You shouldn't leave junk in ", this.name, "; ", x.name, " (", x, ") has been moved to your inventory.");
#2:tell(">**> Cleaned up `", x.name, "' (", x, "), owned by `", x.owner.name, "' (", x.owner, "), to ", x.owner, ".");
endif
endif
endfor
junk = {};
for x in (this.contents)
if ((seconds_left() < 2) || (ticks_left() < 1000))
suspend(0);
endif
if (!is_player(x))
junk = {@junk, x};
endif
endfor
suspend(5 * 60);
endwhile
endif
.
#63:0
"Return a toad (child of #1, owned by $hacker) from this.contents.  Move it to #-1.  Recreate as a child of args[1], or of #1 if no args are given.  Chown to caller_perms() or args[2] if present.";
{?what = #1, ?who = caller_perms()} = args;
if (!(caller_perms().wizard || (who == caller_perms())))
return E_PERM;
elseif (!(valid(what) && is_player(who)))
return E_INVARG;
elseif ((((who != what.owner) && (!what.f)) && (!who.wizard)) && (!caller_perms().wizard))
return E_PERM;
endif
potential = next_recycled_object();
if (typeof(potential) == OBJ)
return this:setup_toad(potential, who, what);
else
return E_NONE;
endif
.
#63:1
{item} = args;
if (!$perm_utils:controls(caller_perms(), item))
raise(E_PERM);
elseif (is_player(item))
raise(E_INVARG);
endif
this:addhist(caller_perms(), item);
"...recreate can fail (:recycle can crash)...";
this:add_orphan(item);
this:kill_all_tasks(item);
$quota_utils:reimburse_quota(item.owner, item);
$building_utils:recreate(item, $nothing);
this:remove_orphan(item);
.
#63:2
e = `set_task_perms(caller_perms()) ! ANY';
if (typeof(e) == ERR)
return e;
else
val = this:_recreate(@args);
return (val == E_NONE) ? $quota_utils:bi_create(@args) | val;
endif
.
#63:3
if (caller == this)
h = this.history;
if ((len = length(h)) > this.nhist)
h = h[len - this.nhist..len];
endif
this.history = {@h, args};
endif
.
#63:4
if ($perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))
for x in (this.history)
pname = valid(x[1]) ? x[1].name | "A recycled player";
oname = valid(x[2]) ? x[2].name | "recycled";
player:notify(tostr(pname, " (", x[1], ") recycled ", x[2], " (now ", oname, ")"));
endfor
else
player:tell("Sorry.");
endif
.
#63:5
"this:setup_toad(objnum,new_owner,parent)";
"Called by :_create and :request.";
if (caller != this)
return E_PERM;
endif
{potential, who, what} = args;
if (!$quota_utils:creation_permitted(who))
return E_QUOTA;
elseif (valid(potential))
return E_INVARG;
else
set_task_perms({@callers(), {#-1, "", player}}[2][3]);
"... if :initialize crashes...";
this:add_orphan(potential);
$building_utils:recreate(potential, what);
$wiz_utils:set_owner(potential, who);
this:remove_orphan(potential);
"... if we don't get this far, the object stays on the orphan list...";
"... orphan list should be checked periodically...";
return potential;
endif
.
#63:6
if (caller == this)
this.orphans = setadd(this.orphans, args[1]);
endif
.
#63:7
if (caller == this)
this.orphans = setremove(this.orphans, args[1]);
endif
.
#63:8
"Usage:  valid(object)";
"True if object is valid.";
return valid(args[1]);
.
#63:9
if (caller_perms().wizard)
this.orphans = {};
this.history = {};
this.lost_souls = {};
pass(@args);
endif
.
#63:10
if (!caller_perms().wizard)
raise(E_PERM);
endif
fork (1800)
this:(verb)();
endfork
for x in (this.lost_souls)
this.lost_souls = setremove(this.lost_souls, x);
if ((valid(x) && (typeof(x.owner.owned_objects) == LIST)) && (!(x in x.owner.owned_objects)))
x.owner.owned_objects = setadd(x.owner.owned_objects, x);
$quota_utils:summarize_one_user(x.owner);
endif
$command_utils:suspend_if_needed(0);
endfor
.
#63:11
who = args[1];
if ($quota_utils.byte_based && (is_clear_property(who, "size_quota") || is_clear_property(who, "owned_objects")))
raise(E_QUOTA);
endif
cheater = 0;
other_cheaters = {};
for x in (this.lost_souls)
if (((valid(x) && ((owner = x.owner) != $hacker)) && (typeof(owner.owned_objects) == LIST)) && (!(x in owner.owned_objects)))
if (owner == who)
who.owned_objects = setadd(who.owned_objects, x);
cheater = 1;
else
"it's someone else's quota scam we're detecting...";
other_cheaters = setadd(other_cheaters, owner);
owner.owned_objects = setadd(owner.owned_objects, x);
this.lost_souls = setremove(this.lost_souls, x);
endif
endif
this.lost_souls = setremove(this.lost_souls, x);
endfor
if ($quota_utils.byte_based)
if (cheater)
$quota_utils:summarize_one_user(who);
endif
if (other_cheaters)
fork (0)
for x in (other_cheaters)
$quota_utils:summarize_one_user(x);
endfor
endfork
endif
endif
.
#63:12
for x in (this.orphans)
if ((!valid(x)) || ((x.owner != $hacker) && (x in x.owner.owned_objects)))
this.orphans = setremove(this.orphans, x);
endif
endfor
.
#63:13
pass(#-1);
.
#63:14
"kill_all_tasks ( object being recycled )";
" -- kill all tasks involving this now-recycled object";
((caller == this) || (caller == #0)) || raise(E_PERM);
{object} = args;
((typeof(object) == OBJ) || (typeof(object) == ANON)) || raise(E_INVARG);
if (!valid(object))
fork (0)
for t in (queued_tasks())
for c in (`task_stack(t[1]) ! E_INVARG => {}')
if (object in c)
kill_task(t[1]);
continue t;
endif
endfor
endfor
endfork
endif
.
#65:0
if (i = args[1] in {"noinclude", "sender"})
return {{{"include", "all"}[i], !args[2]}};
else
return {args};
endif
.
#65:1
"... we'll take anything...";
raw = args[2];
if (raw == 1)
"...+@mail => @mailo=new";
return {args[1], "new"};
else
return args[1..2];
endif
.
#65:2
{oname, raw, data} = args;
if (typeof(raw) == LIST)
if (length(raw) > 1)
return "Too many arguments.";
endif
raw = raw[1];
elseif (typeof(raw) == INT)
return {oname, raw && ((oname == "manymsgs") ? 20 | 1)};
endif
if ((value = $code_utils:toint(raw)) == E_TYPE)
return tostr("`", raw, "'?  Number expected.");
endif
return {oname, value};
.
#65:3
{oname, raw, data} = args;
if (typeof(raw) == STR)
raw = $string_utils:explode(raw, ",");
elseif (typeof(raw) == INT)
return raw ? "You need to give one or more recipients." | {oname, 0};
endif
value = $mail_editor:parse_recipients({}, raw);
if (value)
return {oname, value};
else
return "No valid recipients in list.";
endif
.
#65:4
value = this:get(@args);
if (value)
return {tostr(value), {tostr("Query when asking for ", value, " or more messages.")}};
else
return {0, {"Willing to be spammed with arbitrarily many messages/headers"}};
endif
.
#65:5
value = this:get(@args);
if (value)
return {value, {"Sticky folders:  mail commands default to whatever", "mail collection the previous successful command looked at."}};
else
return {0, {"Teflon folders:  mail commands always default to `on me'."}};
endif
.
#65:6
if (value = this:get(@args))
return {"", {tostr("Default message sequence for @mail:  ", (typeof(value) == STR) ? value | $string_utils:from_list(value, " "))}};
else
default = $mail_agent.("player_default_@mail");
return {0, {tostr("Default message sequence for @mail:  ", (typeof(default) == STR) ? default | $string_utils:from_list(default, " "))}};
endif
.
#65:7
if (value = this:get(@args))
return {"", {tostr("Default Reply-to:  ", $mail_agent:name_list(@value))}};
else
return {0, {"No default Reply-to: field"}};
endif
.
#65:8
if (o = (name = args[2]) in {"sender", "noinclude"})
args[2] = {"all", "include"}[o];
return {@pass(@args), tostr("(", name, " is a synonym for -", args[2], ")")};
else
return pass(@args);
endif
.
#65:9
"... must be object, list of objects, or false...";
value = args[1];
if (typeof(value) == OBJ)
return {{value}};
elseif (!this:istype(value, {{OBJ}}))
return $string_utils:capitalize("Object or list of objects expected.");
else
return {value};
endif
.
#65:10
if (value = this:get(@args))
return {value, {"Have MOO-mail automatically forwarded to me at", "my registered email-address."}};
else
return {value, {"Receive MOO-mail here on the MOO."}};
endif
"Last modified Tue Jun  1 02:10:08 1993 EDT by Edison@OpalMOO (#200).";
.
#65:11
":check_netmail(value) => Makes sure the email-address is one that can actually be used by $network:sendmail().";
"The actual value sent is not checked since it can only be a boolean flag.  The player's email_address property is what is checked.";
"Possible situations where the address would be unusable are when the address is invalid or we can't connect to the site to send mail.";
"Returns a string error message if unusable or {value} otherwise.";
if (caller != this)
return E_PERM;
endif
if (args[1] && (reason = $network:email_will_fail($wiz_utils:get_email_address(player))))
return tostr("Invalid registered email_address: ", reason);
endif
return args;
.
#65:12
value = this:get(args[1], "expire");
if (value < 0)
return {1, {"Messages will not expire."}};
else
return {value, {tostr("Unkept messages expire in ", $time_utils:english_time(value || $mail_agent.player_expire_time), value ? "" | " (default)")}};
endif
.
#65:13
{oname, value, data} = args;
if ((typeof(value) == STR) && index(value, " "))
value = $string_utils:explode(value, " ");
if (!value)
return {oname, 0};
endif
endif
if (value == 1)
return {oname, -1};
elseif (typeof(value) == LIST)
if (length(value) > 1)
nval = $time_utils:parse_english_time_interval(@value);
if (typeof(nval) == ERR)
return "Time interval should be of a form like \"30 days, 10 hours and 43 minutes\".";
else
return {oname, nval};
endif
endif
value = value[1];
endif
if ((nval = $code_utils:toint(value)) || (nval == 0))
return {oname, (nval < 0) ? -1 | nval};
elseif (value == "Never")
return {oname, -1};
else
return "Number, time interval (e.g., \"30 days\"), or \"Never\" expected";
endif
.
#65:14
if (caller_perms().wizard)
for x in ({"fast_check", "idle_check", "idle_threshold"})
this:remove_name(x);
for y in ({"show", "check", "parse"})
delete_verb(this, (y + "_") + x);
delete_property(this, (y + "_") + x);
endfor
endfor
pass(@args);
endif
.
#65:15
if ((what = args[1]) in {"new", "contents", "all"})
return {what};
else
return "Error: `news' option must be one of `new' or `contents' or `all'";
endif
.
#65:16
if (typeof(args[2]) == INT)
return tostr(strsub(verb, "parse_", ""), " is not a boolean option.");
else
return {args[1], (typeof(args[2]) == STR) ? args[2] | $string_utils:from_list(args[2], " ")};
endif
.
#65:17
if ((value = this:get(@args)) == "all")
return {value, {"the `news' command will show all news"}};
elseif (value == "contents")
return {value, {"the `news' command will show the titles of all articles"}};
elseif (value == "new")
return {value, {"the `news' command will show only new news"}};
else
return {0, {"the `news' command will show all news"}};
endif
.
#65:18
{name, value, bleh} = args;
if (typeof(value) == INT)
return tostr(name, " is not a boolean option.");
elseif (typeof(value) == STR)
value = {value};
endif
ok = this.unsend_sequences;
for x in (value)
if ((!(pos = index(x, ":"))) || (!(x[1..pos - 1] in ok)))
return tostr("Invalid sequence - ", x);
elseif (pos != rindex(x, ":"))
return tostr("As a preventative measure, you may not use more than one : in a sequence. The following sequence is therefore invalid - ", x);
endif
endfor
return {name, value};
.
#65:19
if (value = this:get(@args))
return {"", {tostr("Default message sequence for @unsend:  ", (typeof(value) == STR) ? value | $string_utils:from_list(value, " "))}};
else
default = $mail_agent.("player_default_@unsend");
return {0, {tostr("Default message sequence for @unsend:  ", (typeof(default) == STR) ? default | $string_utils:from_list(default, " "))}};
endif
.
#66:0
if (i = args[1] in {"parens", "noisy_insert"})
return {{{"no_parens", "quiet_insert"}[i], !args[2]}};
else
return {args};
endif
.
#66:1
if (o = (name = args[2]) in {"parens", "noisy_insert"})
args[2] = {"no_parens", "quiet_insert"}[o];
return {@pass(@args), tostr("(", name, " is a synonym for -", args[2], ")")};
else
return pass(@args);
endif
.
#68:0
":get(options,name) => returns the value of the option specified by name";
"i.e., if {name,value} is present in options, return value";
"      if name is present, return 1";
"      otherwise return 0";
{options, name} = args;
if (name in options)
return 1;
elseif (a = $list_utils:assoc(name, options))
return a[2];
else
return 0;
endif
.
#68:1
":set(optionlist,oname,value) => revised optionlist or string error message.";
"oname must be the full name of an option in .names or .extras.";
"Note that values must not be of type ERR.  ";
"FALSE (0, blank string, or empty list) is always a legal value.";
"If a verb :check_foo is defined on this, it will be used to typecheck any";
"non-false or object-type value supplied as a new value for option `foo'.";
"";
"   :check_foo(value) => string error message or {value to use}";
"";
"If instead there is a property .check_foo, that will give either the expected ";
"type or a list of allowed types.";
"Otherwise, the option is taken to be a boolean flag and all non-false, ";
"non-object values map to 1.";
"";
{options, oname, value} = args;
if (!((oname in this.names) || (oname in this.extras)))
return "Unknown option:  " + oname;
elseif (typeof(value) == ERR)
"... no option should have an error value...";
return "Error value";
elseif ((!value) && (typeof(value) != OBJ))
"... always accept FALSE (0, blankstring, emptylist)...";
elseif ($object_utils:has_callable_verb(this, check = "check_" + oname))
"... a :check_foo verb exists; use it to typecheck the value...";
if (typeof(c = this:(check)(value)) == STR)
return c;
endif
value = c[1];
elseif ($object_utils:has_property(this, tprop = "type_" + oname))
"... a .type_foo property exists...";
"... property value should be a type or list of types...";
if (!this:istype(value, t = this.(tprop)))
return $string_utils:capitalize(this:desc_type(t) + " value expected.");
endif
elseif ($object_utils:has_property(this, cprop = "choices_" + oname))
"... a .choices_foo property exists...";
"... property value should be a list of {value,docstring} pairs...";
if (!$list_utils:assoc(value, c = this.(cprop)))
return tostr("Allowed values: ", $string_utils:english_list($list_utils:slice(c, 1), "(??)", " or "));
endif
else
"... value is considered to be boolean...";
if (!value)
"... must be an object.  oops.";
return tostr("Non-object value expected.");
endif
value = 1;
endif
"... We now have oname and a value.  However, if oname is one of the extras,";
"... then we need to call :actual to see what it really means.";
if (oname in this.names)
nvlist = {{oname, value}};
elseif ((typeof(nvlist = this:actual(oname, value)) != LIST) || (!nvlist))
return nvlist || "Not implemented.";
endif
"... :actual returns a list of pairs...";
for nv in (nvlist)
{oname, value} = nv;
if (i = (oname in options) || $list_utils:iassoc(oname, options))
if ((!value) && (typeof(value) != OBJ))
"value == 0, blank string, empty list";
options[i..i] = {};
elseif (value == 1)
options[i] = oname;
else
options[i] = {oname, value};
endif
elseif (value || (typeof(value) == OBJ))
options[1..0] = {(value == 1) ? oname | {oname, value}};
endif
endfor
return options;
.
#68:2
":parse(args[,...]) => {oname [,value]} or string error message";
"additional arguments are fed straight through to :parse_* routines.";
" <option> <value>     => {option, value}";
" <option>=<value>     => {option, value}";
" <option> is <value>  => {option, value}";
" +<option>            => {option, 1}";
" -<option>            => {option, 0}";
" !<option>            => {option, 0}";
" <option>             => {option}";
if (!(words = args[1]))
return "";
endif
option = words[1];
words[1..1] = {};
if (flag = option && index("-+!", option[1]))
option[1..1] = "";
endif
if (i = index(option, "="))
rawval = option[i + 1..$];
option = option[1..i - 1];
if (i == 1)
"... =bar ...";
return "Blank option name?";
elseif (flag)
"... +foo=bar";
return "Don't give a value if you use +, -, or !";
elseif (words)
"... foo=bar junk";
return $string_utils:from_list(words, " ") + "??";
endif
elseif (!option)
return "Blank option name?";
elseif (flag)
if (words)
"... +foo junk";
return "Don't give a value if you use +, -, or !";
endif
rawval = (flag - 1) % 2;
else
words && ((words[1] == "is") && (words[1..1] = {}));
rawval = words;
endif
"... do we know about this option?...";
if (!(oname = this:_name(strsub(option, "-", "_"))))
return tostr((oname == $failed_match) ? "Unknown" | "Ambiguous", " option:  ", option);
endif
"... determine new value...";
if (!rawval)
"... `@option foo is' or `@option foo=' ...";
return (rawval == {}) ? {oname} | {oname, 0};
elseif ($object_utils:has_callable_verb(this, pverb = "parse_" + oname))
return this:(pverb)(oname, rawval, args[2..$]);
elseif ($object_utils:has_property(this, cprop = "choices_" + oname))
return this:parsechoice(oname, rawval, this.(cprop));
elseif (rawval in {0, "0", {"0"}})
return {oname, 0};
elseif (rawval in {1, "1", {"1"}})
return {oname, 1};
else
return tostr("Option is a flag, use `+", option, "' or `-", option, "' (or `!", option, "')");
endif
.
#68:3
":_name(string) => full option name corresponding to string ";
"               => $failed_match or $ambiguous_match as appropriate.";
if (((string = args[1]) in this.names) || (string in this.extras))
return string;
endif
char = (namestr = this._namelist)[1];
if (!(i = index(namestr, char + string)))
return $failed_match;
elseif (i != rindex(namestr, char + string))
return $ambiguous_match;
else
j = index(namestr[i + 1..$], char);
return namestr[i + 1..(i + j) - 1];
endif
.
#68:4
":add_name(name[,isextra]) adds name to the list of options recognized.";
"name must be a nonempty string and must not contain spaces, -, +, !, or =.";
"isextra true means that name isn't an actual option (recognized by :get) but merely a name that the option setting command should recognize to set a particular combination of options.  Actual options go in .names; others go in .extras";
{name, ?isextra = 0} = args;
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif ((!name) || match(name, "[-!+= ]"))
"...name is blank or contains a forbidden character";
return E_INVARG;
elseif (name in this.names)
"...name is already in option list";
if (isextra)
this.names = setremove(this.names, name);
this.extras = setadd(this.extras, name);
return 1;
else
return 0;
endif
elseif (name in this.extras)
if (isextra)
return 0;
else
this.names = setadd(this.names, name);
this.extras = setremove(this.extras, name);
return 1;
endif
else
char = this._namelist[1];
if (isextra)
this.extras = setadd(this.extras, name);
else
this.names = setadd(this.names, name);
endif
if (!index(this._namelist, (char + name) + char))
this._namelist = tostr(this._namelist, name, char);
endif
return 1;
endif
.
#68:5
":remove_name(name) removes name from the list of options recognized.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif (!(((name = args[1]) in this.names) || (name in this.extras)))
"...hmm... already gone...";
return 0;
else
char = this._namelist[1];
this._namelist = strsub(this._namelist, (char + name) + char, char);
this.names = setremove(this.names, name);
this.extras = setremove(this.extras, name);
return 1;
endif
.
#68:6
":show(options,name or list of names)";
" => text describing current value of option and what it means";
name = args[2];
if (typeof(name) == LIST)
text = {};
for n in (name)
text = {@text, @this:show(@listset(args, n, 2))};
endfor
return text;
elseif (!((name in this.names) || (name in this.extras)))
return {"Unknown option:  " + name};
elseif ($object_utils:has_callable_verb(this, sverb = "show_" + name))
r = this:(sverb)(@args);
value = r[1];
desc = r[2];
elseif ($object_utils:has_property(this, sverb) && ((value = this:get(args[1], name)) in {0, 1}))
desc = this.(sverb)[value + 1];
if (typeof(desc) == STR)
desc = {desc};
endif
elseif ($object_utils:has_property(this, cprop = "choices_" + name))
if (!(value = this:get(args[1], name)))
desc = this.(cprop)[1][2];
elseif (!(a = $list_utils:assoc(value, this.(cprop))))
return {(name + " has unexpected value ") + toliteral(value)};
else
desc = a[2];
endif
elseif (name in this.extras)
return {name + " not documented (complain)"};
else
value = this:get(args[1], name);
desc = {"not documented (complain)"};
if (typeof(value) in {LIST, STR})
desc[1..0] = toliteral(value);
value = "";
endif
endif
if (value in {0, 1})
which = "-+"[value + 1] + name;
elseif ((typeof(value) in {OBJ, STR, INT}) && (value != ""))
which = tostr(" ", name, "=", value);
else
which = " " + name;
endif
show = {$string_utils:left(which + "  ", this.namewidth) + desc[1]};
for i in [2..length(desc)]
show = {@show, $string_utils:space(this.namewidth) + desc[i]};
endfor
return show;
.
#68:7
":actual(<name>,<value>) => list of {<name>,<value>} pairs or string errormsg";
" corresponding to what setting option <name> to <value> actually means";
" e.g., :actual(\"unfoo\",1) => {{\"foo\",0}}";
" e.g., :actual(\"g7mode\",1) => {{\"splat\",37},{\"baz\",#3}}";
return "Not implemented.";
.
#68:8
":istype(value,types) => whether value is one of the given types";
if ((vtype = typeof(value = args[1])) in (types = args[2]))
return 1;
elseif (vtype != LIST)
return 0;
else
for t in (types)
if ((typeof(t) == LIST) && this:islistof(value, t))
return 1;
endif
endfor
endif
return 0;
.
#68:9
":islistof(value,types) => whether value (a list) has each element being one of the given types";
types = args[2];
for v in (value = args[1])
if (!this:istype(v, types))
return 0;
endif
endfor
return 1;
.
#68:10
":desc_type(types) => string description of types";
nlist = {};
for t in (types = args[1])
if (typeof(t) == LIST)
if (length(t) > 1)
nlist = {@nlist, tostr("(", this:desc_type(t), ")-list")};
else
nlist = {@nlist, tostr(this:desc_type(t), "-list")};
endif
elseif (t in {INT, OBJ, STR, LIST})
nlist = {@nlist, {"number", "object", "string", "?", "list"}[t + 1]};
else
return "Bad type list";
endif
endfor
return $string_utils:english_list(nlist, "nothing", " or ");
.
#68:11
":parsechoice(oname,rawval,assoclist)";
which = {};
oname = args[1];
rawval = args[2];
choices = $list_utils:slice(args[3], 1);
errmsg = tostr("Allowed values for this flag: ", $string_utils:english_list(choices, "(??)", " or "));
if (typeof(rawval) == LIST)
if (length(rawval) > 1)
return errmsg;
endif
rawval = rawval[1];
elseif (typeof(rawval) != STR)
return errmsg;
endif
for c in (choices)
if (index(c, rawval) == 1)
which = {@which, c};
endif
endfor
if (!which)
return errmsg;
elseif (length(which) > 1)
return tostr(rawval, " is ambiguous.");
else
return {oname, which[1]};
endif
.
#69:0
raise(@args);
"this:(this.names[toint(args[1]) + 1])()";
.
#69:1
"... hmmm... don't know how to raise E_NONE...";
return E_NONE;
.
#69:2
"...raise E_TYPE ...";
1[2];
.
#69:3
"...raise E_DIV ...";
1 / 0;
.
#69:4
"...raise E_PERM ...";
this.owner.password;
.
#69:5
"...raise E_PROPNF ...";
this.a;
.
#69:6
"...raise E_VERBNF ...";
this:a();
.
#69:7
"...raise E_VARNF ...";
a;
.
#69:8
"...raise E_INVIND ...";
#-1.a;
.
#69:9
move(this, this);
.
#69:10
"...raise E_MAXREC ...";
this:(verb)();
.
#69:11
"...raise E_RANGE ...";
{}[1];
.
#69:12
"...raise E_ARGS ...";
toint();
.
#69:13
"...raise E_NACC ...";
move($hacker, this);
.
#69:14
"...raise E_INVARG ...";
parent(#-1);
.
#69:15
set_task_perms($no_one);
"...raise E_QUOTA ...";
create($thing);
.
#69:16
return 0;
.
#69:17
return toliteral(args[1]);
"return this.names[toint(args[1]) + 1];";
.
#69:18
"toerr -- given a string or a number, return the corresponding ERR.";
"If not found or an execution error, return -1.";
if (typeof(string = args[1]) == STR)
for e in (this.all_errors)
if (tostr(e) == string)
return e;
endif
endfor
elseif (typeof(number = args[1]) == INT)
for e in (this.all_errors)
if (toint(e) == number)
return e;
endif
endfor
endif
return -1;
.
#69:19
"match_error -- searches for tostr(E_WHATEVER) in a string, returning the ERR, returns -1 if no error string is found.";
string = args[1];
for e in (this.all_errors)
if (index(string, tostr(e)))
return e;
endif
endfor
return -1;
.
#70:0
if (caller_perms().wizard)
pass(@args);
this.mail_notify = {player};
player:set_current_message(this, 0, 0, 1);
this.moderated = 1;
else
return E_PERM;
endif
.
#71:0
player:tell_lines(this:description());
player:tell($string_utils:pronoun_sub("%S %<is> moving around from room to room, cleaning up.", this));
.
#71:1
"$housekeeper:cleanup([insist]) => clean up player's objects. Argument is 'up' or 'up!' for manually requested cleanups (notify player differently)";
if (caller_perms() != this)
return E_PERM;
endif
for object in (this.clean)
x = object in this.clean;
if (this.requestors[x] == player)
if (result = this:replace(object, @args))
player:tell(result, ".");
endif
endif
$command_utils:suspend_if_needed(0);
endfor
player:tell("The housekeeper has finished cleaning up your objects.");
.
#71:2
"replace the object given to its proper spot (if there is one).";
{object, ?insist = 0} = args;
i = object in this.clean;
if (!i)
return tostr(object, " is not on the ", this.name, "'s cleanup list");
endif
place = this.destination[i];
if (!((($recycler:valid(object) && ($recycler:valid(r = this.requestors[i]) && is_player(r))) && ($recycler:valid(place) || (place == #-1))) && (!(object.location in this.recycle_bins))))
"object no longer valid (recycled or something), remove it.";
this.clean = listdelete(this.clean, i);
this.requestors = listdelete(this.requestors, i);
this.destination = listdelete(this.destination, i);
return tostr(object) + " is no longer valid, removed from cleaning list";
endif
oldloc = loc = object.location;
if (object.location == place)
"already in its place";
return "";
endif
requestor = $recycler:valid(tr = this.requestors[i]) ? tr | $no_one;
if (insist != "up!")
if ($code_utils:verb_or_property(object, "in_use"))
return ("Not returning " + object.name) + " because it claims to be in use";
endif
for thing in (object.contents)
if (thing:is_listening())
return ((("Not returning " + object.name) + " because ") + thing.name) + " is inside";
endif
$command_utils:suspend_if_needed(0);
endfor
if (valid(loc) && (loc != $limbo))
if (loc:is_listening())
return ((("Not returning " + object.name) + " because ") + loc.name) + " is holding it";
endif
for y in (loc:contents())
if ((y != object) && y:is_listening())
return (((("Not returning " + object.name) + " because ") + y.name) + " is in ") + loc.name;
endif
$command_utils:suspend_if_needed(0);
endfor
endif
endif
if (valid(place) && (!place:acceptable(object)))
return (place.name + " won't accept ") + object.name;
endif
try
requestor:tell("As you requested, the housekeeper tidies ", $string_utils:nn(object), " from ", $string_utils:nn(loc), " to ", $string_utils:nn(place), ".");
if ($object_utils:has_verb(loc, "announce_all_but"))
loc:announce_all_but({requestor, object}, "At ", requestor.name, "'s request, the ", this.name, " sneaks in, picks up ", object.name, " and hurries off to put ", ($object_utils:has_property(object, "po") && (typeof(object.po) == STR)) ? object.po | "it", " away.");
endif
except (ANY)
"Ignore errors";
endtry
fork (0)
this:moveit(object, place, requestor);
if ((loc = object.location) == oldloc)
return (object.name + " wouldn't go; ") + ((!place:acceptable(object)) ? (" perhaps " + $string_utils:nn(place)) + " won't let it in" | ((" perhaps " + $string_utils:nn(loc)) + " won't let go of it"));
endif
try
object:tell("The housekeeper puts you away.");
if ($object_utils:isa(loc, $room))
loc:announce_all_but({object}, "At ", requestor.name, "'s request, the housekeeper sneaks in, deposits ", object:title(), " and leaves.");
else
loc:tell("You notice the housekeeper sneak in, give you ", object:title(), " and leave.");
endif
except (ANY)
"Ignore errors";
endtry
endfork
return "";
.
#71:3
if (args)
if (!valid(who = args[1]))
return;
endif
player:tell(who.name, "'s personal cleanup list:");
else
who = 0;
player:tell("Housekeeper's complete cleanup list:");
endif
player:tell("------------------------------------------------------------------");
printed_anything = 0;
objs = this.clean;
reqs = this.requestors;
dest = this.destination;
objfieldwid = length(tostr(max_object())) + 1;
for i in [1..length(objs)]
$command_utils:suspend_if_needed(2);
req = $recycler:valid(tr = reqs[i]) ? tr | $no_one;
ob = objs[i];
place = dest[i];
if (((who == 0) || (req == who)) || (ob.owner == who))
if (!valid(ob))
player:tell($string_utils:left(tostr(ob), objfieldwid), $string_utils:left("** recycled **", 50), "(", req.name, ")");
else
player:tell($string_utils:left(tostr(ob), objfieldwid), $string_utils:left(ob.name, 26), "=>", $string_utils:left(tostr(place), objfieldwid), (valid(place) ? place.name | "nowhere") || "nowhere", " (", req.name, ")");
endif
printed_anything = 1;
endif
endfor
if (!printed_anything)
player:tell("** The housekeeper has nothing in the cleanup list.");
endif
player:tell("------------------------------------------------------------------");
.
#71:4
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
{what, ?who = player, ?where = what.location} = args;
if ((what < #1) || (!valid(what)))
return "invalid object";
endif
if ($object_utils:isa(who, $guest))
return tostr("Guests can't use the ", this.name, ".");
endif
if (!is_player(who))
return tostr("Non-players can't use the ", this.name, ".");
endif
if (!valid(where))
return tostr("The ", this.name, " doesn't know how to find ", where, " in order to put away ", what.name, ".");
endif
if (is_player(what))
return ("The " + this.name) + " doesn't do players, except to cart them home when they fall asleep.";
endif
for x in (this.eschews)
if ($object_utils:isa(what, x[1]))
ok = 0;
for y in [3..length(x)]
if ($object_utils:isa(what, x[y]))
ok = 1;
endif
endfor
if (!ok)
return tostr("The ", this.name, " doesn't do ", x[2], "!");
endif
endif
endfor
if ($object_utils:has_callable_verb(where, "litterp") ? where:litterp(what) | ((where in this.public_places) && (!(what in where.residents))))
return tostr("The ", this.name, " won't litter ", where.name, "!");
endif
if (i = what in this.clean)
if ((!this:controls(i, who)) && valid(this.destination[i]))
return tostr($recycler:valid(tr = this.requestors[i]) ? tr.name | "Someone", " already asked that ", what.name, " be kept at ", this.destination[i].name, "!");
endif
this.requestors[i] = who;
this.destination[i] = where;
else
this.clean = {what, @this.clean};
this.requestors = {who, @this.requestors};
this.destination = {where, @this.destination};
endif
return tostr("The ", this.name, " will keep ", what.name, " (", what, ") at ", valid(where) ? ((where.name + " (") + tostr(where)) + ")" | where, ".");
.
#71:5
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
{what, ?who = player} = args;
if (i = what in this.clean)
if (!this:controls(i, who))
return tostr("You may remove an object from ", this.name, " list only if you own the object, the place it is kept, or if you placed the original cleaning order.");
endif
this.clean = listdelete(this.clean, i);
this.destination = listdelete(this.destination, i);
this.requestors = listdelete(this.requestors, i);
return tostr(what.name, " (", what, ") removed from cleanup list.");
else
return tostr(what.name, " not in cleanup list.");
endif
.
#71:6
"does player control entry I?";
{i, who} = args;
if ((who in {this.owner, @this.owners}) || who.wizard)
return "Yessir.";
endif
cleanable = this.clean[i];
if (this.requestors[i] == who)
return "you asked for the previous result, you can change this one.";
elseif (((who == cleanable.owner) || (!valid(dest = this.destination[i]))) || (who == dest.owner))
return "you own the object or the place where it is being cleaned to, or the destination is no longer valid.";
else
return "";
endif
.
#71:7
"start the housekeeper cleaning continuously. Kill any previous continuous";
"task. Not meant to be called interactively.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
if ($code_utils:task_valid(this.task))
taskn = this.task;
this.task = 0;
kill_task(taskn);
endif
fork taskn (0)
while (1)
index = 1;
while (index <= length(this.clean))
this.cleaning = x = this.clean[index];
this.cleaning_index = index;
index = index + 1;
fork (0)
`this:replace(x) ! ANY';
endfork
suspend(this.testing ? 2 | this:time());
endwhile
suspend(5);
this:litterbug();
endwhile
endfork
this.task = taskn;
.
#71:8
for room in (this.public_places)
for thingy in (room.contents)
suspend(10);
if (((thingy.location == room) && this:is_litter(thingy)) && (!this:is_watching(thingy, $nothing)))
"if it is litter and no-one is watching";
fork (0)
this:send_home(thingy);
endfork
suspend(0);
endif
endfor
endfor
.
#71:9
return valid(thing = args[1]) && thing:is_listening();
.
#71:10
if (caller != this)
return E_PERM;
endif
litter = args[1];
littering = litter.location;
this:ejectit(litter, littering);
home = litter.location;
if ($object_utils:isa(home, $room))
home:announce_all("The ", this.name, " sneaks in, deposits ", litter:title(), " and leaves.");
else
home:tell("You notice the ", this.name, " sneak in, give you ", litter:title(), " and leave.");
endif
if ($object_utils:has_callable_verb(littering, "announce_all_but"))
littering:announce_all_but({litter}, "The ", this.name, " sneaks in, picks up ", litter:title(), " and rushes off to put it away.");
endif
.
#71:11
"Wizardly verb to move object with requestor's permission";
if (caller != this)
return E_PERM;
else
set_task_perms(player = args[3]);
return args[1]:moveto(args[2]);
endif
.
#71:12
"this:ejectit(object,room): Eject args[1] from args[2].  Callable only by housekeeper's quarters verbs.";
if (caller == this)
args[2]:eject(args[1]);
endif
.
#71:13
what = args[1];
if (!(where = what in this.clean))
return 0;
else
return {this.destination[where], this.requestors[where]};
endif
.
#71:14
thingy = args[1];
for x in (this.litter)
if ($object_utils:isa(thingy, x[1]) && (!$object_utils:isa(thingy, x[2])))
return 1;
endif
endfor
return 0;
.
#71:15
if (caller_perms().wizard)
this.password = "Impossible password to type";
this.last_password_time = 0;
this.litter = {};
this.public_places = {};
this.requestors = {};
this.destination = {};
this.clean = {};
this.eschews = {};
this.recycle_bins = {};
this.cleaning = #-1;
this.task = 0;
this.owners = {#2};
this.mail_forward = {#2};
this.player_queue = {};
this.move_player_task = 0;
this.moveto_task = 0;
pass(@args);
endif
.
#71:16
count = 0;
for i in (this.requestors)
if (i == player)
count = count + 1;
endif
$command_utils:suspend_if_needed(1);
endfor
player:tell("Number of items in cleanup list: ", tostr(length(this.clean)));
player:tell("Number of items you requested to be tidied: ", tostr(count));
player:tell("Number of requestors: ", tostr(length($list_utils:remove_duplicates(this.requestors))));
player:tell("Time to complete one cleaning circuit: ", $time_utils:english_time(length(this.clean) * this:time()));
player:tell("The Housekeeper is in " + (($housekeeper.testing == 0) ? "normal, non-testing mode." | "testing mode. "));
if (!$code_utils:task_valid($housekeeper.task))
player:tell("The Housekeeper task has died. Restarting...");
$housekeeper:continuous();
else
player:tell("The Housekeeper is actively cleaning.");
endif
.
#71:17
"return a string status if the hosuekeeper is cleaning this object";
cleanable = args[1];
info = this:is_object_cleaned(cleanable);
if (info == 0)
return tostr(cleanable.name, " is not cleaned by the ", this.name, ".");
else
return tostr(cleanable.name, " is kept tidy at ", $string_utils:nn(info[1]), " at the request of ", $string_utils:nn(info[2]), ".");
endif
.
#71:18
"Returns the amount of time to suspend between objects while continuous cleaning.";
"Currently set to try to complete cleaning circuit in one hour, but not exceed one object every 20 seconds.";
return max(20 + $login:current_lag(), length(this.clean) ? 3600 / length(this.clean) | 0);
.
#71:19
return caller == this;
.
#71:20
if (!$perm_utils:controls(caller_perms(), this))
"perms don't control the $housekeeper; probably not called by $room:disfunc then. Used to let args[1] call this. No longer.";
return E_PERM;
endif
this.player_queue = {@this.player_queue, {args[1], time() + 300}};
if ($code_utils:task_valid(this.move_player_task))
"the move-players-home task is already running";
return;
endif
fork tid (10)
while (this.player_queue)
if ((mtime = this.player_queue[1][2]) < (time() + 10))
who = this.player_queue[1][1];
"Remove from queue first so that if they do something malicious, like put a kill_task in a custom :accept_for_abode, they won't be in the queue when the task restarts with the next player disconnect. Ho_Yan 12/3/98";
this.player_queue = listdelete(this.player_queue, 1);
if (is_player(who) && (!$object_utils:connected(who)))
dest = `who.home:accept_for_abode(who) ! ANY => 0' ? who.home | $player_start;
if (who.location != dest)
player = who;
this:move_em(who, dest);
endif
endif
else
suspend(mtime - time());
endif
$command_utils:suspend_if_needed(1);
endwhile
endfork
this.move_player_task = tid;
.
#71:21
if (caller == this)
{who, dest} = args;
set_task_perms(who);
fork (0)
fork (0)
"This is forked so that it's protected from aborts due to errors in the player's :moveto verb.";
if (who.location != dest)
"Unfortunately, if who is -already- at $player_start, move() won't call :enterfunc and the sleeping body never goes to $limbo. Have to call explicitly for that case. Ho_Yan 11/2/95";
if (who.location == $player_start)
$player_start:enterfunc(who);
else
"Nosredna, 5/4/01: but wait, why don't we just moved them straight to limbo?";
move(who, $limbo);
endif
endif
endfork
start = who.location;
this:set_moveto_task();
who:moveto(dest);
if (who.location != start)
start:announce(this:take_away_msg(who));
endif
if (who.location == dest)
dest:announce(this:drop_off_msg(who));
endif
endfork
else
return E_PERM;
endif
.
#71:22
return $string_utils:pronoun_sub(this.(verb), args[1], this);
.
#71:23
"sets $housekeeper.moveto_task to the current task_id() so player:moveto's can check for validity.";
if (caller != this)
return E_PERM;
endif
this.moveto_task = task_id();
.
#72:0
"Given an email address, return {userid, site}.";
"Valid addresses are of the form `userid[@site]'.";
"At least for now, if [@site] is left out, site will be returned as blank.";
"Should be a default address site, or something, somewhere.";
address = args[1];
return (at = index(address, "@")) ? {address[1..at - 1], address[at + 1..$]} | {address, ""};
.
#72:1
"given a site, try to figure out what the `local' domain is.";
"if site has a @ or a % in it, give up and return E_INVARG.";
"blank site is returned as is; try this:local_domain(this.localhost) for the answer you probably want.";
site = args[1];
if (index(site, "@") || index(site, "%"))
return E_INVARG;
elseif (match(site, "^[0-9.]+$"))
return E_INVARG;
elseif (!site)
return "";
elseif (!(dot = rindex(site, ".")))
dot = rindex(site = this.site, ".");
endif
if ((!dot) || (!(dot = rindex(site[1..dot - 1], "."))))
return site;
else
domain = site[dot + 1..$];
site = site[1..dot - 1];
while (site && (domain in this.large_domains))
if (dot = rindex(site, "."))
domain = tostr(site[dot + 1..$], ".", domain);
site = site[1..dot - 1];
else
return tostr(site, ".", domain);
endif
endwhile
return domain;
endif
.
#72:2
":open(address, port, [connect-connection-to])";
"Open a network connection to address/port.  If the connect-connection-to is passed, then the connection will be connected to that object when $login gets ahold of it.  If not, then the connection is just ignored by $login, i.e. not bothered by it with $welcome_message etc.";
"The object specified by connect-connection-to has to be a player (though it need not be a $player).";
"Returns the (initial) connection or an error, as in open_network_connection";
if (!this:trust(caller_perms()))
return E_PERM;
endif
{address, port, ?connect_to} = args;
if (length(args) < 3)
connect_to = $nothing;
elseif (((typeof(connect_to) == OBJ) && valid(connect_to)) && is_player(connect_to))
if (!$perm_utils:controls(caller_perms(), connect_to))
return E_PERM;
endif
else
return E_INVARG;
endif
if (typeof(connection = `open_network_connection(address, port) ! ANY') != ERR)
if (valid(connect_to))
this.connect_connections_to = {@this.connect_connections_to, {connection, connect_to}};
endif
endif
return connection;
.
#72:3
if (!this:trust(caller_perms()))
return E_PERM;
endif
con = args[1];
if (!index(`connection_name(con) ! ANY => ""', " to "))
return E_INVARG;
endif
boot_player(con);
if (i = $list_utils:iassoc(con, $network.connect_connections_to))
$network.connect_connections_to = listdelete($network.connect_connections_to, i);
endif
return 1;
.
#72:4
"sendmail(to, subject, line1, line2, ...)";
"  sends mail to internet address 'to', with given subject.";
"  It fills in various fields, such as date, from (from player), etc.";
"  the rest of the arguments are remaining lines of the message, and may begin with additional header fields.";
"  (must match RFC822 specification).";
"Requires $network.trust to call (no anonymous mail from MOO).";
"Returns 0 if successful, or else error condition or string saying why not.";
if (!this:trust(caller_perms()))
return E_PERM;
endif
mooname = this.MOO_name;
mooinfo = tostr(mooname, " (", this.site, " ", this.port, ")");
if (reason = this:invalid_email_address(to = args[1]))
return reason;
endif
"took out Envelope-from:  + this.errors_to_address";
tries = 4;
result = "unknown";
while ((tries > 0) && (result != 0))
tries = tries - 1;
result = this:raw_sendmail(to, "Date: " + $time_utils:rfc822_ctime(), "From: " + this:return_address_for(player), "To: " + to, "Subject: " + args[2], "Errors-to: " + this.errors_to_address, "X-Mail-Agent: " + mooinfo, @args[3..$]);
endwhile
return result;
.
#72:5
return (who = args[1]).wizard || (who in this.trusts);
.
#72:6
if (caller_perms().wizard)
pass(@args);
this.active = 0;
this.errors_to_address = "moomailerrors@yourhost";
this.site = "yoursite";
this.postmaster = "postmastername@yourhost";
this.usual_postmaster = "postmastername@yourhost";
this.password_postmaster = "postmastername@yourhost";
this.envelope_from = "postmastername@yourhost";
this.blank_envelope = 0;
this.MOO_name = "YourMOO";
this.maildrop = "localhost";
this.port = 7777;
this.large_domains = {};
this.trusts = {$hacker};
this.connect_connections_to = {};
endif
.
#72:7
"Copied from sendmail fix (#88079):raw_sendmail by Lineman (#108318) Mon Feb  1 19:29:43 1999 PST";
"rawsendmail(to, @lines)";
"sends mail without processing. Returns 0 if successful, or else reason why not.";
if (!caller_perms().wizard)
return E_PERM;
endif
if (!this.active)
return "Networking is disabled.";
endif
if (typeof(this.debugging) == LIST)
"who to notify";
debugging = this.debugging;
else
"notify this owner";
debugging = this.debugging && {this.owner};
endif
address = args[1];
body = listdelete(args, 1);
data = {"HELO " + this.site, ("MAIL FROM:<" + this.postmaster) + ">", ("RCPT TO:<" + address) + ">", "DATA"};
blank = 0;
for x in (body)
this:suspend_if_needed(0);
if (!(blank || match(x, "^[!-9;-~]+: ")))
if (x)
data = {@data, ""};
endif
blank = 1;
endif
data = {@data, (x && (x[1] == ".")) ? "." + x | x};
endfor
data = {@data, ".", "QUIT", ""};
suspend(0);
target = E_NONE;
for maildrop in ((typeof(this.maildrop) == LIST) ? this.maildrop | {this.maildrop})
target = $network:open(maildrop, 25);
if (typeof(target) != ERR)
break;
endif
endfor
if (typeof(target) == ERR)
return tostr(@(target == E_NONE) ? {"No maildrop specified"} | {"Cannot open connection to maildrop ", maildrop, ": ", target});
endif
set_connection_option(target, "hold-input", 1);
blast = 0;
msg = 0;
expects = {"220", "250", "250", "250%|251", "354", "250", "221"};
for line in (data)
if (!blast)
reply = this:tcp_wait(target);
if (typeof(reply) == ERR)
msg = "Connection dropped or timed out.";
break;
elseif (!match(reply[1..3], expects[1]))
msg = (("Expected " + expects[1]) + " but got ") + reply;
break;
endif
debugging && notify(debugging[1], "GET: " + reply);
expects[1..1] = {};
if (reply[1..3] == "221")
"Service closing transmission channel";
break;
elseif (reply[1..3] == "354")
"Start mail input; end with <CRLF>.<CRLF>";
blast = 1;
endif
elseif (line == ".")
blast = 0;
endif
debugging && notify(debugging[1], "SEND:" + line);
while (((ticks_left() < 4000) || (seconds_left() < 2)) || (!notify(target, line, 1)))
suspend(0);
endwhile
endfor
$network:close(target);
debugging && notify(debugging[1], "EXIT:" + (msg || "Mail sent successfully."));
return msg;
.
#72:8
"invalid_email_address(email) -- check to see if email looks like a valid email address. Return reason why not.";
address = args[1];
if (!address)
return "no email address supplied";
endif
if (!(at = rindex(address, "@")))
return ("'" + address) + "' doesn't look like a valid internet email address";
endif
name = address[1..at - 1];
host = address[at + 1..$];
if (match(name, "^in%%") || match(name, "^smtp%%"))
return tostr("'", name, "' doesn't look like a valid username (try removing the 'in%' or 'smtp%')");
endif
if (!match(host, $network.valid_host_regexp))
return tostr("'", host, "' doesn't look like a valid internet host");
endif
if (!match(name, $network.valid_email_regexp))
return tostr("'", name, "' doesn't look like a valid user name for internet mail");
endif
return "";
.
#72:9
return match(args[1], this.valid_host_regexp) ? "" | tostr("'", args[1], "' doesn't look like a valid internet host name");
.
#72:10
":email_will_fail(email-address[, display?]) => Makes sure the email-address is one that can actually be used by $network:sendmail().";
{email, ?display = 0} = args;
reason = this:invalid_email_address(email);
if (reason && display)
player:tell("Invalid email address: ", reason);
endif
return reason;
"following is code from OpalMOO, not used here";
"Possible situations where the address would be unusable are when the address is invalid or we can't connect to the site to send mail.";
"If <display> is true, error messages are displayed to the player and 1 is returned when address is unuable.  If <display> is false and address is unusable, the error message is returned.  If the address is usable, 0 is always returned.";
if (!this:approved_for_network(caller_perms()))
return E_PERM;
endif
if (!this:valid_email_address(email))
msg = tostr("Your email address (", email, ") is not a usable account.");
elseif ((result = this:verify_email_address(email)) == E_INVARG)
msg = tostr("Unable to connect to ", this:parse_address(email)[2], ".");
elseif (typeof(result) == STR)
msg = tostr("The site ", (parse = this:parse_address(email))[2], " does not recognize ", parse[1], " as a valid account.");
else
return 0;
endif
if (display)
player:tell(msg);
return 1;
else
return msg;
endif
"Last modified Tue Jun 15 00:19:01 1993 EDT by Ranma (#200).";
.
#72:11
"for trusted players, they can read from objects they own or open connections";
if (!this:trust(caller_perms()))
return E_PERM;
elseif (valid(x = args[1]))
if ((x.owner == x) || (x.owner != caller_perms()))
return E_INVARG;
endif
"elseif (!this:is_outgoing_connection(x) return E_PERM";
endif
return `read(@args) ! ANY';
.
#72:12
":is_open(object)";
"return true if the object is somehow connected, false otherwise.";
return typeof(`idle_seconds(@args) ! ANY') == INT;
"Relies on test in idle_seconds, and the error catching";
.
#72:13
"Peer at an incoming connection.  Decide if it should be connected to something, return that object. If it should be ignored (outbound connection), return 1. Called only by #0:do_login_command";
if (caller != #0)
return;
endif
what = args[1];
"this code for unix servers >= 1.7.5 only";
if (index(`connection_name(what) ! ANY => ""', " to "))
"outbound connection";
if (ct = $list_utils:assoc(what, this.connect_connections_to))
this.connect_connections_to = setremove(this.connect_connections_to, ct);
return ct[2];
else
return 1;
endif
else
return 0;
endif
.
#72:14
":return_address_for(player) => string of 'return address'. Currently inbound mail doesn't work, so this is a bogus address.";
who = args[1];
if (valid(who) && is_player(who))
return tostr(toint(who), "@", this.site, " (", who.name, ")");
else
return tostr($login.registration_address, " (non-player ", who, ")");
endif
.
#72:15
"called when restarting to clean out state.";
if (caller != #0)
return E_PERM;
endif
this.connect_connections_to = {};
.
#72:16
return index(`connection_name(args[1]) ! ANY => ""', " to ");
.
#72:17
"for trusted players, they can write to connections";
if (!this:trust(caller_perms()))
return E_PERM;
elseif (valid(x = args[1]))
return E_INVARG;
elseif (!this:is_outgoing_connection(x))
return E_PERM;
endif
return notify(x, args[2]);
.
#72:18
"$command_utils:suspend_if_needed but chowned to player";
if ($command_utils:running_out_of_time())
set_task_perms(caller_perms().wizard ? player | caller_perms());
return $command_utils:suspend_if_needed(@args);
endif
.
#72:19
":error(ERN, host, port) interpret open_network_connection(host, port) error";
{msg, host, port} = args;
if (msg == E_PERM)
return "Networking not enabled in server, or else user doesn't have permission to call o_n_c();";
elseif (msg == E_INVARG)
return tostr("The host/port ", toliteral(host), "/", toliteral(port), " is invalid or is not responding.");
elseif (msg == E_QUOTA)
return tostr("The connection to ", toliteral(host), "/", toliteral(port), " cannot be made at this time.");
else
return tostr("Unusual error: ", toliteral(msg));
endif
.
#72:20
"'cause this doesn't have a $_utils name";
return this:description();
.
#72:21
"adjust_postmaster_for_password(enter_or_exit): permits the MOO to have two different postmasters for different kinds of bounces.  If entering password (argument \"enter\"), change to $network.password_postmaster, else (argument \"exit\") change to $network.usual_postmaster.";
if (args[1] == "enter")
$network.postmaster = $network.password_postmaster;
$network.errors_to_address = $network.password_postmaster;
$network.envelope_from = $network.password_postmaster;
else
$network.postmaster = $network.usual_postmaster;
$network.errors_to_address = $network.usual_postmaster;
$network.envelope_from = $network.blank_envelope ? "" | $network.usual_postmaster;
endif
.
#72:22
"$network:add_queued_mail( mail message )";
"  -- where `mail message' is in the same format as passed to :raw_sendmail";
if (caller == this)
this.queued_mail = {@this.queued_mail, {time(), args}};
if (!$code_utils:task_valid(this.queued_mail_task))
fork fid (3600)
this:send_queued_mail();
endfork
this.queued_mail_task = fid;
endif
return 1;
else
return E_PERM;
endif
.
#72:23
"$network:send_queued_mail()";
"  -- tries to send the mail stored in the .queued_mail property";
while (queued_mail = this.queued_mail)
message = queued_mail[1];
if (!this:raw_sendmail(@message[2]))
this.queued_mail = setremove(this.queued_mail, message);
else
"wait an hour";
suspend(3600);
endif
endwhile
.
#72:24
"Copied from sendmail fix (#88079):tcp_wait by Lineman (#108318) Mon Feb  1 19:28:18 1999 PST";
{conn, ?timeout = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (timeout)
fork task (timeout)
boot_player(conn);
endfork
endif
while (1)
if (typeof(line = `read(conn) ! ANY') == ERR)
break;
elseif (match(line, "^[0-9][0-9][0-9] "))
timeout && `kill_task(task) ! ANY';
break;
endif
endwhile
return line;
.
#73:0
":_make(...) => new node with value {...}";
if (!(caller in {this._mgr, this}))
return E_PERM;
endif
prop = this:_genprop();
add_property(this, prop, args, {$generic_biglist_home.owner, ""});
return prop;
.
#73:1
":_kill(node) destroys the given node.";
if (!(caller in {this, this._mgr}))
return E_PERM;
endif
delete_property(this, args[1]);
.
#73:2
return (caller == this._mgr) ? this.(args[1]) | E_PERM;
.
#73:3
return (caller == this._mgr) ? this.(args[1]) = listdelete(args, 1) | E_PERM;
.
#73:4
gp = this._genprop;
ngp = "";
for i in [1..length(gp)]
if (gp[i] != "z")
ngp = (ngp + "bcdefghijklmnopqrstuvwxyz"[strcmp(gp[i], "`")]) + gp[i + 1..$];
return " " + (this._genprop = ngp);
endif
ngp = ngp + "a";
endfor
return " " + (this._genprop = ngp + "a");
.
#73:5
"this is a dummy. You have to decide what your leaves are going to look like and then write this verb accordingly.  It should, given a leaf/list-element, return the corresponding key value.  So for an ordinary alist, where all of the leaves are of the form {key,datum}, you want:";
return args[1][1];
.
#73:6
if (!caller_perms().wizard)
return E_PERM;
endif
pass(@args);
this.mowner = $hacker;
this._mgr = $biglist;
.
#74:0
all_help = this.help_msg;
if (typeof(all_help) == STR)
all_help = {all_help};
endif
helpless = {};
for vrb in (this.feature_verbs)
if (loc = $object_utils:has_verb(this, vrb))
loc = loc[1];
help = $code_utils:verb_documentation(loc, vrb);
if (help)
all_help = {@all_help, "", tostr(loc, ":", verb_info(loc, vrb)[3]), @help};
else
helpless = {@helpless, vrb};
endif
endif
endfor
if (helpless)
all_help = {@all_help, "", ("No help found on " + $string_utils:english_list(helpless, "nothing", " or ")) + "."};
endif
return {@all_help, "----"};
.
#74:1
"Definition from #1";
desc = this:description();
if (desc)
player:tell_lines(desc);
else
player:tell("You see nothing special.");
endif
player:tell("Please type \"help ", this, "\" for more information.");
.
#74:2
"Proper usage for the Generic Feature Object:";
"";
"First of all, the Generic Feature Object is constructed with the idea";
"that its children will be @moved to #24300, which is kind of a warehouse";
"for feature objects.  If there's enough interest, I'll try to make the";
"stuff that works with that in mind optional.";
"";
"Make a short description.  This is so I can continue to have looking at";
"#24300 give the descriptions of each of the objects in its .contents.";
"The :look_msg automatically includes a pointer to `help <this object>',";
"so you don't have to.";
"";
"Put a list of the commands you want people to use in";
"<this object>.feature_verbs.  (You need to use the :set_feature_verbs";
"verb to do this.)";
"";
"When someone types `help <this object>', they will be told the comment";
"strings from each of the verbs named in .feature_verbs.";
.
#74:3
return this in args[1].features;
.
#74:4
if ($perm_utils:controls(caller_perms(), this) || (caller == this))
return this.feature_ok = args[1];
else
return E_PERM;
endif
.
#74:5
"Can't see `get' unless it's in the room; can't see `drop' unless it's in the player.  Should possibly go on $thing.";
"Should use :contents, but I'm in a hurry.";
hidden = pass(@args);
if (this.location != args[1])
hidden = setadd(hidden, {$thing, verb_info($thing, "drop")[3], {"this", "none", "none"}});
hidden = setadd(hidden, {$thing, verb_info($thing, "give")[3], {"this", "at/to", "any"}});
endif
if (this.location != args[1].location)
hidden = setadd(hidden, {$thing, verb_info($thing, "get")[3], {"this", "none", "none"}});
endif
return hidden;
.
#74:6
if ($perm_utils:controls(caller_perms(), this) || (caller == this))
return this.feature_verbs = args[1];
else
return E_PERM;
endif
.
#74:7
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
pass(@args);
this.feature_verbs = {};
else
return E_PERM;
endif
.
#74:8
if (($code_utils:verb_location() == this) && caller_perms().wizard)
this.warehouse = $feature_warehouse;
`delete_property(this, "guest_ok") ! ANY';
`delete_verb(this, "set_ok_for_guest_use") ! ANY';
pass(@args);
endif
.
#74:9
"This is just a blank verb definition to encourage others to use this verb name if they care when a user is no longer using that feature.";
.
#74:10
return;
.
#74:11
":has_feature_verb(verb, dlist, plist, ilist)";
"If this feature has a feature verb that matches <verb> and whose {dobj, prep, iobj} arguments match the possibilities listed in <dlist>, <plist> and <ilist>, then return the name of that verb, otherwise return false.";
"Note: Individual FOs may over-ride this the method to redirect particular feature verbs to different verbs on the object. For example, 'sit with <any>' and 'sit on <any>' could be directed to separate :sit_with() and :sit_on() verbs -- which is something that the code below cannot do.";
{vrb, dlist, plist, ilist} = args;
if (`valid(loc = $object_utils:has_callable_verb(this, vrb)[1]) ! ANY => 0')
vargs = verb_args(loc, vrb);
if ((vargs[2] in plist) && ((vargs[1] in dlist) && (vargs[3] in ilist)))
return vrb;
endif
endif
return 0;
.
#75:0
notify(player, tostr(@args));
.
#75:1
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
.
#75:3
{who, what, name} = args;
return (who == verb_info(what, name)[1]) || who.wizard;
.
#75:4
{who, what, name} = args;
return (who == property_info(what, name)[1]) || who.wizard;
.
#75:5
args && raise(E_ARGS);
set_task_perms(caller_perms());
r = [];
r["Objects"] = {};
return r;
.
#75:6
{o, ?options = []} = args;
((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);
if (`valid(o) ! E_TYPE')
pcount = length(properties(o));
vcount = length(verbs(o));
set_task_perms(caller_perms());
r = ["Attributes" -> []];
v = parents(o);
m = ["id" -> "parents"];
m["status"] = this:_controls(caller_perms(), o) ? "writable" | "readable";
r["Attributes"]["parents"] = ["Meta" -> m, "Value" -> ["value" -> v]];
if (typeof(o) == OBJ)
v = is_player(o);
m = ["id" -> "player"];
m["status"] = `caller_perms().wizard ! E_INVIND' ? "writable" | "readable";
r["Attributes"]["player"] = ["Meta" -> m, "Value" -> ["value" -> v]];
endif
r["Values"] = [];
for a in (this:_values(o))
this:_suspend_if_necessary();
r["Values"][a] = this:read_value(o, a, options);
endfor
r["Properties"] = {};
for p in [1..pcount]
this:_suspend_if_necessary();
r["Properties"] = {@r["Properties"], this:read_property(o, p)};
endfor
r["Verbs"] = {};
for v in [1..vcount]
this:_suspend_if_necessary();
r["Verbs"] = {@r["Verbs"], this:read_verb(o, v)};
endfor
if (p = o.w || this:_controls(caller_perms(), o))
status = "writable";
elseif (o.r)
status = "readable";
else
status = "";
endif
if (typeof(o) == OBJ)
r["Meta"] = ["id" -> toint(o), "status" -> status];
else
r["Meta"] = ["status" -> status];
endif
return r;
else
if (typeof(o) == OBJ)
r = ["Meta" -> ["id" -> toint(o), "status" -> "invalid"]];
else
r = ["Meta" -> ["status" -> "invalid"]];
endif
return r;
endif
.
#75:7
{o, r, ?options = []} = args;
((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);
if (`valid(o) ! E_TYPE')
properties = properties(o);
verbs = verbs(o);
set_task_perms(caller_perms());
try
r["Attributes"];
r["Values"];
r["Properties"];
r["Verbs"];
errors = 0;
parents = `r["Attributes"]["parents"]["Value"]["value"] ! E_RANGE => parents(o)';
if (parents(o) != parents)
x = this:_write_parents(o, ["Value" -> ["value" -> {}]]);
errors = errors + ("Error" in mapkeys(x));
endif
location = `r["Values"]["location"]["Value"]["value"] ! E_RANGE => o.location';
if (o.location != location)
x = this:write_value(o, "location", ["Value" -> ["value" -> $nothing]]);
errors = errors + ("Error" in mapkeys(x));
endif
owner = `r["Values"]["owner"]["Value"]["value"] ! E_RANGE => o.owner';
if ("owner" in mapkeys(r["Values"]))
r["Values"]["owner"] = this:write_value(o, "owner", r["Values"]["owner"]);
errors = errors + ("Error" in mapkeys(r["Values"]["owner"]));
endif
if ("parents" in mapkeys(r["Attributes"]))
r["Attributes"]["parents"] = this:_write_parents(o, r["Attributes"]["parents"]);
errors = errors + ("Error" in mapkeys(r["Attributes"]["parents"]));
endif
if ("player" in mapkeys(r["Attributes"]))
r["Attributes"]["player"] = this:_write_player(o, r["Attributes"]["player"]);
errors = errors + ("Error" in mapkeys(r["Attributes"]["player"]));
endif
if ("location" in mapkeys(r["Values"]))
r["Values"]["location"] = this:write_value(o, "location", r["Values"]["location"]);
errors = errors + ("Error" in mapkeys(r["Values"]["location"]));
endif
if ((lp1 = length(properties)) < (lp2 = length(r["Properties"])))
for p in [lp1 + 1..lp2]
this:_suspend_if_necessary();
`add_property(o, tostr("___", p, "___"), 0, {owner, ""}) ! E_PERM';
endfor
else
for p in [lp2 + 1..lp1]
this:_suspend_if_necessary();
delete_property(o, properties[p]);
endfor
endif
if ((lv1 = length(verbs)) < (lv2 = length(r["Verbs"])))
for v in [lv1 + 1..lv2]
this:_suspend_if_necessary();
`add_verb(o, {owner, "", tostr("___", v, "___")}, {"this", "none", "this"}) ! E_PERM';
endfor
else
for v in [lv2 + 1..lv1]
this:_suspend_if_necessary();
delete_verb(o, lv2 + 1);
endfor
endif
for p in [1..length(r["Properties"])]
this:_suspend_if_necessary();
r["Properties"][p] = this:write_property(o, p, r["Properties"][p]);
if ("Error" in mapkeys(r["Properties"][p]))
if ((lp1 < lp2) && (r["Properties"][p]["Error"]["diagnostic"] == "property is invalid"))
r["Properties"][p]["Error"]["diagnostic"] = "permission denied";
endif
errors = errors + 1;
endif
endfor
for v in [1..length(r["Verbs"])]
this:_suspend_if_necessary();
r["Verbs"][v] = this:write_verb(o, v, r["Verbs"][v], `options["verbs"] ! E_RANGE => []');
if ("Error" in mapkeys(r["Verbs"][v]))
if ((lv1 < lv2) && (r["Verbs"][v]["Error"]["diagnostic"] == "verb is invalid"))
r["Verbs"][v]["Error"]["diagnostic"] = "permission denied";
endif
errors = errors + 1;
endif
endfor
values = setremove(setremove(mapkeys(r["Values"]), "location"), "owner");
for a in (values)
this:_suspend_if_necessary();
r["Values"][a] = this:write_value(o, a, r["Values"][a], options);
errors = errors + ("Error" in mapkeys(r["Values"][a]));
endfor
if (errors < 1)
r = this:read_object(o);
else
r["Meta"] = ["id" -> toint(o), "status" -> "unknown"];
r["Error"] = ["diagnostic" -> "errors in sub-operations"];
endif
return r;
except (E_RANGE, E_TYPE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
else
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
endif
.
#75:8
{object, property} = args;
for parent in (parents(object))
this:_suspend_if_necessary();
if (ret = `property_info(parent, property) ! E_PROPNF')
return ret;
endif
endfor
return {};
.
#75:9
{o} = args;
x = {};
for t in ({o, @ancestors(o)})
this:_suspend_if_necessary();
y = {};
for z in (properties(t))
this:_suspend_if_necessary();
y = {z, @y};
endfor
x = {@y, @x};
endfor
x = {"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a", @x};
return x;
.
#75:10
{o} = args;
set_task_perms(caller_perms());
r = ["Values" -> {}];
for value in (this:_values(o))
this:_suspend_if_necessary();
r["Values"] = {@r["Values"], this:read_value(o, value)};
endfor
return r;
.
#75:11
{o, a, ?options = []} = args;
strip_clear_values = `options["strip_clear_values"] ! E_RANGE';
set_task_perms(caller_perms());
try
if (a == "location")
v = o.location;
p = this:_controls(caller_perms(), o) ? "rw" | "r";
elseif (a in {"owner", "programmer", "wizard"})
v = o.(a);
p = `caller_perms().wizard ! E_INVIND' ? "rw" | "r";
elseif (a in {"r", "w", "f", "a"})
v = o.(a);
p = this:_controls(caller_perms(), o) ? "rw" | "r";
elseif (a in {"name"})
v = o.(a);
p = (`caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && (!is_player(o)))) ? "rw" | "r";
else
v = o.(a);
pi = property_info(o, a);
p = (index(pi[2], "w") || this:_controls_property(caller_perms(), o, a)) ? "rw" | "r";
c = is_clear_property(o, a);
endif
except (E_INVIND, E_PROPNF)
r = ["Meta" -> ["id" -> a, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> a, "status" -> "denied"]];
return r;
endtry
m = ["id" -> a];
m["status"] = index(p, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Value" -> ["value" -> v]];
if (`r["Value"]["clear"] = c ! E_VARNF' && strip_clear_values)
r["Value"] = mapdelete(r["Value"], "value");
endif
if (`pi ! E_VARNF')
if ((ppi = this:_parent_property_info(o, a)) && (ppi != pi))
r["Value"]["owner"] = pi[1];
r["Value"]["perms"] = pi[2];
endif
endif
return r;
.
#75:12
{o, a, r, ?options = []} = args;
set_task_perms(caller_perms());
mk = mapkeys(r);
if ((!("Meta" in mk)) && (!("Value" in mk)))
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
endif
old = this:read_value(o, a, options);
if (`old["Value"] ! E_RANGE' == `r["Value"] ! E_RANGE')
return old;
endif
try
mk = mapkeys(r["Value"]);
if (a in {"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a"})
if ("clear" in mk)
r["Error"] = ["diagnostic" -> "clear is not applicable"];
return r;
endif
if ("owner" in mk)
r["Error"] = ["diagnostic" -> "owner is not applicable"];
return r;
endif
if ("perms" in mk)
r["Error"] = ["diagnostic" -> "perms is not applicable"];
return r;
endif
endif
c = `r["Value"]["clear"] ! E_RANGE';
if (c)
clear_property(o, a);
else
v = r["Value"]["value"];
if (a == "location")
(o.location != v) && move(o, v);
else
o.(a) = v;
endif
endif
if (("owner" in mk) || ("perms" in mk))
set_property_info(o, a, {`r["Value"]["owner"] ! E_RANGE => caller_perms()', r["Value"]["perms"]});
endif
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PROPNF)
r["Error"] = ["diagnostic" -> "value is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_NACC)
r["Error"] = ["diagnostic" -> "move refused by destination"];
return r;
except (E_RECMOVE)
r["Error"] = ["diagnostic" -> "recursive move"];
return r;
endtry
return this:read_value(o, a, options);
.
#75:13
{o, r} = args;
set_task_perms(caller_perms());
try
v = r["Value"]["value"];
(parents(o) != v) && chparents(o, v);
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVARG)
r["Error"] = ["diagnostic" -> "argument is invalid"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
v = parents(o);
m = ["id" -> "parents"];
m["status"] = this:_controls(caller_perms(), o) ? "writable" | "readable";
return ["Meta" -> m, "Value" -> ["value" -> v]];
.
#75:14
{o, r} = args;
set_task_perms(caller_perms());
try
v = r["Value"]["value"];
(is_player(o) != v) && set_player_flag(o, v);
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVARG)
r["Error"] = ["diagnostic" -> "argument is invalid"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
v = is_player(o);
m = ["id" -> "player"];
m["status"] = `caller_perms().wizard ! E_INVIND' ? "writable" | "readable";
return ["Meta" -> m, "Value" -> ["value" -> v]];
.
#75:15
{o, v} = args;
try
vx = verbs(o);
except (E_TYPE, E_INVARG)
r = ["Meta" -> ["id" -> o, "status" -> "invalid"]];
return r;
endtry
try
vn = vx[v];
except (E_TYPE, E_RANGE)
r = ["Meta" -> ["id" -> v, "status" -> "invalid"]];
return r;
endtry
set_task_perms(caller_perms());
try
vi = verb_info(o, v);
va = verb_args(o, v);
vc = verb_code(o, v);
p = (index(vi[2], "w") || this:_controls_verb(caller_perms(), o, v)) ? "rw" | "r";
except (E_TYPE, E_INVARG, E_VERBNF)
r = ["Meta" -> ["id" -> v, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> v, "status" -> "denied"]];
return r;
endtry
m = ["id" -> v];
m["status"] = index(p, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Verb" -> ["owner" -> vi[1], "perms" -> vi[2], "names" -> vi[3], "dobj" -> va[1], "prep" -> va[2], "iobj" -> va[3], "code" -> vc]];
return r;
.
#75:16
{o, v, r, ?options = []} = args;
error1 = error2 = 0;
try
vx = verbs(o);
except (E_TYPE, E_INVARG)
error1 = 1;
endtry
try
vn = vx[v];
except (E_VARNF)
except (E_TYPE, E_RANGE)
error2 = 1;
endtry
set_task_perms(caller_perms());
old = this:read_verb(o, v);
if (`old["Verb"] ! E_RANGE' == `r["Verb"] ! E_RANGE')
return old;
endif
if (error1)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
elseif (error2)
r["Error"] = ["diagnostic" -> "verb is invalid"];
return r;
endif
try
r1 = r["Verb"];
set_verb_info(o, v, {`r1["owner"] ! E_RANGE => caller_perms()', r1["perms"], r1["names"]});
set_verb_args(o, v, {r1["dobj"], r1["prep"], r1["iobj"]});
vc = `r1["code"] ! E_RANGE => {}';
if (vc != E_RANGE)
if (set_verb_code(o, v, vc))
r["Error"] = ["diagnostic" -> "compilation errors"];
return r;
endif
endif
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND, E_INVARG)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
endtry
return this:read_verb(o, v);
.
#75:17
{o, p, ?options = []} = args;
try
px = properties(o);
except (E_TYPE, E_INVARG)
r = ["Meta" -> ["id" -> o, "status" -> "invalid"]];
return r;
endtry
try
pn = px[p];
except (E_TYPE, E_RANGE)
r = ["Meta" -> ["id" -> p, "status" -> "invalid"]];
return r;
endtry
set_task_perms(caller_perms());
try
pi = property_info(o, pn);
pv = o.(pn);
s = (index(pi[2], "w") || this:_controls_property(caller_perms(), o, pn)) ? "rw" | "r";
except (E_TYPE, E_INVARG, E_PROPNF)
r = ["Meta" -> ["id" -> p, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> p, "status" -> "denied"]];
return r;
endtry
m = ["id" -> p];
m["status"] = index(s, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Property" -> ["owner" -> pi[1], "perms" -> pi[2], "name" -> pn, "value" -> pv]];
return r;
.
#75:18
{o, p, r, ?options = []} = args;
error1 = error2 = 0;
try
px = properties(o);
except (E_TYPE, E_INVARG)
error1 = 1;
endtry
try
pn = px[p];
except (E_VARNF)
except (E_TYPE, E_RANGE)
error2 = 1;
endtry
set_task_perms(caller_perms());
old = this:read_property(o, p);
if (`old["Property"] ! E_RANGE' == `r["Property"] ! E_RANGE')
return old;
endif
if (error1)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
elseif (error2)
r["Error"] = ["diagnostic" -> "property is invalid"];
return r;
endif
try
r1 = r["Property"];
set_property_info(o, pn, {`r1["owner"] ! E_RANGE => caller_perms()', r1["perms"], r1["name"]});
o.(r1["name"]) = r1["value"];
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND, E_INVARG)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
endtry
return this:read_property(o, p);
.
#75:19
{?parents = {}} = args;
o = ["Attributes" -> [], "Values" -> [], "Properties" -> {}, "Verbs" -> {}];
if (parents)
o["Attributes"]["parents"] = ["Value" -> ["value" -> parents]];
endif
return o;
.
#75:20
{t, n, v} = args;
t["Values"][n] = ["Value" -> ["value" -> v]];
return t;
.
#75:21
{t, pn, pv, pi} = args;
p = ["Property" -> ["owner" -> pi[1], "perms" -> pi[2], "name" -> pn, "value" -> pv]];
t["Properties"] = {@t["Properties"], p};
return t;
.
#75:22
{t, vi, va, ?vc = {}} = args;
v = ["Verb" -> ["owner" -> vi[1], "perms" -> vi[2], "names" -> vi[3], "dobj" -> va[1], "prep" -> va[2], "iobj" -> va[3], "code" -> vc]];
t["Verbs"] = {@t["Verbs"], v};
return t;
.
#76:0
if (i = args[1] in {"list_numbers"})
return {{{"list_no_numbers"}[i], !args[2]}};
else
return {args};
endif
.
#76:1
if (o = (name = args[2]) in {"list_numbers"})
args[2] = {"list_no_numbers"}[o];
return {@pass(@args), tostr("(", name, " is a synonym for -", args[2], ")")};
else
return pass(@args);
endif
.
#76:2
if (value = this:get(@args))
return {value, {tostr("Default args for @verb:  ", $string_utils:from_list(value, " "))}};
else
return {0, {"Default args for @verb:  none none none"}};
endif
.
#76:3
value = args[1];
if (typeof(value) != LIST)
return "List expected";
elseif (length(value) != 3)
return "List of length 3 expected";
elseif (!(value[1] in {"this", "none", "any"}))
return tostr("Invalid dobj specification:  ", value[1]);
elseif (!((p = $code_utils:short_prep(value[2])) || (value[2] in {"none", "any"})))
return tostr("Invalid preposition:  ", value[2]);
elseif (!(value[3] in {"this", "none", "any"}))
return tostr("Invalid iobj specification:  ", value[3]);
else
if (p)
value[2] = p;
endif
return {value};
endif
.
#76:4
{oname, raw, data} = args;
if (typeof(raw) == STR)
raw = $string_utils:explode(raw, " ");
elseif (typeof(raw) == INT)
return raw ? {oname, {"this", "none", "this"}} | {oname, 0};
endif
value = $code_utils:parse_argspec(@raw);
if (typeof(value) != LIST)
return tostr(value);
elseif (value[2])
return tostr("I don't understand \"", $string_utils:from_list(value[2], " "), "\"");
else
value = {@value[1], "none", "none", "none"}[1..3];
return {oname, (value == {"none", "none", "none"}) ? 0 | value};
endif
.
#76:5
value = this:get(@args);
if (value)
return {value, {tostr("Default permissions for @property=`", value, "'.")}};
else
return {0, {"Default permissions for @property=`rc'."}};
endif
.
#76:7
{oname, raw, data} = args;
if (typeof(raw) != STR)
return "Must be a string composed of the characters `rwc'.";
endif
len = length(raw);
for x in [1..len]
if (!(raw[x] in {"r", "w", "c"}))
return "Must be a string composed of the characters `rwc'.";
endif
endfor
return {oname, raw};
.
#76:8
value = args[1];
if (typeof(value) != STR)
return "Must be a string composed of the characters `RWXD'.";
elseif ((stripped = $string_utils:subst(value, {{"R", ""}, {"W", ""}, {"X", ""}, {"D", ""}})) != "")
"I know you can strip_all_but, but we want to report invalid values.";
return tostr("Invalid permission ", $s("character", length(stripped)), ": ", stripped);
else
return {value};
endif
.
#76:9
if (value = this:get(@args))
return {value, {tostr("Default permissions for @verb:  ", value)}};
else
return {0, {"Default permissions for @verb:  rd"}};
endif
.
#76:10
{oname, raw, data} = args;
if (typeof(raw) == STR)
raw = {raw};
elseif (typeof(raw) == INT)
return raw ? {oname, "rxd"} | {oname, 0};
endif
value = this:check_verb_perms(raw[1]);
if (typeof(value) == STR)
return value;
endif
if (value[1] == "")
value = "RD";
endif
return {oname, (value[1] == "RD") ? 0 | value[1]};
.
#77:0
value = args[1];
if (m = match(value, "[^rwf]"))
return tostr("Unknown object flag:  ", value[m[1]]);
else
return {tostr(index(value, "r") ? "r" | "", index(value, "w") ? "w" | "", index(value, "f") ? "f" | "")};
endif
.
#77:1
if (value = this:get(@args))
return {value, {tostr("Object flags for @create:  ", value)}};
else
return {0, {tostr("@create leaves all object flags reset")}};
endif
.
#77:2
raw = args[2];
if (raw == 1)
"...+create_flags => create_flags=r";
return {args[1], "r"};
elseif (typeof(raw) == STR)
return args[1..2];
elseif (typeof(raw) != LIST)
return "???";
elseif (length(raw) > 1)
return tostr("I don't understand \"", $string_utils:from_list(listdelete(raw, 1), " "), "\"");
else
return {args[1], raw[1]};
endif
.
#77:3
name = args[2];
what = (verb == "show_dig_room") ? "room" | "exit";
if ((value = this:get(args[1], name)) == 0)
return {0, {tostr("@dig ", what, "s are children of $", what, ".")}};
else
return {value, {tostr("@dig ", what, "s are children of ", value, " (", valid(value) ? value.name | "invalid", ").")}};
endif
.
#77:4
{oname, raw, data} = args;
if (typeof(raw) == LIST)
if (length(raw) > 1)
return tostr("I don't understand \"", $string_utils:from_list(listdelete(raw, 1), " "), "\".");
endif
raw = raw[1];
endif
if (typeof(raw) != STR)
return "You need to give an object id.";
elseif ($command_utils:object_match_failed(value = player:my_match_object(raw), raw))
return "Option unchanged.";
endif
what = (verb == "parse_dig_room") ? "room" | "exit";
generic = #0.(what);
if (value == generic)
return {oname, 0};
else
if (!$object_utils:isa(value, generic))
player:tell("Warning: ", value, " is not a descendant of $", what, ".");
endif
return {oname, value};
endif
.
#79:0
if (!caller_perms().wizard)
return E_PERM;
else
args[1].size_quota = this.default_quota;
args[1].ownership_quota = this.large_negative_number;
endif
.
#79:1
if (!caller_perms().wizard)
return E_PERM;
else
pass(@args);
this.exempted = {};
this.working = #2;
this.task_time_limit = 500;
this.repeat_cycle = 0;
this.large_objects = {};
this.report_recipients = {#2};
this.default_quota = {100000, 0, 0, 1};
$quota_utils = this;
endif
.
#79:2
return 0;
.
#79:3
set_task_perms(caller_perms());
who = this:parse_create_args(@args);
"Because who can be E_INVARG, need to catch E_TYPE. Let $recycler:_create deal with returning E_PERM since that's what's going to happen. Ho_Yan 11/19/96.";
if ((!`who.wizard ! E_TYPE => 0') && $recycler.contents)
return $recycler:_create(@args);
elseif (this:creation_permitted(who))
this:enable_create(who);
value = `create(@args) ! ANY';
this:disable_create(who);
if (typeof(value) != ERR)
this:charge_quota(who, value);
if ((typeof(who.owned_objects) == LIST) && (!(value in who.owned_objects)))
this:add_owned_object(who, value);
endif
endif
return value;
else
return E_QUOTA;
endif
.
#79:4
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
else
args[1].ownership_quota = 1;
endif
.
#79:5
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
else
args[1].ownership_quota = this.large_negative_number;
endif
.
#79:6
"This figures out who is gonna own the stuff @create does.  If one arg, return caller_perms().  If two args, then if caller_perms().wizard, args[2].";
{what, ?who = #-1} = args;
if (!valid(who))
return caller_perms();
elseif ($perm_utils:controls(caller_perms(), who))
return who;
else
return E_INVARG;
endif
.
#79:7
"Here's the tricky one.  Collect all the user's characters' cached usage data and total quotas.  Compare same.  If usage bigger than quotas, return 0.  Else, add up the total number of objects that haven't been measured recently.  If greater than the allowed, return 0.  Else, reluctantly, return 1.";
who = args[1];
if (who.wizard || (who == $hacker))
"... sorry folks --Rog";
return 1;
endif
if ((!$object_utils:has_property(who, "size_quota")) || is_clear_property(who, "size_quota"))
return 0;
endif
$recycler:check_quota_scam(who);
allwho = this:all_characters(who);
quota = 0;
usage = 0;
unmeasured = 0;
for x in (allwho)
quota = quota + x.size_quota[1];
usage = usage + x.size_quota[2];
unmeasured = unmeasured + x.size_quota[4];
endfor
if (usage >= quota)
return 0;
elseif (unmeasured >= this.max_unmeasured)
return 0;
else
return 1;
endif
.
#79:8
{who} = args;
if ((caller != this) && (!this:can_peek(caller_perms(), who)))
return E_PERM;
elseif ($object_utils:has_property($local, "second_char_registry"))
seconds = $local.second_char_registry:all_second_chars(who);
if (seconds == E_INVARG)
return {who};
else
return seconds;
endif
else
return {who};
endif
.
#79:9
who = args[1];
if (this:can_peek(caller_perms(), who) && (length(all = this:all_characters(who)) > 1))
many = 1;
else
many = 0;
all = {who};
endif
if (many)
tquota = 0;
tusage = 0;
ttime = $maxint;
tunmeasured = 0;
tunmeasurable = 0;
endif
for x in (all)
{quota, usage, timestamp, unmeasured} = x.size_quota;
unmeasurable = 0;
if (unmeasured >= 100)
unmeasurable = unmeasured / 100;
unmeasured = unmeasured % 100;
endif
if (many)
player:tell(x.name, " quota: ", $string_utils:group_number(quota), "; usage: ", $string_utils:group_number(usage), "; unmeasured: ", unmeasured, "; no .object_size: ", unmeasurable, ".");
tquota = tquota + quota;
tusage = tusage + usage;
ttime = min(ttime, timestamp);
tunmeasured = tunmeasured + unmeasured;
tunmeasurable = tunmeasurable + unmeasurable;
endif
endfor
if (many)
this:display_quota_summary(who, tquota, tusage, ttime, tunmeasured, tunmeasurable);
else
this:display_quota_summary(who, quota, usage, timestamp, unmeasured, unmeasurable);
endif
.
#79:10
return args[1].size_quota[1];
.
#79:11
"Charge args[1] for the quota required to own args[2]";
{who, what} = args;
if ((caller == this) || caller_perms().wizard)
usage_index = 2;
unmeasured_index = 4;
object_size = $object_utils:has_property(what, "object_size") ? what.object_size[1] | -1;
if (object_size <= 0)
who.size_quota[unmeasured_index] = who.size_quota[unmeasured_index] + 1;
else
who.size_quota[usage_index] = who.size_quota[usage_index] + object_size;
endif
else
return E_PERM;
endif
.
#79:12
"reimburse args[1] for the quota required to own args[2]";
{who, what} = args;
if ((caller == this) || caller_perms().wizard)
usage_index = 2;
unmeasured_index = 4;
if (((valid(who) && is_player(who)) && $object_utils:has_property(what, "object_size")) && (!is_clear_property(who, "size_quota")))
object_size = what.object_size[1];
if (object_size <= 0)
who.size_quota[unmeasured_index] = who.size_quota[unmeasured_index] - 1;
else
who.size_quota[usage_index] = who.size_quota[usage_index] - object_size;
endif
endif
else
return E_PERM;
endif
.
#79:13
"Set args[1]'s quota to args[2]";
if ((caller_perms().wizard || (caller == this)) || this:can_touch(caller_perms()))
"Size_quota[1] is the total quota permitted.";
return args[1].size_quota[1] = args[2];
else
return E_PERM;
endif
.
#79:14
"Return args[1]'s quotas.  second arg of 1 means add all second chars.";
{who, ?all = 0} = args;
if (all && ((caller == this) || this:can_peek(caller_perms(), who)))
all = this:all_characters(who);
else
all = {who};
endif
baseline = {0, 0, 0, 0};
for x in (all)
baseline[1] = baseline[1] + x.size_quota[1];
baseline[2] = baseline[2] + x.size_quota[2];
baseline[3] = min(baseline[3], x.size_quota[3]) || x.size_quota[3];
baseline[4] = baseline[4] + x.size_quota[4];
endfor
return baseline;
.
#79:15
{who, quota, usage, timestamp, unmeasured, unmeasurable} = args;
player:tell(who.name, " has a total building quota of ", $string_utils:group_number(quota), " bytes.");
player:tell($gender_utils:get_pronoun("P", who), " total usage was ", $string_utils:group_number(usage), " as of ", player:ctime(timestamp), ".");
if (usage > quota)
player:tell(who.name, " is over quota by ", $string_utils:group_number(usage - quota), " bytes.");
else
player:tell(who.name, " may create up to ", $string_utils:group_number(quota - usage), " more bytes of objects, properties, or verbs.");
endif
if (unmeasured)
plural = unmeasured != 1;
player:tell("There ", plural ? tostr("are ", unmeasured, " objects") | "is 1 object", " which ", plural ? "are" | "is", " not yet included in the tally; this tally may thus be inaccurate.");
if (unmeasured >= this.max_unmeasured)
player:tell("The number of unmeasured objects is too large; no objects may be created until @measure new is used.");
endif
endif
if (unmeasurable)
plural = unmeasurable != 1;
player:tell("There ", plural ? tostr("are ", unmeasurable, " objects") | "is 1 object", " which do", plural ? "" | "es", " not have a .object_size property and will thus prevent additional building.", (who == player) ? "  Contact a wizard for assistance in having this situation repaired." | "");
endif
.
#79:16
"This wants to only be called by a wizard cuz I'm lazy.  This is just for @second-char anyway.";
if (caller_perms().wizard)
q = this:get_size_quota(args[1], 1);
return q[1] - q[2];
endif
.
#79:17
return value_bytes(args[1]);
set_task_perms(caller_perms());
v = args[1];
t = typeof(v);
if (t == LIST)
b = ((length(v) + 1) * 2) * 4;
for vv in (v)
$command_utils:suspend_if_needed(2);
b = b + this:value_bytes(vv);
endfor
return b;
elseif (t == STR)
return length(v) + 1;
else
return 0;
endif
.
#79:18
"No need for lengthy algorithms to measure an object, we have a builtin now. Ho_Yan 10/31/96";
set_task_perms($wiz_utils:random_wizard());
o = args[1];
if (((($object_utils:has_property(o, "object_size") && (o.object_size[1] > this.too_large)) && (!caller_perms().wizard)) && (caller_perms() != this.owner)) && (caller_perms() != $hacker))
return o.object_size[1];
endif
b = object_bytes(o);
if ($object_utils:has_property(o, "object_size"))
oldsize = is_clear_property(o, "object_size") ? 0 | o.object_size[1];
if ($object_utils:has_property(o.owner, "size_quota"))
"Update quota cache.";
if (oldsize)
o.owner.size_quota[2] = o.owner.size_quota[2] + (b - oldsize);
else
o.owner.size_quota[2] = o.owner.size_quota[2] + b;
if (o.owner.size_quota[4] > 0)
o.owner.size_quota[4] = o.owner.size_quota[4] - 1;
endif
endif
endif
o.object_size = {b, time()};
endif
if (b > this.too_large)
this.large_objects = setadd(this.large_objects, o);
endif
return b;
.
#79:19
who = args[1];
results = this:summarize_one_user(who);
{total, nuncounted, nzeros, oldest, eldest} = results;
player:tell(who.name, " statistics:");
player:tell("  ", $string_utils:group_number(total), " bytes of storage measured.");
player:tell("  Oldest measurement date ", ctime(oldest), " (", $string_utils:from_seconds(time() - oldest), " ago) of object ", eldest, " (", valid(eldest) ? eldest.name | "$nothing", ")");
if (nzeros || nuncounted)
player:tell("  Number of objects with no statistics recorded:  ");
player:tell("      ", nzeros, " recently created, ", nuncounted, " not descendents of #1");
endif
.
#79:20
"Summarizes total space usage by one user (args[1]).  Optional second argument is a flag to say whether to re-measure all objects for this user; specify the number of seconds out of date you are willing to accept.  If negative, will only re-measure objects which have no recorded data.";
"Returns a list of four values:";
"  total : total measured space in bytes";
"  uncounted : Number of objects that were not counted because they aren't descendents of #1";
"  zeros : Number of objects which have been created too recently to have any measurement data at all (presumably none if re-measuring)";
"  most-out-of-date : the time() the oldest actual measurement was taken";
"  object-thereof: the object who had this time()'d measurement";
who = args[1];
if (length(args) == 2)
if (args[2] < 0)
earliest = 1;
else
earliest = time() - args[2];
endif
else
earliest = 0;
endif
nzeros = 0;
oldest = time();
eldest = #-1;
nuncounted = 0;
total = 0;
for x in ((typeof(who.owned_objects) == LIST) ? who.owned_objects | {})
if (x.owner == who)
"Bulletproofing against recycling during suspends!";
"Leaves us open to unsummarized creation during this period, which is unfortunate.";
if ($object_utils:has_property(x, "object_size"))
size = x.object_size[1];
time = x.object_size[2];
if (time < earliest)
"Re-measure.  This side-effects x.object_size.";
this:object_bytes(x);
size = x.object_size[1];
time = x.object_size[2];
endif
if (time && (time <= oldest))
oldest = time;
eldest = x;
elseif (!time)
nzeros = nzeros + 1;
endif
if (size >= 0)
total = total + size;
endif
else
nuncounted = nuncounted + 1;
endif
endif
$command_utils:suspend_if_needed(0);
endfor
if (!is_clear_property(who, "size_quota"))
"Cache the data, but only if they aren't scamming.";
who.size_quota[2] = total;
who.size_quota[3] = oldest;
who.size_quota[4] = (nuncounted * this.unmeasured_multiplier) + nzeros;
endif
return {total, nuncounted, nzeros, oldest, eldest};
.
#79:21
":recent_object_bytes(x, n) -- return object size of x, guaranteed to be no more than n days old.  N defaults to this.cycle_days.";
{object, ?since = this.cycle_days} = args;
if (!valid(object))
return 0;
elseif (`object.object_size[2] ! ANY => 0' > (time() - (((since * 24) * 60) * 60)))
"Trap error when doesn't have .object_size for some oddball reason. Ho_Yan 11/19/96";
return object.object_size[1];
else
return this:object_bytes(object);
endif
.
#79:22
if (!caller_perms().wizard)
return E_PERM;
else
start_time = time();
{num_processed, num_repetitions} = this:measurement_task_body(args[1]);
players = players();
lengthp = length(players);
if ((!num_repetitions) && (num_processed < (lengthp / 2)))
"Add this in because we aren't getting people summarized like we should.  We're going to work for way longer now, cuz we're going to do a second pass, but we really need to get those summaries done.  Only do this if we hardly did any work.  Note the -1 here: measure all newly created objects as well.  More work, sigh.";
extra_end = time() + (3600 * 3);
for x in (players)
if (is_player(x) && (time() < extra_end))
"Robustness as above, plus don't run all day.  My kingdom for a break statement";
this:summarize_one_user(x, -1);
endif
$command_utils:suspend_if_needed(0);
endfor
endif
$mail_agent:send_message(player, this.report_recipients, "quota-utils report", {tostr("About to measure objects of player ", this.working.name, " (", this.working, "), ", $string_utils:ordinal(this.working in players), " out of ", lengthp, ".  We processed ", num_processed + (lengthp * num_repetitions), " players in this run in ", num_repetitions, " time", (num_repetitions == 1) ? "" | "s", " through all players.  Total time spent:  ", $time_utils:dhms(time() - start_time), ".")});
endif
.
#79:23
return (args[1] == this.owner) || $perm_utils:controls(args[1], args[2]);
.
#79:24
return args[1].wizard;
.
#79:25
dobj = args[1];
who = valid(caller_perms()) ? caller_perms() | player;
if (!this:can_peek(who, dobj.owner))
return E_PERM;
endif
props = $object_utils:all_properties_suspended(dobj);
grand_total = obj_over = this:object_overhead_bytes(dobj);
output = {tostr("Object overhead:  ", obj_over)};
if (props)
total = 0;
lines = {};
output = {@output, "Properties, defined and inherited, sorted by size:"};
for x in (props)
$command_utils:suspend_if_needed(0, "...One moment. Working on the breakdown...");
if (!is_clear_property(dobj, x))
size = value_bytes(dobj.(x));
total = total + size;
if (size)
lines = {@lines, {x, size}};
endif
endif
endfor
lines = $list_utils:reverse_suspended($list_utils:sort_suspended(0, lines, $list_utils:slice(lines, 2)));
for x in (lines)
$command_utils:suspend_if_needed(0, "...One moment. Working on the breakdown...");
text = tostr("  ", x[1], ":  ", x[2]);
output = {@output, text};
endfor
output = {@output, tostr("Total size of properties:  ", total)};
grand_total = grand_total + total;
endif
prop_over = this:property_overhead_bytes(dobj, props);
output = {@output, tostr("Property overhead:  ", prop_over)};
grand_total = grand_total + prop_over;
if (verbs(dobj))
output = {@output, "Verbs, sorted by size:"};
total = 0;
lines = {};
for x in [1..length(verbs(dobj))]
$command_utils:suspend_if_needed(0, "...One moment. Working on the breakdown...");
vname = verb_info(dobj, x)[3];
size = (value_bytes(verb_code(dobj, x, 0, 0)) + length(vname)) + 1;
total = total + size;
lines = {@lines, {vname, size}};
endfor
lines = $list_utils:reverse_suspended($list_utils:sort_suspended(0, lines, $list_utils:slice(lines, 2)));
for x in (lines)
$command_utils:suspend_if_needed(0, "...One moment. Working on the breakdown...");
text = tostr("  ", x[1], ":  ", x[2]);
output = {@output, text};
endfor
output = {@output, tostr("Total size of verbs:  ", total)};
grand_total = grand_total + total;
verb_over = this:verb_overhead_bytes(dobj);
output = {@output, tostr("Verb overhead:  ", verb_over)};
grand_total = grand_total + verb_over;
endif
output = {@output, tostr("Grand total:  ", grand_total)};
return output;
"Last modified Sun Dec 31 10:12:14 2006 PST, by Roebare (#109000) @ LM.";
.
#79:26
object = args[1];
return ((13 * 4) + length(object.name)) + 1;
.
#79:27
{o, ?ps = $object_utils:all_properties_suspended(o)} = args;
return (value_bytes(properties(o)) - 4) + ((length(ps) * 4) * 4);
.
#79:28
o = args[1];
vs = verbs(o);
return (length(vs) * 5) * 4;
.
#79:29
":add_owned_object(who, what) -- adds what to whose .owned_objects.";
{who, what} = args;
if ((typeof(who.owned_objects) == LIST) && (what.owner == who))
who.owned_objects = setadd(who.owned_objects, what);
endif
.
#79:30
"This is a one-shot run of the measurement task, as opposed to :measurement_task, which will fork once per day.";
if (!caller_perms().wizard)
return E_PERM;
else
{num_processed, num_repetitions} = this:measurement_task_body();
$mail_agent:send_message(player, player, "quota-utils report", {"finished one shot run of measurement task: processed ", num_processed, " players in ", num_repetitions, " runs through all players."});
endif
.
#79:31
if (!caller_perms().wizard)
return E_PERM;
else
num_processed = 0;
num_repetitions = 0;
usage_index = 2;
time_index = 3;
unmeasured_index = 4;
players = setremove(players(), $hacker);
lengthp = length(players);
index = this.working in players;
keep_going = 1;
if (!index)
"Uh, oh, our guy got reaped while we weren't looking.  Better look for someone else.";
index = 1;
while ((this.working > players[index]) && (index < lengthp))
$command_utils:suspend_if_needed(0);
index = index + 1;
endwhile
this.working = players[index];
endif
day = (60 * 60) * 24;
stop = time() + args[1];
early = time() - (day * this.cycle_days);
tooidle = day * this.cycle_days;
"tooidletime is only used if !this.repeat_cycle.";
tooidletime = time() - tooidle;
local_per_player_hack = $object_utils:has_verb($local, "per_player_daily_scan");
while ((time() < stop) && keep_going)
who = players[index];
if (is_player(who) && $object_utils:has_property(who, "size_quota"))
"Robustness in the face of reaping...";
if ((!this.repeat_cycle) || ((who.last_disconnect_time > tooidletime) && (who.last_disconnect_time != $maxint)))
"only measure people who login regularly if we're a big moo.";
usage = 0;
unmeasured = 0;
earliest = time();
for o in (who.owned_objects)
if ((valid(o) && (o.owner == who)) && (!(o in this.exempted)))
"sanity check: might have recycled while we suspended!";
if ($object_utils:has_property(o, "object_size"))
if (o.object_size[2] < early)
usage = usage + this:object_bytes(o);
else
usage = usage + o.object_size[1];
earliest = min(earliest, o.object_size[2]);
endif
else
unmeasured = unmeasured + 1;
endif
endif
$command_utils:suspend_if_needed(3);
endfor
if (!is_clear_property(who, "size_quota"))
who.size_quota[usage_index] = usage;
who.size_quota[unmeasured_index] = this.unmeasured_multiplier * unmeasured;
who.size_quota[time_index] = earliest;
else
$mail_agent:send_message(player, player, "Quota Violation", {tostr(who, " has a clear .size_quota property."), $string_utils:names_of({who, @$object_utils:ancestors(who)})});
endif
elseif (who.size_quota[unmeasured_index])
"If they managed to create an object *despite* being too idle (presumably programmatically), measure it.";
this:summarize_one_user(who, -1);
endif
elseif (is_player(who))
"They don't have a size_quota property.  Whine.";
$mail_agent:send_message(player, player, "Quota Violation", {tostr(who, " doesn't seem to have a .size_quota property."), $string_utils:names_of({who, @$object_utils:ancestors(who)})});
endif
if (local_per_player_hack)
$local:per_player_daily_scan(who);
endif
if (index >= lengthp)
index = 1;
else
index = index + 1;
endif
num_processed = num_processed + 1;
if (num_processed > lengthp)
if (this.repeat_cycle)
"If we've gotten everyone up to threshold, try measuring some later than that.";
early = early + ((24 * 60) * 60);
tooidle = tooidle * 4;
tooidletime = tooidletime - tooidle;
num_repetitions = num_repetitions + 1;
num_processed = 0;
if (early > time())
"Don't spin our wheels when we've measured everything!";
keep_going = 0;
endif
else
keep_going = 0;
endif
endif
this.working = players[index];
endwhile
return {num_processed, num_repetitions};
endif
.
#79:32
if ((caller == this) || caller_perms().wizard)
day = 24 * 3600;
hour_of_day_GMT = 8;
fork ((((hour_of_day_GMT * 60) * 60) + day) - (time() % day))
this:schedule_measurement_task();
this.measurement_task_running = task_id();
this:measurement_task(this.task_time_limit);
this.measurement_task_running = 0;
endfork
endif
.
#79:33
"Put all your wizards in $byte_quota_utils.wizards.  Then various long-running tasks will cycle among the permissions, spreading out the scheduler-induced personal lag.";
$wiz_utils.old_task_perms_user = setadd($wiz_utils.old_task_perms_user, caller);
return $wiz_utils:random_wizard();
.
#79:34
"this:property_exists(object, property)";
" => does the specified property exist?";
return !(!`property_info(@args) ! ANY');
.
#80:0
"*Must* be called with PDATA first, and LINES second.";
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
else
try
this.(args[2]);
except (E_PROPNF)
add_property(this, args[2], {}, {$hacker, ""});
endtry
try
this.(args[3]);
except (E_PROPNF)
add_property(this, args[3], 5, {$hacker, ""});
endtry
endif
.
#80:1
if (!caller_perms().wizard)
return;
else
for x in (properties(this))
if (x[1] == "#")
delete_property(this, x);
endif
$command_utils:suspend_if_needed(0);
endfor
pass(@args);
endif
.
#80:2
{who, newdata} = args;
if (is_player(who) && caller_perms().wizard)
"if ($perm_utils:controls(caller_perms(), who) && is_player(who))";
d = tostr(who, "pdata");
l = tostr(who, "lines");
this:ensure_props_exist(who, d, l);
data = this.(d);
lines = this.(l);
"Icky G7 code copied straight out of $player:tell.";
if (((len = length(this.(d) = {@data, newdata})) * 2) > (lines * 3))
this.(d) = this.(d)[(len - lines) + 1..len];
endif
else
return E_PERM;
endif
.
#80:3
who = args[1];
if ($perm_utils:controls(caller_perms(), who))
d = tostr(who, "pdata");
if (typeof(`this.(d) ! ANY') == LIST)
return this.(d);
else
return {};
endif
else
return E_PERM;
endif
.
#80:4
who = args[1];
if ($perm_utils:controls(caller_perms(), who))
d = tostr(who, "pdata");
"OK if this would toss its cookies if no prop, no damage.";
`this.(d) = {} ! ANY';
else
return E_PERM;
endif
.
#80:5
maximum = this.max_lines;
who = args[1];
if ($perm_utils:controls(caller_perms(), who) && is_player(who))
l = tostr(who, "lines");
this:ensure_props_exist(who, l, l);
kept = min(args[2], maximum);
this.(l) = kept;
return kept;
else
return E_PERM;
endif
.
#80:6
if ((((caller != this) && (caller_perms() != #-1)) && (caller_perms() != player)) || (!player.wizard))
$error:raise(E_PERM);
endif
threshold = ((60 * 60) * 24) * 3;
for x in (properties(this))
if (x[1] == "#")
l = length(x);
who = toobj(x[1..l - 5]);
if (((!valid(who)) || (!is_player(who))) || (!this:is_paranoid(who)))
delete_property(this, x);
else
if (index(x, "lines"))
if (typeof(this.(x)) != INT)
this.(x) = 10;
endif
elseif (index(x, "pdata"))
if (((!$object_utils:connected(who)) && (who.last_disconnect_time < (time() - threshold))) && (who.last_connect_time < (time() - threshold)))
this.(x) = {};
endif
if (typeof(this.(x)) != LIST)
this.(x) = {};
endif
endif
endif
endif
$command_utils:suspend_if_needed(0);
endfor
.
#80:7
return this:description();
.
#80:8
if (!caller_perms().wizard)
return E_PERM;
else
threedays = (3 * 24) * 3600;
fork ((((7 * 60) * 60) + threedays) - (time() % threedays))
this:(verb)();
endfork
this:gc();
endif
.
#80:9
"Some people make their .paranoid !r.  Wizardly verb to retrieve value.";
return `args[1].paranoid ! ANY';
.
#81:0
if (!caller_perms().wizard)
return E_PERM;
else
args[1].ownership_quota = $wiz_utils.default_player_quota;
endif
.
#81:1
if (!caller_perms().wizard)
return E_PERM;
else
pass(@args);
"Uncomment this if you want to send the core out with object quota.";
"  $quota_utils = this";
endif
.
#81:2
if (!caller_perms().wizard)
return E_PERM;
else
victim = args[1];
oldquota = victim.ownership_quota;
if ($object_utils:has_property($local, "second_char_registry") && $local.second_char_registry:is_second_char(victim))
"don't increment quota for 2nd chars when programmering";
victim.ownership_quota = oldquota;
else
victim.ownership_quota = oldquota + ($wiz_utils.default_programmer_quota - $wiz_utils.default_player_quota);
endif
endif
.
#81:3
"Calls built-in create.";
set_task_perms(caller_perms());
return `create(@args) ! ANY';
.
#81:4
$recycler:check_quota_scam(args[1]);
return args[1].ownership_quota > 0;
.
#81:5
return 1;
.
#81:6
who = args[1];
if (caller_perms() == who)
q = who.ownership_quota;
total = (typeof(who.owned_objects) == LIST) ? length(setremove(who.owned_objects, who)) | 0;
if (q == 0)
player:tell(tostr("You can't create any more objects", (total < 1) ? "." | tostr(" until you recycle some of the ", total, " you already own.")));
else
player:tell(tostr("You can create ", q, " new object", (q == 1) ? "" | "s", (total == 0) ? "." | tostr(" without recycling any of the ", total, " that you already own.")));
endif
else
if ($perm_utils:controls(caller_perms(), who))
player:tell(tostr(who.name, "'s quota is currently ", who.ownership_quota, "."));
else
player:tell("Permission denied.");
endif
endif
.
#81:7
if ($perm_utils:controls(caller_perms(), args[1]) || (caller == this))
return args[1].ownership_quota;
else
return E_PERM;
endif
.
#81:8
"Charge args[1] for the quota required to own args[2]";
{who, what} = args;
if ((caller == this) || caller_perms().wizard)
who.ownership_quota = who.ownership_quota - 1;
else
return E_PERM;
endif
.
#81:9
"Reimburse args[1] for the quota required to own args[2]";
{who, what} = args;
if ((caller == this) || caller_perms().wizard)
who.ownership_quota = who.ownership_quota + 1;
else
return E_PERM;
endif
.
#81:10
"Set args[1]'s quota to args[2]";
{who, quota} = args;
if (caller_perms().wizard || (caller == this))
return who.ownership_quota = quota;
else
return E_PERM;
endif
.
#81:11
return 0;
.
#81:12
"Is args[1] permitted to examine args[2]'s quota information?";
return $perm_utils:controls(args[1], args[2]);
.
#81:13
"Is args[1] permitted to examine args[2]'s quota information?";
return args[1].wizard;
.
#82:0
output = {"On $server_options, the following settings have been established by the wizards:", ""};
wizonly = {};
etc = {};
mentioned = {};
for x in (setremove(properties(this), "help_msg"))
if (index(x, "protect_") == 1)
mentioned = {@mentioned, x[9..$]};
wizonly = {@wizonly, tostr(x[9..$], "() is ", this.(x) ? "" | "not ", "wizonly.")};
else
etc = {@etc, tostr("$server_options.", x, " = ", $string_utils:print(this.(x)))};
endif
endfor
if ("set_verb_code" in wizonly)
wizonly = {@wizonly, "", "Note: since the 'set_verb_code' built-in function is wiz-only, then the '.program' built-in command is wiz-only too."};
endif
if (bf = $set_utils:intersection(verbs(#0), mentioned))
bf = $list_utils:sort(bf);
etc = {@etc, "", "In your code, #0:(built-in)(@args) should be called rather than built-in(@args) when you would use one of the following built-in functions:", $string_utils:english_list(bf) + ".", ((("Example: #0:" + bf[1]) + "(@args) should be used instead of ") + bf[1]) + "(@args)"};
endif
return {@this.help_msg, @output, @wizonly, "", @etc};
.
#82:1
if (!caller_perms().wizard)
raise(E_PERM);
endif
this.support_numeric_verbname_strings = 0;
pass(@args);
.
#83:0
"Copied from Features Feature Object (#24300):list by Joe (#2612) Mon Oct 10 21:07:35 1994 PDT";
if (this.contents)
player:tell(".features objects:");
player:tell("----------------------");
first = 1;
for thing in (this.contents)
$command_utils:kill_if_laggy(10, "Sorry, the MOO is very laggy, and there are too many feature objects in here to list!");
$command_utils:suspend_if_needed(0);
if (!first)
player:tell();
endif
player:tell($string_utils:nn(thing), ":");
`thing:look_self() ! ANY => player:tell("<<Error printing description>>")';
first = 0;
endfor
player:tell("----------------------");
else
player:tell("No objects in ", this.name, ".");
endif
.
#84:0
if (!caller_perms().wizard)
raise(E_PERM);
endif
pass(@args);
this.("@quota") = {"*forward*", "object-quota"};
.
#87:0
if (typeof(base = this.(verb)) == STR)
base = {base};
endif
base = {@base, "", tostr(".minimum_password_length = ", toliteral(x = this.minimum_password_length)), x ? tostr("Passwords are required to be a minimum of ", $string_utils:english_number(x), " characters in length.") | "There is no minimum length requirement for passwords."};
base = {@base, "", tostr(".check_against_moo = ", toliteral(x = this.check_against_moo)), tostr("Passwords ", x ? "may not" | "may", " be variants on the MOO's name (", $network.MOO_name, ").")};
base = {@base, "", tostr(".check_against_name = ", toliteral(x = this.check_against_name)), tostr("Passwords ", x ? "may not" | "may", " be variants on the player's MOO name and/or aliases.")};
base = {@base, "", tostr(".check_against_email = ", toliteral(x = this.check_against_email)), x ? "Passwords may not be variants on the player's email address." | "Passwords are not checked against the player's email address."};
base = {@base, "", tostr(".check_against_hosts = ", toliteral(x = this.check_against_hosts)), x ? "Passwords may not be variants on the player's hostname(s)." | "Passwords are not checked against the player's hostname(s)."};
base = {@base, "", tostr(".check_against_dictionary = ", toliteral(x = this.check_against_dictionary)), tostr("Passwords ", (typeof(x) in {LIST, OBJ}) ? "may not" | "may", " be dictionary words.", (x && (!$network.active)) ? "  (This option is set but unavailable.)" | "")};
base = {@base, "", tostr(".require_funky_characters = ", toliteral(x = this.require_funky_characters)), tostr("Non-alphabetic characters are ", x ? "" | "not ", "required in passwords.")};
base = {@base, "", tostr(".check_obscure_stuff = ", toliteral(x = this.check_obscure_stuff)), x ? "Misc. obscure checks enabled" | "No obscure checks in use."};
return base;
.
#87:1
":reject_password ( STR password [ , OBJ for-whom ] );";
"=> string value [if the password is rejected, why?]";
"=> false value [if the password isn't rejected]";
if (length(args) == 1)
trust = 0;
else
if ($perm_utils:controls(caller_perms(), args[2]))
trust = 1;
else
return "Permissions don't permit setting of that password.";
endif
endif
"this is gonna be huge";
return (((((((this:trivial_check(@args) || (this.minimum_password_length && this:check_length(@args))) || ((this.check_against_name && trust) && this:check_name(@args))) || ((this.check_against_email && trust) && this:check_email(@args))) || ((this.check_against_hosts && trust) && this:check_hosts(@args))) || ((typeof(this.check_against_dictionary) in {LIST, OBJ}) && this:check_dictionary(@args))) || (this.require_funky_characters && this:check_for_funky_characters(@args))) || (this.check_against_moo && this:check_against_moo(@args))) || (this.check_obscure_stuff && this:check_obscure_combinations(@args));
.
#87:2
if (typeof(pwd = args[1]) != STR)
return "Passwords must be strings.";
elseif (index(pwd, " "))
return "Passwords may not contain spaces.";
elseif (length(args) == 2)
if (((typeof(who = args[2]) != OBJ) || (!valid(who))) || (!is_player(who)))
return "That's not a player.";
elseif (!$perm_utils:controls(caller_perms(), who))
return "You can't set the password for that player.";
elseif ($object_utils:isa(who, $guest))
return "Sorry, but guest characters are not allowed to change their passwords.";
endif
endif
.
#87:3
if ((l = this.minimum_password_length) && (length(args[1]) < l))
return tostr("Passwords must be a minimum of ", $string_utils:english_number(l), (l == 1) ? " character " | " characters ", "long.");
endif
.
#87:4
pwd = args[1];
if (valid($player_db:find_exact(pwd)))
return "Passwords may not be close to a player's name/alias pair.";
elseif (valid($player_db:find($string_utils:reverse(pwd))))
return "Passwords ought not be the reverse of a player's name/alias.";
endif
.
#87:5
{pwd, who} = args;
if (!$perm_utils:controls(caller_perms(), who))
return "Permission denied.";
endif
email = $wiz_utils:get_email_address(who);
if (!email)
"can't check";
return;
endif
if (index(email, pwd))
return "Passwords can't match your registered email address.";
endif
.
#87:6
{pwd, who} = args;
if (!$perm_utils:controls(caller_perms(), who))
return "Permission denied.";
endif
hosts = who.all_connect_places;
for x in (hosts)
if (index(x, pwd))
return "Passwords may not match hostnames.";
endif
endfor
.
#87:7
pwd = args[1];
if (typeof(dict) == OBJ)
"assume we're checking mr spell";
try
if (dict:find_exact(pwd) && (!this:_is_funky_case(pwd)))
return "Dictionary words are not permitted for passwords.";
endif
except (ANY)
"in case this is messed up. Just let it go and return 0;";
endtry
endif
.
#87:8
if (this:_is_funky_case(pwd = args[1]))
return;
endif
alphabet = $string_utils.alphabet;
for i in [1..length(pwd)]
if (!index(alphabet, pwd[i]))
return;
endif
endfor
return "At least one unusual capitalization and/or numeric or punctuation character is required.";
.
#87:9
pwd = args[1];
moo = $network.MOO_Name;
if (this:_is_funky_case(pwd))
return;
endif
if (pwd == moo)
return "The MOO's name is not secure as a password.";
endif
if (moo[$ - 2..$] == "MOO")
if (pwd == moo[1..$ - 3])
return "The MOO's name is not secure as a password.";
endif
endif
.
#87:10
pwd = args[1];
if (!strcmp(pwd, u = $string_utils:uppercase(pwd)))
return 0;
elseif (!strcmp(pwd, l = $string_utils:lowercase(pwd)))
return 0;
elseif (!strcmp(pwd, tostr(u[1], l[2..$])))
return 0;
else
return 1;
endif
.
#87:11
pwd = args[1];
if (match(pwd, "^[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]$"))
return "Social security numbers are potentially insecure passwords.";
elseif (match(pwd, "^[0-9]+/[0-9]+/[0-9]+$"))
return "Passwords which look like dates are potentially insecure passwords.";
endif
.
#87:12
if (caller_perms().wizard)
pass(@args);
this.minimum_password_length = this.check_against_name = this.check_against_email = this.check_against_hosts = this.check_against_dictionary = this.require_funky_characters = this.check_against_moo = this.check_obscure_stuff = 0;
endif
.
#88:0
"'@rooms' - List the rooms which are known by name.";
line = "";
for item in (this.rooms)
line = (((line + item[1]) + "(") + tostr(item[2])) + ")   ";
endfor
player:tell(line);
.
#88:1
"'@go <place>' - Teleport yourself somewhere. Example: '@go liv' to go to the living room.";
dest = this:lookup_room(dobjstr);
if (dest == $failed_match)
player:tell("There's no such place known.");
else
this:teleport(player, dest);
endif
.
#88:2
"Look up a room in your personal database of room names, returning its object number. If it's not in your database, it checks to see if it's a number or a nearby object.";
room = args[1];
if (room == "home")
return player.home;
elseif (room == "me")
return player;
elseif (room == "here")
return player.location;
elseif (!room)
return $failed_match;
endif
index = this:index_room(room);
if (index)
return this.rooms[index][2];
else
return this:my_match_object(room);
"old code no longer used, 2/11/96 Heathcliff";
source = player.location;
if (!(valid(source) && ($room in $object_utils:ancestors(source))))
source = $room;
endif
return source:match_object(room);
endif
.
#88:3
"Teleport a player or object. For printing messages, there are three cases: (1) teleport self (2) teleport other player (3) teleport object. There's a spot of complexity for handling the invalid location #-1.";
set_task_perms((caller == this) ? this | $no_one);
{thing, dest} = args;
source = thing.location;
if (valid(dest))
dest_name = dest.name;
else
dest_name = tostr(dest);
endif
if (source == dest)
player:tell(thing.name, " is already at ", dest_name, ".");
return;
endif
thing:moveto(dest);
if (thing.location == dest)
tsd = {thing, source, dest};
if (thing == player)
this:teleport_messages(@tsd, this:self_port_msg(@tsd), this:oself_port_msg(@tsd), this:self_arrive_msg(@tsd), "");
elseif (is_player(thing))
this:teleport_messages(@tsd, this:player_port_msg(@tsd), this:oplayer_port_msg(@tsd), this:player_arrive_msg(@tsd), this:victim_port_msg(@tsd));
else
this:teleport_messages(@tsd, this:thing_port_msg(@tsd), this:othing_port_msg(@tsd), this:thing_arrive_msg(@tsd), this:object_port_msg(@tsd));
endif
elseif (thing.location == source)
if ($object_utils:contains(thing, dest))
player:tell("Ooh, it's all twisty. ", dest_name, " is inside ", thing.name, ".");
else
if ($object_utils:has_property(thing, "po"))
pronoun = thing.po;
else
pronoun = "it";
endif
player:tell("Either ", thing.name, " doesn't want to go, or ", dest_name, " didn't accept ", pronoun, ".");
endif
else
thing_name = (thing == player) ? "you" | thing.name;
player:tell("A strange force deflects ", thing_name, " from the destination.");
endif
.
#88:4
"Send teleport messages. There's a slight complication in that the source and dest need not be valid objects.";
{thing, source, dest, pmsg, smsg, dmsg, tmsg} = args;
if (pmsg)
"The player's own message.";
player:tell(pmsg);
endif
if (smsg)
`source:room_announce_all_but({thing, player}, smsg) ! E_VERBNF, E_INVIND';
endif
if (dmsg)
`dest:room_announce_all_but({thing, player}, dmsg) ! E_VERBNF, E_INVIND';
endif
if (tmsg)
"A message to the victim being teleported.";
thing:tell(tmsg);
endif
.
#88:5
"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.";
here = player.location;
if ((prepstr != "to") || (!iobjstr))
player:tell("Usage: @move <object> to <location>");
return;
endif
if ((!dobjstr) || (dobjstr == "me"))
thing = this;
else
thing = `here:match_object(dobjstr) ! E_VERBNF, E_INVIND => $failed_match';
if (thing == $failed_match)
thing = player:my_match_object(dobjstr);
endif
endif
if ($command_utils:object_match_failed(thing, dobjstr))
return;
endif
if ((!player.programmer) && ((thing.owner != player) && (thing != player)))
player:tell("You can only move your own objects.");
return;
endif
dest = this:lookup_room(iobjstr);
if ((dest == #-1) || (!$command_utils:object_match_failed(dest, iobjstr)))
this:teleport(thing, dest);
endif
.
#88:6
"'index_room (<room name>)' - Look up a room in your personal database of room names, returning its index in the list. Return 0 if it is not in the list. If the room name is the empty string, then only exact matches are considered; otherwise, a leading match is good enough.";
room = tostr(args[1]);
size = length(room);
index = 1;
match = 0;
for item in (this.rooms)
item_name = item[1];
if (room == item_name)
return index;
elseif ((size && (length(item_name) >= size)) && (room == item_name[1..size]))
match = index;
endif
index = index + 1;
endfor
return match;
.
#88:7
"'@addroom <name> <object>', '@addroom <object> <name>', '@addroom <name>', '@addroom <object>', '@addroom' - Add a room to your personal database of teleport destinations. Example: '@addroom Kitchen #24'. Reasonable <object>s are numbers (#17) and 'here'. If you leave out <object>, the object is the current room. If you leave out <name>, the name is the specified room's name. If you leave out both, you get the current room and its name.";
if (((!caller) && (player != this)) || (caller && (callers()[1][3] != this)))
if (!caller)
player:tell(E_PERM);
endif
return E_PERM;
endif
if (!dobjstr)
object = this.location;
name = valid(object) ? object.name | "Nowhere";
elseif (command = this:parse_out_object(dobjstr))
name = command[1];
object = command[2];
else
name = dobjstr;
object = this.location;
endif
if (!valid(object))
player:tell("This is not a valid location.");
return E_INVARG;
endif
player:tell("Adding ", name, "(", tostr(object), ") to your database of rooms.");
this.rooms = {@this.rooms, {name, object}};
.
#88:8
"'@rmroom <roomname>' - Remove a room from your personal database of teleport destinations. Example: '@rmroom library'.";
if (((!caller) && (player != this)) || (caller && (callers()[1][3] != this)))
if (!caller)
player:tell(E_PERM);
endif
return E_PERM;
endif
index = this:index_room(dobjstr);
if (index)
player:tell("Removing ", this.rooms[index][1], "(", this.rooms[index][2], ").");
this.rooms = listdelete(this.rooms, index);
else
player:tell("That room is not in your database of rooms. Check '@rooms'.");
endif
.
#88:9
"'@join <player>' - Teleport yourself to the location of any player, whether connected or not.";
if (dobjstr == "")
player:tell("Usage: @join <player>. For example, '@join frand'.");
return;
endif
target = $string_utils:match_player(dobjstr);
$command_utils:player_match_result(target, dobjstr);
if (valid(target))
if (target == this)
if (player == this)
player:tell("There is little need to join yourself, unless you are split up.");
else
player:tell("No thank you. Please get your own join verb.");
endif
return;
endif
dest = target.location;
msg = this:enlist(this:join_msg());
editing = $object_utils:isa(dest, $generic_editor);
if (editing)
dest = dest.original[target in dest.active];
editing_msg = "%N is editing at the moment. You can wait here until %s is done.";
if (player.location == dest)
msg = {editing_msg};
else
msg = {@msg, editing_msg};
endif
endif
if (msg && ((player.location != dest) || editing))
player:tell_lines($string_utils:pronoun_sub(msg, target));
elseif (player.location == dest)
player:tell("OK, you're there. You didn't need to actually move, though.");
return;
endif
this:teleport(player, dest);
endif
.
#88:10
"'@find #<object>', '@find <player>', '@find :<verb>' '@find .<property>' - Attempt to locate things. Verbs and properties are found on any object in the player's vicinity, and some other places.  '@find ?<help>' looks for a help topic on any available help database.";
if (!dobjstr)
player:tell("Usage: '@find #<object>' or '@find <player>' or '@find :<verb>' or '@find .<property>' or '@find ?<help topic>'.");
return;
endif
if (dobjstr[1] == ":")
name = dobjstr[2..$];
this:find_verb(name);
return;
elseif (dobjstr[1] == ".")
name = dobjstr[2..$];
this:find_property(name);
return;
elseif (dobjstr[1] == "#")
target = toobj(dobjstr);
if (!valid(target))
player:tell(target, " does not exist.");
endif
elseif (dobjstr[1] == "?")
name = dobjstr[2..$];
this:find_help(name);
return;
else
target = $string_utils:match_player(dobjstr);
$command_utils:player_match_result(target, dobjstr);
endif
if (valid(target))
player:tell(target.name, " (", target, ") is at ", valid(target.location) ? target.location.name | "Nowhere", " (", target.location, ").");
endif
.
#88:11
"'find_verb (<name>)' - Search for a verb with the given name. The objects searched are those returned by this:find_verbs_on(). The printing order relies on $list_utils:remove_duplicates to leave the *first* copy of each duplicated element in a list; for example, {1, 2, 1} -> {1, 2}, not to {2, 1}.";
name = args[1];
results = "";
objects = $list_utils:remove_duplicates(this:find_verbs_on());
for thing in (objects)
if (valid(thing) && (mom = $object_utils:has_verb(thing, name)))
results = ((((results + "   ") + thing.name) + "(") + tostr(thing)) + ")";
mom = mom[1];
if (thing != mom)
results = ((((results + "--") + mom.name) + "(") + tostr(mom)) + ")";
endif
endif
endfor
if (results)
this:tell("The verb :", name, " is on", results);
else
this:tell("The verb :", name, " is nowhere to be found.");
endif
.
#88:12
"'@ways', '@ways <room>' - List any obvious exits from the given room (or this room, if none is given).";
if (dobjstr)
room = dobj;
else
room = this.location;
endif
if ((!valid(room)) || (!($room in $object_utils:ancestors(room))))
player:tell("You can only pry into the exits of a room.");
return;
endif
exits = {};
if ($object_utils:has_verb(room, "obvious_exits"))
exits = room:obvious_exits();
endif
exits = this:checkexits(this:obvious_exits(), room, exits);
exits = this:findexits(room, exits);
this:tell_ways(exits, room);
.
#88:13
"Add to the 'exits' list any exits in the room which have a single-letter alias.";
{room, exits} = args;
alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
for i in [1..length(alphabet)]
found = room:match_exit(alphabet[i]);
if (valid(found) && (!(found in exits)))
exits = {@exits, found};
endif
endfor
return exits;
.
#88:14
"Check a list of exits to see if any of them are in the given room.";
{to_check, room, exits} = args;
for word in (to_check)
found = room:match_exit(word);
if (valid(found) && (!(found in exits)))
exits = {@exits, found};
endif
endfor
return exits;
.
#88:15
"This verb returns messages that go only to you. You don't need to have your name tacked on to the beginning of these. Heh.";
msg = this.(verb);
if (msg && (length(args) >= 3))
msg = this:msg_sub(msg, @args);
endif
return msg;
.
#88:16
"This verb returns messages that go to other players. It does pronoun substitutions; if your name is not included in the final string, it adds the name in front.";
msg = this.(verb);
if (!msg)
msg = $frand_class.(verb);
endif
if (length(args) >= 3)
msg = this:msg_sub(msg, @args);
endif
if (!$string_utils:index_delimited(msg, player.name))
msg = (player.name + " ") + msg;
endif
return msg;
.
#88:17
"Do pronoun and other substitutions on the teleport messages. The arguments are: 1. The original message, before any substitutions; 2. object being teleported; 3. from location; 4. to location. The return value is the final message.";
{msg, thing, from, to} = args;
msg = $string_utils:substitute(msg, $string_utils:pronoun_quote({{"%<from room>", valid(from) ? from.name | "Nowhere"}, {"%<to room>", valid(to) ? to.name | "Nowhere"}}));
msg = $string_utils:pronoun_sub(msg, thing);
return msg;
.
#88:18
"'obvious_exits()' - Return a list of common exit names which are obviously worth looking for in a room.";
return {"n", "ne", "e", "se", "s", "sw", "w", "nw", "north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "u", "d", "up", "down", "out", "exit", "leave", "enter"};
.
#88:19
":tell_ways (<list of exits>)' - Tell yourself a list of exits, for @ways. You can override it to print the exits in any format.";
exits = args[1];
answer = {};
for e in (exits)
answer = {@answer, ((e.name + " (") + $string_utils:english_list(e.aliases)) + ")"};
endfor
player:tell("Obvious exits: ", $string_utils:english_list(answer), ".");
.
#88:20
"Return the name and number of an object, e.g. 'Root Class (#1)'.";
o = args[1];
return (((valid(o) ? o.name | "Nothing") + " (") + tostr(o)) + ")";
.
#88:21
"'parse_out_object (<string>)' -> {<name>, <object>}, or 0. Given a string, attempt to find an object at its beginning or its end. An object can be either an object number, or 'here'. If this succeeds, return a list of the object and the unmatched part of the string, called the name. If it fails, return 0.";
words = $string_utils:words(args[1]);
if (!length(words))
return 0;
endif
word1 = words[1];
wordN = words[$];
if (length(word1) && (word1[1] == "#"))
start = 2;
finish = length(words);
what = toobj(word1);
elseif (word1 == "here")
start = 2;
finish = length(words);
what = this.location;
elseif (length(wordN) && (wordN[1] == "#"))
start = 1;
finish = length(words) - 1;
what = toobj(wordN);
elseif (wordN == "here")
start = 1;
finish = length(words) - 1;
what = this.location;
else
return 0;
endif
"toobj() has the nasty property that invalid strings get turned into #0. Here we just pretend that all references to #0 are actually meant for #-1.";
if (what == #0)
what = $nothing;
endif
name = $string_utils:from_list(words[start..finish], " ");
if (!name)
name = valid(what) ? what.name | "Nowhere";
endif
return {name, what};
.
#88:22
"'enlist (<x>)' - If x is a list, just return it; otherwise, return {x}. The purpose here is to turn message strings into lists, so that lines can be added. It is not guaranteed to work for non-string non-lists.";
x = args[1];
if (!x)
return {};
elseif (typeof(x) == LIST)
return x;
else
return {x};
endif
.
#88:23
"@spellproperties <object>";
"@spellmessages <object>";
"Spell checks the string properties of an object, or the subset of said properties which are suffixed _msg, respectively.";
set_task_perms(player);
if (!dobjstr)
player:notify(tostr("Usage: ", verb, " <object>"));
return;
elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))
return;
elseif (typeof(props = $object_utils:all_properties(dobj)) == ERR)
player:notify("Permission denied to read properties on that object.");
return;
endif
props = setremove(props, "messages");
if (verb[1..7] == "@spellm")
spell = {};
for prop in (props)
if ((index(prop, "_msg") == (length(prop) - 3)) && index(prop, "_msg"))
spell = {@spell, prop};
endif
endfor
props = spell;
endif
if (props == {})
player:notify(tostr("No ", (verb[1..7] == "@spellm") ? "messages" | "properties", " found to spellcheck on ", dobj, "."));
return;
endif
for data in (props)
if (typeof(dd = `dobj.(data) ! ANY') == LIST)
text = {};
for linenum in (dd)
text = listappend(text, linenum);
endfor
elseif ((((typeof(dd) == OBJ) || (typeof(dd) == INT)) || (typeof(dd) == ERR)) || (typeof(dd) == FLOAT))
text = "";
elseif (typeof(dd) == STR)
text = dd;
endif
if (typeof(text) == STR)
text = {text};
endif
linenumber = 0;
for thisline in (text)
$command_utils:suspend_if_needed(0);
linenumber = linenumber + 1;
if (((((typeof(thisline) != LIST) && (typeof(thisline) != OBJ)) && (typeof(thisline) != INT)) && (typeof(thisline) != FLOAT)) && (typeof(thisline) != ERR))
i = $string_utils:strip_chars(thisline, "!@#$%^&*()_+1234567890={}[]<>?:;,./|\"~'");
if (i)
i = $string_utils:words(i);
for ii in [1..length(i)]
$command_utils:suspend_if_needed(0);
if (!$spell:valid(i[ii]))
if ((rindex(i[ii], "s") == length(i[ii])) && $spell:valid(i[ii][1..$ - 1]))
msg = "Possible match: " + i[ii];
elseif ((rindex(i[ii], "'s") == (length(i[ii]) - 1)) && $spell:valid(i[ii][1..$ - 2]))
msg = "Possible match: " + i[ii];
else
msg = "Unknown word: " + i[ii];
endif
if (length(text) == 1)
foo = ": ";
else
foo = (" (line " + tostr(linenumber)) + "): ";
endif
player:notify(tostr(dobj, ".", data, foo, msg));
endif
endfor
endif
endif
endfor
endfor
player:notify(tostr("Done spellchecking ", dobj, "."));
.
#88:24
"'@at' - Find out where everyone is. '@at <player>' - Find out where <player> is, and who else is there. '@at <obj>' - Find out who else is at the same place as <obj>. '@at <place>' - Find out who is at the place. The place can be given by number, or it can be a name from your @rooms list. '@at #-1' - Find out who is at #-1. '@at me' - Find out who is in the room with you. '@at home' - Find out who is at your home.";
this:internal_at(argstr);
.
#88:25
"'at_players ()' - Return a list of players to be displayed by @at.";
return connected_players();
.
#88:26
"'do_at_all ()' - List where everyone is, sorted by popularity of location. This is called when you type '@at'.";
locations = {};
parties = {};
counts = {};
for who in (this:at_players())
loc = who.location;
if (i = loc in locations)
parties[i] = setadd(parties[i], who);
counts[i] = counts[i] - 1;
else
locations = {@locations, loc};
parties = {@parties, {who}};
counts = {@counts, 0};
endif
endfor
locations = $list_utils:sort(locations, counts);
parties = $list_utils:sort(parties, counts);
this:print_at_items(locations, parties);
.
#88:27
"'do_at (<location>)' - List the players at a given location.";
loc = args[1];
party = {};
for who in (this:at_players())
if (who.location == loc)
party = setadd(party, who);
endif
endfor
this:print_at_items({loc}, {party});
.
#88:28
"'print_at_items (<locations>, <parties>)' - Print a list of locations and people, for @at. Override this if you want to make a change to @at's output that you can't make in :at_item.";
{locations, parties} = args;
for i in [1..length(locations)]
$command_utils:suspend_if_needed(0);
player:tell_lines(this:at_item(locations[i], parties[i]));
endfor
.
#88:29
"'at_item (<location>, <party>)' - Given a location and a list of the people there, return a string displaying the information. Override this if you want to change the format of each line of @at's output.";
{loc, party} = args;
su = $string_utils;
if (this.at_number)
number = su:right(tostr(loc), 7) + " ";
else
number = "";
endif
room = su:left(valid(loc) ? loc.name | "[Nowhere]", this.at_room_width);
if (length(room) > this.at_room_width)
room = room[1..this.at_room_width];
endif
text = (number + room) + " ";
if (party)
filler = su:space(length(text) - 2);
line = text;
text = {};
for who in (party)
name = " " + (valid(who) ? who.name | "[Nobody]");
if ((length(line) + length(name)) > this:linelen())
text = {@text, line};
line = filler + name;
else
line = line + name;
endif
endfor
text = {@text, line};
else
text = text + " [deserted]";
endif
return text;
.
#88:30
"'internal_at (<argument string>)' - Perform the function of @at. The argument string is whatever the user typed after @at. This is factored out so that other verbs can call it.";
where = $string_utils:trim(args[1]);
if (where)
if (where[1] == "#")
result = toobj(where);
if ((!valid(result)) && (result != #-1))
player:tell("That object does not exist.");
return;
endif
else
result = this:lookup_room(where);
if (!valid(result))
result = $string_utils:match_player(where);
if (!valid(result))
player:tell("That is neither a player nor a room name.");
return;
endif
endif
endif
if (valid(result) && (!$object_utils:isa(result, $room)))
result = result.location;
endif
this:do_at(result);
else
this:do_at_all();
endif
.
#88:31
"'confunc ()' - Besides the inherited behavior, notify the player's feature objects that the player has connected.";
if ((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this)))
return E_PERM;
endif
pass(@args);
set_task_perms(this);
for feature in (this.features)
try
feature:player_connected(player, @args);
except (E_VERBNF)
continue feature;
except id (ANY)
player:tell("Feature initialization failure for ", feature, ": ", id[2], ".");
endtry
$command_utils:suspend_if_needed(0);
endfor
.
#88:32
"'disfunc ()' - Besides the inherited behavior, notify the player's feature objects that the player has disconnected.";
if ((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this)))
return E_PERM;
endif
pass(@args);
"This is forked off to protect :disfunc from buggy :player_disconnected verbs.";
set_task_perms(this);
fork (max(0, $login:current_lag()))
for feature in (this.features)
try
feature:player_disconnected(player, @args);
except (ANY)
continue feature;
endtry
endfor
endfork
.
#88:33
set_task_perms(player);
if (!argstr)
player:notify(tostr("Usage: ", verb, " one or more words"));
player:notify(tostr("       ", verb, " object:verb"));
player:notify(tostr("       ", verb, " object.prop"));
elseif (!$perm_utils:controls(player, player))
player:notify("Cannot modify dictionary on players who do not own themselves.");
elseif (data = $spell:get_input(argstr))
num_learned = 0;
for i in [1..length(data)]
line = $string_utils:words(data[i]);
for ii in [1..length(line)]
if (seconds_left() < 2)
suspend(0);
endif
if (!$spell:valid(line[ii]))
player.dict = listappend(player.dict, line[ii]);
player:notify(tostr("Word added:  ", line[ii]));
num_learned = num_learned + 1;
endif
endfor
endfor
player:notify(tostr(num_learned ? num_learned | "No", " word", (num_learned != 1) ? "s " | " ", "added to personal dictionary."));
endif
.
#88:34
"@spell a word or phrase  -- Spell check a word or phrase.";
"@spell thing.prop  -- Spell check a property. The value must be a string or a list of strings.";
"@spell thing:verb  -- Spell check a verb. Only the quoted strings in the verb are checked.";
"@cspell word  -- Spell check a word, and if it is not in the dictionary, offset suggestions about what the right spelling might be. This actually works with thing.prop and thing:verb too, but it is too slow to be useful--it takes maybe 30 seconds per unknown word.";
"";
"Mr. Spell was written by waffle (waffle@euclid.humboldt.edu), for use by";
"MOOers all over this big green earth. (....and other places....)";
"This monstrosity programmed Sept-Oct 1991, when I should have been studying.";
"Mr. Spell was then gutted by lisdude on 2-17-19 to use ToastStunt builtins.";
set_task_perms(player);
if (!argstr)
player:notify(tostr("Usage: ", verb, " object.property"));
player:notify(tostr("       ", verb, " object:verb"));
player:notify(tostr("       ", verb, " one or more words"));
else
"@spell or @cspell.";
corrected_words = {};
data = $spell:get_input(argstr);
if (data)
misspelling = 0;
for i in [1..length(data)]
line = $string_utils:words(data[i]);
for ii in [1..length(line)]
$command_utils:suspend_if_needed(0);
if (!$spell:valid(line[ii]))
if ((rindex(line[ii], "s") == length(line[ii])) && $spell:valid(line[ii][1..$ - 1]))
msg = "Possible match: " + line[ii];
msg = (msg + " ") + ((length(data) != 1) ? ("(line " + tostr(i)) + ")  " | "  ");
elseif ((rindex(line[ii], "'s") == (length(line[ii]) - 1)) && $spell:valid(line[ii][1..$ - 2]))
msg = "Possible match: " + line[ii];
msg = (msg + " ") + ((length(data) != 1) ? ("(line " + tostr(i)) + ")  " | "  ");
else
misspelling = misspelling + 1;
msg = ("Unknown word: " + line[ii]) + ((length(data) != 1) ? (" (line " + tostr(i)) + ")  " | "  ");
if ((verb == "@cspell") && (!(line[ii] in corrected_words)))
corrected_words = listappend(corrected_words, line[ii]);
guesses = $string_utils:from_list($spell:guess_words(line[ii]), " ");
if (guesses == "")
msg = msg + "-No guesses";
else
msg = msg + "-Possible correct spelling";
msg = msg + (index(guesses, " ") ? "s: " | ": ");
msg = msg + guesses;
endif
endif
endif
player:notify(tostr(msg));
endif
endfor
endfor
player:notify(tostr("Found ", misspelling ? misspelling | "no", " misspelled word", (misspelling == 1) ? "." | "s."));
elseif (data != $failed_match)
player:notify(tostr("Nothing found to spellcheck!"));
endif
endif
.
#88:35
set_task_perms(player);
if (argstr in player.dict)
player.dict = setremove(player.dict, argstr);
player:notify(tostr("`", argstr, "' removed from personal dictionary."));
else
player:notify(tostr("`", argstr, "' not found in personal dictionary."));
endif
.
#88:36
"'find_property (<name>)' - Search for a property with the given name. The objects searched are those returned by this:find_properties_on(). The printing order relies on $list_utils:remove_duplicates to leave the *first* copy of each duplicated element in a list; for example, {1, 2, 1} -> {1, 2}, not to {2, 1}.";
name = args[1];
results = "";
objects = $list_utils:remove_duplicates(this:find_properties_on());
for thing in (objects)
if (valid(thing) && (mom = $object_utils:has_property(thing, name)))
results = ((((results + "   ") + thing.name) + "(") + tostr(thing)) + ")";
mom = this:property_inherited_from(thing, name);
if (thing != mom)
if (valid(mom))
results = ((((results + "--") + mom.name) + "(") + tostr(mom)) + ")";
else
results = results + "--built-in";
endif
endif
endif
endfor
if (results)
this:tell("The property .", name, " is on", results);
else
this:tell("The property .", name, " is nowhere to be found.");
endif
.
#88:37
"'find_verbs_on ()' -> list of objects - Return the objects that @find searches when looking for a verb. The objects are searched (and the results printed) in the order returned. Feature objects are included in the search. Duplicate entries are removed by the caller.";
return {this, this.location, @valid(this.location) ? this.location:contents() | {}, @this:contents(), @this.features};
.
#88:38
"'find_properties_on ()' -> list of objects - Return the objects that @find searches when looking for a property. The objects are searched (and the results printed) in the order returned. Feature objects are *not* included in the search. Duplicate entries are removed by the caller.";
return {this, this.location, @valid(this.location) ? this.location:contents() | {}, @this:contents()};
.
#88:39
"'property_inherited_from (<object>, <property name>)' -> object - Return the ancestor of <object> on which <object>.<property> is originally defined. If <object>.<property> is not actually defined, return 0. The property is taken as originally defined on the earliest ancestor of <object> which has it. If the property is built-in, return $nothing.";
{what, prop} = args;
if (!$object_utils:has_property(what, prop))
return 0;
elseif (prop in $code_utils.builtin_props)
return $nothing;
endif
ancestor = what;
while ($object_utils:has_property(parent(ancestor), prop))
ancestor = parent(ancestor);
endwhile
return ancestor;
.
#88:40
"'@refuse <action(s)> [ from <player> ] [ for <time> ]' - Refuse all of a list of one or more actions. If a player is given, refuse actions from the player; otherwise, refuse all actions. If a time is specified, refuse the actions for the given amount of time; otherwise, refuse them for a week. If the actions are already refused, then the only their times are adjusted.";
if (!argstr)
player:tell("@refuse <action(s)> [ from <player> ] [ for <time> ]");
return;
endif
stuff = this:parse_refuse_arguments(argstr);
if (stuff)
if (((typeof(who = stuff[1]) == OBJ) && (who != $nothing)) && (!is_player(who)))
player:tell("You must give the name of some player.");
else
"'stuff' is now in the form {<origin>, <actions>, <duration>}.";
if ((stuff[3] < 0) || (stuff[3] > (($maxint - time()) - 2)))
stuff[3] = ($maxint - time()) - 2;
player:tell("That amount of time is too large.  It has been capped at ", $time_utils:english_time(stuff[3]), ".");
endif
this:add_refusal(@stuff);
player:tell("Refusal of ", this:refusal_origin_to_name(stuff[1]), " for ", $time_utils:english_time(stuff[3]), " added.");
endif
endif
.
#88:41
"'@unrefuse <action(s)> [ from <player> ]' - Stop refusing all of a list of actions. If a player is given, stop refusing actions by the player; otherwise, stop refusing all actions of the given kinds. '@unrefuse everything' - Remove all refusals.";
if (argstr == "everything")
if ($command_utils:yes_or_no("Do you really want to erase all your refusals?"))
this:clear_refusals();
player:tell("OK, they are gone.");
else
player:tell("OK, no harm done.");
endif
return;
endif
stuff = this:parse_refuse_arguments(argstr);
if (!stuff)
return;
endif
"'stuff' is now in the form {<origin>, <actions>, <duration>}.";
origins = stuff[1];
actions = stuff[2];
if (typeof(origins) != LIST)
origins = {origins};
endif
n = 0;
for origin in (origins)
n = n + this:remove_refusal(origin, actions);
endfor
plural = ((n == 1) && (length(origins) == 1)) ? "" | "s";
if (n)
player:tell("Refusal", plural, " removed.");
else
player:tell("You have no such refusal", plural, ".");
endif
.
#88:42
"'@refusals' - List your refusals. '@refusals for <player>' - List the given player's refusals.";
if (iobjstr)
who = $string_utils:match_player(iobjstr);
if ($command_utils:player_match_failed(who, iobjstr))
return;
endif
if (!$object_utils:has_verb(who, "refusals_text"))
player:tell("That player does not have the refusal facility.");
return;
endif
else
who = player;
endif
who:remove_expired_refusals();
player:tell_lines(this:refusals_text(who));
.
#88:43
"'@refusal-reporting' - See if refusal reporting is on. '@refusal-reporting on', '@refusal-reporting off' - Turn it on or off..";
if (!argstr)
player:tell("Refusal reporting is ", this.report_refusal ? "on" | "off", ".");
elseif (argstr in {"on", "yes", "y", "1"})
this.report_refusal = 1;
player:tell("Refusals will be reported to you as they happen.");
elseif (argstr in {"off", "no", "n", "0"})
this.report_refusal = 0;
player:tell("Refusals will happen silently.");
else
player:tell("@refusal-reporting on     - turn on refusal reporting");
player:tell("@refusal-reporting off    - turn it off");
player:tell("@refusal-reporting        - see if it's on or off");
endif
.
#88:44
"'parse_refuse_arguments (<string>)' -> {<who>, <actions>, <duration>} - Parse the arguments of a @refuse or @unrefuse command. <who> is the player requested, or $nothing if none was. <actions> is a list of the actions asked for. <duration> is how long the refusal should last, or 0 if no expiration is given. <errors> is a list of actions (or other words) which are wrong. If there are any errors, this prints an error message and returns 0.";
words = $string_utils:explode(args[1]);
possible_actions = this:refusable_actions();
who = $nothing;
actions = {};
until = this.default_refusal_time;
errors = {};
skip_to = 0;
for i in [1..length(words)]
word = words[i];
if (i <= skip_to)
elseif (which = $string_utils:find_prefix(word, possible_actions))
actions = setadd(actions, possible_actions[which]);
elseif ((word[$] == "s") && (which = $string_utils:find_prefix(word[1..$ - 1], possible_actions)))
"The word seems to be the plural of an action.";
actions = setadd(actions, possible_actions[which]);
elseif (results = this:translate_refusal_synonym(word))
actions = $set_utils:union(actions, results);
elseif ((word == "from") && (i < length(words)))
"Modified to allow refusals from all guests at once. 5-27-94, Gelfin";
if (words[i + 1] == "guests")
who = "all guests";
elseif (!(typeof(who = $code_utils:toobj(words[i + 1])) == OBJ))
who = $string_utils:match_player(words[i + 1]);
if ($command_utils:player_match_failed(who, words[i + 1]))
return 0;
endif
endif
skip_to = i + 1;
elseif ((word == "for") && (i < length(words)))
n_words = this:parse_time_length(words[i + 1..$]);
until = this:parse_time(words[i + 1..i + n_words]);
if (!until)
return 0;
endif
skip_to = i + n_words;
else
errors = {@errors, word};
endif
endfor
if (errors)
player:tell((length(errors) > 1) ? "These parts of the command were not understood: " | "This part of the command was not understood: ", $string_utils:english_list(errors, 0, " ", " ", " "));
return 0;
endif
return {this:player_to_refusal_origin(who), actions, until};
.
#88:45
"'time_word_to_seconds (<string>)' - The <string> is expected to be a time word, 'second', 'minute', 'hour', 'day', 'week', or 'month'. Return the number of seconds in that amount of time (a month is taken to be 30 days). If <string> is not a time word, return 0. This is used both as a test of whether a word is a time word and as a converter.";
return $time_utils:parse_english_time_interval("1", args[1]);
.
#88:46
"'parse_time_length (<words>)' -> n - Given a list of words which is expected to begin with a time expression, return how many of them belong to the time expression. A time expression can be a positive integer, a time word, or a positive integer followed by a time word. A time word is anything that this:time_word_to_seconds this is one. The return value is 0, 1, or 2.";
words = {@args[1], "dummy"};
n = 0;
if (toint(words[1]) || this:time_word_to_seconds(words[1]))
n = 1;
endif
if (this:time_word_to_seconds(words[n + 1]))
n = n + 1;
endif
return n;
.
#88:47
"'parse_time (<words>)' -> <seconds> - Given a list of zero or more words, either empty or a valid time expression, return the number of seconds that the time expression refers to. This is a duration, not an absolute time.";
words = args[1];
"If the list is empty, return the default refusal time.";
if (!words)
return this.default_refusal_time;
endif
"If the list has one word, either <units> or <n>.";
"If it is a unit, like 'hour', return the time for 1 <unit>.";
"If it is a number, return the time for <n> days.";
if (length(words) == 1)
return this:time_word_to_seconds(words[1]) || (toint(words[1]) * this:time_word_to_seconds("days"));
endif
"The list must contain two words, <n> <units>.";
return toint(words[1]) * this:time_word_to_seconds(words[2]);
.
#88:48
"'clear_refusals ()' - Erase all of this player's refusals.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
this.refused_origins = {};
this.refused_actions = {};
this.refused_until = {};
this.refused_extra = {};
.
#88:49
"'set_default_refusal_time (<seconds>)' - Set the length of time that a refusal lasts if its duration isn't specified.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
this.default_refusal_time = toint(args[1]);
.
#88:50
"'refusable_actions ()' -> {'page', 'whisper', ...} - Return a list of the actions that can be refused. This is a verb, rather than a property, so that it can be inherited properly. If you override this verb to add new refusable actions, write something like 'return {@pass (), 'action1', 'action2', ...}'. That way people can add new refusable actions at any level of the player class hierarchy, without clobbering any that were added higher up.";
return {"page", "whisper", "move", "join", "accept", "mail"};
.
#88:51
"'translate_refusal_synonym (<word>)' -> list - If the <word> is a synonym for some set of refusals, return the list of those refusals. Otherwise return the empty list, {}. Programmers can override this verb to provide more synonyms.";
word = args[1];
if (word == "all")
return this:refusable_actions();
endif
return {};
.
#88:52
"'default_refusals_text_filter (<origin>, <actions>)' - Return any actions by this <origin> which should be included in the text returned by :refusals_text. This is the default filter, which includes all actions.";
return args[2];
.
#88:53
"'refusals_text (<player>, [<filter verb name>])' - Return text describing the given player's refusals. The filter verb name is optional; if it is given, this verb takes an origin and a list of actions and returns any actions which should be included in the refusals text. This verb works only if <player> is a player who has the refusals facility; it does not check for this itself.";
who = args[1];
"Used to allow you to supply the filter verb name, but that introduced a security hole. --Nosredna";
filter_verb = "default_refusals_text_filter";
text = {};
for i in [1..length(who.refused_origins)]
origin = who.refused_origins[i];
actions = this:(filter_verb)(origin, who.refused_actions[i]);
if (actions)
line = "";
for action in (actions)
line = (line + " ") + action;
endfor
line = (this:refusal_origin_to_name(origin) + ": ") + line;
line = (ctime(who.refused_until[i]) + " ") + line;
text = {@text, line};
endif
endfor
if (!text)
text = {"No refusals."};
endif
return text;
.
#88:54
"'player_to_refusal_origin (<player>)' -> <origin> - Convert a player to a unique identifier called the player's 'refusal origin'. For most players, it's just their object number. For guests, it is a hash of the site they are connecting from. Converting an origin to an origin is a safe no-op--the code relies on this.";
set_task_perms(caller_perms());
{who} = args;
if (((typeof(who) == OBJ) && valid(who)) && (parent(who) == `$local.guest ! E_PROPNF, E_INVIND => $guest'))
return who:connection_name_hash("xx");
else
return who;
endif
.
#88:55
"'refusal_origin_to_name (<origin>)' -> string - Convert a refusal origin to a name.";
origin = args[1];
if (origin in {"all guests", "everybody"})
return origin;
elseif ((typeof(origin) == STR) && (origin == "Permission denied"))
return "an errorful origin";
elseif (typeof(origin) != OBJ)
return "a certain guest";
elseif (origin == #-1)
return "Everybody";
else
return $string_utils:name_and_number(origin);
endif
.
#88:56
"'check_refusal_actions (<actions>)' - Check a list of refusal actions, and return whether they are all legal.";
actions = args[1];
legal_actions = this:refusable_actions();
for action in (actions)
if (!(action in legal_actions))
return 0;
endif
endfor
return 1;
.
#88:57
"'add_refusal (<origin>, <actions> [, <duration> [, <extra>]])' - Add refusal(s) to this player's list. <Actions> is a list of the actions to be refused. The list should contain only actions, no synonyms. <Origin> is the actor whose actions are to be refused. <Until> is the time that the actions are being refused until, in the form returned by time(). It is optional; if it's not given, it defaults to .default_refusal_time. <Extra> is any extra information; it can be used for comments, or to make finer distinctions about the actions being refused, or whatever. If it is not given, it defaults to 0. The extra information is per-action; that is, it is stored separately for each action that it applies to.";
if (caller != this)
return E_PERM;
endif
{orig, actions, ?duration = this.default_refusal_time, ?extra = 0} = args;
origins = this:player_to_refusal_origin(orig);
if (typeof(origins) != LIST)
origins = {origins};
endif
if (typeof(actions) != LIST)
actions = {actions};
endif
if (!this:check_refusal_actions(actions))
return E_INVARG;
endif
until = time() + duration;
for origin in (origins)
if (i = origin in this.refused_origins)
this.refused_until[i] = until;
for action in (actions)
if (j = action in this.refused_actions[i])
this.refused_extra[i][j] = extra;
else
this.refused_actions[i] = {@this.refused_actions[i], action};
this.refused_extra[i] = {@this.refused_extra[i], extra};
endif
endfor
else
this.refused_origins = {@this.refused_origins, origin};
this.refused_actions = {@this.refused_actions, actions};
this.refused_until = {@this.refused_until, until};
this.refused_extra = {@this.refused_extra, $list_utils:make(length(actions), extra)};
endif
endfor
.
#88:58
"'remove_refusal (<origin>, <actions>)' - Remove any refused <actions> by <origin>. The <actions> list should contain only actions, no synonyms. Return the number of such refusals found (0 if none).";
if (caller != this)
return E_PERM;
endif
{origin, actions} = args;
if (typeof(actions) != LIST)
actions = {actions};
endif
count = 0;
i = origin in this.refused_origins;
if (i)
for action in (actions)
if (j = action in this.refused_actions[i])
this.refused_actions[i] = listdelete(this.refused_actions[i], j);
this.refused_extra[i] = listdelete(this.refused_extra[i], j);
count = count + 1;
endif
endfor
if (!this.refused_actions[i])
this.refused_origins = listdelete(this.refused_origins, i);
this.refused_actions = listdelete(this.refused_actions, i);
this.refused_until = listdelete(this.refused_until, i);
this.refused_extra = listdelete(this.refused_extra, i);
endif
endif
return count;
.
#88:59
"'remove_expired_refusals ()' - Remove refusal entries which are past their time limits.";
origins = {};
"Before removing any refusals, figure out which ones to remove. Removing one changes the indices and invalidates the loop invariant.";
for i in [1..length(this.refused_origins)]
if ((time() >= this.refused_until[i]) || ((typeof(this.refused_origins[i]) == OBJ) && (!$recycler:valid(this.refused_origins[i]))))
origins = {@origins, this.refused_origins[i]};
endif
endfor
for origin in (origins)
this:remove_refusal(origin, this:refusable_actions());
endfor
.
#88:60
"'refuses_action (<origin>, <action>, ...)' - Return whether this object refuses the given <action> by <origin>. <Origin> is typically a player. Extra arguments after <origin>, if any, are used to further describe the action.";
"Modified by Diopter (#98842) at LambdaMOO";
{origin, action, @extra_args} = args;
extra_args = {origin, @extra_args};
rorigin = this:player_to_refusal_origin(origin);
if (((which = rorigin in this.refused_origins) && (action in this.refused_actions[which])) && this:("refuses_action_" + action)(which, @extra_args))
return 1;
elseif (((((typeof(rorigin) == OBJ) && valid(rorigin)) && (which = rorigin.owner in this.refused_origins)) && (action in this.refused_actions[which])) && this:("refuses_action_" + action)(which, @extra_args))
return 1;
elseif ((((which = $nothing in this.refused_origins) && (rorigin != this)) && (action in this.refused_actions[which])) && this:("refuses_action_" + action)(which, @extra_args))
return 1;
elseif ((((which = "all guests" in this.refused_origins) && $object_utils:isa(origin, $guest)) && (action in this.refused_actions[which])) && this:("refuses_action_" + action)(which, @extra_args))
return 1;
endif
return 0;
.
#88:61
"'refuses_action_* (<which>, <origin>, ...)' - The action (such as 'whisper' for the verb :refuses_action_whisper) is being considered for refusal. Return whether the action should really be refused. <Which> is an index into this.refused_origins. By default, always refuse non-outdated actions that get this far.";
{which, @junk} = args;
if (time() >= this.refused_until[which])
fork (0)
"This <origin> is no longer refused. Remove any outdated refusals.";
this:remove_expired_refusals();
endfork
return 0;
else
return 1;
endif
.
#88:62
"'report_refusal (<player>, <message>, ...)' - If refusal reporting is turned on, print the given <message> to report the refusal of some action by <player>. The message may take more than one argument. You can override this verb to do more selective reporting.";
if (this.report_refusal)
this:tell(@listdelete(args, 1));
endif
.
#88:63
"'whisper <message> to <this player>' - Whisper a message to this player which nobody else can see.";
if (this:refuses_action(player, "whisper"))
player:tell(this:whisper_refused_msg());
this:report_refusal(player, "You just refused a whisper from ", player.name, ".");
else
pass(@args);
endif
.
#88:64
"'receive_page (<message>)' - Receive a page. If the page is accepted, pass(@args) shows it to the player.";
if (this:refuses_action(player, "page"))
this.page_refused = task_id();
return 0;
endif
this.page_refused = 0;
return pass(@args);
.
#88:65
"'page_echo_msg ()' - Return a message to inform the pager what happened to their page.";
if (task_id() == this.page_refused)
this:report_refusal(player, "You just refused a page from ", player.name, ".");
return this:page_refused_msg();
else
return pass(@args);
endif
.
#88:66
"'moveto (<destination>)', 'accept (<object>)' - Check whether this :moveto or :accept is allowed or refused. If it is allowed, do it. This code is slightly modified from an original verb by Grump.  Upgraded by Bits to account for forthcoming 1.8.0 behavior of callers().";
by = callers();
"Ignore all the verbs on this.";
while (((y = by[1])[1] == this) && (y[2] == verb))
by = listdelete(by, 1);
endwhile
act = (verb == "moveto") ? "move" | "accept";
if ((player != this) && this:refuses_action(player, act, args[1]))
"check player";
return 0;
endif
last = #-1;
for k in (by)
if ((((perms = k[3]) == #-1) && (k[2] != "")) && (k[1] == #-1))
elseif ((!perms.wizard) && (perms != this))
if (perms != last)
"check for possible malicious programmer";
if (this:refuses_action(perms, act, args[1]))
return 0;
endif
last = perms;
endif
endif
endfor
"Coded added 11/8/98 by TheCat, to refuse spurned objects.";
if ((act == "accept") && (typeof(this.spurned_objects) == LIST))
for item in (this.spurned_objects)
if ($object_utils:isa(args[1], item))
return 0;
endif
endfor
endif
"(end of code added by TheCat)";
return pass(@args);
.
#88:67
"'receive_message (<message>, <sender>)' - Receive the given mail message from the given sender. This version handles refusal of the message.";
if ((!$perm_utils:controls(caller_perms(), this)) && (caller != this))
return E_PERM;
elseif (this:refuses_action(args[2], "mail"))
return this:mail_refused_msg();
else
return pass(@args);
endif
.
#88:68
"'whisper_refused_msg()', 'page_refused_msg()', etc. - Return a message string.";
return $string_utils:pronoun_sub(this.(verb), this);
.
#88:69
set_task_perms(caller_perms());
if (pass(@args))
return 1;
endif
{verb, args} = args;
if (valid(dobj = $string_utils:literal_object(dobjstr)) && (r = $match_utils:match_verb(verb, dobj, args)))
return r;
elseif (valid(iobj = $string_utils:literal_object(iobjstr)) && (r = $match_utils:match_verb(verb, iobj, args)))
return r;
else
return 0;
endif
.
#88:70
":ping_features()";
" -- cleans up the .features list to remove !valid objects";
" ==> cleaned-up .features list";
features = this.features;
for x in (features)
if (!$recycler:valid(x))
features = setremove(features, x);
endif
endfor
return this.features = features;
.
#88:71
":set_owned_objects( LIST owned-objects list )";
"  -- set your .owned_objects, ordered as you please";
"  -- no, it will NOT let you set to to anything you want";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
new = args[1];
old = this.owned_objects;
"make sure they're the same";
if (length(new) != length(old))
return E_INVARG;
endif
for i in (new)
old = setremove(old, i);
endfor
if (old)
"something's funky";
return E_INVARG;
endif
return this.owned_objects = new;
else
return E_PERM;
endif
.
#88:72
if (caller_perms().wizard)
pass(@args);
if ($code_utils:verb_location() == this)
this.rooms = {};
else
clear_property(this, "rooms");
endif
this.features = {$pasting_feature, $stage_talk};
endif
.
#88:73
"'find_help (<name>[, databases])'";
"Search for a help topic with the given name. [<databases>] defaults to the ones returned by $code_utils:help_db_list().";
{name, ?databases = $code_utils:help_db_list()} = args;
if (!name)
this:tell("What topic do you want to search for?");
elseif (result = $code_utils:help_db_search(name, databases))
{object, realname} = result;
if (object == $ambiguous_match)
this:tell("The help topic \"", name, "\" could refer to any of the following:  ", $string_utils:english_list(realname));
elseif (((object == $help) && (!$object_utils:has_property(object, realname))) && valid(o = $string_utils:match_object(name, player.location)))
if ($object_utils:has_callable_verb(o, "help_msg"))
this:tell("That help topic was returned by ", $string_utils:nn(o), ":help_msg().");
elseif ($object_utils:has_property(o, "help_msg"))
this:tell("That help topic is located in ", $string_utils:nn(o), ".help_msg.");
else
this:tell("That help topic was matched by $help but there doesn't seem to be any help available for it.");
endif
elseif (object == $help_db["verb"])
if (((what = $code_utils:parse_verbref(realname)) && valid(what[1] = $string_utils:match_object(what[1], player.location))) && $object_utils:has_verb(@what))
this:tell("That help topic is located at the beginning of the verb ", $string_utils:nn(what[1]), ":", what[2], ".");
else
this:tell("That help topic was matched by $help_db[\"verb_help\"] but there doesn't seem to be any help available for it.");
endif
else
where = {};
for x in (databases)
if ({realname} == x:find_topics(realname))
where = setadd(where, x);
endif
endfor
asname = (name == realname) ? "" | ((" as \"" + realname) + "\"");
if (where)
this:tell("That help topic is located on ", $string_utils:nn(where), asname, ".");
else
"...this shouldn't happen unless $code_utils:help_db_search finds a match we weren't expecting";
this:tell("That help topic appears to be located on ", $string_utils:nn(object), asname, ", although this command could not find it.");
endif
endif
else
this:tell("The help topic \"", name, "\" could not be found.");
endif
.
#88:74
"Prevent an object or any of its descendents from going into your inventory, regardless of whose player perms sent it there.";
"Syntax:  @spurn <object>";
"         @spurn !<object>";
"The second form removes an object from your list of spurned objects.";
"Verb created by TheCat, 11/8/98";
if (caller != this)
return E_PERM;
endif
if (!argstr)
this:tell("Spurn what?");
elseif (argstr[1] == "!")
"Stop spurning something.";
item = this:my_match_object(argstr[2..$]);
if (item in this.spurned_objects)
this.spurned_objects = $list_utils:setremove_all(this.spurned_objects, item);
this:tell(("You are no longer spurning " + $string_utils:nn(item)) + " or any kids of it.");
else
this:tell(("You are not spurning " + $string_utils:nn(item)) + ".");
endif
else
"Spurn something.";
item = this:my_match_object(argstr);
if (!$command_utils:object_match_failed(item, argstr))
if (item in this.spurned_objects)
this:tell(("You are already spurning " + $string_utils:nn(item)) + " plus any and all kids of it.");
else
this.spurned_objects = setadd(this.spurned_objects, item);
this:tell(("You are now spurning " + $string_utils:nn(item)) + " plus any and all kids of it.");
endif
endif
endif
.
#88:75
"Displays a list of spurned objects.";
"Verb created by TheCat, 11/8/98";
if (this.spurned_objects)
this:tell("You are spurning the following objects, including any and all descendents:  " + $string_utils:nn(this.spurned_objects));
else
this:tell("You are not spurning any objects.");
endif
.
#88:76
"Permits programmatic setting of .spurned_objects, which is -c.";
{spurned_objects} = args;
if ($perm_utils:controls(caller_perms(), this))
"Note, the final result must be a list of objects, otherwise there's no point.";
if (typeof(spurned_objects) != LIST)
spurned_objects = {spurned_objects};
endif
this.spurned_objects = spurned_objects;
endif
.
#89:0
"Say something out loud, directed at someone or something.";
"Usage:";
"  `target message";
"Example:";
"  Munchkin is talking to Kenneth, who's in the same room with him.  He types:";
"      `kenneth What is the frequency?";
"  The room sees:";
"       Munchkin [to Kenneth]: What is the frequency?";
name = verb[2..$];
who = player.location:match_object(name);
if ($command_utils:object_match_failed(who, name))
return;
endif
player.location:announce_all(player.name, " [to ", who.name, "]: ", argstr);
.
#89:1
"Say something out loud, in some specific way.";
"Usage:";
"  [how]: message";
"Example:";
"  Munchkin decideds to sing some lyrics.  He types:";
"      [sings]: I am the eggman";
"  The room sees:";
"      Munchkin [sings]: I am the eggman";
player.location:announce_all((((player.name + " ") + verb) + " ") + argstr);
.
#89:2
"Perform some physical, non-verbal, action.";
"Usage:";
"  ]third person action";
"Example:";
"  Munchkin has annoyed some would-be tough guy.  He types:";
"      ]hides behind the reactor.";
"  The room sees:";
"      [Munchkin hides behind the reactor.]";
player.location:announce_all("[", (((player.name + " ") + verb[2..$]) + (argstr ? " " + argstr | "")) + "]");
.
#89:3
name = verb[2..$];
argstr = $code_utils:argstr(verb, args, argstr);
player.location:announce_all(player.name, " [", name, "]: ", argstr);
.
#89:4
"Point to yourself.";
"Usage:";
"  <message";
"Example:";
"  Muchkin decides he's being strange. He types:";
"    <being strange.";
"  The room sees:";
"    Munchkin <- being strange.";
player.location:announce_all((((player.name + " <- ") + verb[2..$]) + " ") + argstr);
.
#90:0
"Usage: @paste <prefix> <suffix>";
"Announce a series of entered lines to the room the player is in.";
"Before the lines are quoted, player.paste_header is run through";
"$string_utils:pronoun_sub(), and if the result contains the player's";
"name, it is used as a header.  Otherwise player.name centered in a";
"line of dashes is used.";
"A footer comes afterwards, likewise derived from player.paste_footer.";
"<prefix> and <suffix> are placed before and after each line.";
"";
"This verb is, as one might guess, designed for pasting text to MOO using";
"GnuEmacs or a windowing system.  You should remember that after you";
"have pasted the lines in, you must type . on a line by itself, or you'll";
"sit around waiting for $command_utils:read_lines() to finish _forever_.";
{?prefix = "", ?suffix = ""} = args;
lines = $command_utils:read_lines();
header = $string_utils:pronoun_sub_secure($code_utils:verb_or_property(player, "paste_header"), "") || $string_utils:center(player.name, 75, "-");
to_tell = {header};
for line in (lines)
to_tell = listappend(to_tell, (prefix + line) + suffix);
endfor
to_tell = listappend(to_tell, $string_utils:pronoun_sub_secure($code_utils:verb_or_property(player, "paste_footer"), "") || $string_utils:center("finished", 75, "-"));
for thing in (player.location.contents)
$command_utils:suspend_if_needed(0);
thing:tell_lines(to_tell);
endfor
player:tell("Done @pasting.");
.
#90:1
"Echo a line prefaced by a vertical bar.";
"Usage:";
"  |message";
"Example:";
"  Hacker wants to echo to the room what he just saw. He enters (either by hand, or with Emacs or a windowing system):";
"      |Haakon has disconnected.";
"  The room sees:";
"      Hacker | Haakon has disconnected.";
player.location:announce_all((((player.name + " | ") + verb[2..$]) + " ") + argstr);
.
#90:2
"Syntax: @paste-to <player>";
"";
"Which will then prompt you for the lines to privately send to <player>. The lines will be surrounded by a default footer and header.";
target = $string_utils:match_player(dobjstr);
$command_utils:player_match_result(target, dobjstr);
if (!valid(target))
return;
endif
prefix = "";
suffix = "";
lines = $command_utils:read_lines();
to_tell = {$string_utils:center("Private message from " + player.name, 75, "-")};
for line in (lines)
to_tell = listappend(to_tell, (prefix + line) + suffix);
endfor
to_tell = listappend(to_tell, $string_utils:center("end message", 75, "-"));
target:tell_lines(to_tell);
player:tell("Done @pasting.");
.
#91:0
":vector_add(V1 [,V2 ...]) => VN such that VN[n] = V1[n] + V2[n]...";
":vector_sub(V1 [,V2 ...]) => VN such that VN[n] = V1[n] - V2[n]...";
":vector_mul(V1 [,V2 ...]) => VN such that VN[n] = V1[n] * V2[n]...";
":vector_div(V1 [,V2 ...]) => VN such that VN[n] = V1[n] / V2[n]...";
"Vectors do not need to be the same length, but they should be. VN's length will be the length of the longest vector in the arguments. :vector_add and :vector_sub will pad out the smaller vectors with 0's or 0.0's. :vector_mul and :vector_div will pad out the smaller vectors with 1's or 1.0's. Vectors do not need to contain homogeneous data, but the nth term of each vector must be of the same type.";
"I can see a reason for wanting to do vector addition or subtraction, but multiplication and divareion is usually handled in other ways. I've included them here for novelty, and becuase it was easy enough to do.";
"";
"Vector addition is used when two or more similar vector quantities are at work and need to be resolved into a single vector. For instance, a ship travelling in a current will be acted upon by (at least) two forces: a force propelling it forward (its engine), and a force pushing it off course (the current). The sum of these two forces gives the resultant net force acting upon the ship and, since Force = Mass * Acceleration, the direction the ship is accelerating.";
"";
"Vector subtraction can be used to reverse the process of vector addition. In the ship problem above, let's say the actual resultant force is known, but it does not match the result of adding the propelling force and the drifting force. Friction is probably acting against the motion of the ship. Subtracting the computed resultant force from the known net force will yield the frictional force acting against the progress of the ship.";
"";
"Vector multiplication and division do not have RL examples, but vector multiplication of this type makes computing the dot product of two vectors simple.";
"";
if (length(args) == 1)
return args;
elseif (!args)
return raise(E_INVARG);
endif
type = verb[$ - 2..$];
lresult = max = length(args[1]);
results = args[1];
for n in [2..length(args)]
$command_utils:suspend_if_needed(0);
if (type == "add")
for m in [1..min(lcurr = length(args[n]), lresult)]
results[m] = results[m] + args[n][m];
$command_utils:suspend_if_needed(0);
endfor
if (lcurr > lresult)
results[lresult + 1..lcurr] = args[n][lresult + 1..lcurr];
endif
elseif (type == "sub")
for m in [1..min(lcurr = length(args[n]), lresult)]
results[m] = results[m] - args[n][m];
$command_utils:suspend_if_needed(0);
endfor
if (lcurr > lresult)
for m in [lresult + 1..lcurr]
results = {@results, -args[n][m]};
$command_utils:suspend_if_needed(0);
endfor
endif
elseif (type == "mul")
for m in [1..min(lcurr = length(args[n]), lresult)]
results[m] = results[m] * args[n][m];
$command_utils:suspend_if_needed(0);
endfor
if (lcurr > lresult)
results[lresult + 1..lcurr] = args[n][lresult + 1..lcurr];
endif
else
for m in [1..min(lcurr = length(args[n]), lresult)]
results[m] = results[m] / args[n][m];
$command_utils:suspend_if_needed(0);
endfor
if (lcurr > lresult)
for m in [lresult + 1..lcurr]
results = {@results, (typeof(foo = args[n][m]) == INT) ? 1 / foo | (1.0 / foo)};
$command_utils:suspend_if_needed(0);
endfor
endif
endif
endfor
return results;
.
#91:1
":matrix_add(M1 [, M2 ...]) => MN such that MN[m][n] = M1[m][n] + M2[m][n]...";
":matrix_sub(M1 [, M2 ...]) => MN such that MN[m][n] = M1[m][n] - M2[m][n]...";
"Matrices should all be of the same size.";
"";
"Matrix addition and subtraction is simply the addition or subtraction of the vectors contained in the matrices. See 'help $matrix_utils:vector:add' for more help.";
type = verb[$ - 2..$];
results = args[1];
if (typeof(results[1][1]) == LIST)
for n in [1..length(results)]
results[n] = this:(verb)(results[n], @$list_utils:slice(args[2..$], n));
endfor
else
for n in [1..length(results)]
results[n] = this:("vector_" + type)(results[n], @$list_utils:slice(args[2..$], n));
endfor
endif
return results;
.
#91:2
":transpose(Mmn) => Mnm";
"Transpose an m by n matrix into an n by m matrix by making the rows in the original the columns in the output.";
{mat} = args;
if (!this:is_matrix(mat))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
j = this:dimensions(mat)[2];
result = {};
for n in [1..j]
result = {@result, this:column(mat, n)};
$command_utils:suspend_if_needed(0);
endfor
return result;
.
#91:3
":determinant(M) => NUM the determinant of the matrix.";
"";
"There are several properties of a matrix's determinant. Adding or subtracting a row or column from another row or colum of a matrix does not hange the value of its determinant. Multiplying a row or column of a matrix by a single scalar value has the effect of multiplying the matrix's determinant by the same scalar.";
"";
"However, the most dramatic use of determinants is in solving linear equations. For example, the solution to this system of equations:";
"";
"Ax1 + Bx2 + Cx3 = D";
"Ex1 + Fx2 + Gx3 = H";
"Ix1 + Jx2 + Kx3 = L";
"";
"is";
"";
"     1 |D B C|         1 |A D C|        1 |A B D|";
"x1 = - |H F G|    x2 = - |E H G|   x3 = - |E F H|";
"     Z |L J K|         Z |I L K|        Z |I J L|";
"";
"          |A B C|";
"where Z = |E F G|";
"          |I J K|";
"";
"or, in other words, x1, x2, and x3 are some determinant divided by Z, another determinant.";
"";
"Determinants are also used in computing the cross product of two vectors. See 'help $matrix_utils:cross_prod' for more info.";
"";
{mat} = args;
if (!this:is_square(mat))
return raise("E_INVMAT", "Invalid Matrix Format");
elseif (this:dimensions(mat) == {1, 1})
return mat[1][1];
elseif (this:dimensions(mat)[1] == 2)
return (mat[1][1] * mat[2][2]) - (mat[1][2] * mat[2][1]);
else
result = (typeof(mat[1][1]) == INT) ? 0 | 0.0;
coeff = (typeof(mat[1][1]) == INT) ? 1 | 1.0;
for n in [1..length(mat[1])]
result = result + ((coeff * mat[1][n]) * this:determinant(this:submatrix(1, n, mat)));
coeff = -coeff;
endfor
return result;
endif
"elseif dims == {1,1} lines are courtesy of Link (#122143).  21-Oct-05";
"Originated by Uther. Modified by Link (#122143) on 16-Nov-2005.";
.
#91:4
":inverse(M) => MN such that M * MN = I";
"";
"The inverse of a matrix is very similar to the reciprocal of a scalar number. If two numbers, A and B, equal 1 (the scalar identity number) when multiplied together (AB=1), then B is said the be the reciprocal of A, and A is the reciprocal of B. If A and B are matrices, and the result of multiplying them togeter is the Identity Matrix, then B is the inverse of A, and A is the inverse of B.";
"";
"Computing the inverse involves the solutions of several linear equations. Since linear equations can be easily solved with determinants, this is rather simple. See 'help $matrix_utils:determinant' for more on how determinants solve linear equations.";
"";
{mat} = args;
{i, j} = this:dimensions(mat);
if (tofloat(det = this:determinant(mat)) == 0.0)
return raise("E_NOINV", "No Inverse Exists");
endif
result = {};
for k in [1..i]
sub = {};
for l in [1..j]
sub = {@sub, ((((typeof(mat[1][1]) == INT) ? -1 | -1.0) ^ (k + l)) * this:determinant(this:submatrix(l, k, mat))) / det};
endfor
result = {@result, sub};
endfor
return result;
.
#91:5
":identity(INT <size>) => Identity matrix (I) of dimensions <size> by <size>.";
"All elements of I are 0, except for the diagonal elements which are 1.";
"";
"The Identity Matrix has the unique property such that when another matrix is multiplied by it, the other matrix remains unchanged. This is similar to the number 1. a*1 = a. A * I = A, if the dimensions of I and A are the same.";
"";
n = args[1];
result = this:null(n, n);
for i in [1..n]
result[i][i] = 1;
endfor
return result;
.
#91:6
":null(INT <size>) => Null matrix (O) of dimensions <size> by <size>.";
"All elements of O are 0.";
"";
"The Null Matrix has the property that is equivalent to the number 0; it reduces the original matrix to itself. a * 0 = 0. A * N = N.";
"";
{m, ?n = m} = args;
result = {};
for i in [1..m]
result = {@result, {}};
for j in [1..n]
result[i] = {@result[i], 0};
endfor
endfor
return result;
.
#91:7
":is_square(M) => 1 iff dimensions of M are equal to each other.";
{m} = args;
return (this:is_matrix(m) && (this:order(m) == 2)) && ((dim = this:dimensions(m))[1] == dim[2]);
.
#91:8
":is_null(M) => 1 iff M is O.";
m = length(mat = args[1]);
if (!this:is_square(mat))
return 0;
endif
for i in [1..m]
for j in [1..m]
if (mat[i][j] != 0)
return 0;
endif
endfor
endfor
return 1;
.
#91:9
":is_identity(M) => 1 iff M is I.";
m = length(mat = args[1]);
if (!this:is_square(mat))
return 0;
endif
for i in [1..m]
for j in [1..m]
if ((mat[i][j] != 0) && ((i != j) ? 1 | (mat[i][j] != 1)))
return 0;
endif
endfor
endfor
return 1;
.
#91:10
":cross_prod(V1, V2) => VN, the vector perpendicular to both V1 and V2 with length equal to the area of the parallelogram spanned by V1 and V2, and direction governed by the rule of thumb.";
"";
"If A = a1i + a2j + a3k, represented as a list as {a1, a2, a3}";
"and B = b1i + b2j + b3k, or {b1, b2, b3}, then";
"";
"        |i  j  k |";
"A x B = |a1 a2 a3| = |a2 a3|i - |a1 a3|j + |a1 a2|k";
"        |b1 b2 b3| = |b2 b3|    |b1 b3|    |b1 b2|";
"";
"or, in list terms, as the list of the coefficients of i, j, and k.";
"";
"Note: i, j, and k are unit vectors in the x, y, and z direction respectively.";
"";
"The rule of thumb: A x B = C  If you hold your right hand out so that your fingers point in the direction of A, and so that you can curl them through B as you make a hitchhiking fist, your thumb will point in the direction of C.";
"";
"Put another way, A x B = ABsin(THETA) (A cross B equals the magnitude of A times the magnitude of B times the sin of the angle between them) This is expressed as a vector perpendicular the the A-B plane, pointing `up' if you curl your right hand fingers from A to B, and `down' if your right hand fingers curl from B to A.";
"";
"The cross product has many uses in physics. Angular momentum is the cross product of a particles position vector from the point it is rotating around and it's linear momentum (L = r x p). Torque is the cross product of position and Force (t = r x F).";
"";
{v1, v2} = args;
if (((((l = length(v1)) != length(v2)) || (l != 3)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))
return raise("E_INVVEC", "Invalid Vector Format");
endif
mat = {{1, 1, 1}, v1, v2};
coeff = 1;
result = {};
for n in [1..3]
result = {@result, coeff * this:determinant(this:submatrix(1, n, mat))};
coeff = -coeff;
endfor
return result;
.
#91:11
":norm(V) => FLOAT";
":length(V) => FLOAT";
"The norm is the length of a vector, the square root of the sum of the squares of its elements.";
"";
"In school, we all should have learned the Pythagorean Theorem of right triangles: The sum of the squares of the sides of a right triagle is equal to the square of the hypoteneuse. The Theorem holds true no matter how many dimensions are being considered. The length of a vector is equal to the square root of the sum of the squares of its components. The dot product of a vector with itself happens to be the sum of the squares of its components.";
"";
{v} = args;
return this:is_vector(v) ? sqrt(tofloat(this:dot_prod(v, v))) | E_TYPE;
.
#91:12
":submatrix(i, j, M1) => M2, the matrix formed from deleting the ith row and jth column from M1.";
{i, j, mat} = args;
{k, l} = this:dimensions(mat);
result = {};
for m in [1..k]
sub = {};
for n in [1..l]
if ((m != i) && (n != j))
sub = {@sub, mat[m][n]};
endif
endfor
if (sub)
result = {@result, sub};
endif
endfor
return result;
.
#91:13
":dot_prod(V1, V2) => NUM";
":inner_prod(V1, V2) => NUM";
"The dot, or inner, product of two vectors is the sum of the products of the corresponding elements of the vectors.";
"If V1 = {1, 2, 3} and V2 = {4, 5, 6}, then V1.V2 = 1*4 + 2*5 + 3*6 = 32";
"";
"The dot product is useful in computing the angle between two vectors, and the length of a vector. See 'help $matrix_utils:subtended_angle' and 'help $matrix_utils:length'.";
"";
"A . B = ABcos(THETA)  (A dot B equals the magnitude of A times the magnitude of B times the cosine of the angle between them.)";
"";
{v1, v2} = args;
if ((((l = length(v1)) != length(v2)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))
return raise("E_INVVEC", "Invalid Vector Format");
endif
temp = this:vector_mul(v1, v2);
result = (typeof(temp[1]) == INT) ? 0 | 0.0;
for n in [1..l]
$command_utils:suspend_if_needed(0);
result = result + temp[n];
endfor
return result;
.
#91:14
":dimensions(M) => LIST of dimensional sizes.";
l = {length(m = args[1])};
if (typeof(m[1]) == LIST)
l = {@l, @this:dimensions(m[1])};
endif
return l;
.
#91:15
":order(M) => INT how many dimensions does this matrix have? 1 means vector";
return length(this:dimensions(args[1]));
.
#91:16
":scalar_vector_add(S, V) => VN such that VN[n] = V[n] + S...";
":scalar_vector_sub(S, V) => VN such that VN[n] = V[n] - S...";
":scalar_vector_mul(S, V) => VN such that VN[n] = V[n] * S...";
":scalar_vector_div(S, V) => VN such that VN[n] = V[n] / S...";
"Actually, arguments can be (S, V) or (V, S). Each element of V is augmented by S. S should be either an INT or a FLOAT, as appropriate to the values in V.";
"";
"I can see a reason for wanting to do scalar/vector multiplcation or division, but addition and subtraction between vector and scalar types is not done. I've included them here for novelty, and because it was easy enough to to.";
"";
"Scalar-vector multiplication stretches a vector along its direction, generating points along a line. One of the more famous uses from physics is Force equals mass times acceleration. F = ma. Force and acceleration are both vectors. Mass is a scalar quantity.";
"";
if (typeof(args[1]) == LIST)
{vval, sval} = args;
else
{sval, vval} = args;
endif
if (!this:is_vector(vval))
return raise("E_INVVEC", "Invalid Vector Format");
endif
type = verb[$ - 2..$];
for n in [1..length(vval)]
if (type == "add")
vval[n] = vval[n] + sval;
elseif (type == "sub")
vval[n] = vval[n] - sval;
elseif (type == "mul")
vval[n] = vval[n] * sval;
else
vval[n] = vval[n] / sval;
endif
endfor
return vval;
.
#91:17
":subtended_angle(V1, V2) => FLOAT smallest angle defined by V1, V2 in radians";
"";
"Any two vectors define two angles, one less than or equal to 180 degrees, the other 180 degrees or more. The larger can be determined from the smaller, since their sum must be 360 degrees.";
"";
"The dot product of the two angles, divided by the lengths of each of the vectors is the cosine of the smaller angle defined by the two vectors.";
"";
{v1, v2} = args;
if ((((l = length(v1)) != length(v2)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))
return raise("E_INVVEC", "Invalid Vector Format");
endif
return acos(tofloat(this:dot_prod(v1, v2)) / (this:norm(v1) * this:norm(v2)));
.
#91:18
":column(M, INT <n>) => LIST the nth column of M.";
{mat, i} = args;
j = this:dimensions(mat)[1];
result = {};
for m in [1..j]
result = {@result, mat[m][i]};
$command_utils:suspend_if_needed(0);
endfor
return result;
.
#91:19
":matrix_mul(M1, M2) => MN such that MN[m][n] = the dot product of the mth row of M1 and the transpose of thenth column of M2.";
"";
"Matrix multiplication is the most common and complex operation performed on two matrices. First, matrices can only be multiplied if they are of compatible sizes. An i by j matrix can only be multiplied by a j by k matrix, and the results of this multiplication will be a matrix of size i by k. Each element in the resulting matrix is the dot product of a row from the first matrix and a column from the second matrix. (See 'help $matrix_utils:dot_prod'.)";
"";
{m1, m2} = args;
{i, j} = this:dimensions(m1);
{k, l} = this:dimensions(m2);
if (((j != k) || (!this:is_matrix(m1))) || (!this:is_matrix(m2)))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
result = {};
for m in [1..i]
sub = {};
for n in [1..l]
$command_utils:suspend_if_needed(0);
sub = {@sub, this:dot_prod(m1[m], this:column(m2, n))};
endfor
result = {@result, sub};
endfor
return result;
.
#91:20
":scalar_matrix_add(S, M) => MN such that MN[m][n] = MN[m][n] + S...";
":scalar_matrix_sub(S, M) => MN such that MN[m][n] = MN[m][n] - S...";
":scalar_matrix_mul(S, M) => MN such that MN[m][n] = MN[m][n] * S...";
":scalar_matrix_div(S, M) => MN such that MN[m][n] = MN[m][n] / S...";
"Actually, arguments can be (S, M) or (M, S). Each element of M is augmented by S. S should be either an INT or a FLOAT, as appropriate to the values in M.";
"I can see a reason for wanting to do scalar/matrix multiplication or division, but addition and subtraction between matrix and scalar types is not done. I've included them here for novelty, and because it was easy enough to do.";
type = verb[$ - 2..$];
if (typeof(args[1]) == LIST)
{mval, sval} = args;
else
{sval, mval} = args;
endif
if (!this:is_matrix(mval))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
results = {};
if (typeof(mval[1][1] == LIST))
for n in [1..length(mval)]
results = {@results, this:(verb)(mval[n], sval)};
endfor
else
for n in [1..length(mval)]
results = {@results, this:("scalar_vector_" + type)(mval[n], sval)};
endfor
endif
return results;
.
#91:21
"A matrix is defined as a list of vectors, each having the smae number of elements.";
{m} = args;
if ((typeof(m) != LIST) || (typeof(m[1]) != LIST))
return 0;
endif
len = length(m[1]);
for v in (m)
if ((!this:is_vector(v)) || (length(v) != len))
return 0;
endif
endfor
return 1;
.
#91:22
"A vector shall be defined as a list of INTs or FLOATs. (I'm not gonna worry about them all being the same type.)";
flag = 1;
{v} = args;
if (typeof(v) != LIST)
return 0;
endif
for n in (v)
if (((ntype = typeof(n)) != INT) && (ntype != FLOAT))
flag = 0;
break;
endif
$command_utils:suspend_if_needed(0);
endfor
return flag;
.
#91:23
":is_reflexive   (M) => 1 if M is a reflexive relation, -1 if areflexive,";
"                       0 otherwise.";
":is_areflexive does the same, but with 1 and -1 reversed.";
{m} = args;
if (!this:is_square(m))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
good = bad = 0;
for n in [1..length(m)]
if (!m[n][n])
bad = 1;
else
good = 1;
endif
endfor
return this:_relation_result(good, bad, verb[4] == "a");
.
#91:24
":is_symmetric   (M) => 1 if M is a symmetric relation, -1 if asymmetric,";
"                       0 otherwise.";
":is_asymmetric does the same, but with 1 and -1 reversed.";
{mat} = args;
if (!this:is_square(mat))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
good = bad = 0;
for m in [1..len = length(mat)]
for n in [m + 1..len]
if (mat[m][n] == mat[n][m])
good = 1;
else
bad = 1;
endif
endfor
endfor
return this:_relation_result(good, bad, verb[4] == "a");
.
#91:25
":is_transitive  (M) => 1 if M is a transitive relation, -1 if atransitive,";
"                       0 otherwise.";
":is_atransitive does the same, but with 1 and -1 reversed.";
{mat} = args;
if (!this:is_square(mat))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
good = bad = 0;
for m in [1..len = length(mat)]
for n in [1..len]
if (mat[m][n])
for l in [1..len]
if (mat[n][l])
if (mat[m][l])
good = 1;
else
bad = 1;
endif
endif
endfor
endif
endfor
endfor
return this:_relation_result(good, bad, verb[4] == "a");
.
#91:26
"Common code for is_reflexive, is_symmetric, and is_transitive.";
{good, bad, flag} = args;
if (good && (!bad))
result = 1;
elseif ((!good) && bad)
result = -1;
else
result = 0;
endif
return flag * result;
.
#91:27
":is_partial_ordering(M) => 1 iff M is a reflexive, asymmetric, transitive relation.";
{mat} = args;
return ((this:is_asymmetric(mat) == this:is_reflexive(mat)) == this:is_transitive(mat)) == 1;
.
#93:0
":dd_to_dms(INT|FLOAT <degrees>) => LIST {INT <degrees>, INT <minutes>, FLOAT <seconds>}";
"This verb converts decimal degrees to degrees, minutes, and seconds.";
dd = tofloat(args[1]);
s = (((dd - tofloat(d = toint(dd))) * 60.0) - tofloat(m = toint((dd - tofloat(d)) * 60.0))) * 60.0;
return {d, m, s};
.
#93:1
":dms_to_dd(INT|FLOAT <deg>, INT|FLOAT <min>, INT|FLOAT <sec>) => FLOAT <deg>";
"This verb converts degrees/minutes/seconds to decimal degrees.";
{d, m, s} = args[1..3];
d = tofloat(d);
m = tofloat(m);
s = tofloat(s);
return (d + (m / 60.0)) + (s / 3600.0);
.
#93:2
":rect_to_polar(INT|FLOAT <x>, INT|FLOAT <y>) => FLOAT <radius>, FLOAT <angle>.";
"This verb converts from rectangular (x,y) coordinates to polar (r, theta) coordinates.";
{x, y} = args[1..2];
x = tofloat(x);
y = tofloat(y);
return {sqrt((x * x) + (x * x)), `atan(y, x) ! E_INVARG => 0.0'};
.
#93:3
":polar_to_rect(INT|FLOAT <radius>, INT|FLOAT <angle>) => FLOAT <x>, FLOAT <y>";
"This verb converts from polar (radius, angle) coordinates to rectangulat (x,y) coordinates.";
{r, a} = args[1..2];
r = tofloat(r);
a = tofloat(a);
return {(r = r / (1.0 + (z2 = (z = tan(a / 2.0)) * z))) * (1.0 - z2), (r * 2.0) * z};
.
#93:4
":F_to_C(INT|FLOAT <Fahrenheit>) => FLOAT <Celsius>";
"This verb converts Fahrenheit degrees to Celsius degrees.";
return (tofloat(args[1]) - 32.0) / 1.8;
.
#93:5
":C_to_F(INT|FLOAT <Celsius>) => FLOAT <Fahrenheit>";
"This verb converts Celsius degrees to Fahrenheit degrees.";
return (tofloat(args[1]) * 1.8) + 32.0;
.
#93:6
":convert(STR <units>, STR <units>) => FLOAT conversion factor | LIST errors.";
"This verb attempts to compute the conversion factor between two sets of units. If the two inputs are of the same type (two speeds, two lengths, etc.), the value is returned. If the two inputs are not of the same type, a LIST is returned as follows: {1, {FLOAT <value>, STR <units>}. {FLOAT <value>, STR <units>}}. The 1 indicates that the two inputs were correctly formed. <value> is the conversion factor of the input into the basic <units>. This error output is useful for determining the basic structure and value of an unknown unit of measure. If either of the inputs can not be broken down to known units, a LIST is returned as follows: {0, STR <bad input>}.";
"";
"The format of the input strings is fairly straight forward: any multiplicative combination of units, ending in an optional digit to represent that unit is raised to a power, the whole of which is preceeded by an initial value. Examples: \"100 kg m/sec2\", \"35 joules\", \"2000 furlongs/fortnight\"";
"";
"Some example uses:";
";$convert_utils:convert(\"2000 furlongs/fortnight\", \"mph\")";
"=> 0.744047619047619";
";$convert_utils:convert(\"kilowatt hours\", \"joules\")";
"=> 3600000.0";
"";
";$convert_utils:convert(\"furlongs\", \"mph\")";
"=> {1, {201.168, \"m\"}, {044704, \"m / s\"}}";
"";
";$convert_utils:convert(\"junk\", \"meters\")";
"=> {0, \"junk\"}";
{havestr, wantstr} = args;
{havenum, havestr} = $string_utils:first_word(havestr);
havestr = $string_utils:trimr(tostr(havenum, " ", strsub(havestr, " ", "")));
wantstr = strsub(wantstr, " ", "");
"Preceeding three lines added by GD (#110777) on 23-June-2007 to stop an annoying error when you try to convert to/from things like 'fluid ounces'.";
have = this:_do_convert(havestr);
want = this:_do_convert(wantstr);
if ((have && want) && (have[2] == want[2]))
return have[1] / want[1];
elseif (have && want)
return {1, {have[1], this:_format_units(@have[2])}, {want[1], this:_format_units(@want[2])}};
else
return {0, have ? wantstr | havestr};
endif
.
#93:7
"THIS VERB IS NOT INTENDED FOR USER USAGE.";
":_do_convert is the workhorse of $convert_utils:convert and is based loosely upon the 'units' Perl script the ships with BSD Unix.";
"Essentially, it breaks the input up into values and units, attempts to break each unit down into elementary (basic) units, modifies the value as it goes, until it has no more input or can not convert a unit into a basic unit.";
instr = args[1];
units = this.basic_units_template;
value = 1.0;
top = 1;
"Ensure that the division mark is a spearate word.";
instr = $string_utils:substitute(instr, {{"/", " / "}});
while (instr)
"Grab the next word to process";
{first, instr} = $string_utils:first_word(instr);
if (first == "/")
"Now we're working with values under the division mark - units with negative exponents.";
top = 1 - top;
continue;
elseif (match(first, "|"))
"The word was a value expressed as a ratio. Compute the ratio and adjust the value accordingly.";
value = this:_do_value(first, value, top);
continue;
elseif ($string_utils:is_integer(first) || $string_utils:is_float(first))
"The word was a value. Adjust the accumulated value accordingly.";
value = top ? value * tofloat(first) | (value / tofloat(first));
continue;
elseif (match(first, "[0-9]$"))
"The word ends with a digit, but isn't a value. It must be a powered unit. Expand it: cm3 => cm cm cm";
subs = match(first, "%([a-zA-Z]+%)%([0-9]+%)");
first = substitute("%1", subs);
power = toint(substitute("%2", subs));
while (power > 0)
instr = (first + " ") + instr;
power = power - 1;
endwhile
continue;
else
"Check to see if the word starts with one or more metric prefix and attempt to evaluate the prefix.";
{first, value, top} = this:_try_metric_prefix(first, value, top);
"Check to see if we have a basic unit. If so, adjust the apropriate unit count.";
if (index = first in this.basic_units)
units[index][2] = top ? units[index][2] + 1 | (units[index][2] - 1);
continue;
elseif (prop = `this.(first) ! E_PROPNF => 0')
"Check to see if this is a known unit. If so, convert it and adjust the value and units.";
result = this:_do_convert(prop);
value = top ? value * result[1] | (value / result[1]);
for i in [1..length(units)]
units[i][2] = top ? units[i][2] + result[2][i][2] | (units[i][2] - result[2][i][2]);
endfor
continue;
elseif (first[$] == "s")
"Check to see if this is a normal 's'-ending plural, and try to do the above checks again.";
temp = first[1..$ - 1];
if (index = temp in this.basic_units)
units[index][2] = top ? units[index][2] + 1 | (units[index][2] - 1);
continue;
elseif (prop = `this.(temp) ! E_PROPNF => 0')
result = this:_do_convert(prop);
value = top ? value * result[1] | (value / result[1]);
for i in [1..length(units)]
units[i][2] = top ? units[i][2] + result[2][i][2] | (units[i][2] - result[2][i][2]);
endfor
continue;
endif
endif
"We were unable to find any conversion for the current word, so halt all operation and return 0.";
return 0;
endif
endwhile
"We were able to successfully convert each part of the input. Return the equivalent value and units.";
return {value, units};
.
#93:8
"THIS VERB IS NOT INTENDED FOR USER USAGE.";
":_try_metric_prefix runs through the metrix multipliers and tries to match them against the beginning of the input string. If successful, the given value is adjusted appropritately, and the input string is modified. The verb loops until there are no more prefix matches. (Hence, \"kilodecameter\" can be matched with only one verb call.";
"If anyone knows of other possibilities here, please let me know.";
{first, value, top} = args;
while (1)
if (subs = match(first, "^yocto%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1e+24 | (value * 1e+24);
continue;
endif
if (subs = match(first, "^zepto%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1e+21 | (value * 1e+21);
continue;
endif
if (subs = match(first, "^atto%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1e+18 | (value * 1e+18);
continue;
endif
if (subs = match(first, "^femto%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1e+15 | (value * 1e+15);
continue;
endif
if (subs = match(first, "^pico%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1000000000000.0 | (value * 1000000000000.0);
continue;
endif
if (subs = match(first, "^nano%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1000000000.0 | (value * 1000000000.0);
continue;
endif
if (match(first, "^micron"))
break;
endif
if (subs = match(first, "^micro%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1000000.0 | (value * 1000000.0);
continue;
endif
if (subs = match(first, "^milli%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1000.0 | (value * 1000.0);
continue;
endif
if (subs = match(first, "^centi%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 100.0 | (value * 100.0);
continue;
endif
if (subs = match(first, "^deci%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 10.0 | (value * 10.0);
continue;
endif
if (subs = match(first, "^%(deca%|deka%)%(.*%)"))
first = substitute("%2", subs);
value = (!top) ? value / 10.0 | (value * 10.0);
continue;
endif
if (subs = match(first, "^hecto%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 100.0 | (value * 100.0);
continue;
endif
if (subs = match(first, "^kilo%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1000.0 | (value * 1000.0);
continue;
endif
if (subs = match(first, "^mega%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1000000.0 | (value * 1000000.0);
continue;
endif
if (subs = match(first, "^giga%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1000000000.0 | (value * 1000000000.0);
continue;
endif
if (subs = match(first, "^tera%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1000000000000.0 | (value * 1000000000000.0);
continue;
endif
if (subs = match(first, "^peta%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1e+15 | (value * 1e+15);
continue;
endif
if (subs = match(first, "^exa%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1e+18 | (value * 1e+18);
continue;
endif
if (subs = match(first, "^zetta%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1e+21 | (value * 1e+21);
continue;
endif
if (subs = match(first, "^yotta%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1e+24 | (value * 1e+24);
continue;
endif
break;
endwhile
return {first, value, top};
.
#93:9
"THIS VERB IS NOT INTENDED FOR USER USAGE.";
":_format_units takes the associative list of units and powers and construct a more user friendly string.";
top = bottom = "";
for pair in (args)
if (pair[2] > 0)
top = tostr(top, " ", pair[1], (pair[2] > 1) ? pair[2] | "");
elseif (pair[2] < 0)
bottom = tostr(bottom, " ", pair[1], (pair[2] < -1) ? -pair[2] | "");
endif
endfor
if (bottom)
return ((top + " /") + bottom)[2..$];
else
return top[2..$];
endif
.
#93:10
":K_to_C (INT|FLOAT <Kelvin>) => FLOAT <Celcius>";
"This verb converts Kelvin degrees to Celcius degrees.";
return tofloat(args[1]) - 273.0;
.
#93:11
":C_to_K (INT|FLOAT <Celcius>) => FLOAT <Kelvin>";
"This verb converts Celcius degrees to Kelvin degrees.";
return tofloat(args[1]) + 273.0;
.
#93:12
":F_to_R (INT|FLOAT <Fahrenheit>) => FLOAT <Rankine>";
"This verb converts Fahrenheit degrees to Rankine degrees.";
return tofloat(args[1]) + 459.67;
.
#93:13
":R_to_F (INT|FLOAT <Rankine>) => FLOAT <Fahrenheit>";
"This verb converts Rankine degrees to Fahrenheit degrees.";
return tofloat(args[1]) - 459.67;
.
#93:14
"THIS VERB IS NOT INTENDED FOR USER USAGE.";
":_do_value takes a string of the form <number>|<number>, interprets it as a ratio, and applies that ratio to the incoming 'value' accordingly with the 'top' input, and returns it back to the calling verb.";
{first, value, top} = args;
{numer, denom} = $string_utils:explode(first, "|");
return top ? (value * tofloat(numer)) / tofloat(denom) | ((value * tofloat(denom)) / tofloat(numer));
.
#94:0
"set_gender(newgender) attempts to change this.gender to newgender";
"  => E_PERM   if you don't own this or aren't its parent";
"  => Other return values as from $gender_utils:set.";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
else
result = $gender_utils:set(this, args[1]);
this.gender = (typeof(result) == STR) ? result | args[1];
return result;
endif
.
#94:1
"Copied from generic player (#6):verb_sub by ur-Rog (#6349) Fri Jan 22 11:20:11 1999 PST";
"This verb was copied by TheCat on 01/22/99, so that the generic gendered object will be able to do verb conjugation as well as pronoun substitution.";
text = args[1];
if (a = `$list_utils:assoc(text, this.verb_subs) ! ANY')
return a[2];
else
return $gender_utils:get_conj(text, this);
endif
.
#95:0
if (this:changed(who = player in this.active))
player:tell("You are still editing ", this:working_on(who), ".  Please type ABORT or SAVE first.");
elseif (spec = this:parse_invoke(dobjstr, verb))
this:init_session(who, @spec);
endif
.
#95:1
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
if (dobjstr)
if (objprop = this:property_match_result(dobjstr))
this.objects[who] = objprop[1];
this.properties[who] = objprop[2];
else
return;
endif
else
objprop = {this.objects[who], this.properties[who]};
endif
value_list = this:to_value(@this:text(who));
if (value_list[1])
player:tell("Error on line ", value_list[1], ":  ", value_list[2]);
player:tell("Value not saved to ", this:working_on(who));
elseif (result = this:set_property(@objprop, value_list[2]))
player:tell("Value written to ", this:working_on(who), ".");
this:set_changed(who, 0);
else
player:tell(result);
player:tell("Value not saved to ", this:working_on(who));
endif
.
#95:2
player:tell("I don't understand that.");
.
#95:3
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"_", "1"}, @args)) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk at end of cmd:  ", range[3]);
else
text = this.texts[who];
newins = ins = this.inserting[who];
start = range[1];
if (typeof(debris = this:explode_line("", text[start])) == STR)
player:tell("Line ", start, ":  ", debris);
return;
endif
if (!debris[1])
debris = listdelete(debris, 1);
endif
newlines = {};
for line in (text[i = start + 1..end = range[2]])
dlen = length(debris);
newlines = {@newlines, @debris[1..dlen - 1]};
if (ins == i)
newins = (start + length(newlines)) + 1;
endif
if (typeof(debris = this:explode_line(debris[dlen], line)) == STR)
player:tell("Line ", i, ":  ", debris);
return;
endif
i = i + 1;
endfor
explen = length(newlines) + length(debris);
if (ins > end)
newins = (ins - ((end - start) + 1)) + explen;
endif
this.texts[who] = {@text[1..start - 1], @newlines, @debris, @text[end + 1..length(text)]};
this.inserting[who] = newins;
player:tell("--> ", start, "..", (start + explen) - 1);
endif
.
#95:4
if (!(e = this:readable(who = args ? args[1] | (player in this.active)) || this:ok(who)))
return e;
endif
vlist = this:to_value(@this:text(who));
if (vlist[1])
player:tell("Error on line ", vlist[1], ":  ", vlist[2]);
return E_INVARG;
else
return vlist[2];
endif
.
#95:5
if (!(who = args[1]))
return "????";
endif
object = this.objects[who];
prop = this.properties[who] || "(???)";
return valid(object) ? tostr("\"", object.name, "\"(", object, ")", "." + prop) | tostr(".", prop, " on an invalid object (", object, ")");
.
#95:6
if (this:ok(who = args[1]))
this:load(who, args[4]);
this.objects[who] = args[2];
this.properties[who] = args[3];
player:tell("Now editing ", this:working_on(who), ".");
endif
.
#95:7
if (!(pp = $code_utils:parse_propref(string = args[1])))
player:tell("Property specification expected.");
return 0;
endif
objstr = pp[1];
prop = pp[2];
if ($command_utils:object_match_failed(object = player:my_match_object(objstr, this:get_room(player)), objstr))
elseif (!$object_utils:has_property(object, prop))
player:tell(object.name, "(", object, ") has no \".", prop, "\" property.");
else
return {object, prop};
endif
return 0;
.
#95:8
"WIZARDLY";
vl = $code_utils:verb_loc();
if ((caller != vl) || (caller_perms() != vl.owner))
return E_PERM;
endif
set_task_perms(player);
return args[1].(args[2]);
.
#95:9
"WIZARDLY";
vl = $code_utils:verb_loc();
if ((caller != vl) || (caller_perms() != vl.owner))
return E_PERM;
endif
{object, pname, value} = args;
set_task_perms(player);
if ($object_utils:has_callable_verb(object, "set_" + pname))
if (typeof(attempt = object:("set_" + pname)(value)) != ERR)
return attempt;
endif
endif
return (typeof(e = object.(pname) = value) == ERR) ? e | 1;
.
#95:10
su = $string_utils;
prev = args[1];
line = su:triml(args[2]);
indent = length(args[2]) - length(line);
if (line[1] == "@")
if (!(splicee = $no_one:eval(("{" + line[2..length(line)]) + "}"))[1])
return "Can't eval what's after the @.";
endif
newlines = this:explode_list(indent + 1, splicee[2]);
return {prev, @newlines};
elseif (line[1] == "}")
if (this:is_delimiter(prev) && (!index(prev, "{")))
return {tostr(args[2][1..indent], su:trim(prev), " ", line)};
else
return args;
endif
elseif (line[1] != "{")
return args;
elseif (!rindex(line, "}"))
if (this:is_delimiter(prev))
return {(su:trimr(prev) + (rindex(prev, "{") ? " " | ", ")) + line};
else
return args;
endif
elseif (!(v = $no_one:eval(line))[1])
return "Can't eval this line.";
else
newlines = {@this:explode_list(indent + 2, v[2]), su:space(indent) + "}"};
if (this:is_delimiter(prev))
return {su:trimr(prev) + (rindex(prev, "{") ? " {" | ", {"), @newlines};
else
return {prev, su:space(indent) + "{", @newlines};
endif
endif
.
#95:11
":explode_list(indent,list) => corresponding list of strings to use.";
lines = {};
indent = $string_utils:space(args[1]);
for element in (args[2])
if (typeof(element) == STR)
lines = {@lines, (indent + "\"") + element};
else
lines = {@lines, indent + $string_utils:print(element)};
endif
endfor
return lines;
.
#95:12
line = $string_utils:triml(args[1]);
return line && ((line[1] == "}") || ((line[1] == "{") && (!rindex(line, "}"))));
.
#95:13
":to_value(@list_of_strings) => {line#, error_message} or {0,value}";
"converts the given list of strings back into a value if possible";
stack = {};
curlist = {};
curstr = 0;
i = 0;
for line in (args)
i = i + 1;
if (!(line = $string_utils:triml(line)))
"skip blank lines";
elseif ((char = line[1]) == "+")
if (curstr == 0)
return {i, "previous line is not a string"};
endif
curstr = curstr + line[2..length(line)];
else
if (curstr != 0)
curlist = {@curlist, curstr};
curstr = 0;
endif
if ((char == "}") || ((char == "{") && (!rindex(line, "}"))))
comma = 0;
for c in [1..length(line)]
char = line[c];
if (char == "}")
if (comma)
return {i, "unexpected `}'"};
elseif (!stack)
return {i, "too many }'s"};
endif
curlist = {@stack[1], curlist};
stack = listdelete(stack, 1);
elseif (char == "{")
comma = 1;
stack = {curlist, @stack};
curlist = {};
elseif (char == " ")
elseif ((!comma) && (char == ","))
comma = 1;
else
return {i, tostr("unexpected `", char, "'")};
endif
endfor
elseif (char == "\"")
curstr = line[2..length(line)];
elseif (char == "@")
if (!(v = $no_one:eval(("{" + line[2..length(line)]) + "}"))[1])
return {i, "Can't eval what's after the @"};
endif
curlist = {@curlist, @v[2]};
else
if (!(v = $no_one:eval(line))[1])
return {i, "Can't eval this line"};
endif
curlist = {@curlist, v[2]};
endif
endif
endfor
if (stack)
return {i, "missing }"};
endif
if (curstr != 0)
return {0, {@curlist, curstr}};
else
return {0, curlist};
endif
.
#95:14
if (caller != this)
raise(E_PERM);
elseif (!(string = args[1]))
player:tell_lines({("Usage:  " + args[2]) + " <object>.<property>", ("        " + args[2]) + "          (continues editing an unsaved property)"});
elseif (!(objprop = this:property_match_result(string)))
elseif (ERR == typeof(value = this:property(@objprop)))
player:tell("Couldn't get property value:  ", value);
elseif (typeof(value) != LIST)
player:tell("Sorry... expecting a list-valued property.");
if (typeof(value) == STR)
player:tell("Use @notedit to edit string-valued properties");
else
player:tell("Anyway, you don't need an editor to edit `", value, "'.");
endif
else
return {@objprop, this:explode_list(0, value)};
endif
return 0;
.
#97:0
"HTTP Server";
"";
"This gets called by the #0:do_login_command";
"It keeps track of web browser guests, and it feeds them HTTP instead of Telnet.";
if ((caller != #0) && (caller != this))
return E_PERM;
endif
not_http = args ? args | {$login.blank_command};
guest = $string_utils:connection_hostname(player);
if (!args)
if ((guestnum = $list_utils:iassoc(guest, this.guests)) > 0)
guestinfo = this.guests[guestnum];
if (guestinfo[3] > 1)
"Three blank requests means this is not a guest anymore.";
this.guests = listdelete(this.guests, guestnum);
return not_http;
endif
guestinfo[3] = guestinfo[3] + 1;
this.guests[guestnum] = guestinfo;
else
"Don't know who this is. Do the regular welcome.";
return not_http;
endif
elseif ((guestnum = $list_utils:iassoc(guest, this.guests)) > 0)
"Previously registered HTTP guest.";
if (args && (args[1] == "GET"))
"Registered guest does a GET.";
guestinfo = {guest, time(), 0};
this.guests[guestnum] = guestinfo;
html = {};
keys = $string_utils:explode(args[2], "/");
objid = keys ? toobj(keys[1]) | #-1;
if (valid(objid))
if ($object_utils:has_callable_verb(objid, "html"))
new_player = $no_one;
if ((length(keys) >= 3) && (length(keys[3]) > 2))
if (keys[3] == this:gen_key(keys[1], keys[2], keys[3][1..2]))
new_player = toobj(keys[2]);
keys = (length(keys) > 3) ? keys[4..$] | {};
endif
endif
old_player = player;
player = new_player;
html = `objid:html(@keys) ! ANY';
player = old_player;
if (typeof(html) == ERR)
html = {"HTTP/1.1 500 Internal Server Error", "Content-Type: text/plain", "", "", "ERROR:", tostr(objid) + ":html()", tostr(html)};
endif
elseif ($object_utils:has_readable_property(objid, "html"))
html = objid.html;
else
html = {"HTTP/1.1 404 NOT FOUND", "Content-Type: text/plain", "", "", "HTML not found."};
endif
else
html = {"HTTP/1.1 404 NOT FOUND", "Content-Type: text/plain", "", "", "Object not found."};
endif
"Default header is HTML";
html_header = {"HTTP/1.1 200 OK", "Content-Type: text/html", "", ""};
if (typeof(html) == STR)
html = {html};
endif
if (`html[1][1..6] == "<HTML>" ! ANY => 0')
html = {@html_header, @html};
endif
if ((typeof(html) == LIST) && (length(html) == 0))
html = html_header;
endif
if (html && (typeof(html) == LIST))
for h in (html)
if (typeof(h) == STR)
notify(player, h);
endif
endfor
endif
"Server options need a suspend before they take effect.";
old_boot = $server_options.boot_msg;
$server_options.boot_msg = "";
suspend(0);
boot_player(player);
$server_options.boot_msg = old_boot;
elseif (args[1][$] == ":")
"Client is telling us some HTTP header info.";
boot_player(player);
else
"They stopped doing GETs, so remove them as HTTP.";
this.guests = listdelete(this.guests, guestnum);
return not_http;
endif
elseif (args && (args[1] == "GET"))
"First visit. Register them as a guest and ask them to refresh.";
guestinfo = {guest, time(), 0};
this.guests = {@this.guests, guestinfo};
html = {"HTTP/1.1 200 OK", "Content-Type: text/html", "", "", "<meta http-equiv=\"refresh\" content=\"0\"><br><b>", "", "", "", "Web service initialized. Please reload this page.", "</b>"};
for h in (html)
notify(player, h);
endfor
boot_player(player);
else
"Regular telnet client.";
return not_http;
endif
"HTTP Session successful";
return;
.
#97:1
"This makes a URL key for a specific object and player.";
"With the keyed URL, the PLAYER will be set correctly when :HTML() is called";
key = this:gen_key(player, caller);
notify(player, ("This is the private key for you, " + player.name) + ". Do not share it.");
notify(player, ((((((((("http://" + $network.site) + ":") + $network.port) + "/") + tostr(caller)[2..$]) + "/") + tostr(player)[2..$]) + "/") + key) + "/");
.
#97:2
if (caller != this)
return E_PERM;
endif
player = args[1];
object = args[2];
hash = ((toint(player) + toint(object)) + this.master_key) % 100000000;
if (length(args) > 2)
salt = args[3];
key = crypt(tostr(hash), salt);
else
"Make it only alphanumeric salt, to get through a URL";
salt = this.alpha[random(length(this.alpha))] + this.alpha[random(length(this.alpha))];
key = crypt(tostr(hash), salt);
endif
"Clean out the non-alpha to make key work in a URL";
for i in [1..length(key)]
if (j = index(this.nonalpha, key[i], 1))
key[i] = this.alpha[j];
endif
endfor
return key;
.
#97:3
if (caller_perms().wizard)
this.guests = {};
pass(@args);
endif
.
#99:0
return length(index(a = args[1], "[") ? this:delete(a) | a);
.
#99:1
":[r]index (STR string, STR character, NUM case_matters)";
"like index() and rindex() but ignores ANSI codes";
return (verb == "index") ? index(this:delete(args[1]), @listdelete(args, 1)) | rindex(this:delete(args[1]), @listdelete(args, 1));
.
#99:2
":contains_codes(STR string) => True if <string> contains any ANSI codes";
return !(!match(args[1], this.all_regexp));
.
#99:3
":delete (STR string) => STR <string> with ANSI codes stripped out";
line = args[1];
if (this.active)
while (index = match(line, this.notify_regexp))
line[index[1]..index[2]] = "";
endwhile
line = strsub(line, "[null]", "");
endif
return line;
.
#99:4
if (!this:trusts(caller_perms()))
return E_PERM;
endif
codes = this.extra_codes;
"...we really don't need group regexps anymore, but I'm going to keep them around for a while just in case...";
for x in (this.groups)
this.(tostr("group_", x, "_regexp")) = tostr("%[%(", $string_utils:from_list(g = this.("group_" + x), "%|"), "%)%]");
codes = {@codes, @g};
endfor
this.all = codes;
this.all_regexp = tostr("%[%(b:%)?%(", $string_utils:from_list(codes, "%|"), "%|", this.xterm_256_regexp, "%|", this.truecolor_regexp, "%)%]");
this.terminate_regexp = tostr("%[%(b:%)?%(", $string_utils:from_list($set_utils:difference(codes, {@this.default_codes, @this.group_extra}), "%|"), "%|", this.xterm_256_regexp, "%|", this.truecolor_regexp, "%)%]");
this.notify_regexp = tostr("%[%(b:%)?%(", $string_utils:from_list(setremove(codes, "null"), "%|"), "%|", this.xterm_256_regexp, "%|", this.truecolor_regexp, "%)%]");
colors = {};
ccs = {};
for x in (this.group_colors)
if (!((a = this:get_code(x, "ESC")) in ccs))
colors = setadd(colors, x);
ccs = setadd(ccs, a);
endif
endfor
this.random_colors = colors;
this.replace_code_pointers = {};
index = 0;
leaves = $object_utils:leaves_suspended($ansi_pc);
data = {};
ll = length(leaves);
"...this will probably have to suspend on most large MOOs but you'll have to rewrite it so it can..";
while (index <= ll)
index = index + 1;
if (!is_player(leaves[index]))
elseif (typeof(x = this:update_player_codes(leaves[index])) != LIST)
elseif (!(i = $list_utils:iassoc(x, data, 2)))
data = listappend(data, {1, x});
elseif ((((data[i][1] + 1) * length(x)) / ll) >= 6)
"Must be at least 25% of people for 25 element long lists...";
"                 50%               12...";
"                 12%               50... etc";
this.replace_code_pointers = listappend(this.replace_code_pointers, x);
index = 0;
data = {};
else
data[i][1] = data[i][1] + 1;
endif
endwhile
.
#99:5
if (caller != this)
return E_PERM;
endif
{code, escape_char, ?truecolor_match = 0, ?xterm_256_match = 0} = args;
if (truecolor_match)
ret = tostr(escape_char || this.escape, "[", (code[1] == "b") ? "48" | "38");
ret = substitute(tostr(ret, ";2;%4;%5;%6m"), truecolor_match);
return ret;
elseif (xterm_256_match)
ret = tostr(escape_char || this.escape, "[", (code[1] == "b") ? "48" | "38");
ret = tostr(ret, ";5;", code[(code[1] == "b") ? 4 | 2..$], "m");
return ret;
else
return strsub(strsub(this.("code_" + code), "e", escape_char || this.escape, 1), "b", this.beep);
endif
.
#99:6
":cutoff[_suspended] (STR string, NUM start, NUM end) => STR";
"Acts like: string[start..end] but ignores ANSI codes.";
args = {@args, 0}[1..4];
if (typeof(info = this:cutoff_locs(@args, verb == "cutoff_suspended")) == LIST)
return args[1][info[1]..info[2]];
else
return info;
endif
.
#99:7
":add_group (STR group)";
"Adds <group> to the groups and makes a property for it.";
if (!this:trusts(caller_perms()))
return E_PERM;
elseif (!((args && args[1]) && (typeof(args[1]) == STR)))
return E_INVARG;
elseif (args[1] in this.groups)
return 0;
else
this.groups = setadd(this.groups, args[1]);
arg1 = {this, "group_" + args[1], {}, {$code_utils:verb_perms(), "r"}};
arg2 = {this, tostr("group_", args[1], "_regexp"), "", arg1[4]};
if ($object_utils:has_callable_verb(#0, "add_property"))
$add_property(@arg1);
$add_property(@arg2);
else
add_property(@arg1);
add_property(@arg2);
endif
$options["ansi"]:add_name(args[1]);
return 1;
endif
.
#99:8
":add_code (STR code, NUM/STR sequence, STR group)";
"Adds a new code, <code> and adds it to group <group>.";
"If <sequence> is a string, it is used as the ANSI sequence, otherwise";
"it uses 'e[<sequence>m'.  'e' is replaced with the escape character, and";
"'b' is replaced with the beep character in <sequence>";
if (!this:trusts(caller_perms()))
return E_PERM;
elseif (length(args) < 3)
return E_ARGS;
elseif (!(((args[1] && (typeof(args[1]) == STR)) && (!$object_utils:has_property(this, cn = tostr("code_", args[1])))) && ((group = args[3]) in {@this.groups, E_NONE})))
return E_INVARG;
else
code = args[2];
if (typeof(code) == NUM)
code = tostr("e[", n, "m");
endif
arg = {this, cn, code, {$code_utils:verb_perms(), "r"}};
if ($object_utils:has_verb(#0, "add_property"))
$add_property(@arg);
else
add_property(@arg);
endif
if (args[3] == E_NONE)
this.extra_codes = setadd(this.extra_codes, args[1]);
else
this.("group_" + args[3]) = setadd(this.("group_" + args[3]), args[1]);
endif
this:update_all();
return 1;
endif
.
#99:9
":show_who_listing(players[,more_players])";
" prints a listing of the indicated players.";
" For players in the first list, idle/connected times are shown if the player is logged in, otherwise the last_disconnect_time is shown.  For players in the second list, last_disconnect_time is shown, no matter whether the player is logged in.";
idles = itimes = offs = otimes = listing = {};
for p in (args[2])
if (!valid(p))
listing = {@listing, tostr(p, " <invalid>")};
elseif (typeof(t = p.last_disconnect_time) == NUM)
(p in offs) || ((offs = {@offs, p}) && (otimes = {@otimes, {-t, -t, p}}));
elseif (is_player(p))
listing = {@listing, tostr(p.name, " (", p, ") ", (t == E_PROPNF) ? "is not a $player." | "has a garbled .last_disconnect_time.")};
else
listing = {@listing, tostr(p.name, " (", p, ") is not a player.")};
endif
endfor
for p in (args[1])
if (p in offs)
elseif (!valid(p))
listing = {@listing, tostr(p, " <invalid>")};
elseif ((typeof(i = idle_seconds(p)) != ERR) && (p in connected_players()))
(p in idles) || ((idles = {@idles, p}) && (itimes = {@itimes, {i, connected_seconds(p), p}}));
elseif (typeof(t = p.last_disconnect_time) == NUM)
(offs = {@offs, p}) && (otimes = {@otimes, {-t, -t, p}});
elseif (is_player(p))
listing = {@listing, tostr(p.name, " (", p, ") not logged in.", (t == E_PROPNF) ? "  Not a $player." | "  Garbled .last_disconnect_time.")};
else
listing = {@listing, tostr(p.name, " (", p, ") is not a player.")};
endif
endfor
if (!(idles || offs))
return 0;
endif
idles = $list_utils:sort_alist(itimes);
offs = $list_utils:sort_alist(otimes);
headers = {"Player name", @idles ? {"Connected", "Idle time"} | {"Last disconnect time", ""}, "Location"};
total_width = caller:linelen() || 79;
max_name = total_width / 4;
name_width = length(headers[1]);
names = locations = {};
for lst in ({@idles, @offs})
((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);
p = lst[3];
"p.name and this:ansi_title(p) should be the same length, saves a call to this:length";
namestr = tostr(this:cutoff(this:ansi_title(p), 1, min(max_name, z = length(p.name)), 1), " (", p, ")");
name_width = max((z + 3) + length(tostr(p)), name_width);
names = {@names, namestr};
(typeof(wlm = p.location:who_location_msg(p)) == STR) || (wlm = valid(p.location) ? p.location.name | tostr("** Nowhere ** (", p.location, ")"));
locations = {@locations, wlm};
endfor
time_width = offs ? 15 | 13;
before = {0, w1 = 3 + name_width, w2 = w1 + time_width, w2 + time_width};
su = $string_utils;
tell1 = headers[1];
tell2 = su:space(tell1, "-");
for j in [2..4]
tell1 = su:left(tell1, before[j]) + headers[j];
tell2 = su:left(tell2, before[j]) + su:space(headers[j], "-");
endfor
listing = {@listing, tell1[1..min(length(tell1), total_width)]};
listing = {@listing, tell2[1..min(length(tell2), total_width)]};
"...";
"...print lines...";
"...";
active = 0;
for i in [1..total = (ilen = length(idles)) + length(offs)]
if (i <= ilen)
lst = idles[i];
if (lst[1] < (5 * 60))
active = active + 1;
endif
l = {names[i], su:from_seconds(lst[2]), su:from_seconds(lst[1]), locations[i]};
else
lct = offs[i - ilen][3].last_connect_time;
ldt = offs[i - ilen][3].last_disconnect_time;
ctime = caller:ctime(ldt) || ctime(ldt);
l = {names[i], (lct <= time()) ? ctime | "Never", "", locations[i]};
if ((i == (ilen + 1)) && idles)
listing = {@listing, su:space(before[2]) + "------- Disconnected -------"};
endif
endif
tell1 = l[1];
for j in [2..4]
tell1 = su:left(tell1, before[j]) + l[j];
endfor
listing = {@listing, this:cutoff(tell1, 1, min(this:length(tell1), total_width))};
if ($command_utils:running_out_of_time())
if ($login:is_lagging())
"Check lag two ways---global lag, but we might still fail due to individual lag of the queue this runs in, so check again later.";
listing = {@listing, tostr("Plus ", total - i, " other players (", total, " total; out of time and lag is high).")};
return;
endif
now = time();
suspend(0);
if ((time() - now) > 10)
listing = {@listing, tostr("Plus ", total - i, " other players (", total, " total; out of time and lag is high).")};
return;
endif
endif
endfor
"...";
"...epilogue...";
listing = {@listing, ""};
if (total == 1)
active_str = ", who has" + ((active == 1) ? "" | " not");
else
if (active == total)
active_str = (active == 2) ? "s, both" | "s, all";
elseif (active == 0)
active_str = "s, none";
else
active_str = tostr("s, ", active);
endif
active_str = tostr(active_str, " of whom ha", (active == 1) ? "s" | "ve");
endif
listing = {@listing, tostr("Total: ", total, " player", active_str, " been active recently.")};
vrb = ((caller == $login) || $perm_utils:controls($code_utils:verb_perms(), caller)) ? "notify" | "tell";
for line in (listing)
caller:(vrb)(line);
((seconds_left() < 2) || (ticks_left() < 4000)) && suspend(0);
endfor
return total;
.
#99:10
":notify (OBJ player, STR line[, extra parameters for notify])";
set_task_perms(caller_perms());
{plr, line, @extra} = args;
"...use property_info() instead of $object_utils:isa to save ticks...";
if (((((index(line, "[") && valid(plr)) && property_info(plr, "ansi_options")) && this.active) && (!(task_id() in this.noansi_queue))) && (!plr:ansi_option("ignore")))
codes = (typeof(z = plr.replace_codes) == NUM) ? this.replace_code_pointers[z] | z;
esc = plr:ansi_option("escape");
"... save more ticks here by using 'in' instead of 'ansi_option'...";
truecolor_enabled = "truecolor" in plr.ansi_options;
xterm_256 = "256" in plr.ansi_options;
backgrounds = "backgrounds" in plr.ansi_options;
while (m = match(line, this.notify_regexp))
z = line[m[1] + 1..m[2] - 1];
if (z in codes)
code = this:get_code(z, esc);
elseif ((!backgrounds) && (z[1..2] == "b:"))
code = "";
elseif ((z[1..2] == "b:") && (z[3..$] in codes))
code = this:get_code(z, esc);
elseif (z == "random")
code = this:get_code(this.random_colors[random(length(this.random_colors))], esc);
elseif ((z == ":random") && xterm_256)
code = this:get_code(tostr(":", random(255)), esc, 0, 1);
elseif (xterm_256 && ((z[1] == ":") || (z[1..3] == "b::")))
code = this:get_code(z, esc, 0, 1);
elseif (truecolor_enabled && index(z, ":"))
code = this:get_code(z, esc, m);
else
code = "";
endif
line[m[1]..m[2]] = code;
endwhile
line = strsub(line, "[null]", "");
endif
return notify(plr, line, @extra);
.
#99:11
":add_noansi()";
"Called by tasks to tell players to ignore any ANSI codes from them.";
"Can be undone with a call to :remove_noansi";
if ((length(this.noansi_queue) > 30) && (!$code_utils:task_valid(this.noansi_task)))
fork tid (0)
this:cleanup_noansi();
endfork
this.noansi_task = tid;
endif
this.noansi_queue = setadd(this.noansi_queue, task_id());
.
#99:12
":remove_noansi()";
"Start translating the ANSI codes from the current task again";
this.noansi_queue = setremove(this.noansi_queue, task_id());
.
#99:13
return;
.
#99:14
":self_diagnostic ([NUM fix[, OBJ plyr]]) => NUM errors fixed";
"Reports all errors found to <plyr> or the current player.";
"Fixes any errors it can if <fix> is specified and true.";
"<errors fixed> is the errors that could have been fixed if <fix> is false.";
if (!this:trusts(caller_perms()))
return E_PERM;
else
count = 0;
for x in (this.diagnostic_tests)
player:tell("Running test \"", x, "\"...");
count = count + (!(!this:("test_" + x)(@args)));
endfor
return count;
endif
.
#99:15
":trusts (OBJ player) => true of <player> is trusted by the ANSI system.";
return (args[1].wizard || (args[1] == this.owner)) || (args[1] in this.trusted);
.
#99:16
":cutoff_locs (STR string,NUM start,NUM end[,NUM extra][, NUM suspendok])";
"                                                       => {nstart, nend}";
"Takes <start> and <end>, fixes them to compensate for the ANSI codes, and";
"returns them.  If <extra> is provided and true, <nend> will include the";
"codes after the ending letter.";
start = args[2];
end = args[3];
if (typeof(string = args[1]) != STR)
return E_INVARG;
elseif (!(index(string, "[") && this.active))
return {start, (end == "$") ? length(string) | end};
elseif (start > end)
return args[2..3];
endif
i = begin = 0;
x = 1;
extra = {@args, 0}[4];
reg = this.all_regexp;
l = length(string);
suspendok = {@args, 0}[5];
while (x <= l)
((suspendok && ((ticks_left() < 1000) || (seconds_left() < 2))) && player:tell("suspending...")) && suspend(0);
if (m = match(string, reg))
i = i + (m[1] - 1);
if ((!begin) && ((i + 1) >= start))
begin = (((x + m[1]) - i) + start) - 2;
if (end == "$")
return {begin, l};
endif
endif
if (begin && ((i - extra) >= end))
return {begin, (((x + m[1]) - i) + end) - 2};
endif
x = x + m[2];
string[1..m[2]] = "";
else
return {begin || (((x - i) + start) - 1), (end == "$") ? l | (((x - i) + end) - 1)};
endif
endwhile
return ((end == i) && begin) ? {begin, l} | E_RANGE;
.
#99:17
while (this.noansi_queue && (!$command_utils:running_out_of_time()))
x = this.noansi_queue[1];
if (!$code_utils:task_valid(x))
this.noansi_queue = setremove(this.noansi_queue, x);
endif
endwhile
.
#99:18
if (caller != this)
return E_PERM;
else
new = $recycler:_create($ansi_pc);
if (typeof(new) != OBJ)
return player:tell("Unable to create Benchmark test player: ", new);
endif
new:set_name("Benchmark_test_player");
suspend(0);
ticks = ticks_left();
seconds = seconds_left();
for x in [1..3]
$ansi_utils:notify(new, "[blue]B[bold]e[unbold]n[bold]c[unbold]h[bold]m[unbold]a[bold]r[unbold]k [red]T[bold]e[unbold]s[bold]t [random].[random].[random].[random].[random].");
endfor
for x in [1..3]
$ansi_utils:notify(new, "[123:123:123]B[1:1:1]e[0:100:0]n[100:0:100]c[100:100:100]h[100:0:0]m[0:0:100]a[255:0:255]r[255:0:0]k [0:255:0]T[0:0:255]e[255:255:0]s[123:45:6]t.");
endfor
ticks = ticks - ticks_left();
seconds = seconds - seconds_left();
new:set_ansi_option("colors", 1);
new:set_ansi_option("escape", "~");
new:set_ansi_option("misc", 1);
ticks = ticks + ticks_left();
seconds = seconds + seconds_left();
for x in [1..3]
$ansi_utils:notify(new, "[blue]B[bold]e[unbold]n[bold]c[unbold]h[bold]m[unbold]a[bold]r[unbold]k [red]T[bold]e[unbold]s[bold]t [random].[random].[random].[random].[random].");
endfor
for x in [1..3]
$ansi_utils:notify(new, "[123:123:123]B[1:1:1]e[0:100:0]n[100:0:100]c[100:100:100]h[100:0:0]m[0:0:100]a[255:0:255]r[255:0:0]k [0:255:0]T[0:0:255]e[255:255:0]s[123:45:6]t.");
endfor
for x in [1..3]
$ansi_utils:notify(new, "Testing...");
endfor
this:add_noansi();
for x in [1..3]
$ansi_utils:notify(new, "[blue]B[bold]e[unbold]n[bold]c[unbold]h[bold]m[unbold]a[bold]r[unbold]k [red]T[bold]e[unbold]s[bold]t [random].[random].[random].[random].[random].");
endfor
for x in [1..3]
$ansi_utils:notify(new, "[123:123:123]B[1:1:1]e[0:100:0]n[100:0:100]c[100:100:100]h[100:0:0]m[0:0:100]a[255:0:255]r[255:0:0]k [0:255:0]T[0:0:255]e[255:255:0]s[123:45:6]t.");
endfor
this:remove_noansi();
ticks = ticks - ticks_left();
seconds = seconds - seconds_left();
$recycler:_recycle(new);
player:tell("21 notifies: ", ticks, " tick", (ticks == 1) ? "" | "s", ", ", seconds, " second", (seconds == 1) ? "" | "s", ".");
endif
.
#99:19
":cutoff_assign (STR string, NUM start, NUM end, STR replacement[, NUM extra])";
"                                => STR";
"Example:";
"  string[2..3] = \"test\";";
"Is the same as:";
"  string = $ansi_utils:cutoff_assign(string, 2, 3, \"test\");";
"Except that it ignores the ANSI codes in <string> when finding <start> and";
"<end>.  If <extra> is specified and true, any codes after <end> but before";
"the next character will also be overwritten.";
if (typeof(a = this:cutoff_locs(@listdelete(args, 4))) == LIST)
args[1][a[1]..a[2]] = args[4];
return args[1];
else
return a;
endif
.
#99:20
":setadd (LIST l, value) => LIST";
"Does the same thing as the built-in setadd(), but if <value> is a string,";
"it won't be added to <l> if <value> with it's ANSI codes stripped out equals";
"any of <l>'s elements with their ANSI codes stripped out.";
l = args[1];
if ((typeof(value = args[2]) == STR) && this:contains_codes(value))
nvalue = this:delete(value);
for x in (l)
if ((typeof(x) == STR) && (this:delete(x) == nvalue))
return l;
endif
endfor
endif
return setadd(l, value);
.
#99:21
":setremove (LIST l, value) => LIST";
"Does the same thing as the built-in setremove(), but if <value> is a";
"string, it will remove any string in <l> that, when it's ANSI codes are";
"stripped out, is equal to <value> with it's ANSI codes stripped out.";
l = args[1];
if ((typeof(value = args[2]) != STR) || (!this:contains_codes(value)))
return setremove(l, value);
endif
nvalue = this:delete(value);
for x in [-length(l)..-1]
x = -x;
if ((typeof(l[x]) == STR) && (this:delete(l[x]) == nvalue))
l = listdelete(l, x);
endif
endfor
return l;
.
#99:22
mess = {};
mess = {@mess, tostr("ANSI Version ", this.version, ":")};
a = 0;
for x in (this.groups)
a = a + length(this.("group_" + x));
endfor
mess = {@mess, tostr("It is ", this.active ? "currently" | "not", " active.  There are ", $string_utils:english_number(a), " codes defined in ", $string_utils:english_number(length(this.groups)), " groups.  There ", (length(this.noansi_queue) == 1) ? "is" | "are", " ", $string_utils:english_number(length(this.noansi_queue)), " tasks in the ignore ANSI task queue, and the cleanup task is ", $code_utils:task_valid(this.noansi_queue) ? "currently" | "not", " running.")};
return mess;
.
#99:23
":terminate_normal (STR string) => STR <string> with a [[null]normal] code";
"tacked onto the end if there wasn't one";
if (!index(string = args[1], "["))
return string;
endif
m = rmatch(string, this.terminate_regexp);
while ((string && m) && (m[2] == length(string)))
string = string[1..m[1] - 1];
m = rmatch(string, this.terminate_regexp);
endwhile
return string && (string + ((m && (string[m[1]..m[2]] != "[normal]")) ? "[normal]" | ""));
.
#99:24
"$ansi_utils:left(string,width[,filler])";
"";
"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> followed by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.";
"";
"The <filler> is optional and defaults to \" \"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.";
return this:terminate_normal(z = ((l = this:length(out = tostr(args[1]))) < (len = abs(args[2]))) ? out + this:space(l - len, ((length(args) >= 3) && args[3]) || " ") | ((args[2] > 0) ? out | this:cutoff(out, 1, len)));
.
#99:25
"$ansi_utils:right(string,width[,filler])";
"";
"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then <string> is cut off at <width>.";
"";
"The <filler> is optional and defaults to \" \"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.";
return this:terminate_normal(((l = this:length(out = tostr(args[1]))) < (len = abs(args[2]))) ? this:space(len - l, ((length(args) >= 3) && args[3]) || " ") + out | ((args[2] > 0) ? out | this:cutoff(out, 1, len)));
.
#99:26
"$ansi_utils:center(string,width[,lfiller[,rfiller]])";
"";
"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded and followed by enough filler to make it that wide.  If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.";
"";
"The <lfiller> is optional and defaults to \" \"; it controls what is used to fill the left part of the resulting string when it is too short.  The <rfiller> is optional and defaults to the value of <lfiller>; it controls what is used to fill the right part of the resulting string when it is too short.  In both cases, the filler is replicated as many times as is necessary to fill the space in question.";
return this:terminate_normal(((l = this:length(out = tostr(args[1]))) < (len = abs(args[2]))) ? tostr(this:space((len - l) / 2, lfill = ((length(args) >= 3) && args[3]) || " "), out, this:space(((len - l) + 1) / -2, (length(args) >= 4) ? args[4] | lfill)) | ((args[2] > 0) ? out | this:cutoff(out, 1, len)));
.
#99:27
"columnize (items, n [, width]) - Turn a one-column list of items into an n-column list. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize ({1, 2, 3, 4, 5, 6, 7}, 3));'.";
items = args[1];
n = args[2];
width = {@args, 79}[3];
height = ((length(items) + n) - 1) / n;
items = {@items, @$list_utils:make((height * n) - length(items), "")};
colwidths = {};
for col in [1..n - 1]
colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));
endfor
result = {};
for row in [1..height]
line = tostr(items[row]);
for col in [1..n - 1]
line = tostr(this:terminate_normal(this:left(line, colwidths[col])), " ", items[row + (col * height)]);
endfor
result = listappend(result, this:terminate_normal(this:cutoff(line, 1, min(this:length(line), width))));
endfor
return result;
.
#99:28
"space(len,fill) returns a string of length abs(len) consisting of copies of fill.  If len is negative, fill is anchored on the right instead of the left.";
n = args[1];
(typeof(n) == STR) && (n = this:length(n));
if (" " != (fill = {@args, " "}[2]))
fill = fill + fill;
fill = fill + fill;
fill = fill + fill;
elseif ((n = abs(n)) < 70)
return "                                                                      "[1..n];
else
fill = "                                                                      ";
endif
m = (n - 1) / this:length(fill);
while (m)
fill = fill + fill;
m = m / 2;
endwhile
return (n > 0) ? this:cutoff(fill, 1, n) | this:cutoff(fill, ((f = this:length(fill)) + 1) + n, f);
.
#99:29
":ansi_title (OBJ player[, STR name]) => STR <player>'s title";
"If <name> is specified, it will be used instead of <player>.name";
name = {@args, args[1].name}[2];
for x in (args[1].ansi_title)
if (typeof(x[2]) == LIST)
nn = x[2][random(length(x[2]))];
else
nn = x[2];
endif
nn && (name = strsub(name, x[1], nn));
endfor
return name;
.
#99:30
gray = 0;
x = 1;
string = args[1];
l = length(string);
while ((x <= l) && (m = match(string[x..l], this.all_regexp)))
code = string[x + m[1]..(x + m[2]) - 2];
if (code in {"gray", "grey"})
gray = 1;
elseif (code in this.group_colors)
gray = 0;
elseif (gray && (code == "unbold"))
string[x + m[2]..(x + m[2]) - 1] = "[white]";
x = x + 7;
endif
x = x + m[2];
endwhile
return string;
.
#99:31
":quote_ansi (STR string) => STR new_string";
"Puts a [[null]null] code in the middle of all of the other codes in <string>";
"so they won't be replaced.";
return strsub(args[1], "[", "[[null]");
"...should probably only fix real codes, but this works for now...";
.
#99:32
":update_player_codes (OBJ player)";
"Updates <player>'s .replace_codes property";
if (!this:trusts(caller_perms()))
return E_PERM;
elseif ($object_utils:isa(plr = args[1], $ansi_pc))
codes = {};
for x in (this.groups)
if (plr:ansi_option(x))
codes = {@codes, @this.("group_" + x)};
(x == "extra") || (codes = setadd(codes, "normal"));
endif
endfor
return plr.replace_codes = (codes in this.replace_code_pointers) || codes;
endif
.
#99:33
"fill(string,width[,prefix])";
"tries to cut <string> into substrings of length < <width> along word boundaries.  Prefix, if supplied, will be prefixed to the 2nd..last substrings.";
if (length(args) < 2)
width = 2 + player:linelen();
prefix = "";
else
width = args[2] + 1;
prefix = {@args, ""}[3];
endif
if (width < (3 + length(prefix)))
return E_INVARG;
endif
string = ("$" + args[1]) + " $";
len = this:length(string);
if (len <= width)
last = len - 1;
next = len;
else
last = this:rindex(this:cutoff(string, 1, width), " ");
if (last < ((width + 1) / 2))
last = width + this:index(this:cutoff(string, width + 1, "$", 1), " ");
endif
next = last;
while (string[next = next + 1] == " ")
endwhile
endif
while (string[last = last - 1] == " ")
endwhile
ret = {this:cutoff(string, 2, last)};
width = width - length(prefix);
minlast = (width + 1) / 2;
while (next < len)
string = this:cutoff_assign(string, 1, next - 1, "$");
"string = \"$\" + string[next..len];";
len = (len - next) + 2;
if (len <= width)
last = len - 1;
next = len;
else
last = this:rindex(this:cutoff(string, 1, width), " ");
if (last < minlast)
last = width + this:index(this:cutoff(string, width + 1, "$", 1), " ");
endif
next = last;
while (string[next = next + 1] == " ")
endwhile
endif
while (string[last = last - 1] == " ")
endwhile
if (last > 1)
ret = {@ret, prefix + this:cutoff(string, 2, last)};
endif
endwhile
return ret;
.
#99:34
"Usage:  @ansi-setup <this>";
"Used to fix various core utilities to work with ANSI. This verb can only be used by a wizard, and needs wizperms to run.";
"Ugh, this verb is getting out of control, this stuff should all be moved to diagnostic tests.";
if (!player.wizard)
player:tell("This verb was intended to fix up the rest of a MOO's core so it can function properly with the ANSI PC. If something's wrong, ask a wizard to set this up for you.");
elseif (!$code_utils:verb_perms().wizard)
player:tell("This verb needs to be wizpermed before it can work.");
elseif (!$command_utils:yes_or_no("This will change various verbs in the core so they can be used with the ANSI PC, overwriting the previous verbs. Are you sure you want to do this?"))
player:notify("Well, okay then.");
else
set_task_perms(valid(cp = caller_perms()) ? cp | player);
spiffy = 1;
"----== Corify Objects ==----";
for x in ({"help", "pc", "utils", "options"})
prop = "ansi_" + x;
if (!$object_utils:has_property($sysobj, prop))
add_property($sysobj, prop, #-1, {player, "r"});
player:notify(tostr("Creating a $", prop, " property."));
endif
if (valid($sysobj.(prop)))
elseif (x == "utils")
player:notify(tostr("Setting $", prop, " to ", $string_utils:nn(this), "."));
$sysobj.(prop) = this;
else
objects = {};
for o in ({@player.owned_objects || {}, @player.public_identity.owned_objects || {}, @player.contents || {}, @player.location.contents || {}})
if (index(o.name, "ANSI") && index(o.name, strsub(x, "s", "")))
objects = setadd(objects, o);
endif
endfor
if (!objects)
return player:notify(tostr("Unable to find $", prop, ", please port this object and set #0.", prop, " to it's object number. If you created a new player to own ANSI objects, you might want to temporarily set your .public_identity property to that player and rerun this verb. Remember to reset the property when you're done."));
elseif (length(objects) == 1)
player:notify(tostr("Setting $", prop, " to ", $string_utils:nn(objects[1]), "."));
$sysobj.(prop) = objects[1];
else
return player:notify(tostr("Found ", length(objects), " objects that could be $", prop, ", please set #0.", prop, " to the object number of the correct one:  ", $string_utils:nn_list(objects)));
endif
endif
endfor
"----== Wizperm everything that should be ==----";
for x in (this.need_wizperms)
if (!(info = verb_info(y = $sysobj.(x[1]), x[2]))[1].wizard)
player:notify(tostr("Wizperming $", x[1], ":", x[2], "..."));
set_verb_info(y, x[2], listset(info, player, 1));
endif
endfor
if (!($ansi_help in ((typeof(ah = $ansi_pc.help) == LIST) ? ah | {ah})))
player:notify("Setting $ansi_pc.help...");
$ansi_pc.help = $ansi_help;
endif
"----== Various core hacks ==----";
su = $string_utils;
if (!$object_utils:has_callable_verb(su, "redirect_ansi"))
player:notify("Adding $string_utils:redirect_ansi...");
add_verb(su, {$hacker, "rx", "redirect_ansi"}, {"this", "none", "this"});
set_verb_code(su, "redirect_ansi", this.redirect_su_code);
endif
for x in (this.redirect_su_names)
if ((info = verb_info(su, x)) && (!index(info[3], "redirect_ansi")))
nn = "";
for y in ($string_utils:explode(info[3], " "))
nn = tostr(nn, " ", y, "(noansi)");
endfor
set_verb_info(su, x, listset(info, $string_utils:triml(nn), 3));
player:notify(tostr("Renaming $string_utils:\"", info[3], "\" to \"", nn, "\"..."));
endif
endfor
redirect = $string_utils:from_list({"redirect_ansi", @this.redirect_su_names}, " ");
if ((info = verb_info(su, "redirect_ansi"))[3] != redirect)
player:notify(tostr("Renaming $string_utils:redirect_ansi to \"", redirect, "\"."));
set_verb_info(su, "redirect_ansi", listset(info, redirect, 3));
endif
$command_utils:suspend_if_needed(0);
((!((length(vc = verb_code($login, "notify")) == 2) && index(vc[2], "$ansi_utils:delete"))) && $command_utils:yes_or_no("Update $login:notify?")) ? set_verb_code($login, "notify", {"(caller!=$ansi_utils)&&set_task_perms(caller_perms());notify(player,$ansi_utils:delete(args[1]));"}) || player:notify("$login:notify changed.") | ((spiffy = 0) || player:notify("$login:notify left alone."));
thatline = "line[1..min(width, length(line))]";
newline = "$ansi_utils:cutoff(line,1,min(width,$ansi_utils:length(line)))";
for x in ({"mail_agent", "big_mail_recipient"})
vc = $string_utils:print(verb_code(y = $sysobj.(x), vn = "display_seq_headers"));
player:notify(tostr("$", x, ":", vn, " ", ((index(vc, thatline) && $command_utils:yes_or_no(tostr("Replace \"", thatline, "\" in $", x, ":", vn, " with \"", newline, "\"?"))) && (set_verb_code(y, vn, $string_utils:to_value(strsub(vc, thatline, newline))[2]) == {})) ? "changed." | ((spiffy = 0) || "left alone.")));
endfor
code = {};
for x in (verb_code($login, "@who"))
code = {@code, strsub(x, "$code_utils:show_who_listing", "$ansi_utils:show_who_listing")};
endfor
if (code != verb_code($login, "@who"))
player:notify("Setting $login:@who...");
set_verb_code($login, "@who", code);
endif
$command_utils:suspend_if_needed(0);
code = {};
for x in (verb_code($guest, "do_reset", 0, 0))
if ((m = match(x, "^for x in (%(%{.+%}%))$")) && (info = $string_utils:to_value(substitute("%1", m)))[1])
x = tostr("for x in (", $string_utils:print($set_utils:union(info[2], $ansi_utils.reset_guest_props)), ")");
endif
code = {@code, x};
$command_utils:suspend_if_needed(0);
endfor
if (code != verb_code($guest, "do_reset", 0, 0))
player:notify("Setting $guest:do_reset...");
set_verb_code($guest, "do_reset", code);
endif
code = {};
for x in (verb_code($prog, "@list", 0, 0))
if (code == 0)
elseif (index(x, "$ansi_utils:add_noansi("))
code = 0;
elseif (index(x, "player:notify(tostr(what, \":\", fullname, \"") == 1)
code = {@code, "$ansi_utils:add_noansi();", x};
else
code = {@code, x};
endif
$command_utils:suspend_if_needed(0);
endfor
if (code && (code != verb_code($prog, "@list", 0, 0)))
player:notify("Setting $prog:@list...");
set_verb_code($prog, "@list", code);
endif
code = {};
a = {0, 0};
for x in (verb_code($generic_editor, "list_line"))
a[1] = a[1] || index(x, "$ansi_utils:add_noansi(");
a[2] = a[2] || index(x, "$ansi_utils:remove_noansi(");
code = {@code, x};
$command_utils:suspend_if_needed(0);
endfor
a[1] || (code = {"$ansi_utils:add_noansi();", @code});
a[2] || (code = {@code, "$ansi_utils:remove_noansi();"});
if (code != verb_code($generic_editor, "list_line"))
player:notify("Setting $generic_editor:list_line...");
set_verb_code($generic_editor, "list_line", code);
endif
$command_utils:suspend_if_needed(0);
if (!$object_utils:defines_verb($player_db, "insert"))
player:notify("Adding $player_db:insert...");
add_verb($player_db, {player, "rxd", "insert"}, {"this", "none", "this"});
set_verb_code($player_db, "insert", this.plr_db_insert);
elseif (verb_code($player_db, "insert") != this.plr_db_insert)
player:notify("$player_db:insert already exists, you will have to edit it manually for the ANSI, see $ansi_utils.plr_db_insert for sample code.");
endif
if (verb_code($generic_editor, "fill_string") != this.ge_fill_string)
a = "";
while ($object_utils:has_verb($generic_editor, vname = tostr("fill_string(noansi", a, ")")))
a = toint(a) + 1;
endwhile
set_verb_info($generic_editor, "fill_string", listset(verb_info($generic_editor, "fill_string"), vname, 3));
add_verb($generic_editor, {player, "rx", "fill_string"}, {"this", "none", "this"}) || player:notify("Adding new $generic_editor:fill_string...");
set_verb_code($generic_editor, "fill_string", this.ge_fill_string);
endif
"...ugh, I want to put $prog:@dump in here but the one I put on NestMOO is too big to search...";
"----== Set the non-printable characters ==----";
$command_utils:suspend_if_needed(0);
for x in ({{"escape", 27, "033"}, {"beep", 7, "007"}})
chr = x[1];
code = x[2];
octal = x[3];
if ((typeof(this.(chr)) != STR) || (length(this.(chr)) != 1))
if (eval(";return chr(64);")[1])
player:notify(tostr("Setting $ansi_utils.", chr, " with chr()..."));
eval(tostr(";$ansi_utils.(\"", chr, "\")=chr(", code, ");"));
elseif ((eval = eval(";return filelist(\"\", \"\");"))[1] || (eval = eval(";return file_list(\"\");"))[1])
files = (typeof(eval[2][1]) == LIST) ? eval[2][1] | eval[2];
if ((chr + ".chr") in files)
player:notify(tostr("Setting $ansi_utils.", chr, " from file ", chr, ".chr..."));
if (typeof(eval[2][1]) == LIST)
"Setup for FUP";
eval(tostr(";$ansi_utils.(\"", chr, "\")=fileread(\"\", \"", chr, ".chr\")[1];"));
else
"Setup for FIO";
handle = file_open(tostr("/", chr, ".chr"), "r-tn");
$ansi_utils.(chr) = file_readline(handle);
file_close(handle);
endif
else
player:notify(tostr("File builtin detected, please create a file named \"", chr, ".chr\" in the files directory and put an ASCII character ", code, " in it.  This can be done on most systems with the command:  echo -e '\\", octal, "' > ", chr, ".chr  from the files directory."));
spiffy = 0;
endif
else
z = this.(chr) = tostr("<----- ", $string_utils:uppercase(chr), " ----->");
player:notify(tostr("I can't find any way to set $ansi_utils.", chr, ", please either install the FUP, FileIO, or chr() server patches and rerun this verb, or shut down the MOO, load the DB into an editor, and replace \"", z, "\" with an ASCII character ", code, "."));
spiffy = 0;
endif
endif
endfor
if (this.active)
player:notify("@ansi-setup finished.");
elseif (!spiffy)
player:notify("@ansi-setup can not verify that everything has been set up correctly, you will probably have to rerun this verb.  If you're sure everything is correct, you can type:  ;;$ansi_utils.active=1;  to activate it.");
elseif ($command_utils:yes_or_no("Everything seems to be set up correctly, activate the ANSI system?"))
this.active = 1;
"...raw notify() the first message in case it breaks, we're wizpermed anyway...";
notify(player, "The ANSI system is now active, it can be deactivated by typing: ;;$ansi_utils.active = 0;");
player:notify(tostr("Welcome to ANSI version ", this.version, "."));
else
player:notify("Not activating the ANSI system, you can do this manually by typing: ;;$ansi_utils.active = 1;  when you're sure everything's set up correctly.");
endif
endif
.
#99:35
"Attempt to downscale a 24-bit RGB color into an 8-bit 256 color.";
"Disclaimer: Looks terrible.";
{r, g, b} = args;
red = (toint(r) * 8) / 256;
green = (toint(g) * 8) / 256;
blue = (toint(b) * 7) / 256;
ret = ((red << 5) |. (green << 2)) |. blue;
return ret;
.
#99:36
{?raw = 0, ?input = 0, ?foreground_color = 0} = args;
colors = {"Red", "Green", "Blue", "Yellow", "Cyan", "Purple", "Gray", "White"};
backgrounds = {"Red", "Green", "Blue", "Yellow", "Cyan", "Purple", "White"};
menu = codes = {};
for x in (colors)
if (!foreground_color)
menu = {@menu, tostr(this:hr_to_code(code = x), x, "[normal]")};
codes = {@codes, code};
menu = {@menu, tostr(this:hr_to_code(code = "bold|" + x), "Bold ", x, "[normal]")};
codes = {@codes, code};
endif
if (x in backgrounds)
menu = {@menu, tostr(this:hr_to_code(code = "b:" + x), (x == "white") ? "[gray]" | (foreground_color ? this:Hr_to_code(foreground_color) | "[white]"), "Background ", x, "[normal]")};
codes = {@codes, code};
endif
endfor
menu = {@menu, xterm = "Xterm 256 Value"};
if (player:ansi_option("truecolor"))
menu = {@menu, rgb = "24-bit [red]R[normal][green]G[normal][blue]B[normal] Value"};
endif
menu = {@menu, "None"};
sel = $menu_utils:menu(menu, ["hidden_menu" -> input, "input" -> input]);
if (sel in {0, -1})
return 0;
elseif (sel <= length(codes))
retcode = codes[sel];
if (retcode[1..2] == "b:")
retcode = ((foreground_color ? foreground_color | "white") + "|") + retcode;
endif
if (raw)
return $ansi_utils:hr_to_code(retcode);
else
return retcode;
endif
elseif (menu[sel] == "none")
return "";
elseif (menu[sel] == xterm)
player:tell("Please input an Xterm 256 value in between 0-255.");
val = $command_utils:read();
xtermint = $code_utils:toint(val);
if (((xtermint == E_TYPE) || (xtermint > 255)) || (xtermint < 0))
return player:tell("Invalid input. You must enter a number that is in between 0 and 255.");
endif
if (raw)
return tostr("[:", xtermint, "]");
else
return tostr(":", xtermint);
endif
elseif (menu[sel] == rgb)
red = green = blue = 0;
invalidmsg = "Invalid color value.";
while (((!red) || (!green)) || (!blue))
if (!red)
player:tell("Enter a [red]red[normal] value between 0 and 255:");
red = toint($command_utils:read());
if ((red < 0) || (red > 255))
player:tell(invalidmsg);
red = 0;
continue;
endif
endif
if (!green)
player:tell("Enter a [green]green[normal] value between 0 and 255:");
green = toint($command_utils:read());
if ((green < 0) || (green > 255))
player:tell(invalidmsg);
green = 0;
continue;
endif
endif
if (!blue)
player:tell("Enter a [blue]blue[normal] value between 0 and 255:");
blue = toint($command_utils:read());
if ((blue < 0) || (blue > 255))
player:tell(invalidmsg);
blue = 0;
continue;
endif
endif
endwhile
if (raw)
return tostr("[", red, ":", green, ":", blue, "]");
else
return tostr(red, ":", green, ":", blue);
endif
endif
.
#99:37
"$ansi_utils:hr_to_code(colorstr) - Converts a human readable color sequence to a properly formatted escape code.";
{colorstr} = args;
if (colorstr in {0, ""})
return E_INVARG;
endif
if (colorstr[1] == "[")
colorstr = colorstr[2..$ - 1];
endif
if (index(colorstr, "|"))
ret = "";
for x in ($string_utils:explode(colorstr, "|"))
ret = ((ret + "[") + x) + "]";
endfor
else
ret = ("[" + colorstr) + "]";
endif
return ret;
"Last modified 11/01/18 1:38 a.m. by Sinistral (#2)";
.
#100:0
":ansi_option(name) => returns the value of the specified @ansi option";
if ((a = args[1]) == "escape")
return (i = $list_utils:assoc(a, this.ansi_options)) ? i[2] | 0;
else
return !(!(a in this.ansi_options));
endif
.
#100:1
"@ansi-option <option> [is] <value>   sets <option> to <value>";
"@ansi-option <option>=<value>        sets <option> to <value>";
"@ansi-option +<option>     sets <option>   (usually equiv. to <option>=1";
"@ansi-option -<option>     resets <option> (equiv. to <option>=0)";
"@ansi-option !<option>     resets <option> (equiv. to <option>=0)";
"@ansi-option <option>      displays value of <option>";
if (!args)
player:notify_lines({"Current ANSI options:", "", @$options["ansi"]:show(this.ansi_options, $options["ansi"].names)});
return;
elseif (typeof(presult = $options["ansi"]:parse(args)) == STR)
player:notify(presult);
return;
else
if (length(presult) > 1)
if (typeof(sresult = this:set_ansi_option(@presult)) == STR)
player:notify(sresult);
return;
elseif (!sresult)
player:notify("No change.");
return;
endif
endif
player:notify_lines($options["ansi"]:show(this.ansi_options, presult[1]));
endif
.
#100:2
":set_ansi_option(oname,value)";
"Changes the value of the named option.";
"Returns a string error if something goes wrong.";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return tostr(E_PERM);
endif
foo_options = "ansi_options";
"...";
if (typeof(s = $options["ansi"]:set(this.(foo_options), @args)) == STR)
return s;
elseif (s == this.(foo_options))
return 0;
else
this.(foo_options) = s;
$ansi_utils:update_player_codes(this);
return 1;
endif
.
#100:3
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
line = args[1];
if (!valid(au = $ansi_utils))
return pass(@args);
elseif (("normal" in ((typeof(z = this.replace_codes) == NUM) ? au.replace_code_pointers[z] | z)) && (!(task_id() in au.noansi_queue)))
line = au:terminate_normal(line);
endif
if (this.pagelen)
if (!(this in connected_players()))
"...drop it on the floor...";
return 0;
endif
"...need wizard perms if this and this.owner are different, since...";
"...only this can notify() and only this.owner can read .linebuffer...";
if ((player == this) && (this.linetask[2] != task_id()))
"...player has started a new task...";
"....linetask[2] is the taskid of the most recent player task...";
(this.linetask[2] != this.linetask[1]) && (this.linesleft = this.pagelen - 2);
this.linetask[2] = task_id();
endif
"... digest the current line...";
li = this.linelen ? this:linesplit(line, abs(this.linelen)) | {line};
lbuf = {@this.linebuffer, @li};
"... print out what we can...";
if (this.linesleft)
howmany = min(this.linesleft, length(lbuf));
for l in (lbuf[1..howmany])
au:notify(this, l);
"notify(this, l, nocr);";
endfor
this.linesleft = this.linesleft - howmany;
lbuf[1..howmany] = {};
endif
if (lbuf)
"...see if we need to say ***More***";
if (this.linetask[1] != this.linetask[2])
"....linetask[1] is the taskid of the most recent player task";
"...   for which ***More*** was printed...";
this.linetask[1] = this.linetask[2];
fork (0)
notify(this, strsub(this.more_msg, "%n", tostr(length(this.linebuffer))));
endfork
endif
llen = length(lbuf);
if (llen > 500)
"...way too much saved text, flush some of it...";
lbuf[1..llen - 100] = {"*** buffer overflow, lines flushed ***"};
endif
endif
this.linebuffer = lbuf;
else
if (this.linelen > 0)
for l in (this:linesplit(line, this.linelen))
au:notify(this, l);
endfor
else
au:notify(this, line);
endif
endif
.
#100:4
":linesplit(line,len) => list of substrings of line";
"used by :notify to split up long lines if .linelen>0";
line = args[1];
len = args[2];
cline = {};
au = $ansi_utils;
"..this should eventually return E_RANGE or \"\" and stop...";
while (z = au:cutoff(line, 1, len + 1))
cutoff = au:rindex(z[1..length(z) - 1], " ");
if (nospace = cutoff < ((4 * len) / 5))
cutoff = len + 1;
nospace = index(au:cutoff(line, cutoff, cutoff), " ");
endif
q = au:cutoff_locs(line, 1, cutoff - 1, 1);
cline = {@cline, line[q[1]..q[2]]};
line[q[1]..q[2]] = nospace ? " " | "";
endwhile
return {@cline, line};
.
#100:5
"Usage:  @ansi-test";
"Displays a screen that uses all of the ANSI codes possible.  Useful for testing which codes your terminal program is capable of displaying.";
player:notify($string_utils:center(tostr(" ANSI Test Screen "), l = player:linelen(), "-"));
player:notify_lines($ansi_utils.test_screen);
player:notify($string_utils:space(l, "-"));
.
#100:6
"This makes sure that people don't have color codes in their name. They shouldn't, anyway since it makes it hard to identify them (especially if they use black.)";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
elseif (!is_player(this))
"we don't worry about the names of player classes.";
return pass(@args);
elseif ((name = args[1]) != $ansi_utils:delete(name))
player:notify("Sorry, you can't have color codes in your name. It messes up the db listings and people might not know how to address you if you didn't have your normal name as an alias. You can make a :title, though.");
return E_INVARG;
else
return pass(@args);
endif
.
#100:7
if ($object_utils:has_callable_verb(player.location, "say") != {#3})
"Idiot-proofed it against porting wizards who change $room to something other than #3 (since :say would not be defined on $room.) Clueful wizards can change this.";
return player.location:(verb)(@args);
endif
au = $ansi_utils;
argstr = au:terminate_normal(argstr);
action = {"say", "ask", "exclaim"}[1 + index("?!", argstr[length(argstr)])];
action = (punct == "!") ? "exclaim" | ((punct == "?") ? "ask" | "say");
player:tell(tostr("You ", action, ", \"", argstr, "\""));
player.location:announce(tostr(au:ansi_title(player), " ", action), "s, \"", argstr, "\"");
.
#100:8
"Redirects calls to @who to $ansi_utils:show_who_listing.";
if (caller != player)
return E_PERM;
elseif (!(valid(au = $ansi_utils) && au.active))
return pass(@args);
endif
argstr = prepstr = dobjstr = iobjstr = "";
plyrs = args ? listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1) | connected_players();
au:show_who_listing(plyrs);
.
#100:9
"'at_item (<location>, <party>)' - Given a location and a list of the people there, return a string displaying the information. Override this if you want to change the format of each line of @at's output.";
loc = args[1];
party = args[2];
su = $string_utils;
number = this.at_number ? su:right(tostr(loc), 7) + " " | "";
room = su:left(valid(loc) ? loc.name | "[Nowhere]", this.at_room_width);
($ansi_utils:length(room) > this.at_room_width) && (room = $ansi_utils:cutoff(room, 1, this.at_room_width));
text = (number + room) + " ";
if (party)
filler = su:space(length(text) - 2);
line = text;
text = {};
for who in (party)
name = " " + (valid(who) ? who.name | "[Nobody]");
if (($ansi_utils:length(line) + $ansi_utils:length(name)) > this:linelen())
text = {@text, line};
line = filler + name;
else
line = line + name;
endif
endfor
text = {@text, line};
else
text = text + " [deserted]";
endif
return text;
.
#100:10
if (player != this)
"... somebody's being sneaky...";
"... Can't do set_task_perms(player) since we need to be `this'...";
"... to notify and `this.owner' to change +c properties...";
return;
elseif (!(valid(au = $ansi_utils) && au.active))
return pass(@args);
elseif (!(lbuf = this.linebuffer))
this.linesleft = this.pagelen - 2;
notify(this, "*** No more ***");
elseif (index("flush", dobjstr || "x") == 1)
this.linesleft = this.pagelen - 2;
notify(this, tostr("*** Flushed ***  ", length(lbuf), " lines"));
this.linebuffer = {};
elseif ((index("rest", dobjstr || "x") == 1) || (!this.pagelen))
this.linesleft = this.pagelen - 2;
for l in (lbuf)
au:notify(this, l);
endfor
this.linebuffer = {};
else
howmany = min(this.pagelen - 2, llen = length(lbuf = this.linebuffer));
for l in (lbuf[1..howmany])
au:notify(this, l);
endfor
this.linesleft = (this.pagelen - 2) - howmany;
this.linebuffer = lbuf[howmany + 1..llen];
if (howmany < llen)
notify(this, strsub(this.more_msg, "%n", tostr(llen - howmany)));
this.linetask[1] = task_id();
endif
endif
this.linetask[2] = task_id();
.
#100:11
"This makes sure that people don't have color codes in their aliases. They shouldn't, anyway since it makes it hard to identify them (especially if they use black.)";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
elseif (!is_player(this))
"we don't worry about the names of player classes.";
return pass(@args);
else
for name in (aliases = args[1])
if (name != $ansi_utils:delete(name))
aliases = setremove(aliases, name);
endif
endfor
if (aliases != args[1])
player:notify("Sorry, you can't have color codes in your aliases.");
endif
return pass(aliases);
endif
.
#100:12
return valid(au = $ansi_utils) ? au:ansi_title(this, pass(@args)) | pass(@args);
.
#100:13
if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))
return E_PERM;
else
au = $ansi_utils;
if (au.active)
this:notify(tostr("ANSI Version ", au.version, " is currently active.  Type \"?ansi-intro\" for more information."));
endif
if (((mess = au.status_message) && (!$object_utils:isa(this, $guest))) && (!this:ansi_option("no_connect_status")))
fork (0)
line = $string_utils:space((l = this:linelen()) - 2, "*");
btmmsg = "Type \"@ansi-o +no_connect_status\" to ignore this message.";
this:notify(line);
for a in ((typeof(mess) == LIST) ? {"ANSI Message:", @mess, btmmsg} | {"ANSI Message: " + mess, btmmsg})
for b in ($generic_editor:fill_string(a, l - 2))
this:notify("* " + b);
endfor
endfor
this:notify(line);
endfork
endif
return pass(@args);
endif
.
#100:14
"Usage:";
"  @ansi-status                   - Displays various information about the";
"                                   status of the ANSI system.";
"  @ansi-status version           - Only displays the version number.";
"  @ansi-status message           - Only displays the ANSI message.";
"Trusted users only:";
"  @ansi-status activate          - Activates the ANSI system.";
"  @ansi-status deactivate        - Deactivates the ANSI system.";
"  @ansi-status message <message> - Sets the ANSI message to <message>.";
"  @ansi-status input             - Same as 'message' but lets you input";
"                                   more than one line.";
"  @ansi-status clear             - Clears the ANSI message.";
"  @ansi-status diagnostic        - Runs the ANSI self-diagnostic and";
"                                   reports the results.";
"  @ansi-status diagnostic fix    - Same as above but fixes anything it can.";
"  @ansi-status update            - Updates all the caches, this should be";
"                                   run every once in a while.  See";
"                                   'help $ansi_utils:update_all' for more info.";
au = $ansi_utils;
if (args)
subcommand = args[1];
args[1..1] = {};
else
subcommand = "";
endif
trusts = au:trusts(player);
show = 0;
if (player != this)
player:tell(E_PERM);
elseif (!subcommand)
player:notify_lines($ansi_utils:ansi_status());
trusts && player:notify("You are trusted by the ANSI system.");
show = 1;
elseif (subcommand == "help")
player:notify_lines($code_utils:verb_documentation());
elseif (subcommand == "version")
player:notify(tostr("Currently running ANSI Version ", au.version, "."));
elseif (subcommand == "message")
if (!args)
show = 1;
elseif (trusts)
message = $string_utils:from_list(args, " ");
au.status_message = message;
player:notify("Message set to:  " + message);
if ($command_utils:yes_or_no("Notify users?"))
notify = tostr("The ANSI status message was just set by ", player.name, "; type \"@ansi-status message\" to see it.");
for x in (setremove($object_utils:leaves_suspended($ansi_pc), player))
x:tell(notify);
endfor
endif
else
player:notify("The message can only be set by trusted users, type \"@ansi-status message\" to see the message.");
endif
elseif (!trusts)
player:notify(tostr("The subcommand \"", subcommand, "\" either doesn't exist or is limited to trusted users only."));
elseif (subcommand == "input")
player:notify("What do you want to set the message to?");
message = $command_utils:read_lines();
au.status_message = message;
player:notify("Message set to:");
player:notify_lines(message);
if ($command_utils:yes_or_no("Notify users?"))
notify = tostr("The ANSI status message was just set by ", player.name, "; type \"@ansi-status message\" to see it.");
for x in (setremove($object_utils:leaves_suspended($ansi_pc), player))
x:notify(notify);
endfor
endif
elseif (subcommand == "clear")
au.status_message = "";
player:notify("Cleared status message.");
elseif (subcommand in {"activate", "active", "on"})
player:notify(au.active ? "The ANSI system is already active." | "The ANSI system has been activated.");
au.active = 1;
elseif (subcommand in {"deactivate", "deactive", "off"})
player:notify(au.active ? "The ANSI system has been deactivated, type \"@ansi-status activate\" to reactivate it." | "The ANSI system is not active.");
au.active = 0;
elseif (subcommand == "diagnostic")
status = au:self_diagnostic(fix = index(tostr(@args), "fix"), player);
player:notify(tostr("Diagnostic completed, ", fix ? "fixed" | "found", " ", status, " problem", (status == 1) ? "" | "s", "."));
elseif (subcommand == "update")
player:notify("Updating caches...");
au:update_all();
player:notify("Done updating caches.");
else
player:notify("Invalid subcommand: " + subcommand);
endif
if (show)
if (m = au.status_message)
ml = player:linelen() - 14;
lines = {};
for a in ((typeof(m) == LIST) ? m | {m})
for b in ($generic_editor:fill_string(a, ml))
lines = {@lines, b};
endfor
endfor
player:notify("ANSI message: " + lines[1]);
for x in (listdelete(lines, 1))
player:notify("              " + x);
endfor
else
player:notify("There is no ANSI message set.");
endif
endif
.
#100:15
"Usage:";
"  @ansi-title                 - Displays your current ANSI title settings";
"  @ansi-title <name>          - Displays the title you have set for <name>";
"  @ansi-title <name> is <new> - Sets <new> as the title for <name>";
"  @ansi-title is <new>        - Sets <new> as the title for your current name";
name = dobjstr || this.name;
if (player != this)
player:tell(E_PERM);
elseif (!argstr)
if (typeof(this.ansi_title) != LIST)
player:notify("Your ANSI title seems to be screwed up, resetting it.");
this:set_ansi_title({});
elseif (!this.ansi_title)
player:notify("You don't have any ANSI titles set.");
else
player:notify("Current ANSI title substrings:");
l = player:linelen() - 21;
for x in (this.ansi_title)
z = $generic_editor:fill_string($string_utils:english_list((typeof(x[2]) == LIST) ? x[2] | {x[2]}), l);
player:notify(tostr("   ", $string_utils:left(x[1], 15), " - ", z[1]));
for i in (listdelete(z, 1))
player:notify("                     " + i);
endfor
endfor
player:notify(tostr("Your current name is set to ", $ansi_utils:ansi_title(player), "."));
endif
elseif (iobjstr && (prepstr != "is"))
player:notify_lines($code_utils:verb_documentation());
elseif (!prepstr)
if (i = $list_utils:assoc(name, this.ansi_title))
player:notify(tostr("The substring ", name, " will be replaced with ", i[2], "."));
else
player:notify(tostr("There is no set replacement for the substring ", name, "."));
endif
elseif ($ansi_utils:contains_codes(name))
player:notify("The replacement string shouldn't contain ANSI codes.");
else
at = this.ansi_title;
i = $list_utils:iassoc(name, at);
if (iobjstr)
if (i)
at[i][2] = iobjstr;
else
at = listappend(at, {name, iobjstr});
endif
elseif (i)
at = listdelete(at, i);
endif
if (typeof(result = this:set_ansi_title(at)) != ERR)
if (iobjstr)
player:notify(tostr("Substring ", name, " will be replaced with ", iobjstr, "."));
else
player:notify(tostr("Cleared substring ", name, "."));
endif
elseif (result == E_NACC)
player:notify("The replacement string must be the same as the string replaced except for the ANSI strings.");
else
player:notify(tostr("Error: ", result));
endif
endif
.
#100:16
":set_ansi_title (LIST title_list)";
tl = args[1];
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (typeof(tl) != LIST)
return E_INVARG;
else
au = $ansi_utils;
for x in [1..length(tl)]
if (!(((typeof(tl[x]) == LIST) && (length(tl[x]) == 2)) && (typeof(tl[x][1]) == STR)))
return E_INVARG;
elseif (typeof(tl[x][2]) == LIST)
for y in [1..length(tl[x][2])]
if (typeof(tl[x][2][y]) != STR)
return E_INVARG;
elseif (tl[x][1] != strsub(au:delete(tl[x][2][y]), " ", "_"))
return E_NACC;
else
tl[x][2][y] = au:terminate_normal(tl[x][2][y]);
endif
endfor
elseif (tl[x][1] != strsub(au:delete(tl[x][2]), " ", "_"))
return E_NACC;
else
tl[x][2] = au:terminate_normal(tl[x][2]);
endif
endfor
this.ansi_title = tl;
endif
.
#100:17
if ($object_utils:has_callable_verb(player.location, "say") != {#3})
"Idiot-proofed it against porting wizards who change $room to something other than #3 (since :say would not be defined on $room.) Clueful wizards can change this.";
return player.location:(verb)(@args);
endif
if (argstr && (argstr[1] == ":"))
argstr[1..1] = "";
else
argstr[1..0] = " ";
endif
player.location:announce_all($ansi_utils:ansi_title(player), argstr);
.
#101:0
help = {};
linelen = player:linelen();
log = $ansi_utils.(verb);
vmax = 8 + max(@$list_utils:map_builtin($list_utils:slice(log, 1), "length"));
for x in (log)
help = {@help, tostr($string_utils:left(tostr("Version ", x[1]), vmax), "  ", $string_utils:left($time_utils:time_sub("$N, $Y", x[2]), 25), x[3])};
for l in ((typeof(x[4]) == LIST) ? x[4] | {x[4]})
for i in ($generic_editor:fill_string(l, (linelen - vmax) - 2))
help = {@help, tostr($string_utils:space(vmax + 2), i)};
endfor
endfor
help = {@help, ""};
$command_utils:suspend_if_needed(0);
endfor
return help;
.
#102:0
if (args[1] == "all")
return {{"colors", a = args[2]}, {"backgrounds", a}, {"extra", a}, {"misc", a}, {"blinking", a}, {"bold", a}, {"ignore", 0}, {"truecolor", a}, {"256", a}};
elseif (args[1] == "none")
return {{"colors", a = !args[2]}, {"backgrounds", a}, {"extra", a}, {"misc", a}, {"blinking", a}, {"bold", a}, {"truecolor", a}, {"256", a}};
else
return {args};
endif
.
#102:1
if (value = this:get(@args))
return {value, {tostr("Send \"", value, "\" for the escape character.")}};
else
return {0, {"Use a character 27 as the escape character."}};
endif
.
#102:2
oname = args[1];
raw = args[2];
if (typeof(raw) == STR)
return {oname, raw};
else
return "String value expected.";
endif
.
#103:0
"Usage:  :parse_send_args(msg, @posargs, @keywordargs)";
"";
"Transform a given message's arguments (mostly given positionally) into the correct form for MCP.  The cord type has an ordered list of argument keywords for all valid messages; these are matched with the arguments provided to produce an alist.  If more arguments are provided than keywords are available, then the remaining arguments should be {keyword, value} pairs.  This allows the passing of optional arguments and such.";
"";
"This verb returns an alist suitable for use with :client_notify().";
"";
"Examples:";
"  .messages_out = {{\"edit\", {\"name\", \"text\"}}}";
"  :parse_send_args(\"edit\", \"#123.foo\", {\"This is the first line.\"})";
"    => {{\"name\", \"#123.foo\"}, {\"text\", {\"This is the first line.\"}}}";
"  :parse_send_args(\"edit\", \"#123:foo\", {\"Hi!\"}, {\"type\", \"MOO-Code\"})";
"    => {{\"name\", \"#123.foo\"}, {\"text\", {\"Hi!\"}}, {\"type\", \"MOO-Code\"}}";
{msg, @rest} = args;
a = $list_utils:assoc(msg, this.messages_out);
if (!a)
raise(E_INVARG, "Invalid message");
endif
keywords = a[2];
lkeywords = length(keywords);
lrest = length(rest);
if (lrest < lkeywords)
raise(E_ARGS, "Incorrect number of message arguments");
endif
return {@$list_utils:make_alist({keywords, rest[1..lkeywords]}), @rest[lkeywords + 1..$]};
.
#103:1
"Usage:  :parse_receive_args(msg, alist)";
"";
"Transform a messages arguments from an alist into a mostly-positional list.  The cord type has an ordered list of argument keywords for all valid messages; these are used to construct an ordered list of the items from the alist that correspond to those keywords.  If there are items in the alist that do not match a known keyword, they will be appended to the positional list with keywords attached.";
"";
"Examples:";
"  .messages_in = {{\"edit\", {\"name\", \"text\"}}}";
"  :parse_receive_args({{\"name\", \"#123.foo\"}, {\"text\", {\"Hi!\"}}})";
"    => {\"#123.foo\", \"Hi!\"}";
"  :parse_receive_args({{\"name\", \"#123.foo\"}, {\"text\", {\"Hi!\"}}, {\"type\", \"MOO-Code\"}})";
"    => {\"#123.foo\", \"Hi!\", {\"type\", \"MOO-Code\"}};";
{msg, alist} = args;
a = $list_utils:assoc(msg, this.messages_in);
if (!a)
"this should be caught upstream.";
raise(E_INVARG, "Invalid cord message");
endif
ret = {};
for keyword in (a[2])
i = $list_utils:iassoc(keyword, alist);
if (!i)
"this too should be caught.";
raise(E_INVARG, "Missing argument in cord message");
endif
ret = {@ret, alist[i][2]};
alist = listdelete(alist, i);
endfor
return {@ret, @alist};
.
#103:2
"This is the standard :set_foo verb.  It allows the property to be set if called by this or called with adequate permissions (this's owner or wizardly).";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return this.(verb[5..length(verb)]) = args[1];
else
return E_PERM;
endif
.
#104:0
"This is the standard :set_foo verb.  It allows the property to be set if called by this or called with adequate permissions (this's owner or wizardly).";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return this.(verb[5..length(verb)]) = args[1];
else
return E_PERM;
endif
"version: 1.0 Fox Wed Jul  5 17:58:13 1995 EDT";
.
#104:1
"Usage:  :dispatch_request(who, authkey, name, arguments)";
"";
connection = caller;
{message, alist} = args;
if (verbname = this:message_name_to_verbname(message))
set_task_perms(caller_perms());
this:(verbname)(connection, @this:parse_receive_args(message, alist));
endif
.
#104:2
"Usage:  :match_request(request)";
"";
request = args[1];
if ($object_utils:has_verb(this, verbname = "mcp_" + request))
return verbname;
else
return 0;
endif
"version: 1.0 Fox Wed Jul  5 17:58:14 1995 EDT";
.
#104:3
"Usage:  :initialize_connection()";
"";
{version} = args;
connection = caller;
messages = $list_utils:slice(this.messages_in);
connection:register_handlers(messages);
.
#104:4
{message} = args;
if ($object_utils:has_callable_verb(this, vname = "handle_" + message))
return vname;
else
return 0;
endif
.
#104:5
connection = caller;
return 0;
.
#104:6
"Usage:  :add_cord_type(cord_type)";
"";
{cord_type} = args;
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return this.cord_types = setadd(this.cord_types, cord_type);
else
raise(E_PERM);
endif
.
#104:7
"Usage:  :remove_cord_type(cord_type)";
"";
{cord_type} = args;
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return this.cord_types = setremove(this.cord_types, cord_type);
else
raise(E_PERM);
endif
.
#104:8
{connection, @args} = args;
if (caller == this)
message = verb[6..$];
`connection:send(message, this:parse_send_args(message, @args)) ! E_VERBNF';
else
raise(E_PERM);
endif
.
#105:0
connection = caller;
for keyval in ($mcp.registry:packages())
{name, package} = keyval;
this:send_can(connection, name, @package.version_range);
endfor
this:send_end(connection);
.
#105:1
if (caller == this)
{connection, package, minv, maxv, @rest} = args;
if (valid(pkg = $mcp.registry:match_package(package)))
if (version = $mcp:compare_version_range({minv, maxv}, pkg.version_range))
connection:add_package(pkg, version);
endif
endif
endif
.
#105:2
if (caller == this)
{connection, @rest} = args;
connection:end_negotiation();
endif
.
#106:0
if (caller == this)
return tostr("I", this.next_id = this.next_id + 1);
else
raise(E_PERM);
endif
.
#106:1
{message, alist} = args;
cord = caller;
session = cord.session;
if (cord in $mcp.cord.registry)
return this:send_(session, tostr(cord.id), message, @alist);
else
raise(E_PERM);
endif
.
#106:2
cord = caller;
session = cord.session;
this:send_closed(session, tostr(cord.id));
.
#106:3
{session, id, message, @assocs} = args;
if (caller == this)
$mcp.cord:mcp_receive(id, message, assocs);
endif
.
#106:4
{session, id, @rest} = args;
if (caller == this)
$mcp.cord:mcp_closed(id);
endif
.
#106:5
{name} = args;
for i in ($object_utils:leaves($mcp.cord.type_root))
if (name == (($mcp.registry:package_name(i.parent_package) + "-") + i.cord_name))
return i;
endif
endfor
return $failed_Match;
.
#106:6
if (caller == $mcp.cord)
return pass(@args);
endif
.
#106:7
session = caller;
len = length($mcp.cord.registry_ids);
for i in [0..len - 1]
idx = len - i;
cord = $mcp.cord.registry[idx];
if (cord.session == session)
$recycler:_recycle(cord);
endif
endfor
.
#106:8
{cord_type} = args;
parent = $mcp:package_name(cord_type.parent_package);
if (suffix = cord_type.cord_name)
return (parent + "-") + suffix;
else
return parent;
endif
.
#107:0
"take args and return a list in the format:";
"{true if contains multiline, { { keyword-name, data, multiline }, ... }";
alist = {};
if (length(alist) % 2)
raise(E_ARGS);
endif
contains_multiline = 0;
while (args)
{keyword, value, @args} = args;
if (keyword[$] != ":")
raise(E_INVARG, "invalid keyword: " + keyword);
else
if (keyword[$ - 1] == "*")
contains_multiline = 1;
value = {};
keyword = keyword[1..$ - 2];
else
keyword = keyword[1..$ - 1];
endif
alist = {@alist, {keyword, value}};
endif
endwhile
return {contains_multiline, alist};
.
#107:1
"parse_mcp(@args) =>";
"relies on argstr being a version of @args unwordified";
"{request-name, contains-multiline, authentication-key, data-tag, { { keyword-name, data }, ... } }";
if (length(args) < 1)
raise(E_INVARG, "not enough arguments");
endif
request_name = args[1][4..$];
if (!request_name)
raise(E_INVARG, "no request name");
endif
if (request_name == "*")
return this:parse_mcp_continuation(@args[2..$]);
endif
"... if there is an authentication key, the length of args will be even ...";
if (length(args) % 2)
authentication_key = E_NONE;
message_args = args[2..$];
else
authentication_key = args[2];
message_args = args[3..$];
endif
{contains_multiline, alist} = this:parse_mcp_alist(@message_args);
if (contains_multiline)
if (tag = $list_utils:iassoc("_data-tag", alist))
"mulitline with a datatag, OK";
data_tag = alist[tag][2];
alist = listdelete(alist, tag);
else
raise(E_INVARG, "multiline fields with no data tag");
endif
else
data_tag = E_NONE;
endif
if (typeof(alist) == LIST)
return {request_name, contains_multiline, authentication_key, data_tag, alist};
else
return alist;
endif
.
#107:2
{data_tag, keyword, @rest} = args;
value = argstr[(index(argstr, keyword) + length(keyword)) + 1..$];
keyword = keyword[1..$ - 1];
return {"*", data_tag, keyword, value};
.
#107:3
"parse(@args) => parsed MCP message ready for dispatch or 0";
"                if there was nothing to dispatch for this message";
"                (as in multiline continuations, dispatch";
"                for those occurs at the END";
"returns {message, authkey, alist} or 0";
"argstr must equal the unmodified line from the client";
{argstr, @words} = args;
session = caller;
message = this:parse_mcp(@words);
if (message[1] == "*")
{n, data_tag, keyword, value} = message;
session:multiline_add_value(data_tag, keyword, value);
elseif ((message[1] == ":") || (message[1] == "END"))
{request, dummy, data_tag, dummy, dummy} = message;
return session:multiline_finish(player, data_tag);
else
{request, contains_multiline, authkey, data_tag, alist} = message;
if (contains_multiline)
session:multiline_begin(request, authkey, data_tag, alist);
else
return {request, authkey, alist};
endif
endif
return 0;
.
#107:4
{request, authkey, alist} = args;
keyvals = "";
need_data_tag = 0;
multilines = {};
for keyval in (alist)
{keyword, value, ?maybe_ignore} = keyval;
if (typeof(value) == STR)
if (!match(value, this.unquoted_string))
value = toliteral(value);
endif
elseif (typeof(value) == LIST)
need_data_tag = 1;
multilines = {@multilines, {keyword, value}};
keyword = keyword + "*";
value = "\"\"";
else
value = toliteral(value);
endif
keyvals = (((keyvals + " ") + keyword) + ": ") + value;
endfor
if (need_data_tag)
data_tag = this:next_datakey();
keyvals = (keyvals + " _data-tag: ") + data_tag;
endif
message = "#$#" + request;
if (authkey)
message = (message + " ") + authkey;
endif
message = {message + keyvals};
if (need_data_tag)
prefix = ("#$#* " + data_tag) + " ";
for field in (multilines)
{keyword, value} = field;
for line in (value)
message = {@message, tostr(prefix, keyword, ": ", (typeof(line) == LIST) ? toliteral(line) | line)};
endfor
endfor
message = {@message, "#$#: " + data_tag};
endif
return message;
.
#107:5
datakey = tostr(random(), this.next_datakey);
this.next_datakey = this.next_datakey + 1;
return datakey;
.
#108:0
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
this.connection = args[1];
this:set_name("session for " + tostr(this.connection));
return 1;
else
return E_PERM;
endif
.
#108:1
{request, authkey, data_tag, alist} = args;
if (caller != $mcp.parser)
raise(E_PERM);
elseif ($list_utils:assoc(data_tag, this.pending_multilines))
"it's not valid to begin two requests with the same data tag, drop it";
return;
endif
this.pending_multilines = {@this.pending_multilines, {data_tag, authkey, request, alist}};
.
#108:2
{who, data_tag} = args;
if ((caller != this) && (caller != $mcp.parser))
raise(E_PERM);
elseif (!(n = $list_utils:iassoc(data_tag, this.pending_multilines)))
"drop it";
return;
else
{data_tag, authkey, request, alist} = this.pending_multilines[n];
this.pending_multilines = listdelete(this.pending_multilines, n);
return {request, authkey, alist};
endif
.
#108:3
{data_tag, keyword, value} = args;
if (caller != $mcp.parser)
raise(E_PERM);
elseif (!(n = $list_utils:iassoc(data_tag, this.pending_multilines)))
"drop it";
return;
elseif (!(nkey = $list_utils:iassoc(keyword, this.pending_multilines[n][4])))
"drop it";
return;
elseif (typeof(this.pending_multilines[n][4][nkey][2]) != LIST)
"not a multiline, drop it.";
return;
else
this.pending_multilines[n][4][nkey][2] = {@this.pending_multilines[n][4][nkey][2], value};
endif
.
#108:4
if (caller != $mcp)
raise(E_PERM);
else
set_task_perms(caller_perms());
if (`player.MCP_snoop ! ANY')
player:tell("C->S: ", argstr);
endif
if (message = $mcp.parser:parse(argstr, @args))
this:dispatch(@message);
endif
endif
.
#108:5
if (caller == $mcp)
this:_signal_package_waiter(E_INVARG);
for package in ($list_utils:slice(this.packages))
fork (0)
package:finalize_connection();
endfork
endfor
return $mcp:finalize_connection(this);
endif
.
#108:6
if (caller != $mcp)
raise(E_PERM);
else
this:send("mcp", {{"version", "2.1"}, {"to", "2.1"}});
endif
.
#108:7
"This is the standard :set_foo verb.  It allows the property to be set if called by this or called with adequate permissions (this's owner or wizardly).";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return this.(verb[5..length(verb)]) = args[1];
else
return E_PERM;
endif
.
#108:8
{package, version} = args;
if (caller in {$mcp.negotiate, this})
if (n = $list_utils:iassoc(package, this.packages))
packages = this.packages;
packages[n][2] = version;
this:set_packages(packages);
else
this:set_packages({@this.packages, {package, version}});
endif
package:initialize_connection(version);
this:_signal_package_waiter(package, version);
endif
.
#108:9
{package} = args;
if (assoc = $list_utils:assoc(package, this.packages))
return assoc[2];
endif
.
#108:10
{messages} = args;
package = caller;
{plist, mlist} = this.message_handlers;
prefix = this:package_name(package);
for message in (messages)
message = this:message_fullname(prefix, message);
if (idx = message in mlist)
if (plist[idx] != package)
raise(E_INVARG);
endif
else
plist = {@plist, package};
mlist = {@mlist, message};
endif
endfor
this.message_handlers = {plist, mlist};
.
#108:11
{message, authkey, alist} = args;
if (caller == this)
if ((!this.phase) && (message == "mcp"))
authkey = $list_utils:assoc("authentication-key", alist);
minv = $list_utils:assoc("version", alist);
maxv = $list_utils:Assoc("to", alist);
if (((authkey && minv) && maxv) && $mcp:compare_version_range({minv[2], maxv[2]}, {$mcp.version, $mcp.version}))
this:set_authentication_key(authkey[2]);
this:add_package($mcp.negotiate, $mcp.negotiate.version_range[1]);
else
"woop woop break somehow";
return;
endif
this:set_phase(1);
$mcp.negotiate:do_negotiation();
elseif (this.phase)
if ((this.authentication_key != E_NONE) && (authkey != this.authentication_key))
return;
endif
package = this:find_handler(message);
if (typeof(package) == OBJ)
set_task_perms(caller_perms());
package:dispatch(this:strip_prefix(this:package_name(package), message), alist);
endif
"figure out which package to dispatch to";
"do dispatch";
endif
endif
.
#108:12
{message, alist} = args;
who = caller_perms();
if (caller == this)
prefix = "";
elseif ($list_utils:assoc(caller, this.packages))
package = caller;
message = this:message_fullname(this:package_name(package), message);
else
raise(E_PERM);
endif
con = this.connection;
snoop = `this.connection.MCP_snoop ! E_PROPNF, E_INVIND => 0';
for line in ($mcp.parser:unparse(message, this.authentication_key, alist))
notify(con, line);
if (snoop)
notify(con, "S->C: " + line);
endif
endfor
.
#108:13
{message} = args;
if (assoc = $list_utils:passoc(message, this.message_handlers[2], this.message_handlers[1]))
return assoc[2];
endif
.
#108:14
return this.connection;
.
#108:15
{package} = args;
return $mcp.registry:package_name(package);
.
#108:16
{prefix, message} = args;
if (message)
message = (prefix + "-") + message;
else
message = prefix;
endif
return message;
.
#108:17
{prefix, message} = args;
if (index(message, prefix + "-") == 1)
return message[length(prefix) + 2..$];
elseif (index(message, prefix) == 1)
return message[length(prefix) + 1..$];
elseif (message == prefix)
return "";
else
return message;
endif
.
#108:18
if (caller == $mcp.negotiate)
this:_signal_package_waiter(0);
endif
.
#108:19
{package, timeout} = args;
if (caller == this)
this.package_waiters = {@this.package_waiters, {package, task_id()}};
if (timeout < 0)
r = suspend();
else
r = suspend(timeout);
endif
this.package_waiters = setremove(this.package_waiters, {package, task_id()});
return r;
endif
.
#108:20
{?package = $nothing, value} = args;
if (caller == this)
all = package == $nothing;
for keyval in (this.package_waiters)
{pkg, tid} = keyval;
if (all || (pkg == package))
`resume(tid, value) ! ANY';
endif
endfor
endif
.
#108:21
{package, ?timeout} = args;
timeout = `timeout ! E_VARNF => -1';
if (v = this:handles_package(package))
return v;
else
return this:_add_package_waiter(package, timeout);
endif
.
#109:0
{name, package} = args;
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
if (name in this.package_names)
raise(E_INVARG, "Another package with that name already exists");
elseif (package in this.packages)
raise(E_INVARG, "That package already is registered under a different name.");
else
this.package_names = {@this.package_names, name};
this.packages = {@this.packages, package};
endif
endif
.
#109:1
{name} = args;
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
if (idx = name in this.package_names)
this.package_names = listdelete(this.package_names, idx);
this.packages = listdelete(this.packages, idx);
else
raise(E_INVARG, "Not a defined package");
endif
endif
.
#109:2
{name} = args;
if (idx = name in this.package_names)
return this.packages[idx];
else
return $failed_match;
endif
.
#109:3
{package} = args;
if (idx = package in this.packages)
return this.package_names[idx];
else
return "";
endif
.
#109:4
return $list_utils:make_alist({this.package_names, this.packages});
.
#109:5
if (caller_perms().wizard)
for name in (this.package_names)
this:remove_package(name);
endfor
for x in (children($mcp.package))
`this:add_package(x.name, x) ! E_INVARG';
endfor
endif
.
#109:6
if (!$perm_utils:controls(player, this))
player:tell("You don't have permission to add or remove MCP 2.1 packages.");
elseif ($command_utils:object_match_failed(dobj, dobjstr))
elseif (!$object_utils:isa(dobj, $mcp.package))
player:tell(dobj.name, " is not a valid MCP 2.1 package (descendant of ", $mcp.package, ").");
elseif (!$perm_utils:controls(player, dobj))
player:tell("You don't control ", dobj.name, " in order to add or remove it.");
else
name = dobj.name;
package = dobj;
try
if (verb == "@add-package")
this:add_package(name, package);
player:tell("Added ", package.name, ".");
else
this:remove_package(name);
player:tell("Removed ", package.name, ".");
endif
except v (ANY)
{code, message, value, tb} = v;
player:tell(code, ": ", message);
endtry
endif
.
#110:0
{connection} = args;
if (caller != this)
raise(E_PERM);
elseif (typeof(session = this.session:new()) != ANON)
raise(session);
endif
session:set_connection(connection);
session:initialize_connection();
return session;
.
#110:1
{session} = args;
if (!(caller in {this, session}))
raise(E_PERM);
elseif (!$object_utils:isa(session, this.session))
raise(E_INVARG);
elseif (session == this.session)
raise(E_INVARG);
else
$recycler:_recycle(session);
endif
.
#110:2
{who} = args;
if (caller != this)
raise(E_PERM);
endif
return this:create_session(who);
.
#110:3
{con} = args;
if (caller == con)
this:destroy_session(con);
endif
.
#110:4
"string version number -> {major, minor}";
{version} = args;
if (m = match(version, "%([0-9]+%)%.%([0-9]+%)"))
return {toint(substitute("%1", m)), toint(substitute("%2", m))};
endif
.
#110:5
{client, server} = args;
{min1, max1} = client;
{min2, max2} = server;
min1 = (typeof(min1) == STR) ? this:parse_version(min1) | min1;
min2 = (typeof(min2) == STR) ? this:parse_version(min2) | min2;
max1 = (typeof(max1) == STR) ? this:parse_version(max1) | max1;
max2 = (typeof(max2) == STR) ? this:parse_version(max2) | max2;
if (!(((min1 && min2) && max1) && max2))
return;
else
if ((this:compare_version(max1, min2) <= 0) && (this:compare_version(max2, min1) <= 0))
if (this:compare_version(max1, max2) < 0)
return max2;
else
return max1;
endif
endif
endif
return 0;
.
#110:6
"-1 if v1 > v2, 0 if v1 = v2, 1 if v1 < v2";
{v1, v2} = args;
if (v1 == v2)
return 0;
else
{major1, minor1} = v1;
{major2, minor2} = v2;
if (major1 == major2)
if (minor1 > minor2)
return -1;
else
return 1;
endif
elseif (major1 > major2)
return -1;
else
return 1;
endif
endif
.
#110:7
{major, minor} = args;
return tostr(major, ".", minor);
.
#110:8
{who} = args;
return `who.out_of_band_session ! E_PROPNF => $failed_match';
.
#110:9
{who} = args;
if (listeners(caller))
if ($recycler:valid(who.out_of_band_session))
`who.out_of_band_session:finish() ! ANY';
endif
who.out_of_band_session = this:initialize_connection(who);
endif
.
#110:10
{who} = args;
if (listeners(caller))
if ($recycler:valid(who.out_of_band_session))
`who.out_of_band_session:finish() ! ANY';
who.out_of_band_session = $nothing;
endif
else
raise(E_PERM);
endif
.
#110:11
if (listeners(caller))
if ($recycler:valid(session = player.out_of_band_session))
set_task_perms(player);
return session:do_out_of_band_command(@args);
endif
endif
.
#110:12
return this.registry:(verb)(@args);
.
#110:13
{who, @rest} = args;
if (valid(session = this:session_for(who)))
return session:(verb)(@rest);
endif
.
#110:14
return {"parser", "session", "package", "negotiate", "registry", "cord", "simpleedit", "client", "status", "dispatch"};
.
#111:0
"Notify a connection of something.";
set_task_perms(caller_perms());
if (this < #0)
return notify(this, @args);
else
return this:(verb)(@args);
endif
.
#113:0
"Usage:  :send_content()";
"";
if ($perm_utils:controls(caller_perms(), args[1]))
pass(@args);
else
raise(E_PERM);
endif
.
#113:1
"Usage:  :handle_set(session, reference, type, content)";
"";
{session, reference, type, content} = args;
if (caller != this)
raise(E_PERM);
endif
set_task_perms(session.connection);
try
if (type == "moo-code")
rval = this:edit_set_program(reference, content);
elseif (reference == "sendmail")
rval = this:edit_sendmail(reference, content);
else
rval = this:edit_set_note_value(reference, type, content);
endif
player:notify_lines((typeof(rval) == LIST) ? rval | {rval});
except v (ANY)
player:notify_lines((typeof(v[2]) == LIST) ? v[2] | {v[2]});
"   player:notify_lines($code_utils:format_traceback(v[4], v[2]));";
endtry
.
#113:2
{reference, lines} = args;
set_task_perms(caller_perms());
args = $string_utils:words(reference);
punt = 1;
if (!(spec = $code_utils:parse_verbref(args[1])))
raise(E_INVARG, "Invalid reference: " + reference);
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
return;
elseif ($string_utils:is_numeric(spec[2]))
"numeric verbref";
if ((verbname = $code_utils:tonum(spec[2])) == E_TYPE)
raise(E_INVARG, "Invalid verb number");
elseif (length(args) > 1)
raise(E_INVARG, "Invalid reference: " + reference);
elseif ((verbname < 1) || `verbname > length(verbs(object)) ! E_PERM => 0')
raise(E_INVARG, "Verb number out of range.");
else
argspec = 0;
punt = 0;
endif
elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)
raise(E_INVARG, tostr(argspec));
elseif (argspec[2])
raise(E_INVARG, $string_utils:from_list(argspec[2], " ") + "??");
elseif (length(argspec = argspec[1]) in {1, 2})
raise(E_INVARG, {"Missing preposition", "Missing iobj specification"}[length(argspec)]);
else
punt = 0;
verbname = spec[2];
if (index(verbname, "*") > 1)
verbname = strsub(verbname, "*", "");
endif
endif
"...";
"...if we have an argspec, we'll need to reset verbname...";
"...";
if (punt)
elseif (argspec)
named = argspec[4..min(5, $)];
argspec = argspec[1..3];
if (!(argspec[2] in {"none", "any"}))
argspec[2] = $code_utils:full_prep(argspec[2]);
endif
loc = $code_utils:find_verb_named_1_based(object, verbname);
while (loc && (`verb_args(object, loc) ! E_PERM' != argspec))
loc = $code_utils:find_verb_named_1_based(object, verbname, loc + 1);
endwhile
if (loc)
verbname = loc;
else
punt = "...can't find it....";
raise(E_INVARG, "That object has no verb matching that name + args.");
endif
else
named = {};
loc = (typeof(verbname) == NUM) ? verbname | 0;
endif
if (!punt)
try
info = verb_info(object, verbname);
except e (ANY)
if (e[1] == E_VERBNF)
raise(E_INVARG, "That object does not have that verb definition.");
else
raise(E_INVARG, tostr(e[2]));
endif
punt = 1;
endtry
if (!punt)
aliases = info[3];
if (!loc)
loc = aliases in (verbs(object) || {});
endif
endif
endif
if (punt)
return;
else
"filter the verb?";
if (this.v_filter_in)
lines = this.v_filter_in[1]:(this.v_filter_in[2])(lines);
endif
if (0 && named)
"Disabled: We want to see all of the code in the verb and not in the title.";
code = $code_utils:split_verb_code(lines);
lines = {@code[1], @$code_utils:named_args_to_code(named), @code[2]};
endif
try
result = set_verb_code(object, verbname, lines);
except e (ANY)
result = e[2] + " ";
"just in case some idiot throws an error with an empty string";
endtry
what = $string_utils:nn(object);
if (result)
if (typeof(result) == STR)
return {"Error programming " + what, result, "Verb not programmed."};
else
return {"Error programming " + what, @result, tostr(length(result), " error(s)."), "Verb not programmed."};
endif
else
return {"0 errors.", "Verb programmed."};
endif
endif
.
#113:3
"See $player:@@sendmail";
set_task_perms(caller_perms());
{reference, msg} = args;
end_head = ("" in msg) || (length(msg) + 1);
subject = "";
replyto = "";
rcpts = {};
body = msg[end_head + 1..length(msg)];
for i in [1..end_head - 1]
line = msg[i];
if (index(line, "Subject:") == 1)
subject = $string_utils:trim(line[9..length(line)]);
elseif (index(line, "To:") == 1)
if (!(rcpts = $mail_agent:parse_address_field(line)))
player:notify("No recipients found in To: line");
return;
endif
elseif (index(line, "Reply-to:") == 1)
if ((!(replyto = $mail_agent:parse_address_field(line))) && $string_utils:trim(line[10..length(line)]))
player:notify("No address found in Reply-to: line");
return;
endif
elseif (i = index(line, ":"))
player:notify(tostr("Unknown header \"", line[1..i], "\""));
return;
else
player:notify("Blank line must separate headers from body.");
return;
endif
endfor
if (!rcpts)
player:notify("No To: line found.");
elseif (!(subject || body))
player:notify("Blank message not sent.");
else
player:notify("Sending...");
result = $mail_agent:send_message(player, rcpts, replyto ? subject | {subject, replyto}, body);
if (e = result && result[1])
if (length(result) == 1)
player:notify("Mail actually went to no one.");
else
player:notify(tostr("Mail actually went to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
endif
else
player:notify(tostr((typeof(e) == ERR) ? e | ("Bogus recipients:  " + $string_utils:from_list(result[2]))));
player:notify("Mail not sent.");
endif
endif
return {};
.
#113:4
set_task_perms(caller_perms());
{reference, type, content} = args;
"reference format == [str|val]:#xx[.pname]";
if (!match(reference, "^%(str%|val%):.+"))
return {"Malformed reference: " + reference};
else
vtype = reference[1..3];
reference = reference[5..$];
if (((vtype == "str") && (type == "string")) && (length(content) <= 1))
text = content ? content[1] | "";
elseif (vtype == "val")
text = {};
for x in [1..length(content)]
$sin(0);
value = $string_utils:to_value(content[x]);
if (value[1] != 1)
return {tostr("Error on line ", x, ":  ", value[2]), "Value not saved."};
else
text = {@text, value[2]};
endif
endfor
else
text = content;
endif
endif
if (spec = $code_utils:parse_propref(reference))
o = $code_utils:toobj(spec[1]);
p = spec[2];
if (typeof(o) == OBJ)
if ($object_utils:has_callable_verb(o, setter = "set_" + p))
e = o:(setter)(text);
else
e = o.(p) = text;
endif
else
return {"Malformed reference: You must supply an object number."};
endif
if (typeof(e) == ERR)
raise(e, tostr("Error: ", e));
else
return tostr("Set ", p, " property of ", o.name, " (", o, ").");
endif
elseif (typeof(note = $code_utils:toobj(argstr)) == OBJ)
o = note;
e = note:set_text(text);
if (typeof(e) == ERR)
return {tostr("Error: ", e)};
else
return tostr("Set text of ", o.name, ".");
endif
else
raise(E_INVARG, tostr("Error: Malformed argument to ", verb, ": ", argstr));
endif
.
#113:5
"Charter: given a block of verb code lines from the user, transform it into code ready to be passed to set_verb_code().  In particular, reverse any transformation made by :verbcode_internal_to_external.";
"This version transforms `// foo' comments to `\"foo\";' comments.";
lines = args[1];
new_comments = player:prog_option("//_comments");
if (!new_comments)
return lines;
endif
newlines = {};
for line in (lines)
mat = match(line, "^ *// ?%(.*%)$");
if (mat)
comment = substitute("%1", mat);
out = $code_utils:commentify({comment});
newlines = {@newlines, out[1]};
else
newlines = {@newlines, line};
endif
endfor
return newlines;
.
#113:6
"Charter: given a block of verb code from the verb_code() primitive, transform it into its external representation to be presented to the user.";
"This version transforms `\"foo\";' comments to `// foo' comments.";
lines = args[1];
new_comments = player:prog_option("//_comments");
if (!new_comments)
return lines;
endif
newlines = {};
for line in (lines)
mat = match(line, "^%( *%)%(\".*\";%)$");
if (mat)
blanks = substitute("%1", mat);
comment = substitute("%2", mat);
uncommented = $code_utils:uncommentify({comment});
out = (blanks + "// ") + uncommented[1];
newlines = {@newlines, out};
else
newlines = {@newlines, line};
endif
endfor
return newlines;
.
#114:0
if (verb in {"init_for_core", "exitfunc", "enterfunc", "moveto"})
return `pass(@args) ! ANY => 0';
elseif (verb in {"sin", "cos", "sqrt"})
this = tofloat(this);
elseif (verb == "english_time")
return $time_utils:english_time(this);
elseif (verb in {"include_for_core", "proxy_for_core"})
return {};
endif
return call_function(verb, this, @args);
.
#115:0
return call_function("set" + verb, this, @args);
.
#115:1
return call_function("listdelete", this, @args);
.
#115:2
return call_function("list" + verb, this, @args);
.
#115:3
set_task_perms(player);
return $string_utils:from_list(this, args ? args[1] | " ");
.
#115:4
set_task_perms(player);
"Don't respond to calls from built-ins";
{_, name, programmer, location, _} = callers()[1];
if ((name && (programmer == $nothing)) && (location == $nothing))
return;
endif
"Exceptions";
if (verb in {"init_for_core", "exitfunc", "enterfunc", "moveto"})
return `pass(@args) ! ANY => 0';
elseif (verb in {"from_list", "english_list", "title_list", "generate_symmetrical_columns"})
return $string_utils:(verb)(this, @args);
elseif (verb == "include_for_core")
return {};
elseif ($object_utils:has_callable_verb($list_utils, verb))
return $list_utils:(verb)(this, @args);
elseif (verb == "len")
return length(this, @args);
endif
"Frobs, originally conceptualized by Todd Sundsted for Improvise.";
if (this && (`prototype = this[1] ! E_RANGE' in $frobs))
return prototype:(verb)(@args);
endif
return pass(@args);
.
#117:0
return call_function("map" + verb, this, @args);
.
#117:1
"Merges the map with <args>";
for v, k in (args[1])
this[k] = v;
endfor
return this;
.
#117:2
"Map:generate_json()";
"Map:json()";
"So that programmers can call generate_json directly on a map.";
"Just calls the builtin of the same name.";
return call_function("generate_json", this, @args);
.
#117:3
"This catches everything else that doesn't have a specific function.";
set_task_perms(caller_perms());
"don't respond to calls from built-ins";
{_, name, programmer, location, _} = callers()[1];
if ((name && (programmer == $nothing)) && (location == $nothing))
return;
endif
"Frobs, originally conceptualized by Todd Sundsted for Improvise.";
if (this && (`prototype = this[$map_proto.frob_key_name] ! E_RANGE' in $frobs))
return prototype:(verb)(@args);
endif
return pass(@args);
.
#118:0
"the perms check you want is probably:";
if ((caller == this) || (caller == this.class))
"allows pass() and :new()";
else
raise(E_PERM);
endif
.
#118:1
"WIZARDLY";
set_task_perms(caller_perms());
player = caller_perms();
w = new_waif();
w:initialize(@args);
return w;
.
#119:0
if (verb in {"init_for_core", "exitfunc", "enterfunc", "moveto"})
return `pass(@args) ! ANY => 0';
elseif ((verb == "length") || (verb == "len"))
return length(this);
elseif (verb == "strip_ansi")
return $ansi_utils:delete(this);
endif
if (verb in {"include_for_core", "proxy_for_core"})
return {};
endif
"So that programmers can call string:json() or string:parse_json(),";
"And get a map as the return value (if the string can be parsed into json).";
if ((verb == "parse_json") || (verb == "json"))
return call_function("parse_json", this, @args);
endif
r = $string_utils:(verb)(this, @args);
if (r != 0)
return r;
endif
.
#120:0
"Last modified 12/10/18 1:14 a.m. by Sinistral (#2) on ChatMUD";
return length((typeof(this) == MAP) ? this:keys() | this);
.
#120:1
"Created 02/01/19 1:40 p.m. by Sinistral (#2) on ChatMUD";
"Last ditch attempt to do something useful...";
set_task_perms(caller_perms());
if (verb in {"init_for_core", "include_for_core", "proxy_for_core"})
return {};
elseif (this in {$failed_match, $ambiguous_match, $nothing})
return this;
endif
return call_function(verb, this, @args);
.
#121:0
if (caller != this)
return E_PERM;
endif
{session, @stats} = args;
who = session.connection;
if (i = who in $list_utils:slice(this.client_info, 2))
this.client_info = listset(this.client_info, {time(), who, stats}, i);
else
this.client_info = {@this.client_info, {time(), who, stats}};
endif
.
#121:1
{session, linelen, @args} = args;
if (caller != this)
return E_PERM;
endif
((ll = toint(linelen)) > 0) && this:adjust_linelen(who = session.connection, (who.linelen > 0) ? ll | (-1 * ll));
.
#121:2
if ($perm_utils:controls(caller_perms(), this))
this.client_info = {};
endif
.
#121:3
{who, @args} = args;
if ($perm_utils:controls(caller_perms(), who))
if (valid(session = $mcp:session_for(who)) && session:handles_package(this))
return pass(session, @args);
else
return E_INVIND;
endif
endif
.
#121:4
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
else
info = {};
for dude in (args)
if (i = $list_utils:iassoc(dude, this.client_info, 2))
(ticks_left() < 4000) && suspend(0);
dudeinf = this.client_info[i];
session = $mcp:session_for(dudeinf[2]);
if ((valid(session) && session:handles_package(this)) && `dudeinf[1] >= (dude.last_connect_time - 3) ! ANY')
info = {@info, dudeinf[2..3]};
endif
endif
endfor
return info;
endif
.
#121:5
{who, linelen} = args;
if (caller != this)
return E_PERM;
endif
who.linelen = linelen;
.
#121:6
{clients, users} = this.client_stats;
for x in (this.client_info)
if (is_player(x[2]) == 0)
if ((ind = x[3][1] in clients) == 0)
clients = {@clients, x[3][1]};
users = {@users, 1};
else
users[ind] = users[ind] + 1;
endif
this.client_info = setremove(this.client_info, x);
endif
$command_utils:suspend_if_needed(0);
endfor
this.client_stats = {clients, users};
.
#122:0
{?owner = caller_perms()} = args;
if ((owner != caller_perms()) && (!caller_perms().wizard))
return E_PERM;
endif
return create(this, owner, 1);
"This could potentially allow people to skirt quota since we're not tracking it.";
"I'm not sure of the best fix, though. Maybe make bf_create handle it?";
.
#123:0
{session, text} = args;
if ((caller == this) || $perm_utils:controls(caller_perms(), session.connection))
return this:send_(session, text);
endif
.
#124:0
{?text = {}, ?prompt = "[Type lines of input; use `.' to end.]", ?commandchar = this:get_opt("cmd_char", player), ?verb = 0, ?extra = {}} = args;
"Arguments:";
"  text: The text to be edited.";
"  prompt: The prompt displayed to the player to ask for input.";
"  commandchar: The character used to indicate an editor command vs text to be added.";
"  verb: A flag indicating whether or not this is verb code, which will add editor commands for compilation and commenting.";
"  extra: Extra information passed in, primarily for verb info to use with the compile command.";
if (typeof(text) == STR)
text = {text};
elseif (typeof(text) != LIST)
return raise(E_TYPE, "Invalid datatype");
endif
this:log_last_edit(player, task_id());
state = $edit_state:new(text, verb, extra);
"NOTE: The waif is created AND destroyed in-verb. It is NOT persistant!";
player:tell(prompt);
if (state.verb && state.extra)
verb_name = tostr($string_utils:nn(state.extra[1][1]), ":", state.extra[1][2]);
player:tell("Now editing ", verb_name, ".");
state.verb_name = verb_name;
endif
state.ins = length(state.text) + 1;
player:tell("Insertion point is before line ", state.ins, ".");
if (this:get_option("expert") == 0)
player:tell();
player:tell("Type '", commandchar, "help' for assistance, '", commandchar, "abort' to abandon.");
endif
while loop (1)
try
if (!player:is_listening())
return;
endif
cont = 1;
(!this:get_option("no_line_notifies")) && player:tell("  >");
line = read(player);
if (typeof(line) != STR)
return state.text;
endif
if (line == "@abort")
player:tell(">> Command Aborted <<");
kill_task(task_id());
elseif (line == "..")
line = ".";
elseif (line == ".")
line = this:get_option("cmd_char") + "done";
endif
if (`line[1] ! ANY' == commandchar)
cmd = $string_utils:explode(line[2..$]);
if ((commandchar == ".") && (!cmd))
line = this:get_option("cmd_char") + "done";
elseif (!cmd)
player:tell("You must enter a command. (", commandchar, "help for help.)");
continue;
endif
state.command = cmd[1];
state.arg = cmd[2..$];
if (state.command in {"insert", "ins", "inse", "inser"})
this:cmd_insert(state);
elseif (state.command in {"paste", "load"})
this:cmd_load(state);
elseif (state.command in {"copy", "save"})
this:cmd_save(state);
elseif (state.command == "pass")
this:cmd_pass(state);
elseif (state.command in {"reload", "rehash"})
return this:cmd_reload(@args, state);
elseif (state.command in {"change", "changeline"})
this:cmd_changeline(state);
elseif (state.command in {"replace", "repl", "re"})
this:cmd_replace(state);
elseif (state.command in {"find", "search", "GREP", "f", "s"})
this:cmd_grep(state);
elseif (state.command in {"done", "quit", "q"})
if (typeof(ret = this:cmd_quit(state)) == ERR)
continue;
else
return state.text;
endif
elseif (state.command in {"abort", "abandon", "q!"})
player:tell(">> Command Aborted <<");
kill_task(task_id());
elseif ((state.verb && state.extra) && (state.command in {"what", "verb"}))
player:tell("Currently editing: ", state.extra[1][1]:nn(), ":", state.extra[1][2], ".");
elseif ((state.verb && state.extra) && (state.command in {"compile", "w", "send"}))
{object, verbname} = state.extra[1];
program = this:program_verb(object, verbname, state);
elseif (state.verb && (state.command[1] == "/"))
"Assume they want to make a verb comment.";
line = ("\"" + line[3..$]) + "\";";
cont = 0;
elseif (state.command == "import")
this:cmd_paste_letter(state);
elseif (state.command == "set")
this:options($string_utils:from_list(state.arg, " "));
elseif (state.command in {"del", "dele", "delet", "delete", "erase", "rm"})
this:cmd_delete(state);
elseif (state.command in {"list", "l", "view", "p"})
this:cmd_list(state);
elseif (state.verb && (state.command in {"comment", "commentify"}))
this:cmd_commentify(state);
elseif (state.verb && (state.command in {"uncomment", "uncommentify"}))
this:cmd_uncommentify(state);
elseif (state.command in {"spellcheck", "spell"})
state.text = $spell:interactive_spellcheck(state.text);
player:tell("Spell check completed.");
elseif (state.command == "count")
this:cmd_count(state);
elseif (state.verb && (state.command in {"tb", "jtb"}))
this:cmd_traceback(state);
elseif (state.verb && (state.command in {"ptb", "print_traceback"}))
this:cmd_print_traceback(state);
elseif (state.verb && (state.command in {"local", "localedit"}))
this:cmd_localedit(state);
elseif (state.command in {"format", "form"})
this:cmd_format(state);
elseif (state.command in {"help", "?"})
this:cmd_help(state);
elseif (state.command in {"clipboard", "saved", "clip"})
this:cmd_show_clipboard(state);
else
player:tell("Unrecognized command. (", commandchar, "help for help.)");
endif
if (cont != 0)
continue;
endif
endif
this:do_add_line(state, line);
except error (ANY)
player:tell("Something has gone wrong...");
player:tell(toliteral(error));
break;
continue;
endtry
endwhile
.
#124:1
{arg, maxrange, insertion} = args;
if (typeof(arg) == LIST)
arg = $string_utils:from_list(arg, " ");
endif
range = {0, 0};
explode_by = {"..", " ", "-", "+"};
exploded_by = 0;
for x in (explode_by)
expl = $string_utils:explode(arg, x);
if (length(expl) > 1)
exploded_by = x;
break;
endif
endfor
if (length(expl) > 2)
return tostr("Junk at end of command: ", $string_utils:from_list(expl[3..$], " "), ".");
elseif (length(expl) == 1)
if ((single = expl[1]) == "$")
range = {maxrange, maxrange};
elseif (single == "^")
range = {insertion, insertion};
elseif ((toint(single) > 0) && (toint(single) <= maxrange))
range = {toint(single), toint(single)};
endif
else
for x in (expl)
if (x == "$")
line = maxrange;
elseif (x == "^")
line = insertion;
elseif (!$string_utils:is_numeric(x))
return tostr("Garbled Range: ", arg, " - should be integers");
elseif ((toint(x) <= 0) || (toint(x) > maxrange))
return tostr("Lines range from 1 to ", maxrange, ".");
else
line = toint(x);
endif
range[x in expl] = line;
endfor
endif
if (exploded_by == "+")
increment_line = range[1] + range[2];
range = {increment_line, increment_line};
endif
if (range[1] > range[2])
return tostr("Garbled Range: ", range[1], " greater than ", range[2], ". Put smallest index first.");
elseif (0 in range)
return tostr("Garbled Range: ", arg);
endif
return range;
.
#124:2
"-1 == option not found";
{option, ?player = player} = args;
opt = `player.inline_editor_options[option] ! ANY => $nothing';
if (opt != $nothing)
return opt;
else
return $edit_utils.default_options[option];
endif
.
#124:3
{?argstr = 0} = args;
options = {};
options = {@options, ["name" -> "Set Command Prefix", "identifier" -> "prefix", "state" -> tostr(this:get_option("cmd_char"))]};
options = {@options, ["name" -> "Set Escape Character", "identifier" -> "escape", "state" -> tostr(this:get_option("escape_char"))]};
options = {@options, ["name" -> "Advanced Mode (suppresses warnings and help prompts)", "identifier" -> "expert", "state" -> this:get_option("expert")]};
options = {@options, ["name" -> "Suppress Line Added Notifications", "identifier" -> "suppress", "state" -> this:get_option("no_line_notifies")]};
options = {@options, ["name" -> "Color Line Numbers", "identifier" -> "color_line", "state" -> ((color = this:get_option("color_line")) != "") ? tostr($ansi_utils:hr_to_code(color), color, "[normal]") | 0]};
options = {@options, ["name" -> "Color Line Indicator", "identifier" -> "color_indicator", "state" -> ((color = this:get_option("color_indicator")) != "") ? tostr($ansi_utils:hr_to_code(color), color, "[normal]") | 0]};
options = {@options, ["name" -> "Set As Default Editor For Verbs and Notes", "identifier" -> "default_editor", "state" -> this:get_option("default_editor")]};
if (player.programmer)
options = {@options, ["name" -> "Jump to Error Line", "identifier" -> "jump_to_error", "state" -> this:get_option("jump_to_error")]};
endif
opt = $menu_utils:options_menu(options);
if (opt == 0)
return;
endif
if (opt == "prefix")
player:tell("Enter a single character that you wish to begin editor commands with. It should preferably be a symbol, not a letter or number.");
cmd = $command_utils:read();
if (((length(cmd) > 1) || (cmd in $string_utils:char_list($string_utils.alphabet + $string_utils.digits))) || (length(cmd) <= 0))
return player:tell("Invalid command prefix. It should not be a number or letter and must be one (1) character in length.");
endif
result = this:set_option(player, "cmd_char", cmd);
if (typeof(result) != STR)
player:tell("There was an error setting your command prefix.");
else
player:tell("Command prefix set.");
endif
elseif (opt == "escape")
player:tell("Enter a single character that you wish to escape lines with. When lines are started with this character, any editor parsing will be bypassed. It should preferably be a symbol, not a letter or number.");
esc = $command_utils:read();
if (((length(esc) > 1) || (esc in $string_utils:char_list($string_utils.alphabet + $string_utils.digits))) || (length(esc) <= 0))
return player:tell("Invalid escape character. It should not be a number or letter and must be one (1) character in length.");
endif
result = this:set_option(player, "escape_char", esc);
if (typeof(result) != STR)
player:tell("There was an error setting your escape character.");
else
player:tell("Escape character set.");
endif
elseif (opt == "expert")
opt = !this:get_option("expert");
result = this:set_option(player, "expert", opt);
player:tell("You ", opt ? "activate" | "deactivate", " advanced mode.");
elseif (opt == "suppress")
opt = !this:get_option("no_line_notifies");
result = this:set_option(player, "no_line_notifies", opt);
player:tell(opt ? "You will no longer receive a message when a line has been added to the working text." | "You will once again receive a message when a line has been added to the working text.");
elseif (opt == "default_editor")
opt = !this:get_option("default_editor");
result = this:set_option(player, "default_editor", opt);
player:tell(opt ? "When editing verbs or notes, you will now use the inline editor by default." | "You will no longer use the inline editor to edit verbs and notes.");
elseif (opt == "jump_to_error")
opt = !this:get_option("jump_to_error");
result = this:set_option(player, "jump_to_error", opt);
player:tell(opt ? "When editing verbs, the cursor will move to the line indicated in the traceback if an error occurs." | "The cursor will no longer move to the traceback line when errors occur.");
elseif (opt == "color_line")
option = "color_line";
status = this:get_option(option);
if (((status != "") && ($command_utils:yes_or_no("Would you like to select a different color?") == 1)) || (status == ""))
choice = $ansi_utils:color_selector();
this:set_option(player, option, choice);
player:tell("Color set.");
else
this:set_option(player, option, "");
player:tell("Color cleared.");
endif
elseif (opt == "color_indicator")
option = "color_indicator";
status = this:get_option(option);
if (((status != "") && ($command_utils:yes_or_no("Would you like to select a different color?") == 1)) || (status == ""))
choice = $ansi_utils:color_selector();
this:set_option(player, option, choice);
player:tell("Color set.");
else
this:set_option(player, option, "");
player:tell("Color cleared.");
endif
endif
.
#124:4
{player, task} = args;
this:refresh_last_edits();
if (pos = player in $list_utils:slice(this.last_edits))
this.last_edits[pos][2] = task;
this.last_edits[pos][3] = ftime();
else
this.last_edits = setadd(this.last_edits, {player, task, ftime()});
endif
.
#124:5
{player} = args;
return `this.last_edits[player in $list_utils:slice(this.last_edits)][3] ! ANY => 0';
.
#124:6
edits = this.last_edits;
"Clear out invalid editor sessions.";
for x in (edits)
if ((!$code_utils:task_valid(x[2])) || (!x[1]:is_listening()))
edits = setremove(edits, x);
endif
endfor
this.last_edits = edits;
.
#124:8
{player, ?create = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
endif
session = 0;
for x in (this.sessions)
if ((x.last_modified != 0) && ((time() - x.last_modified) > $time_utils.week))
this.sessions = setremove(this.sessions, x);
endif
if (x.player == player)
return x;
endif
endfor
if (create)
session = $edit_session:new();
session.player = player;
this.sessions = {@this.sessions, session};
return session;
endif
return $nothing;
.
#124:9
{player} = args;
return `$code_utils:task_valid(this.last_edits[player in $list_utils:slice(this.last_edits)][2]) ! ANY => 0';
.
#124:10
{object, verbname, state} = args;
ret = 0;
try
set_task_perms(player);
simpleedit = $mcp.registry:match_package("dns-org-mud-moo-simpleedit");
if (result = set_verb_code(object, verbname, (typeof(simpleedit) == ERR) ? state.text | simpleedit:verbcode_external_to_internal(state.text)))
player:notify_lines(result);
player:notify(tostr(length(result), " error(s)."));
player:notify("Verb not programmed.");
state.traceback = result;
line_error = $string_utils:match_string(result[1], "Line *: *");
if (line_error != 0)
line_error = toint(line_error[1]);
state.traceback_line = line_error;
if (this:get_option("jump_to_error") && (line_error != 0))
if ((line_error > 0) && (line_error <= (length(state.text) + 1)))
state.ins = line_error;
endif
endif
endif
else
player:notify("0 errors.");
player:notify(tostr(object, ":", verbname, " successfully compiled."));
endif
except error (ANY)
player:notify(error[2]);
player:notify("Verb not programmed.");
endtry
.
#124:11
{state} = args;
if (!state.arg)
player:tell("Insert where? (Use a positive integer or '$' for the last line.)");
return E_INVARG;
elseif (((state.arg[1] != "$") && (toint(state.arg[1]) <= 0)) || (toint(state.arg[1]) > (length(state.text) + 1)))
player:tell("Insertion ranges from line 1 to ", length(state.text) + 1, ".");
return E_INVARG;
endif
if (state.arg[1] == "$")
state.ins = length(state.text) + 1;
else
state.ins = toint(state.arg[1]);
endif
(state.ins > 1) && this:list_line(state, state.ins - 1);
(state.ins <= length(state.text)) && this:list_line(state, state.ins);
player:tell("Now inserting before line ", state.ins, ".");
.
#124:12
{state} = args;
if (this:session_for(player) == $nothing)
player:tell("You have no text saved.");
return E_INVARG;
endif
if (state.text && ($command_utils:yes_or_no("The current text will be lost. Are you sure you wish to load saved text?") == 0))
player:tell("Aborted.");
return E_INVARG;
endif
state.text = this:session_for(player).text;
player:tell("Saved text loaded.");
.
#124:13
{state} = args;
if (this:session_for(player, 1).text && ($command_utils:yes_or_no("You already have text saved. Do you wish to overwrite it?") == 0))
player:tell("Aborted.");
return E_INVARG;
endif
if (!(state.arg in {0, {}}))
range = this:parse_range(state.arg, length(state.text), state.ins);
if (typeof(range) == STR)
player:tell(range);
return E_INVARG;
endif
{start, end} = range;
text = state.text[start..end];
else
text = state.text;
endif
this:session_for(player, 1).text = text;
this:session_for(player).last_modified = time();
player:tell("The text has been successfully saved. To load it in for editing later, type ", this:get_opt("cmd_char"), "paste.");
.
#124:14
{state} = args;
passthrough = $string_utils:from_list(state.arg, " ");
force_input(player, passthrough);
suspend(0);
while ($player_utils:reading_input(player) && player:is_listening())
yin();
endwhile
.
#124:15
text = args[$].text;
args = args[1..$ - 1];
player:tell("Reloading...");
"Maintain text through reloads.";
if (length(args) >= 1)
args[1] = text;
endif
return this:editor(@args);
.
#124:16
{state} = args;
if (length(state.arg) < 2)
player:tell("Usage: ", this:get_option("cmd_char"), "", state.command, " <line-number> <new-text>");
return E_INVARG;
elseif (!state.text)
player:tell("There is no text to change.");
return E_INVARG;
else
if (state.arg[1] == "$")
NUM = length(state.text);
elseif (state.arg[1] == "^")
NUM = state.ins;
else
NUM = toint(state.arg[1]);
endif
if ((NUM < 1) || (NUM > length(state.text)))
player:tell("There is no line with that number. Lines range from 1 to ", length(state.text), ".");
return E_INVARG;
else
newline = $string_utils:from_list(state.arg[2..$], " ");
state.text[NUM] = newline;
player:tell("Line ", NUM, " changed.");
endif
endif
.
#124:17
{state} = args;
if (!state.text)
player:tell("There is no text to search.");
return E_INVARG;
elseif (!state.arg)
player:tell("Usage: FIND <text>");
return E_INVARG;
endif
hohum = (state.ins == (length(state.text) + 1)) ? 1 | state.ins;
"Note: If the caret is at the bottom, search the full text instead of nothing.";
found = 0;
for x in (state.text[hohum..$])
if (index(x, hoargs = $string_utils:from_list(state.arg, " ")))
found = hohum;
break;
endif
hohum = hohum + 1;
endfor
if (!found)
player:tell("No text matching `", $string_utils:from_list(state.arg, " "), "'.");
return E_INVARG;
endif
state.ins = found + 1;
player:tell(found, ": ", state.text[found]);
.
#124:18
{state} = args;
if (state.verb && state.extra)
{object, verbname} = state.extra[1];
if ((verb_code(object, verbname) != state.text) && ($command_utils:yes_or_no("If you proceed, the text of the working verb could be lost due to failed compilation. Are you sure you wish to continue?") != 1))
player:tell("Aborted.");
return E_INVARG;
endif
program = this:program_verb(object, verbname, state);
endif
.
#124:19
{state} = args;
if (!state.text)
player:tell("There is no text to delete.");
else
range = this:parse_range(state.arg, length(state.text), state.ins);
if (!state.arg)
if ((state.ins - 1) <= 0)
range = {state.ins, state.ins};
else
range = {state.ins - 1, state.ins - 1};
endif
endif
if (typeof(range) == STR)
player:tell(range);
return E_INVARG;
endif
{start, end} = range;
for x in [start..end]
player:tell("   ", state.text[start]);
state.text = listdelete(state.text, start);
endfor
state.ins = start;
if (state.ins > (length(state.text) + 1))
state.ins = length(state.text) + 1;
endif
player:tell("---Line", (end > start) ? "s" | "", " deleted. Insertion point is before line ", state.ins, ".");
endif
.
#124:20
{state} = args;
if (!state.text)
player:tell("No text to list.");
return E_INVARG;
"     elseif (!state.arg)";
"       player:tell(\"List what lines? (Line ranges from 1 to \", state.ins-1, \".)\");";
else
if (!state.arg)
if ((state.ins + 8) > length(state.text))
listuntil = length(state.text);
else
listuntil = state.ins + 8;
endif
if ((state.ins - 8) <= 0)
listfrom = 1;
else
listfrom = state.ins - 8;
endif
range = {listfrom, listuntil};
elseif (state.arg == {"all"})
range = {1, length(state.text)};
else
range = this:parse_range(state.arg, length(state.text), state.ins);
if (typeof(range) == STR)
player:tell(range);
return E_INVARG;
endif
endif
{start, end} = range;
ind = start;
"Since we don't want to introduce ANSI into the actual text, we'll create a temp variable.";
if (state.verb && ("highlight_syntax" in player.prog_options))
list_text = $code_utils:highlight_syntax(state.text[start..end]);
else
list_text = state.text[start..end];
endif
for x in (list_text)
$command_utils:suspend_if_needed(0);
line_color = this:get_opt("color_line");
player:tell((line_color != "") ? $ansi_utils:hr_to_code(line_color) | "", ind, (line_color != "") ? "" | "", ": ", (typeof(x) != STR) ? toliteral(x) | x);
ind = ind + 1;
if (ind == state.ins)
ind_color = this:get_opt("color_indicator");
player:tell((ind_color != "") ? $ansi_utils:hr_to_code(ind_color) | "", "^^^^", (ind_color != "") ? "" | "");
endif
endfor
endif
.
#124:21
{state} = args;
if (((length(state.arg) == 1) && (state.arg[1] in {"line", "lines"})) || (!state.arg))
player:tell("Lines: ", length(state.text));
endif
if (((length(state.arg) == 1) && (state.arg[1] in {"character", "letters", "chars", "char", "characters"})) || (!state.arg))
chars = 0;
for x in (state.text)
chars = chars + length(x);
endfor
player:tell("Characters: ", chars);
endif
if (((length(state.arg) == 1) && (state.arg[1] in {"word", "words"})) || (!state.arg))
words = 0;
for x in (state.text)
words = words + length($string_utils:words(x));
endfor
player:tell("Words: ", words);
endif
.
#124:22
{state} = args;
player:tell("Command Help");
player:tell(dashes = "-------------");
cmds = vcmds = {};
for x in (verb_code(this, "editor"))
line = $string_utils:trim(x);
if (match = $string_utils:match_string(line, "*f (state.command in {*})"))
"cmds = {@cmds, @$string_utils:to_value(match)[2]};";
cmds = {@cmds, $string_utils:explode($string_utils:strip_all_but(match[2], $string_utils.alphabet + ",?/"), ",")};
elseif (match = $string_utils:match_string(line, "*f (state.command == \"*\")"))
cmds = {@cmds, {match[2]}};
elseif (match = $string_utils:match_string(line, "elseif (state.verb && state.command == \"*\")"))
vcmds = {@vcmds, {match[1]}};
elseif (match = $string_utils:match_string(line, "elseif (state.verb && state.command in {*})"))
vcmds = {@vcmds, $string_utils:explode($string_utils:strip_all_but(match[1], $string_utils.alphabet + ",?/"), ",")};
elseif (match = $string_utils:match_string(line, "elseif (state.verb && state.extra && state.command == \"*\")"))
vcmds = {@vcmds, {match[1]}};
elseif (match = $string_utils:match_string(line, "elseif (state.verb && state.extra && state.command in {*})"))
vcmds = {@vcmds, $string_utils:explode($string_utils:strip_all_but(match[1], $string_utils.alphabet + ",?/"), ",")};
endif
endfor
ret = {};
if (!state.arg)
ret = {@ret, "Help is available on the following topics:", ""};
ret = {@ret, @$string_utils:columnize($list_utils:slice(player.programmer ? {@cmds, @vcmds} | cmds), 3)};
else
for x in ({@cmds, @vcmds})
if (((x in vcmds) && ((player.programmer != 1) || (!state.verb))) || (state.arg && ((state.arg[1] in x) == 0)))
continue x;
endif
ret = {@ret, tostr(x[1], "", (length(x) > 1) ? tostr(" (Aliases: ", $string_utils:english_list(x[2..$]), ")") | "", ":")};
if (ind = x[1] in $list_utils:slice(this.help))
"                ret = {@ret, tostr($list_utils:slice(help, 2)[ind])};";
ret = {@ret, @this.help[ind][2..$]};
else
ret = {@ret, "No help available."};
endif
endfor
endif
if (!ret)
ret = {@ret, tostr("No help on that command is presently available. To see a list of commands, type ", this:get_opt("cmd_char", player), "help without arguments.")};
endif
player:tell_lines(ret);
player:tell(dashes);
if (!state.arg)
player:tell();
player:tell("To work with ranges, do one of the following:");
player:tell("/delete 1..4 -- Erases lines 1 through 4.");
player:tell("/delete 8..$ -- Erases up until the end of the text, starting at line 8.");
player:tell("/list 3 4 -- Lists lines 3-4.");
player:tell("/delete 1 -- Erases line 1.");
player:tell("/list 40+40 -- Lists the contents of line 80.");
endif
.
#124:23
{state} = args;
letters = {};
for x in (player.contents)
if (((x != 0) && (isa(x, $note) || isa(x, $letter))) && x:is_readable_by(player))
letters = {@letters, x};
endif
endfor
if (letters == {})
player:tell("You are not carrying any notes.");
else
if (length(letters) > 1)
player:tell("Pick a note to paste into the working text.");
letter = letters[$command_utils:menu(letters)];
else
letter = letters[1];
endif
if ($command_utils:yes_or_no(tostr("Really insert the text of ", letter:title(), "?")) == 1)
state.text = {@state.text[1..state.ins - 1], @letter:text(), @state.text[state.ins..$]};
player:tell("Text inserted.");
endif
endif
.
#124:24
{state} = args;
if (!state.arg)
player:tell("You must include what lines you wish to comment.");
return E_INVARG;
endif
range = this:parse_range(state.arg, length(state.text), state.ins);
if (typeof(range) == STR)
player:tell(range);
return E_INVARG;
endif
{start, end} = range;
for x in [start..end]
state.text[x] = ("" + toliteral(state.text[x])) + ";";
endfor
player:tell("Line", (end < start) ? "s" | "", " commented.");
.
#124:25
{state} = args;
if (!state.arg)
player:tell("You must include what lines you wish to uncomment.");
return E_INVARG;
endif
range = this:parse_range(state.arg, length(state.text), state.ins);
if (typeof(range) == STR)
player:tell(range);
return E_INVARG;
endif
{start, end} = range;
bogus = {};
for x in [start..end]
if (((length(state.text[x]) > 3) && (state.text[x][1] == "\"")) && (state.text[x][$ - 1..$] == "\";"))
state.text[x] = state.text[x][2..$ - 2];
else
bogus = {@bogus, state.text[x]};
endif
endfor
player:tell("Line", (end < start) ? "s" | "", " uncommented.");
if (bogus)
player:tell("---", length(bogus), " ", $s("line", length(bogus)), " ", (start < end) ? "were" | "was", " not comments.");
endif
.
#124:26
{state} = args;
if (!state.traceback_line)
player:tell("There are no recorded tracebacks.");
return E_INVARG;
else
if ((state.traceback_line > 0) && (state.traceback_line <= (length(state.text) + 1)))
state.ins = state.traceback_line;
player:tell("Insertion point is now at line '", state.ins, "'.");
else
player:tell("The recorded traceback line is no longer valid.");
endif
endif
.
#124:27
{state} = args;
if (!state.traceback)
player:tell("There are no recorded tracebacks.");
return E_INVARG;
else
player:tell("Last recorded traceback:");
player:tell_lines(state.traceback);
endif
.
#124:28
{state} = args;
if (!state.text)
player:tell("No text to format.");
return E_INVARG;
endif
ind = 1;
reformatted = {};
player:tell("Formatting...");
for x in (state.text)
if (length(x) > abs(player:linelen()))
player:tell("Line ", ind, " too long: reformatting.");
reformatted = {@reformatted, @player:linesplit(x, abs(player:linelen()))};
else
reformatted = {@reformatted, x};
endif
ind = ind + 1;
endfor
state.text = reformatted;
player:tell("Done.");
.
#124:29
{state, line} = args;
if (`line[1] == this:get_option("escape_char") ! ANY' && (length(line) > 1))
line = line[2..$];
endif
if (state.ins > length(state.text))
state.text = {@state.text, line};
else
state.text = {@state.text[1..state.ins - 1], line, @state.text[state.ins..$]};
endif
(!this:get_option("no_line_notifies")) && player:tell("Line ", state.ins, " added.");
this:log_last_edit(player, task_id());
state.ins = state.ins + 1;
.
#124:30
{player, option, value} = args;
if (!caller_perms().wizard)
return E_PERM;
endif
options = player.inline_editor_options;
if (this.default_options[option] == #-1)
return -1;
endif
if (options == 0)
player.inline_editor_options = [];
endif
if ((this.default_options[option] == value) && (option in player.inline_editor_options:keys()))
player.inline_editor_options = player.inline_editor_options:delete(option);
else
player.inline_editor_options[option] = value;
endif
"Sacrificing sanity checks for tick savings.";
if (this:get_opt(option, player) == value)
return value;
endif
return -1;
.
#124:31
{state} = args;
saved = this:session_for(player, 1);
if (!saved.text)
player:tell("You have no text saved.");
return E_INVARG;
else
player:tell("You have the following text saved:");
player:tell();
player:tell_lines_suspended(saved.text);
player:tell();
player:tell("(end of saved text)");
endif
.
#124:32
{state} = args;
oldoption = this:get_option("edit_verbs");
this:set_option(player, "edit_verbs", 0);
$verb_editor:invoke((tostr(state.extra[1][1]) + ":") + state.extra[1][2], "@program", state.text);
this:set_option(player, "edit_verbs", oldoption);
kill_task(task_id());
.
#124:33
{state} = args;
if (length(state.arg) < 1)
player:tell("Usage: ", this:get_option("cmd_char"), "", state.command, " <PCRE replacement>");
return E_INVARG;
elseif (!state.text)
player:tell("There is no text to change.");
return E_INVARG;
else
changed = 0;
success = 1;
range = {1, length(state.text)};
if ((length(state.arg) >= 2) && (typeof(this:parse_range(state.arg[$], length(state.text), state.ins)) == LIST))
range = this:parse_range(state.arg[$], length(state.text), state.ins);
player:tell("(Running replacement", (range[1] != range[2]) ? "s" | "", " on ", (range[1] == range[2]) ? "line " + tostr(range[1]) | tostr("lines ", range[1], " to ", range[2]), ".)");
endif
for I in [range[1]..range[2]]
try
newline = pcre_replace(state.text[I], $string_utils:from_list(state.arg));
except e (ANY)
player:tell("Error on line ", I, ": ", e[2]);
success = 0;
break;
endtry
if (newline != state.text[I])
changed = changed + 1;
state.text[I] = newline;
endif
yin();
endfor
player:tell("Replacement ", success ? "complete" | "failed", ". ", changed, " ", $s("line", changed), " affected.");
endif
.
#124:34
if (caller_perms().wizard)
this.last_edits = {};
this.sessions = {};
pass(@args);
endif
.
#124:35
$ansi_utils:add_noansi();
{state, line} = args;
f = 1 + (line in {(ins = state.ins) - 1, ins});
text = state.text[line];
player:tell($string_utils:right(line, 3, " _^"[f]), ":_^"[f], " ", text);
$ansi_utils:remove_noansi();
.
#125:0
{text, verb, extra, @overflow} = args;
new = pass(player);
new.text = text;
new.verb = verb;
new.extra = extra;
return new;
.
#126:0
"Usage: $menu_utils:menu(menu, options)";
"Menu: Should be a list of strings.";
"Options: A map containing option modifiers.";
"You can insert an _ in your menu if you wish to create a blank line and not include it in the numeric output.";
"Similarly, you can include ##<header> as a menu item if you want to render an automatically capitalized heading in the midst of your menu.";
SU = $string_utils;
{menu, ?options = 0} = args;
default_options = ["invalid_selection_msg" -> "Invalid selection.", "prompt" -> "Enter your selection:", "map_verb" -> "title", "kill_after_invalid_selection" -> 1, "expires_in" -> 0, "expired_msg" -> "Selection time expired; menu closed.", "target" -> player, "header_msg" -> 0, "blank_input_msg" -> 0, "input" -> 0, "hidden_menu" -> 0, "autofit_header" -> {}, "autofit_padding" -> 2, "columns" -> 0, "capitalize_string_entries" -> 1];
if (options == 0)
options = default_options;
else
for x in (mapkeys(default_options))
if ((x in mapkeys(options)) == 0)
options[x] = default_options[x];
endif
endfor
endif
if (typeof(options["prompt"]) == STR)
options["  prompt"] = {options["prompt"]};
endif
player = options["target"];
names = {};
i = 0;
for x in (menu)
number = 0;
if (x == "_")
"Blank Line";
name = "";
menu = setremove(menu, x);
elseif ((((typeof(x) in {OBJ, ANON, WAIF}) == 0) && (length(x) > 2)) && (x[1..2] == "##"))
name = SU:capitalize_each(x[3..$]);
menu = setremove(menu, x);
elseif (typeof(x) in {OBJ, ANON, WAIF})
i = i + 1;
name = this:return_map_verb(x, options["map_verb"]);
number = 1;
elseif (typeof(x) == STR)
i = i + 1;
name = options["capitalize_string_entries"] ? x:capitalize_each() | x;
number = 1;
else
name = x;
endif
if (number)
name = tostr("[", i, "] ", name);
endif
names = {@names, name};
$sin();
endfor
if (!options["hidden_menu"])
(options["header_msg"] != 0) && player:tell(options["header_msg"]);
if (typeof(`menu[1] ! ANY => STR') == LIST)
"Autofit the menu according to lengths.";
for x in [1..length(names)]
names[x] = {tostr("[", x, "]"), @names[x]};
endfor
header = options["autofit_header"];
names = SU:autofit(header ? {header, @names} | names, options["autofit_padding"], header);
if (header)
"If we have a header, we need to move it to the right of the numeric options so that it's not a heading for the numbers.";
space = SU:space(length(tostr(length(names))) + 4);
"Two for brackets, two for space, the rest for how many numbers display";
for x in [1..2]
player:tell(space, names[x]);
endfor
names = names[3..$];
endif
endif
if (options["columns"])
player:tell_lines($ansi_utils:columnize(names, options["columns"], player:linelen()));
else
player:tell_lines(names);
endif
endif
"Fork a task to kill the menu if a selection wasn't chosen in the given time period.";
if ((options["expires_in"] > 0) && (!options["hidden_menu"]))
menu_task_id = task_id();
fork (options["expires_in"])
if ($code_utils:task_valid(menu_task_id))
kill_task(menu_task_id);
player:tell(options["expired_msg"]);
endif
endfork
endif
if (!options["input"])
options["hidden_menu"] && player:tell();
player:tell_lines(options["prompt"]);
player:notify(tostr("[Type a line of input or `@abort' to abort the command.]"));
selection = read(player);
else
selection = tostr(options["input"]);
endif
if ((!selection) && options["blank_input_msg"])
player:tell(options["blank_input_msg"]);
if (options["kill_after_invalid_selection"])
return kill_task(task_id());
else
return 0;
endif
elseif (SU:is_numeric(selection))
selection = toint(selection);
if ((selection <= 0) || (selection > length(menu)))
player:tell(options["invalid_selection_msg"]);
if (options["kill_after_invalid_selection"])
return kill_task(task_id());
else
return -1;
endif
endif
return selection;
elseif (selection == "$")
return length(menu);
elseif (selection == "^")
return 1;
else
if (selection != "")
if (selection == "@abort")
player:tell(">> Command Aborted <<");
return kill_task(task_id());
endif
i = 0;
matches = {};
for x in (menu)
if ((x == "") || ((length(x) > 2) && (x[1..2] == "##")))
continue;
elseif (typeof(x) == LIST)
x = x[1];
"       x = $string_utils:from_list(x, \" \");";
endif
i = i + 1;
for y in ($string_utils:words(x:strip_ansi()))
if (index(y, selection) == 1)
matches = {@matches, i};
endif
endfor
endfor
if (matches)
if (length(matches) == 1)
return matches[1];
else
match_menu = {};
for x in (matches)
match_menu = {@match_menu, menu[x]};
endfor
player:tell("Multiple matches were detected. Please be more specific.");
for x in ({"hidden_menu", "input"})
`options = options:delete(x) ! ANY';
endfor
return matches[this:menu(match_menu, options)];
endif
endif
endif
player:tell(options["invalid_selection_msg"]);
if (options["kill_after_invalid_selection"])
return kill_task(task_id());
else
return -1;
endif
endif
.
#126:1
{OBJ, verb} = args;
return `OBJ:(verb)() ! ANY => "Unknown"';
.
#126:2
"$menu_utils:options_menu(options[,input[,  menu_op]])";
"This is a menu verb, specifically intended for option menus that need complexity and robustness not provided by $option_utils.";
"It's only real purpose is option matching, not setting. Setting is left as an exercise to the programmer.";
"Options: This should be a list of maps with the following keys-";
"";
"       Name: The name, as displayed to the user";
"       Identifier: An internal identifier that's returned with the selection.";
"       State: The state of the option that should be displayed to the user, such as on or off.";
"       If the state is an integer, we'll automatically assume \"[red]Off[normal]\" for false booleans and \"[green]On[normal]\" for true ones.";
"";
"Input: Defaults to argstr, which should be set by the server before this verb is executed. This is used to optionally match on option names rather than printing a menu.";
"Menu_op: This is a map of options to pass to the corresponding menu call later.";
"This verb simply returns the corresponding number.";
"If the option has a corresponding identifier, this returns the identifier instead of the index.";
{options, ?input = argstr, ?menu_op = []} = args;
default_off = "[red]Off[normal]";
default_on = "[green]On[normal]";
if (input)
menu_op["hidden_menu"] = 1;
menu_op["invalid_selection_msg"] = "Invalid option.";
menu_op["input"] = input;
menu_op["kill_after_invalid_selection"] = 0;
endif
menu = {};
IDs = [];
names = {};
for x in (options)
name = x["name"];
names = {@names, name};
if ("identifier" in x:keys())
IDs[name] = x["identifier"];
endif
state = x["state"];
if (typeof(state) == INT)
display = state ? default_on | default_off;
elseif ((typeof(state) in {STR, ANON, OBJ}) == 0)
display = toliteral(state);
else
display = state;
endif
display = ("[" + display) + "]";
menu = {@menu, {name, display}};
endfor
ret = this:menu(menu, menu_op);
if (ret == -1)
return 0;
else
if (names[ret] in IDs:keys())
return IDs[names[ret]];
else
return ret;
endif
endif
.
